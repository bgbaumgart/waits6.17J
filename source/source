;: OUTER[J17,SYS]
COMMENT ⊗   VALID 00047 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00006 00002	TITLE STANFORD A-I PDP-6/10 TIME-SHARING SYSTEM  6.16/M
C00007 00003	LIST OF INDEPENDENT MONITOR COMMAND FEATURES
C00010 00004	 ACCUMULATOR ASSIGNMENTS
C00013 00005	MNEMONICS FOR DDB WORDS
C00016 00006	    DEVICE SERVICE DISPATCH TABLE ASSIGNMENTS
C00018 00007	 DEVICE CHARACTERISTICS WORD DEFINITIONS
C00021 00008	 DDB ASSIGNMENTS, DEVCHR BITS
C00023 00009	 I/O STATUS WORD ASSIGNMENTS
C00026 00010	REST OF BITS IN LH ARE DEVICE DEPENDENT EXCEPT BIT 14 WHICH
C00028 00011	 JOB BUFFER AREA HEADER
C00029 00012	JOB STATUS WORD(JBTSTS IN IOINI1), ONE FOR EACH JOB
C00033 00013	JBTSIN SWAP IN LIST BITS
C00034 00014	JBTST2	TWO PROCESSOR INTERLOCKED SPACEWAR STATUS BITS
C00037 00015	PRIVILEGE BITS (IN JBTPRV AND JB2PRV)
C00042 00016	STATISTICS VARIABLES
C00044 00017	 SYSTEM MACROS
C00046 00018	MORE SYSTEM MACROS
C00048 00019	 MACROS TO SYNCHRONIZE PROCESSORS
C00049 00020	MACROS TO PUSH AND POP ACS, DISASTER MACROS
C00051 00021	PARAMETER ASSIGNMENTS FOR THIS SYSTEM.
C00053 00022	 HERE, WE DEFINE THE LEGAL QUEUES AND QUANTUM TIMES
C00055 00023	DEVICE NAMES NOT IN THE ASSEMBLER.(IN INCREASING ORDER)
C00057 00024	IOP CONO/CONI BITS
C00058 00025	FIRST 19 JULY 67
C00062 00026	SYSDSP SYSTEM INITIALIZATION DISPATCH TABLE, STARTING AT LOC 200
C00064 00027	 AT LOCATION 210 BEGINS THE LIST OF USEFUL LOCATIONS
C00066 00028	 HERE LIE THE ROUTINES TO PUSH AND POP ACCUMULATORS
C00068 00029	THIS PRINTS "YOU'RE IN DDT" AND ENTERS DDT.
C00069 00030	 THIS PART HANDLES AUTOMATIC RELOADS AND RESTARTS
C00072 00031	 WAIT FOR THE PDP-6 TO CATCH UP BEFORE RELOADING
C00074 00032	 HERE WE PUT A ROUTINE INTO THE ACS AND JUMP TO IT WHILE SYSTEM IS BEING READ IN
C00076 00033	 ROUTINE TO TYPE ON THE CONSOLE TELETYPE
C00078 00034	 THIS ROUTINE SKIPS AND SETS DISFLAG AND TURNS OFF PI'S IF
C00079 00035	OTHER SYSTEM DATA STORAGE
C00081 00036	 P2 INITIALIZATION WAIT LOOP. WAITS FOR P1 TO TELL IT TO GO
C00082 00037	 INTERRUPT BIT DEFINITIONS, APR CONI BIT DEFINITIONS
C00085 00038	IOINIT -- CHANNEL LINKAGES AND SAVE ROUTINES.
C00087 00039	 MORE PI CHANNEL ROUTINES FOR P1
C00089 00040	 MORE PI CHANNEL ROUTINES FOR P1
C00091 00041	 CHANNEL ROUTINES FOR P2
C00093 00042	 MORE P2 INTERRUPT ROUTINES
C00095 00043	CHANNEL SAVE AND RESTORE CODE.
C00097 00044	DSKSAV:TVSAV:
C00098 00045	 P2 PI CHANNEL AC SAVE AND RESTORE ROUTINES
C00100 00046	 P2 INTERRUPT AC STORAGE AND PD LISTS
C00101 00047	 HERE WE DEFINE THE CHANNEL NUMBERS, CHANNEL TRAP LOCATIONS AND
C00103 ENDMK
C⊗;

TITLE STANFORD A-I PDP-6/10 TIME-SHARING SYSTEM  6.16/M
SUBTTL	OUTER BLOCK CODE AND SYMBOL DEFINITIONS

DEFINE XD(SYMBOL,VALUE),<↓SYMBOL←←VALUE>
DEFINE XP(SYMBOL,VALUE),<SYMBOL←←VALUE>

XD	SW3330,-1
XD	SW2314,0

;LIST OF INDEPENDENT MONITOR COMMAND FEATURES
;THESE FEATURES CAN BE ELIMINATED FROM A SYSTEM BY
;SETTING THE APPROPRIATE FTXXXX SYMBOL BELOW TO 0
;AND REASSEMBLING. SOME OF THE ROUTINES AFFECTED
;BY EACH FEATURE ARE LISTED BELOW.

XD FTTALK,-1

XD FTATTACH,-1

XD FTSWAP,-1	;SWAPPING SYSTEM
		;APPEARS IN APRSER,SCHEDU,SCNSER,DSKSER,SYSINI,STUFF,LOWCOR

XD FTDISK,-1	;DISK SYSTEM
		;APPEARS IN APRSER,SYSINI,ONCE,STUFF,SCHEDU
		;IF FTDISK=-1,THEN FTLOGIN MUST BE -1

XD FTLOGIN,-1	;LOGIN-LOGOUT COMMANDS AND UUOS
		;APPEARS IN APRSER,STUFF,LOWCOR
		;FTDISK IMPLIES FTLOGIN


IFNDEF FTDDT,{XD FTDDT,-1	; SET TO -1 TO INCLUDE DDT}
IFN FTDDT,<XD EDDT,21>		;EXEC MODE SYSTEM DDT

XD FTBAT,-1	;SET TO -1 TO INCLUDE PHANTOM JOB(S) STARTUP

XD FTDSWP,FTDDT	;CHANGE TO 0 TO DISABLE SWAPPING DDT CODE!

IFNDEF IMPSW,<XD IMPSW,-1>	;HAVE IMP UNLESS OTHERWISE SPECIFIED

XD FTHG,-1	;SET TO -1 TO INCLUDE HISTOGRAM COLLECTION ROUTINES

XD FTOIKB,0	;OLD III KEYBOARDS
		;APPEARS IN TTYSER, OUTER(CH5 CODE).
		;SET TO -1 TO INCLUDE SERVICE FOR OLD SCROUNGY KEYBOARDS.

XD FTSTAT,-1	;SET TO -1 TO INCLUDE JAM'S SWAPPING STATISTICS

XD FTDSKPPN,-1	;SET TO -1 TO ENABLE DISK PPN ALIAS'S

XD FTSHF1K,0	;SET TO -1 TO ALLOW SHUFFLING 1K AT A TIME (BAD IDEA)

XD FTDDSTAT,0	;SET TO -1 TO INCLUDE THE DATA DISK STATISTICS FEATURE

XD FTTTYBUG,-1	;SET TO -1 FOR COMCNT BUG TRAPS

XD FTDRD,-1	;SET FOR REDUNDANCY CHECKS/BUG TRAPS. (DEPT REDUNDANCY DEPT.)

XD FTXCTR,0	;SET TO -1 TO SIMULATE XCT 1,

XD FTCORBUG,0	;SET TO -1 FOR CORE TABLE CONSISTIENCY CHECK

XD FTTKBG,0	;SET TO -1 FOR TALK RING BUG TRAPS

; ACCUMULATOR ASSIGNMENTS

XALL
DEFINE XD (SYMBOL,VALUE) <↓SYMBOL←VALUE>

;ACCUMULATOR ASSIGNMENTS

;* MEANS LOADED BY UUO HANDLER ON ALL UUOS

XD IOS,0	;*IO DEVICE STATUS WORD(SEE BELOW FOR BITS)
XD TAC,1	;TEMPORARY(SOMETIMES PRESERVED ACCROSS SUB.)
XD TAC1,2	;TEMPORARY(SOMETIMES PRESERVED ACCROSS SUB.)
XD PDP,3	;*PUSH DOWN POINTER(SEPARATE LIST FOR EACH PI
XD P,PDP
PDP←←PDP	;ONLY PRINT P
		;CHANNEL AND EACH USER JOB
XD ITEM,4	;BUFFER ITEM COUNT, OR JOB NUMBER
XD J,ITEM
ITEM←←ITEM
XD DAT,5	;TTY OUTPUT BUFFER POINTER FOR COMMANDS,ERROR
		;MESSAG		;OR TEMPORARY
XD JBUF,DAT	;ADDRESS OF 3 WORD BUFFER HEADER IN USER AREA
XD DEVDAT,6	;*LH=UUOS DONE SO FAR FOR THIS DEVICE(SEE BELOW)
		;RH=ADDRESS OF DEVICE DATA BLOCK
XD DDB,DEVDAT
DEVDAT←←DEVDAT
XD PROG,7	;*LH=HIGHEST REL. LOC. IN USER AREA
		;RH=ABSOLUTE ADDRESS OF USER AREA
XD JDAT,PROG	;*RH=ADDRESS OF JOB DATA AREA
		;LH=HIGHEST REL. LOC. IN USER AREA
XD JDMPRG,0	;HAS THE VALUE OF JDAT-PROG

XD TEM,10	;TEMPORARY USED ONLY SCNSER IO ROUTINE


XD DSER,11	;*ADDRESS OF DEVICE SERVICE ROUT. DISPATCH TABLE
XD BUFPNT,12
		; CONTENTS OF FIRST WORD OF 3 WORD USER BUFFER HEADER
XD UCHN,BUFPNT	;*USER IO CHANNEL NO.
XD PID,13	; IN DEMOCRACY, THIS IS THE PROCESSOR DATA AREA ADDRESS
XD UUO,14	;*CURRENT UUO IN PROGRESS
		;PROG IN INDEX FIELD FOR RELOCATION
XD AC1,15	;TEMPORARY ACS(MORE TEMPORARY THAN TAC,TAC1)
XD AC2,16
XD AC3,17

;AC FIELD DEFINITIONS FOR XCTR
IFE FTXCTR,<
↓XR←←4
↓XW←←1
↓XRW←←5
↓XLB←←1
↓XDB←←1
↓XEW←←11	;FOR MOVEM @1(UUO)
>
IFN FTXCTR,<
↓XR←←2
↓XW←←4
↓XRW←←6
↓XLB←←10
↓XDB←←12
>
DEFINE XD (SYMBOL,VALUE) <↓SYMBOL←←VALUE>

;MNEMONICS FOR DDB WORDS
; SOME BITS IN TTYTAB, USED EVERY WHERE IN THE WORLD
COMBIT←←400000		;COMMAND WAITING BIT
DLYBIT←←200000		;DELAYED COMMAND BIT
			;"COMMAND" ONLY SERVICES TTY WHEN COMBIT
			;IS SET!

; DEVICE DATA BLOCK DEFINITIONS

	XD STTIBF,30		;SIZE OF SYSTEM TTY INPUT BUFFER
	XD STTOBF,30		;SIZE OF SYSTEM TTY OUTPUT BUFFER
	XD UTTYBF,30		;SIZE OF USER TTY BUFFER
	XD LPP,=24		;NUMBER OF LINES ON A SCOPE
	XD WPL,=17		;NUMBER OF WORDS TO A LINE ON SCOPE
	XD LINLGD,WPL*5-3	;NUMBER OF CHRS ALLOWED
	XD DDBSKW,1		; NUMBER OF WORDS IN FRONT OF DDB CURRENTLY USED

; DEVICE DATA BLOCK NAMES
	XD DEVCMR,-1		; MORE DEVICE CHARACTERISTICS
	XD DEVNAM,0		;NAME IN SIXBIT ASCII
				;C(LH)=DEVICE MNEMONIC
				;C(RH)=DEVICE NUMBER, LEFT JUSTIFIED
	XD DEVCHR,1		;CHARACTERISTIC
				;BITS 0-5=JOB NUMBER(BYTE POINTER=PJOBN)
				;ZERO VALUE IMPLIES NOT ASSIGNED
	XD HUNGCT,100
				; BITS 6-11 = HUNG DEVICE COUNT. SET WHEN
				;DEVICE BECOMES ACTIVE. DECREMENTED EVERY SECOND.
	XD HUNGST,1
				; BITS 12-17 = HUNG DEVICE COUNT
				;SETTING. 0 MEANS DEVICE CAN NEVER BE HUNG.
	XD PUNITS,7
	XD PUNITP,22-PUNITS
				;BITS 18-24=DEVICE NUMBER,BINARY(BYTE POINTER=PUNIT)
				;BITS 25-35=BUFFER SIZE
	XD DEVIOS,2		;STATUS WORD.  SEE BELOW
	XD DEVSER,3
				; C(LH) = NEXT DEVICE DATA BLOCK
				;C(RH)=DEVICE SERVICE DISPATCH TABLE

;    DEVICE SERVICE DISPATCH TABLE ASSIGNMENTS
	XD DGIVDD,-4		;RETURN DDB (SHARABLE)
	XD DGETDD,-3		;MAKE DDB (")
	XD DINI,-2		;DEVICE INITIALIZATION
	XD DHNG,-1		;DEVICE IS HUNG
	XD DRL,0		;RELEASE
	XD DCL,1		;CLOSE
	;IMMEDIATE ADDRESS PART OF CLOSE UUO
		XD CLSOUT,1	;INHIBIT CLOSING OUTPUT
		XD CLSIN,2	;INHIBIT CLOSING INPUT
	XD DOU,2		;OUTPUT
	XD DIN,3
				; INPUT, SHORT DISPATCH TABLE
	XD DEN,4		;ENTER
	XD DLK,5		;LOOKUP
	XD DDO,6		;DUMP MODE OUTPUT
	XD DDI,7		;DUMP MODE INPUT
	XD DSO,10		;SETO
	XD DSI,11		;SETI
	XD DGF,12		;GETF UUO
	XD DRN,13		;RENAME
	XD DCLI,14		;CLOSE INPUT
	XD DCLR,15
				; CALL D,[SIXBIT /UTPCLR/]
	XD DMT,16		;MTAPE
		;END OF LONG DISPATCH TABLE

; DEVICE CHARACTERISTICS WORD DEFINITIONS

	XD DEVMOD,4
				; BITS 6-11 = LEFT HALF OF IMAGE MODE BYTE POINTER
				;BIT 35-J=1 IF MODE J IS LEGAL FOR THIS DEVICE
				;BIT 18 DEVICE ASSIGNED BY CONSOLE COMMAND
				;BIT 19 DEVICE ASSIGNED BY PROGRAM (INIT)

;RIGHT HALF OF DEVICE CHARACTERISTICS WORD(DEVCHR UUO)
	XD ASSCON,400000	;ASSIGNED BY CONSOLE COMMAND ASSIGN
		;NOTE: READ CODE BETWEEN SYS1 & IOGO BEFORE CHANGING ASSCON
	XD ASSPRG,200000
				; ASSIGNED BY PROGRAM (INIT UUO)
;LEFT HALF DEVICE CHARACTERISTICS(DEVCHR UUO)
	XD DVOUT,1		;OUTPUT DEVICE
	XD DVIN,2		;INPUT DEVICE
	XD DVDIR,4		;HAS A DIRECTORY
	XD DVTTY,10		;IS A TTY
	XD DVMTA,20		;IS A MAG TAPE(REWIND)
	XD DVAVAL,40
				; 1 IF DEVICE IS AVAILABLE TO THIS JOB
				;SET BY DEVCHR UUO
	XD DVDTA,100		;IT IS A DECTAPE
	XD DVPTR,200		;IS A PAPER TAPE READER
	XD DVPTP,400		;IS A PAPER TAPE PUNCH
	XD DVLNG,1000
				; INDICATES DEVICE HAS A LONG DISPATCH TABLE
				;(OTHER UUOS BESIDES INPUT,OUTPUT,CLOSE,RELEASE)
	XD DVIMP,2000		;IS AN ARPA INTERGALLACTIC MASSAGE POSTERIOR
	XD DVTV,4000		; IS A TV CAMERA
	XD TTYUSE,10000		;TTY DDB IN USE FLAG
	XD TTYATC,20000		;TTY ATTACHED TO JOB IF 1
	XD DVLPT,40000		;IS A LPT (CARRIAGE CONTROL IN FORTRAN)
	XD DVUDP,100000		; IS A USER DISK PACK
	XD DVDSK,200000		;IS A DISK
	XD DVDIRIN,400000	;DECTAPE DIRECTORY IN CORE IF 1

; DDB ASSIGNMENTS, DEVCHR BITS

	XD DEVLOG,5		;LOGICAL NAME FOR JOB DEVICE
	XD DEVBUF,6
				; C(LH) = RE. ADR. OF 3 WORD OUTPUT BUFFER HEADER
				;C(RH)=REL. ADR. OF 3 WORD INPUT BUFFER HEADER
	XD DEVIAD,7
				; C(LH) = PROG, IN INDEX FIELD
	XD DEVADR,DEVIAD
				;C(RH)=REL. INPUT BUFFER ADD. SERVICE ROUT. IS FILLING
	XD DEVOAD,10
				; C(LH) = PROG, IN INDEX FIELD
	XD DEVPTR,DEVOAD
				;C(RH)=REL. OUTPUT BUFFER ADR. SERVICE ROU. IS EMPTYING
	XD DEVCTR,11
;FOR LONG DISPATCH TABLE DEVICES ONLY:
	XD DEVFIL,11		;FILE NAME IN SIXBIT
	XD DEVEXT,12		;LH=EXTENSION, RH=UNUSED
	XD DEVPPN,13		; PROJ-PROG NUMBER
; LH OF DEVICE CHARACTERISTICS EXTENSION WORD, DEVCMR
	XD DEVIBF,400000	;MEANS DEVICE HAS AN INTERNAL SYSTEM BUFFER
				; AND DOES NOT SET IOACT, BUT SETS DEVSBB
	XD DEVAOA,200000	; MEANS THAT THE DEVICE SERVICE ROUTINE MAY BE
				; CALLED EVEN IF IO IS ACTIVE
	XD DEVSHR,100000	;SHARABLE - MUST GET/RELEASE NEW DDBS

	XD DEVLUP,40000		;REQUIRES LOCAL-USER STATUS TO INIT OR ASSIGN
	XD DEVMAS,20000		;MUST ASSIGN DEVICE FIRST BEFORE DOING INIT
				;ALSO OK IF USER HAS DEV INITED ALREADY

; I/O STATUS WORD ASSIGNMENTS
;DATA MODES: BITS 32-35(BYTE POINTER=PIOMOD)
	XP A,0			;ASCII
	XD AL,1			;ASCII LINE
	XP I,10			;IMAGE
	XD IB,13		;IMAGE BINARY
	XP B,14			;BINARY
	XD SD,15		;SCOPE DUMP MODE
	XD DR,16		;DUMP BY RECORDS
	XP D,17			;DUMP ACROSS RECORDS
; STATUS BITS
;RIGHT HALF (USER)
	XD IOWC,20
				; DON'T COMPUTE WORD COUNT
	XD IOCON,40		;CONTINUOUS (CONT=0)
	XD IONRCK,100
				; READ WITH NO REREAD CHECK FOR MTAPE
				; FOR LPT - NO CHAR. CONVERSION
				; FOR PTP - DON'T COMPUTE PARITY
				; FOR XGP-ESCAPE TO OTHER MODES
;BITS 27,28	DENSITY OF MAG TAPE
;		00=INSTALATION STANDARD
;		01=200 BPI
;		10=556 BPI
;		11=800 BPI
	XD IOPAR,1000
				; MAG TAPE, BCD MODE, WRITE EVEN PARITY
	XD IOTEND,2000		;END OF MAG TAPE
	XD IOBOT,4000		;BEGINNING OF MAG TAPE
	XD IOACT,10000		;DEVICE ACTIVE
	XD IODEND,20000		;DATA END ENCOUNTERED
	XD IOBKTL,40000		;BLOCK TOO LARGE
	XD IODTER,100000	;DATA ERROR
	XD IODERR,200000	;DEVICE ERROR
	XD IOIMPM,400000
				; IMPROPER MODE, DETECTED BY THE
				;INPUT SERVICE ROUTINE
; LEFT HALF (SYSTEM)
	XD IOW,1		;I/O WAIT
	XD IOBEG,2		;VIRGIN DEVICE
	XD IOFST,4
				; NEXT ITEM WILL BE THE FIRST ITEM OF A BUFFER
	XD IO,20		;OUT=1, IN=0
	XD IOEND,40		;SERVICE ROUTINE HAS TRANSMITTED LAST DATA
	XD DEVSBB,1000		; MEANS INTERNAL SYSTEM BUFFER IS BUSY

;REST OF BITS IN LH ARE DEVICE DEPENDENT EXCEPT BIT 14 WHICH
;IS KEPT IN RESERVE.


;LEFT HALF USRJDA (JOB DEVICE ASSIGNMENTS) UUO'S FOR THIS CHANNEL SINCE LAST INIT
	XD INITB,400000
				; INIT - SAVEGET DEPENDS ON THIS BEING THE SIGN BIT
	XD IBUFB,200000
				; INIT WITH INPUT BUFFER HEADER SPECIFIED
	XD OBUFB,100000
				; INIT WITH OUTPUT BUFFER HEADER SPECIFIED
	XD LOOKB,40000		;LOOKUP
	XD ENTRB,20000		;ENTER
	XD INPB,10000		;INPUT
	XD OUTPB,4000		;OUTPUT
	XD ICLOSB,2000		;INPUT CLOSE
	XD OCLOSB,1000		;OUTPUT CLOSE
	XD INBFB,400		;INBUF
	XD OUTBFB,200		;OUTBUF
	XD SYSDEV,100
				; THIS DEVICE IS A SYSTEM TAPE, OR UFD 1,3
				;PROJ.PROG. NO 1,3 ON DSK
				;RELEASE CLEARS THEM ALL

;MTAPE UUO BITS
	XD SLICE,40
				; SET SLICE LEVEL, IF 1, ACCORDING TO 'SLEVEL'
	XP SLEVEL,20
				; VALUE OF SLICE LEVEL, IF SLICE IF 1

; JOB BUFFER AREA HEADER
	XD JBFADR,0
				; BIT 0 = 1 IF THIS BUFFER RING HAS NEVER BEEN
				;REFERENCED FROM THE USER'S PROGRAM BY
				;AN INPUT OR OUTPUT COMMAND.
				;BITS 1-17=UNUSED
				;BITS 18-35=CURRENT BUFFER ADDRESS
	XD JBFPTR,1
				; BYTE POINTER TO NEXT BYTE-1
	XD JBFCTR,2		;POSITIVE ITEM COUNT
; JOB BUFFER HEADER
	XD IOUSE,400000
				; 1 IF BUFFER IF FULL, OR BEING EMPTIED
				;0 IF BUFFER IS EMPTY (OR BEING FILLED)
				;BITS 1-17=BUFFER SIZE
				;BITS 18-35=NEXT BUFFER ADDRESS

;JOB STATUS WORD(JBTSTS IN IOINI1), ONE FOR EACH JOB

	XD RUN,400000		;USER WANTS JOB TO RUN(MUST BE SIGN BIT)

	XD CMWB,200000		;JOB TYPED A COMMAND WHICH NEEDS CORE
				;WHICH IS ON DISK.  SET BY COMMAND DECODER
				;CLEARED WHEN JOB IN CORE AGAIN.

	XD JACCT,100000		;ACCOUNTING PGM RUNNING HERE, LOGIN OR LOGOUT

	XD JNA,40000		;THIS JOB NUMBER IS ASSIGNED, JOB IS INITIALIZED

	XD JERR,20000		;SYSTEM ERROR (PLDOV,ILM...)IN JOB. CAN'T CONTINUE.

	XD JLOG,10000		;JOB SUCCESSFULLY LOGGED IN

	XD SHF,4000		;MONITOR IS WAITING FOR DEVICES FOR THIS
				;JOB TO STOP AFTER CURRENT BUFFERFULL
				;SO JOB CAN BE SHUFFLED IN CORE

	XD SWP,2000		;0 IF JOB IN CORE, 1 IF SWAPPED OUT OR ON WAY

	XD JSEG,1000		; MEANS THAT THIS IS NOT A JOB BUT IS
				; REALLY A HIGH SEGMENT WITH NO JOB DATA AREA

	XD CLKR,400		;THIS JOB HAS A CLOCK REQUEST IN
				;NEEDED SO ONLY ONE REQUEST PER JOB

	XD JWSIZ,5		;SIZE OF WAIT CODE
	XD JWPOS,=14		; RIGHT MOST BIT POSITION OF WAIT CODE
	XD WTMASK,370		; MASK FOR CLEARING WAIT CODES
	;BITS 10-14 USED TO INDICATE JOB IN WAIT FOR A SHARABLE DEVICE
	;0 MEANS JOB NOT WAITING FOR SHARABLE DEVICE
	;SEE SCHEDULER(CLKCSS) FOR DEFINITION OF WAIT CODES

	XD JHLDIN,2		; SET TO KEEP JOB IN CORE (MAY BE SHUFFLED)
				; CLEARED BY CLRSIN WHEN JBTSIN=0 FOR THE
				; "OTHER" SEGMENT.

	XD JWP,1		; IF JSEG IS ON, THEN THIS BIT MEANS THAT
				; THIS UPPER SEGMENT IS WRITE PROTECTED

; RH BITS IN JBTSTS . . .

	XD SAVJDA,400000	; MEANS THAT JOBDATA AREA IS SAVED IN JBTPDL.

	XD WIPEJD,200000	; MEANS 200 RST HAS HAPPENED AND
				;   JOB WAS ON DISK AND COULDN'T GET WIPED
	XD JLOCK,100000		;JOB IS LOCKED IN CORE AFTER A LOCK UUO.
	XD SDEADIN,040000	; CORE DEADLOCK DETECTOR HAS A CLOCK REQUEST IN

	XD SDEAD1,20000		; DEADLOCK CONDITION STILL EXISTS IF SDEADIN STILL ON.

	XD FBINP,010000		; FAST-BAND TRANSFER IN PROGRESS

	XD FBERP,004000		; ERROR ON LAST FAST-BAND TRANSFER

	XD FBJWT,002000		; JOB WAITING FOR LAST TRANSFER

	; BITS 30-35 ARE THE NUMBER OF THE HIGH SEGMENT THIS JOB HAS, ZERO IF NONE

	XD STOPIO,SWP+CMWB+SHF	;FORCE JOB TO STOP FOR SWAP, SHUFFLE OR COMMAND

	XD RUNABLE,RUN+JNA	; BITS NEEDED FOR A JOB TO BE RUNABLE

	XP RUNMSK,JLOG!CLKR!CMWB!JACCT!JHLDIN
				;BITS WHICH DO NOT MATTER FOR RUNABILITY


REPEAT 0,<
;; 2-PROCESSOR INTERLOCKED STATUS BITS (COULD BE FLUSHED)
; LH BITS . . .
	XD RUN2,2		; PROCESS RUNNABLE ON P2
	XD RUN1,1		; PROCESS RUNNABLE ON P1

; RH BITS . . .

	;NONE YET
>

;JBTSIN SWAP IN LIST BITS

	XD INTSNB,400000		;INTERRUPT HANDLER
					;CALL INTRUN AT FININ
	XD BATSNB,200000		;PHANTOM STARTUP
					;CALL BATSW AT FININ
	XD COMSNB,100000		;DELAYED COMMAND
					;CALL COMMAND AT FININ
	XD JRDSNB,40000			;JOB READ
					;CALL JRSRCH AND JRDWIN AT FININ
	XD SPWSNB,20000			;FS OR LOCK FORCED SPACEWAR USER OUT
					;TURN BIT OFF AT FININ

	;BITS 24-29 BACKWARD LINK IN SWAP IN CHAIN
	;BITS 30-35 FORWARD LINK IN SWAP IN CHAIN

;BITS IN JBTSIN WHICH MAY HAVE TURNED ON JHLDIN IN JBTSTS FOR ANOTHER JOB
XD HLDSNB,INTSNB!COMSNB

	;JOBS ENTERED AT END OF LIST, SWAPPED IN FROM FRONT

;JBTST2	TWO PROCESSOR INTERLOCKED SPACEWAR STATUS BITS

;JBTST2 IS USED FOR COMMUNICATING FROM THE SPACEWAR
;SERVICE ROUTINE TO THE REST OF THE SYSTEM.  THE BITS IN
;IT ARE DEFINED AS FOLLOWS:

;LH BITS
	XD	SPWRUN,400000	;THIS JOB HAS A SPACEWAR MODULE ACTIVE.
	XD	SPWGRT,200000	;"I AM THE GREATEST", TO BE DEFINED LATER.
	XD	SPWSUS,100000	;THE MONITOR WANTS THIS JOB TO STOP FOR SOME
				;GOOD REASON (LIKE TO SHUFFLE IT).  GIVE THE
				;SPACEWAR MODULE ONE MORE QUANTUM WITH A WARNING
				;THAT IT WILL BE A WHILE UNTIL IT IS RUN AGAIN
	XD	SPWST1,40000	;THIS JOB HAS BEEN WARNED AND IS STOPPED ON P1
	XD	SPWERB,20000	;SPACEWAR MODULE HAS BEEN TERMINATED BY AN ERROR.
				;BITS 18-35 ARE THE PC AT THE TIME OF THE ERROR.
	XD	SPWSU1,10000	;SUSPENSION WARNING HAS BEEN GIVEN TO JOB ON P1
				;THE ROUTINE WHICH IS ENTERED WHEN A SPW JOB DOES
				;A UUO (TERMINATES) ACTUALLY DOES THE SUSPENSION.
	XD	SPWST2,4000	;SAME AS SPWST1 FOR P2
	XD	SPWSU2,2000	;SAME AS SPWSU1 FOR P2
	XD	SPWNT1,1000	;NO TIMEOUT FOR P1
	XD	SPWNT2,400	;NO TIMEOUT FOR P2

;BITS 10-12 ARE NOT USED AS YET
				;ERROR BITS:  SWPERB SET FOR ANY OF THESE.
	XD	ILLTMO,20	;TIMEOUT FROM SPACEWAR
	XD	ILMSPW,10	;ILL MEM REF FROM SPACE WAR MODE
	XD	NXMSPW,4	;NXM FROM SPACE WAR MODE
	XD	POVSPW,2	;PDLOV FROM SPACE WAR MODE
	XD	CNSSPW,1	;CONS TRAP FROM SPACE WAR MODE

;PRIVILEGE BITS (IN JBTPRV AND JB2PRV)
COMMENT	 $

THE MONITOR  HAS BEEN  CHANGED SO  THAT CERTAIN  FUNCTIONS THAT  WERE
FORMERLY  RESTRICTED TO [1,2]  OR SOME  OTHER PRIVILEGED PPN  ARE NOW
AVAILABLE ON THE BASIS OF PRIVILEGE BITS INSTEAD OF BY PPN.

PRIVILEGE BITS ARE  KEPT FOR EACH JOB  IN JBTPRV.   JBTPRV IS SET  BY
THE LOGIN UUO.  THE LOGIN CUSP WILL DETERMINE WHAT  PRIVILEGES TO SET
FROM DATA THAT IS KEPT WITH THE USER'S PASSWORD.

A  NEW  UUO, SETPRV  HAS BEEN  ADDED  TO ALLOW  A  JOB TO  CHANGE ITS
PRIVILEGES.  SETPRV  WITH AN ARGUMENT OF  -1 WILL RETURN THE  CURRENT
SET  OF PRIVILEGES  IN  THE USER'S  AC;  ANY OTHER  ARGUMENT WILL  BE
INTERPRETED AS  AN ATTEMPT  TO CHANGE  PRIVILEGE BITS.  SUCH  ATTEMPT
WILL BE SUCCESSFUL  IF EITHER PRIPRV IS  ALREADY SET OR JACCT  IS SET
JBTSTS.  THE  RESULTING PRIVILEGE BITS WILL BE RETURNED IN THE AC, AS
AN INDICATION OF SUCESS OR FAILURE.


THE CURRENTLY IMPLEMENTED SET OF PRIVILEGES ARE::

NAME	BIT	FUNCTION
PRI	0	ALLOWS USER TO RESET HIS PRIVILEGES
DAW	1	ALLOWS ACCESS TO MTAPE WRITES ON THE DISK
PRO	2	ALLOWS ACCESS RENAME FILES
REA	3	ALLOWS ACCESS READ FILES
WRT	4	ALLOWS ACCESS WRITE FILES
UDP	5	ALLOWS ACCESS TO UDP'S WITHOUT PASSWORD
UPG	6	ALLOWS UPGSEL TO SELECT OTHER III'S, ALSO DD DIDLING
MES	7	CAN SEND MESSAGES TO BUSY CONSOLES
KIL	8	CAN DO MESSY KILL COMMAND
DEV	9	CAN DETACH DEVICES FROM SYSTEM
SEG	10	ALLOWS SEGMENT ACCESS AND SETPRO
SSL	11	ALLOWS SETTING SYSTEM SL RESERVATION TABLE
ACW	12	ABSOLUTE WRITES IN CORE THROUGH SETPR2
INF	13	ALLOWS ACCESS TO PASSWORD DATA
TLK	14	ALLOWS TALK COMMAND WHILE "BUSY".
FBW	15	ALLOWS ABSOLUTE WRITES ON LIBRASCOPE.
		THIS IS INTENDED ONLY FOR STARTING SYSTEM IN USER MODE.
XGP	16	ALLOWS CALL ['XGPUUO']

MOST USERS WILL NEED NO PRIVILEGES, HOWEVER, REQUESTS FOR
PRIVILEGES WILL BE CONSIDERED.

$


DEFINE PRIVS
<
;	LEFT HALF
XLPRIV PRI,400000		;PRIVILEGE PRIVILEGE
XLPRIV DAW,200000		;DISK ABSOLUTE WRITE 
;  NEXT THREE MUST BE 100000,40000, AND 20000 UNLESS DSKSER IS CHANGED!!!
XLPRIV PRO,100000		;FILE SYSTEM RENAME PRIV
XLPRIV REA,40000		;FILE SYSTEM READ PRIV
XLPRIV WRT,20000		;FILE SYSTEM WRITE PRIV

XLPRIV UDP,10000		;READ LAST BLOCK OF UDP
XLPRIV UPG,4000			;SELECT OTHER DPYS WITH UPGIOT
XLPRIV MES,2000			;CAN DO TTYMES ARBITRARILY
XLPRIV KIL,1000			;CAN USE CONSOLE KILL COMMAND
XLPRIV DEV,400			;CAN USE DET/ATT DEVICE COMMAND
XLPRIV SEG,200			;SEGMENT ACCESS & SETPRO OK
XLPRIV SSL,100			;CAN SET SERVICE LEVEL RESERVATION TABLE
XLPRIV ACW,40			;CAN DO ABS MODE WRITE USING SETPR2
XLPRIV INF,20			;CAN READ AND WRITE SPECIAL FILE INFO
XLPRIV TLK,10			;CAN TALK TO ANY CONSOLE
XLPRIV FBW,4			;ALLOWS ABSOLUTE FBWRITE.
XLPRIV XGP,2			;THIS IS THE XGP FONT COMPILER
XLPRIV LUP,1			;LOCAL USER PRIVILEGE
>

DEFINE XLPRIV $ (NAM,VAL)
<XD	NAM$PRV,VAL>

;DEFINE BITS
PRIVS

;THESE ARE THE RESTRICTED PRIVILEGES FOR ENABLE COMMAND
↓RSPRVS←←<XWD XGPPRV!SSLPRV,0>

;STATISTICS VARIABLES
;LENGTH OF STATISTICS TABLE
XD	STATLEN,600

;OPCODES FOR VARIOUS STATS
XD CSZSTA,000000		;BYTE(1)0(3)0(8)HIGH ORDER BITS OF CORE SIZE(6)J#
XD CPSSTA,040000		;BYTE(1)0(3)1(8)HIGH ORDER BITS OF CORE POSITION(6)J#
XD NAMSTA,400000		;BYTE(1)1(5)0(6)UNUSED(6)J#
				;FOLLOWING TWO 18 BIT BYTES ARE JOBNAME
XD QUESTA,410000		;BYTE(1)1(5)1(6)QUEUE CODE(6)J#
XD SINSTA,420000		;BYTE(1)1(5)2(6)JBTSIN BIT #(6)J#
XD SEGSTA,430000		;BYTE(1)1(5)3(6)SEGMENT #(6)J#
XD SPWSTA,440000		;BYTE(1)1(5)4(6)0-17:TICS OF SPW, 77:SPW OFF(6)J#
XD GLUSTA,450000		;BYTE(1)1(5)5(6)JBTGLU COUNT(6)J#
XD LOKSTA,460000		;BYTE(1)1(5)6(6)1:LOCKING, 0:UNLOCKING(6)J#
XD FITSTA,470000		;BYTE(1)1(5)7(6)UNUSED(6)J#

; SYSTEM MACROS

;MACRO TO PREVENT SCHEDULING, USED AT UUO LEVEL WHEN A
;REENTRANT ROUTINE IS CHANGING COMMON DATA NOT YET
;ASSIGNED TO A PARTICULAR JOB

DEFINE NOSCHED
<>

;MACRO TO ALLOW SCHEDULING ONCE MORE

DEFINE SCHEDULE
<>

;MACRO TO PREVENT CORE SHUFFLING, USED AT UUO LEVEL WHEN
;A ROUTINE SETS UP AN ABSOLUTE USER ADDRESS IN AN AC
;OTHER THAN PDP,PROG, OR JDAT. THE MAIN EXAMPLE IS A BLT
;FROM EXEC TO USER OR USER TO EXEC.

DEFINE NOSHUFF
<>

DEFINE SHUFFL
<>

;MACRO TO START A DEVICE FROM UUO LEVEL
;TAC:=XWD DEVINT FLAGS,CONO ARGUMENTS

DEFINE STARTDV ! (A)
<
	CONO PI,PIOFF
	HLRM TAC,A!CON
	CONO A,(TAC)
	CONO PI,PION
>

;MORE SYSTEM MACROS

DEFINE CAT ! (A,B) <A!B>

OPDEF	CLRBFI	[TTYUUO	11,]
OPDEF	INWAIT	[TTYUUO	14,]

;USER MODE DATA REFERENCE
IFE FTXCTR,<OPDEF XCTR [XCT]>
IFN FTXCTR,<OPDEF XCTR [107000,,]>

DEFINE TYPE (S) <
	PUSHJ P,TTYFUW		; WAIT FOR OUTPUT TO FINISH
	CLRBFI			; CLEAR INPUT BUFFER TYPEAHEAD
	PUSHJ P,INLMES
	ASCIZ /S
/
	PUSHJ P,TYPGO		; START UP TTY
>

DEFINE HGMAC(CODE)	<
	IFN FTHG,	<
		JUMPN	PID,.+3
		PUSH	P,[CODE]
		POP	P,HGCODE	>>

; MACRO TO DEFINE TABLES FOR SECONDARY DISPATCH UUOS

DEFINE UUOMAC(TBL,BASUUO)
{TBL:	UUOS{ UUOMC2 X}UUOCNT←←.-TBL
	BASUUO UUOCNT-1,UUOLNK
↑↑UUOLNK←←.
	UUOS{<SIXBIT,X,>}}

DEFINE UUOMC2(A,B,C){B,,IFDIF<C><><C;>A}

↓UUOLNK←←0

;; MACROS TO SYNCHRONIZE PROCESSORS

	XD PSYNCN,4	; NUMBER OF CONTROL CELLS NEEDED

DEFINE SYNINI (A) <
	SETZM A
	SETZM A+1
	SETZM A+2
	SETZM A+3
>

DEFINE PSYNC1(A) <
	PUSHJ P,PWAIT
	 A
IFIDN <A><><JFCL>
>

DEFINE PSYNC (A) <
	PUSHJ P,PWAIT
	 MOVEI TAC,A
>

DEFINE XSYNC1(A) <
	PUSHJ P,XWAIT
	 A
IFIDN <A><><JFCL>
>

DEFINE XSYNC (A) <
	PUSHJ P,XWAIT
	 MOVEI TAC,A
>

;MACROS TO PUSH AND POP ACS, DISASTER MACROS

↓FIXNUM←←10		;NUMBER OF SECTORS TO READ AT A TIME IN SYSFIX
↓FIXLEN←←FIXNUM*40	;TOTAL NUMBER OF WORDS

DEFINE PUSHACS <
	PUSHJ P,PUSHIT
>
DEFINE POPACS <
	PUSHJ P,POPIT
>

DEFINE DEBCHECK <
	SKIPE DEBMODE
	PUSHJ P,DDTCALL
>
;THIS MACRO IS FOR USE IN CALLING DISERR IN COMCSS
;EXAMPLE:
;	PUSHJ P,DISERR
;	DISARG	STR,[ASCIZ/TAC=/]
;	DISARG	OCT,TAC
;	DISARG	STR,[ASCIZ/
;/]
;	-1
;WOULD TYPE:
;	TAC=000000000030
;
;IF TAC CONTAINED 30
OPDEF OPZERO[0]
DEFINE DISARG $ (A,B)
<	A$QQQ B
>
DEFINE QQQNAM
<	ERRMAC	STR
	ERRMAC	CHR
	ERRMAC	OCT
	ERRMAC	LOC
	ERRMAC	DEC
	ERRMAC	SIX
	ERRMAC	DCP
>
DEFINE ERRMAC $ (I)
<	OPDEF I$QQQ [QQQ⊗=23]
QQQ←←QQQ+1
>
QQQ←←0

	QQQNAM

;PARAMETER ASSIGNMENTS FOR THIS SYSTEM.

XD LJOBN,100	;3330 HAS ENOUGH ROOM FOR ALL 64 POSSIBLE JOBS
XD JOBN,100	; IF NOT SWAPPING ON THE LIBRACROCK, CAN USE ALL JOB NUMBERS
XD NSPMEM,=2000	;2 MICRO-SECONDS PER MEMORY CYCLE.
XD PTRNUM,1	;ONE PAPER TAPE READER.
XD PTPNUM,1	;ONE PAPER TAPE PUNCH.
XD LPTNUM,1	;ONE LINE PRINTER.
XD CDRNUM,0	;NO CARD READER.
XD TVNUM,1	;ONE TV CAMERA
XD ADNUM,1	;AN A/D CONVERTER.

XD DTCNUM,4	;FOUR DEC TAPE DRIVES
XD MTCNUM,2	;EIGHT MAG TAPES.
XD SCNNUM,20	;SIXTEEN TTYS ON THE TTY SCANNER.
XD DPYNUM,6	;NO. DISPLAY CONSOLES.
XD DDNUM,100-6	; NUMBER OF DATA DISK TERMINALS
XD KBDNUM,DPYNUM	;SAME NUMBER OF KEYBOARDS.
XD PTYNUM,24	;NO. OF PSEUDO TELETYPES.
XD DILNUM,1	;NO DIALERS YET
XD ELFNUM,1	;NO. PERIPHERAL PROCESSORS (PDP-11'S) -- BO 6-MAY-74
XD IOPDLN,2*23	;IO PUSH/POP STACK LENGTH, ENOUGH FOR ALL IO CHANNELS (ONCE)
XD CLKPLN,140	;CLOCK PDL LENGTH

; HERE, WE DEFINE THE LEGAL QUEUES AND QUANTUM TIMES

DEFINE QUEUES
<	X (FUCK)	;THIS BECOMES QUEUE 0, WHICH IS ACTUALLY UNUSED
	X (ST)		;SYSTEM TAPE WAIT
	X (DT)		;DECTAPE CONTROL WAIT (UP TO 8 DRIVES)
	X (DC)		;DATA CONTROL (DC) WAIT - MAGTAPE AND DECTAPE
	X (MT)		;MAGTAPE CONTROL WAIT (UP TO 8 UNITS)
>


;JOB STATUS CODES WHICH HAVE NO CORRESPONDING QUEUES
;JOBS ARE UNRUNABLE WHEN IN THESE STATES

DEFINE CODES
<	X (IOW)		;IO WAIT
	X (DIOW)	; DISK IO WAIT
	X (DW)		; DEVICE WAIT
	X (NUL)		;JOB NUMBER NOT ASSIGNED
	X (STOP)	;STOP (CONTROL C)
	X (INTW)	; INTERRUPT WAIT
	X (SEG)		; UPPER SEGMENT WAIT
>

DEFINE PQUEUES
<	X (RUN)		; GENERALIZED RUN QUEUE
	X (T)		; TELETYPE RUN QUEUE
>

; QUANTUM TIME

	XD QQMQT,10	; MINOR QUANTUM TIME
	XD JIFSEC,=60	; NUMBER OF TICKS IN A SECOND
	XD JLLENGTH,=20	; NUMBER OF PREVIOUS JOB LOAD FACTORS WE WILL KEEP
	XD JLTIME,2*JOBN	;MUST BE THIS BIG AT LEAST!  REG 1-22-74
IFG =60-JOBN,<XD JLTIME,=120>	;RECOMPUTE PRIORITIES EVERY 2.0 SECONDS
;	XD SWAPLIMIT,=90*2000 	;NOW DEFINED IN CORDAT AS A CORE CELL.

;DEVICE NAMES NOT IN THE ASSEMBLER.(IN INCREASING ORDER)
XD APR,0
XD PI,4
XD IOP,10	;I/O PROCESSOR (167)
XD PTP,100
XD PTR,104
XD CTY,120
XD TTY,CTY
XD LPT,124
XD DC,200
XD DCB,204	;DATA CONTROL (136)
XD DTC,210
XD DTS,214
XD MTC,220
XD MTS,224
XD MTM,230
XD ADC,240	; NEW AD CONVERTER (PDP-6)
XD DAC,244	; NEW DA CONVERTER (PDP-6)
XD DCSA,300
XD DCSB,304
XD DKB,310	;MICROSWITCH KEYBOARD SCANNER
XD VDS,340	;EARNEST VIDEO SWITCH
XD PK,370	;(TELEPHONE) PAGING KLUDGE
XD DIL,374	;AUTO DIALER
XD IMP,400	; ARPA INTERGALLACTIC MASSAGE PROCESSOR
XD TV,404	;TV CAMERA INTERFACE
XD PEN,414	;LIGHT PEN ON DISPLAY
XD ARM,420	;MECHANICAL ARM
XD AD,424	;A/D CONVERTER
XD DPY,430	;DISPLAY CONSOLES
XD KBD,434	;THEIR KEYBOARDS
XD XGP,440	;XEROX GRAPHICS PRINTER
XD DSK,444	;DISK INTERFACE
XD D11,470	;PDP-11 DATA TRANSFER INTERFACE
XD PMP,500	;P. PETIT'S IBM CHANNEL
XD IBM,504	;	"
XD DDD,510	;DATA DISK DISPLAYS
XD PCLK,730	;PETIT'S CALENDAR CLOCK
XD AS,774	;AUDIO SWITCH

;IOP CONO/CONI BITS

;7		35-33 PI CHANNEL
XD	IOPJDN,10	;JOB DONE
XD	IOPNXM,20	;NON-EX-MEM
XD	IOPMIS,40	;DATA MISS

XD	IOPPAR,100000	;PARITY ERROR
XD	IOPRLY,200000	;EARLY RESPONSE (ALSO SETS DATA MISS)

XD	IOPANY,IOPNXM!IOPMIS!IOPPAR!IOPRLY	;ANY ERROR BIT

SUBTTL FIRST 19 JULY 67
;STANDARD MAG TAPE DENSITY(556 BPI),PARITY(ODD-BINARY)
	XD STDENS,2
				; STANDARD MAG TAPE DENSITY
				;STDENS=D+P WHERE D AND P ARE:
				;D=1(200 BPI);D=2(556 BPI);D=3(800 BPI)
				;P=0(ODD-BINARY PARITY);P=4(EVEN-BCD PARITY)
;NO. OF TIMES TO TRY ON DECTAPE ERRORS
	XD DTTRY,4
				; NUMBER OF RETRYS ON DECTAPE ERRORS
;SIZE OF MAGTAPE RECORDS(DATA WORDS IN BUFFER)
	XD MTSIZ,200
				; SIZE FOF MAGTAPE RECORDS
;SIZE OF LPT BUFFER(NO. OF DATA WORDS)
	XD LPTSIZ,=24
				; SIZE OF LPT BUFFERS
; SIZE OF LPT SYSTEM BUFFER
	XD LPTBLN,300
; SIZE OF PTP SYSTEM BUFFER
	XD PTPBLN,320
;MAX. NO. OF CONSECUTIVE DECTAPE BLOCKS BEFORE RESCHEDULING
	XD BLKQNT,=50
				; MAX. NO. OF CONSECUTIVE DECTAPE BLOCKS BEFORE
				;RESCHEDULING IF ANOTHER JOB WAITING
; SPECIAL LOCATIONS IN MEMORY
	XD DDTMEM,37
				; MEMORY SIZE FOR SYSTEM DDT AND SYSMAK
	XD DDTSYM,36

;SYSDSP SYSTEM INITIALIZATION DISPATCH TABLE, STARTING AT LOC 200
;THIS SUBROUTINE MUST BE LOADED FIRST
;ROUTINE "ONCE" IS ONCE ONLY CODE. IT CONVERTS THE DATE
;AND SETS UP IO SERVICE CHAIN,

IFN FTDDT,<
	LOC 74		;CONVINCE SAVE COMMAND TO SAVE ENTIRE CORE IMAGE
	0,,DDT		;AFTER LOADING WITH SYMBOLS

	LOC 162		;POINTERS INTO DDT FOR BOOT HACK
	NOTDDT
	SYMLOC
	INDDT
	DDTSWP
↓BOOTWC:0		;DDT STORES WCMA FOR IOP FOR SWAPPED USER CORE HERE
↓BOOTSE:0		;DDT STORES SECTOR NUMBER FOR ABOVE HERE
>

LOC 200		; THE SYSTEM IS AN ABSOLUTE ASSEMBLY, STARTING AT 200

; 200 - INITIALIZE SYSTEM VARIABLES ONCE ONLY
SYSDSP:
	JRST SYSINI

; 201 - GO INTO EXEC DDT
IFN FTDDT,<JRST DDT>
IFE FTDDT,<HALT .>

; 202 - MAKE NEW SYSTEM OUT OF JOB 1
	JRST SYSMAK

; 203 - INITIALIZE SYSTEM VARIABLES ALL OVER AGAIN
	JRST JSR2

; 204 - P2 RESTART ADDRESS
	JRST .	;LOOP HERE UNTIL PDP-10 IS READY. THEN JRST P2START

; 205 - BRING MACHINE UP IN MAINTENANCE MODE
	HALT	.		;NOT ANY MORE!

; 206 - WRITE OUT SYSTEM ON THE DISK
	JRST BEGIN

; 207 - STOP MONITOR, ERROR HALT, WRITES OUT LAST SAT BLOCK AND STOPS
	HALT	.	

; AT LOCATION 210 BEGINS THE LIST OF USEFUL LOCATIONS
;IN THE SYSTEM USED BY SYSTAT.

IFN FTSWAP,<
XWD 0,JBTSTS
 PRJPRG 
 JBTSWP 
 SPWGO 
 TTIME 
 UPTIME 
 CORMAX 
 DEVLST
>
IFE FTSWAP,<
XWD 0,JBTSTS
 0 
 0 
 SPWGO 
 TTIME 
 UPTIME 
 0 
 DEVLST
>
; THIS IS AT LOCATION 220
        TTYTAB 
        <BYTE(9)SCNNUM,DPYNUM,DDNUM,PTYNUM> 
        JOBN-1 
        JBTADR 
        JBTQ 
        JOBNAM 
        JOB 
        CONFIG
;NEXT IS 230
        SP2GO 
        JOBQUE 
        JBTPRI 
        JBTJL 
        NQUES 
        QNAMS 
        JBTLIN 
        LETAB

; NEXT IS LOC 240
JBTJLH
IFN FTSTAT, <	STATS 
 JBTGSL 
 STATLEN 
 STATPTR 
 STATNUM >
IFE FTSTAT, <	    0 
 JBTGSL 
 0 
 0 
 0	>
							INTIME 
 STBEG

; NEXT IS AT 250
JBTKCJ 
 JBTBTM 
 LASTRESTART 
 TTYLOK 
 MAINTMODE 
 BIGHOL 
 LASTDISASTERTIME 
 SHFWAT
;NEXT IS AT 260
STEND2 
 FBBANDLIST 
 EXPMOD 
 MEMSIZ 
 FSRPQ 
 SYSTOP 
 CORTAB 
 NOLOGIN
;NEXT IS AT 270
PTYJOB
JBTPRV
XWD UCLLEN⊗9+UCLDLN,UCLTAB
XWD 0,DSKPPN
FTIME
NJOBS
DSKOPS
INITIM
;NEXT IS AT 300
XWD -DISPL,COMTAB
FBACT
LINTAB
ASTAB
JB2PRV
XWD -LFTLEN,LFTTAB
XWD -RHTLEN,RHTTAB
JBTSIN
;NEXT IS AT 310
JBTGLU
JOBNM1
DDFCNT
BLOCK 2	;PATCH AREA FOR INTERESTING NEW POINTERS

; HERE LIE THE ROUTINES TO PUSH AND POP ACCUMULATORS

SIXRUN:
	JFCL		;TESTED BY 6'S NULL JOB (MUST BE IN LOW CORE)

↑↑PUSHIT:
	PUSH P,0	; SAVE 0
	HLRE 0,P	; PICK UP COUNT
	ADDI 0,20	; ADD IN DISPLACEMENT
	XOR 0,P		; IF SIGNS ARE DIFFERENT, NOT ENOUGH STACK
	JUMPGE 0,PUSHOK
	POP P,0		; CAN'T DO IT, LOSE BIG
	MOVE	TAC,[POINT 7,[ASCIZ ⊗NOT ENOUGH ROOM TO PUSH ACS.
⊗]]
	JSR DDTTYPE
	CONSZ APR,MAOFF
	JRST DDT
	HALT AUTOLOAD

PUSHOK:
	POP P,0		; GET BACK 0
	EXCH 0,(P)	;SAVE 0 AND GET RETURN.
	MOVEM 0,20(P)	;GEE, THIS WAY WE RETURN WITH A POPJ
	MOVEI 0,1(P)
	HRLI 0,1
	BLT 0,17(P)
	ADD P,[XWD 20,20]
	POPJ P,		;RETURN TO SENDER

↑↑POPIT:
	MOVSI 0,-17(P)
	HRRI 0,1
	BLT 0,17
	MOVE 0,20(P)
	EXCH 0,(P)
	POPJ P,

;THIS PRINTS "YOU'RE IN DDT" AND ENTERS DDT.

DDTCALL:

	MOVEM	TAC,DDTPAC
IFN FTDDT,{
IFN FTDSWP,<	SKIPE	NOTDDT			;ANY DDT?
		JRST	NXDDT			;NO	>;FTDSWP
	MOVE	TAC,[POINT 7,[ASCIZ/YOU'RE IN DDT π↓π
/]]
	JSR	DDTTYPE
	MOVE	TAC,DDTPAC
	CONSZ	APR,MAOFF
	JRST	DDT
	JRST	4,DDT
}

NXDDT:
	MOVE TAC,[POINT 7,[ASCIZ/NO DDT
/]]
	JSR	DDTTYPE
	MOVE	TAC,DDTPAC
	POPJ	P,

DDTPAC:
	0

; THIS PART HANDLES AUTOMATIC RELOADS AND RESTARTS
AUTOLOAD:

	CONSZ APR,MAOFF		;ARE WE THE PDP-6
	JRST AUTO10		;PDP-10
	CONO APR,200000
	CONO PI,10400		;RESET PI'S
	JRST SYSDSP+4		;P2 RESTART LOC

AUTO10:
	EXCH P,ERRPD
	PUSHACS
	SETOM DISFLAG
	PUSHJ P,DISFLU
	POPACS
	SKIPN DEBMODE
	CONSZ DSK,1B27
	PUSHJ P,DDTCALL
	CONO APR,200000
	CONO PI,10400		; RESET PI SYSTEM
	PUSHJ P,DSKSTP		; WRITE OUT SAT
	CONO APR,200000
	CONO PI,10400		; RESET PI SYSTEM
	SKIPN P2NUM		;ANY SIX AT ALL?
	JRST AUTO1		;NO SKIP THE INTERLOCK
	SETZM AUTOSYNC
	MOVE TAC,[JSR AUTO6]
	MOVEM TAC,46
	MOVEM TAC,56
	MOVEI TAC,200000
	SKIPN AUTOSYNC
	SOJG TAC,.-1
	JUMPN TAC,AUTO1
	SKIPE AUTOSYNC
	JRST AUTO1
	MOVE TAC,SIXPNT		;PLEASE START PDP-6
	JSR DDTTYPE

; WAIT FOR THE PDP-6 TO CATCH UP BEFORE RELOADING

AUTO2:
	SETOM CH3
	SETZM CH3		; MAKE SURE PDP-6 GETS PAST INITIALIZE CODE
	SKIPN AUTOSYNC
	JRST AUTO2
AUTO1:

	MOVE TAC,RSTPNT		;AUTO RESTART
	JSR DDTTYPE
	MOVE TAC,UPTIME
	EXCH TAC,LASTRESTART
REPEAT 0,<			;TIRED OF RESTARTS THAT DON'T WORK?
	SUB TAC,UPTIME
	MOVNS TAC
	CAIG TAC,=60*JIFSEC
	JRST AUTO3
	MOVE TAC,MONPTR
	PUSHJ P,CHECK
	CAME TAC1,MONSUM
>
	JRST AUTO3
	SETZM AUTOSYNC	; IF MONITOR IS STILL OK, DO A 200 RESTART
	JRST SYSDSP
AUTO3:
	HRLZI 17,AUTOL
	BLT 17,17
	JRST 0

SIXPNT:
	POINT 7,.+1
	ASCIZ /
PLEASE START THE PDP-6 AT 204
/

RSTPNT:
	POINT 7,.+1
	ASCIZ /
AUTOMATIC RESTART
/


; HERE WE PUT A ROUTINE INTO THE ACS AND JUMP TO IT WHILE SYSTEM IS BEING READ IN

AUTO6:
	0
	CONO PI,10400
	CONO APR,200000
	MOVE 1,[MOVE 17,AUTOSYNC]
	MOVE 2,[JUMPN 17,1]
	MOVE 3,[SOJG 0,3]
	MOVE 4,[JRST AUTO4]
	MOVEI 0,100000
	SETOM AUTOSYNC
	JRST 1

AUTO4:
	MOVE TAC,[JSR P2CH3]	; RESTORE INTERRUPT LOCATIONS
	MOVEM TAC,46
	MOVE TAC,[JSR P2CH7]
	MOVEM TAC,56
	JRST SYSDSP+4

DEBMODE:

	0

AUTOL:

	PHASE 0
AUTOL3:
	CONO DSK,1B23!1B24
	CONO IOP,0
	DATAO IOP,AUTOL1
	JFCL
	JFCL
	DATAO DSK,SYSBAND
	CONSO IOP,IOPANY!IOPJDN	;WAIT FOR SOMETHING TO HAPPEN
	JRST .-1
	CONSZ IOP,IOPANY	;DID SOMETHING BAD HAPPEN
	HALT 0
	SETZM AUTOSYNC
	JRST SYSDSP

AUTOL1:
	XWD -=76*2000,0

DEPHASE



; ROUTINE TO TYPE ON THE CONSOLE TELETYPE
; ENTER WITH BYTE PTR TO ASCIZ IN TAC.

...TM2:
	0				;TEMPORARY CELL
↑↑DDTTYPE:
	0				;JSR TO HERE.
	MOVEM	TAC1,...TM2		;SAVE TAC1
DDTTY1:
	ILDB	TAC1,TAC		;GET BYTE
	JUMPE	TAC1,DDTTY2		;NULL ENDS THE MESSAGE
	CONSZ	CTY,20			;WAIT FOR OUTPUT BUSY TO BE OFF.
	JRST	.-1
	DATAO	CTY,TAC1		;TYPE CHARACTER
	CONSO	CTY,40			;DID THEY TYPE ANYTHING (INPUT DONE)
	JRST	DDTTY1			;NO. - LOOP TO GET NEXT CHARACTER
	DATAI	CTY,TAC1		;YES. READ CHARACTER.
DDTTY3:
	CONSZ	CTY,20
	JRST	.-1			;WAIT TO ECHO CHARACTER
	DATAO	CTY,TAC1		;ECHO
	CAIE	TAC1,15			;CR?
	JRST	DDTTY4			;NO. STOP NOW.
	MOVEI	TAC1,12
	JRST	DDTTY3			;YES. GO DO A LF.

DDTTY4:
	ILDB	TAC1,TAC		;FLUSH UNTIL NULL BYTE
	JUMPN	TAC1,.-1		;BEACUSE SOME PEOPLE RETURN TO 1(TAC)

DDTTY2:
	MOVE	TAC1,...TM2		;RESTORE TAC1
	JRST	@DDTTYPE


; THIS ROUTINE SKIPS AND SETS DISFLAG AND TURNS OFF PI'S IF
;THE SYSTEM SHOULD BE RESTARTED

ALTNOW:
	MOVE TAC,UPTIME
	EXCH TAC,LASTDISASTERTIME
	SUB TAC,UPTIME
	MOVNS TAC
	CAILE TAC,=60*JIFSEC
	POPJ P,
	CONO PI,PIOFF
	AOS (P)
	SETOM DISFLAG
	POPJ P,

;OTHER SYSTEM DATA STORAGE
;LOCATIONS SETUP BY ONCE ONLY OPERATOR DIALOGUE

DETFLG:
	0			; TELLS SYSINI THAT AD AND DIS ARE TO BE DETACHED FROM THE SYSTEM
CRKTIM:
	0			; TIME OF DAY TO BE PASSED ALONG
CRKDAT:
	0			; DATE CELL
P1NUM:
	0			; PROCESSOR 1 NUMBER
				; HAS BIT 'MAOFF' SET IN LH IF P1 IS IN MA TRAP OFFSET
P2NUM:
	0			; PROCESSOR 2 NUMBER AND MAOFF FLAG
PWRCNT:
	1B17			; POWER FAILURE COUNT DOWN
P2RCNT:
	1B17			; P2 POWER FAILURE COUNT DOWN
XJBPFI:
	XWD JOBPFI,0
				;JOBPFI=HIGHEST LOC. IN USER JOB DATA AREA
				;PROTECTED FROM IO
IFN FTLOGIN,<			;DEC 3.16
REFLAG:
	0			;DEC 3.16
;IF REFLAG IS NON-ZERO (SET BY REFRESH CODE IN ONCE) THEN THE
;FIRST USER TO TYPE "LOGIN" IS GIVEN IT AS A PROGECT-PROGRAMMER
;NUMBER.
MAINTMODE:
	0		; IF MAINTMODE≠0, ONLY GOD MAY LOG IN.
NOLOGIN:
	0		; SET ≠ 0 TO PREVENT LOGINS
EXPMOD:
		0		;IF ≠ 0 THEN X.TXT[2,2] IS TYPED BY LOGIN
BLTSWP:
		0		;IF ≠ 0 THEN BLT CORE IMAGE AFTER SWAPIN
>
SYSSIZ:
	SYSMAK			;SIZE OF MONITOR(FIRST LOC NOT USED)

; P2 INITIALIZATION WAIT LOOP. WAITS FOR P1 TO TELL IT TO GO

P2XFR1:
	JRST .+1
P2XFR:
	AOJA 0,.
	AOJA 0,.
	JRST 4,-1

PICON:
	CONO PI,32237		; PI ENABLE CHNS 3, 5, 6, AND 7
				; AND PARITY BOX
P2CON:
	CONO PI,32237		; PI ENABLE FOR P2
INIMES:
	.+1
ASCIZ /SYSTEM LOADED ON /
SAVITM:
	0			; SOMEWHERE IN IOINIT

; INTERRUPT BIT DEFINITIONS, APR CONI BIT DEFINITIONS

	XD	PION,200
	XD	PIOFF,400
	XD	USRMOD,10000
	XD	ADRBRK,040000
	XD	IOTUSR,100000
	XD	MAOFF,40

REPEAT 0,<
;SYSTEM WRITE REFERENCE KLUGE:
;SYS WR REF KLUGE IS ENABLED BY DATAO PTR,[1]. DISABLED BY DATAO PTR,[0]
	XD	SYSCLB,400000		;SYSTEM STOMPED FLAG (CONI)
	XD	CLRCLB,100000		;CLEAR SAME (CONO)
	XD	SWRENB,4000		;SYSTEM WRITE REFERENCE ENABLED (CONI)
>

	XD	SAVDMP,'DMP'

;USER INTERRUPT BIT ASSIGNMENTS - LH FIRST . . .
	XD	INTSWW,400000		; INTERRUPT BEFORE SWAPPING
	XD	INTSWD,200000		; INTERRUPT WHEN SWAP DONE
	XD	INTSHW,100000		; INTERRUPT BEFORE SHUFFLING
	XD	INTSHD,040000		; INTERRUPT WHEN SHUFFLE COMPLETE
	XD	INTTTY,020000		; INTERRUPT ON TELETYPE INPUT
	XD	INTPTI,010000		; INTERRUPT ON PSEUDO-TELETYPE INPUT
	XD	INTMAIL,004000		; INTERRUPT ON MAIL
	XD	INTWAIT,002000		; INTERRUPT ON UUO COMPLETE
	XD	INTPTO,001000		; INTERRUPT ON PSEUDO-TELETYPE OUTPUT
	XD	INTPAR,000400		; PARITY ERROR INTERRUPT
	XD	INTCLK,000200		; CLOCK INTERRUPT
	XD	INTINR,000100		; IMP INTERRUPT BY RECEIVER
	XD	INTINS,000040		; IMP INTERRUPT BY SENDER
	XD	INTIMS,000020		; IMP STATUS CHANGE INTERRUPT
	XD	INTINP,000010		; IMP INPUT WAITING
	XD	INTTTI,000004		; INTERRUPT ON <ESC>I
	XD	INTQXF,2		;INTERRUPT ON Q XFER
	XD	INTHAL,1		; INTERRUPT ON ↑C HALT
; INTERRUPT BIT ASSIGNMENTS - RH
	XD	CNS,400000		; INTERRUPT ON CONS TRAP
	XD	POV,200000		; INTERRUPT ON PDL OV
	XD	ILM,20000		; INTERRUPT ON ILL. MEM. REF.
	XD	NXM,10000		; INTERRUPT ON NON-EX. MEM.
	XD	INTFOV,100		; INTERRUPT ON FOATING OVERFLOW
	XD	INTOV,10		; INTERRUPT ON ARITHMETIC OVERFLOW


DEVLST:

IFN FTDISK,<XWD DSKDDB,0>
IFE FTDISK,<XWD PTRDDB,0>

;THE FOLLOWING ARE USED TO CREATE MXQUE
;THE MAXIMUM QUEUE SIZE
	XD	MXQUE,0

DEFINE	X (A)	<↓MXQUE←←MXQUE+1;>

	QUEUES
	CODES
	PQUEUES

NQUES←←MXQUE	;THIS IS USED TO PUT THIS VALUE INTO WORD 234

;IOINIT -- CHANNEL LINKAGES AND SAVE ROUTINES.
SUBTTL IOINIT	J. SAUTER, 04-AUG-68

;INTERRUPT ROUTINE LINKAGES
;IF THE CHANNEL OF A DEVICE IS CHANGED IN S,
;  THE CODE HEREIN MUST BE CHANGED AS WELL.

;USED IN ONCE

↓CH1:	0
IFN ADNUM,<
	JRST ADINT		;A-D IS THE ONLY THING  ON CH1.
>
	JEN	@CH1

↓CH2:	0
	JEN	@CH2

↓CH3:	0
DPYCON:
	CONSZ	DPY,400000	; III PROCESSOR?
	JRST	DPYINT		; YES
	CONSZ	510,20		; DATA DISK?
	JRST	DDINT		; YES
	CONSZ	PI,1B18		; POWER FAILURE?
	JRST	PWROFF		; OH DEAR?
PARCON:
	CONSZ	PI,1B20		;PARITY ERROR?
	JRST	PARINT		;YES.

APRCON:
	CONSO	APR,400		;THIS IS THE PDP-10 NOT APR INTERRUPT BIT
	JRST	APRINT		;YES.
	JEN	@CH3

↓CH4:	0
IFG DTCNUM,<
DTCCON:
	CONSZ	DTS,0		;DEC TAPE CONTROLLER?
	JRST	DTCINT		;YES.>
IFE DTCNUM+MTCNUM,<
	SKIPE	DTCFLAG		; DEC TAPE - MAG TAPE STARTUP INTERRUPT?
	JRST	DTCINT		; YES.>
IFG MTCNUM,<
MTCCON:
	CONSZ	MTS,0		;MAG TAPE CONTROLLER?
	JRST	MTCINT		;YES.>
IFN IMPSW,<
	CONSZ	IMP,040000	; ERROR BIT
	JRST	IMPERB		; YES, HE MIGHT BE DEAD
	CONSZ	IMP,030000	; INPUT DONE OR INPUT END?
	JRST	IMPINT
IMPOTS:
	CONSZ	IMP,004000	; OUTPUT DONE?
	JRST	IMPOUT		; YES
IMPCTS:

>
	JEN	@CH4

; MORE PI CHANNEL ROUTINES FOR P1

↓CH5:	0
IFN LPTNUM,<
LPTCON:
	CONSZ	LPT,0		;LINE PRINTER?
	JRST	LPTINT		;YES.>

IFG SCNNUM,<
	CONSZ	DCSA,1010	;TELETYPE SCANNER?
	JRST	SCNINT		;YES.>

IFG KBDNUM,<
	CONSZ	DKB,10		;MICROSWITCH KEYBOARD?
	JRST	DKBINT		;YES

IFN FTOIKB,<
	CONSZ	KBD,40		;OLD DISPLAY CONSOLE KEYBOARD?
	JRST	KBDINT		;YES	>>

	CONSZ	TTY,50		;CONSOLE TELETYPE?
	JRST	CTYINT		;YES.

	CONSZ	PK,7		;PIA?
	CONSO	PK,10		;INTERRUPT BIT?
	JRST	.+2
	JRST	PKINT		;(TELEPHONE) PAGING KLUDGE (IN TTYSER)

IFN PTRNUM,<
PTRCN1:
	CONSZ	PTR,0		;PAPER TAPE READER?
	JRST	PTRINT		;YES.>

IFN CDRNUM,<
CDRCON:
	CONSZ	CDR,0		;CARD READER?
	JRST	CDRINT		;YES.>
	JEN	@CH5

;	NOTE:	SCNINT IS PLACED FIRST BECAUSE DISCONNECTED TELETYPES
;		RUN OPEN, FLOODING THE SYSTEM WITH INTERRUPTS.  SINCE
;		THE VASE MAJORITY OF CH5 INTERRUPTS ARE OF THIS NATURE
;		TTYS SHOULD BE THE FIRST TO BE CHECKED.

;	NOTE:	FOR SIMILAR REASONS, DKBINT IS PLACED JUST AFTER SCNINT.
;		ALSO, LPTINT IS NOW FIRST SINCE THE LPT GENERATES INTERRUPTS
;		AT A VERY HIGH RATE WHILE LOADING THE BUFFER.

; MORE PI CHANNEL ROUTINES FOR P1

↓CH6:	0
IFN FTDISK,<
	CONSZ	PMP,20		; 2314 MAYBE?
	CONSO	PMP,4		;IS IT US OR D2CHN?
	CAIA			;NOT US!
	JRST	IXINT		; YES, DO YO' STUFF, BWANA SAHIB!
>
IFN TVNUM,<
TVCON:
	CONSZ	IOP,0		;I/O PROC. FOR TV CAMERA?
	JRST	TVINT		;YES.>
IFN FTDISK,<
DIPCON:
	CONSZ	IOP,IOPANY!IOPJDN;I/O PROCESSOR FOR DISK?
	JRST IFBINT
	CONSZ	DSK,3370	;DISK INTERFACE?
	JRST DFBINT
>
IFN PTPNUM,<
PTPCN1:
	CONSZ	PTP,0		;PAPER TAPE PUNCH?
	JRST	PTPINT		;YES.>
IFN DILNUM,<
	CONSZ	DIL,20
	JRST	DILINT		;DIALER INTERRUPT
>;IFN DILNUM
IFN ELFNUM,<			;BO 6-MAY-74
	CONSZ D11,770000	;ERROR INTERRUPT FROM THE PDP-11?
	JRST ELFINT
>;ELFNUM
	JEN	@CH6

↓CH7:	0
	SKIPLE	CLKFLG		;CLOCK INTERRUPT?
	JRST	CLKINT		;YES.
	SKIPGE CLKFLG
	JRST CLKIN0		;SPECIAL ENTRY FOR USRXIT KLUDGE
	JEN	@CH7

; CHANNEL ROUTINES FOR P2

↓P2CH1:	0
IFN ADNUM,<
ADJMP:
	JFCL	ADINT		; SERVE IT! (TURNED INTO JRST WHEN RUNNING)
>
	CONSZ	DAC,2000	; NEW DA CONVERTER INTERRUPTING?
DACJMP:
	JRST	DACIST		; YES
	CONSZ	ADC,40		; NEW AD CONVERTER INTERRUPTING?
ADCJMP:
	JRST	ADCIST		; YES, GO SERVICE
	JEN	@P2CH1

↓P2CH2:	0
	CONSZ	XGP,XGPDON	;XGP INTERFACE INTERRUPTING?
	JRST	XGPINT		;YES. PROCESS INTERRUPT.
	JEN	@P2CH2

↓P2CH3:	0
	CONSZ	PI,1B18		; POWER FAILURE?
	JRST	P2ROFF		; OH DEAR!!
P2RCON:
	CONSZ	PI,1B20		; PARITY ERROR MAYBE?
	JRST	P2RINT		; P2 PARITY ROUTINES
↓AP2CON:
	CONSZ	APR,631200	; APR FLAG BITS FOR P2(CHECKS PC CHNG ENB)
	JRST	AP2INT		; GO TO P2 APR ROUTINES
	JEN	@P2CH3

; MORE P2 INTERRUPT ROUTINES

↓P2CH4:	0
↓P2CH4S:MOVEM	17,CH4SA2+17	;SAVE AC'S FOR XGPSER COMPILER
	MOVE	17,[JEN @P2CH4]
	MOVEM	17,P2CH4E	;SET THE EXIT INSTRUCTION TO NORMAL
	MOVEI	17,CH4SA2
	BLT	17,CH4SA2+16
	MOVSI	17,XGPSAC	;GET OLD AC'S FROM COMPILER
	BLT	17,17
	JRST	@X2DISP
X2DISP:
	.+1			;JSR HERE TO CO-ROUTINE COMPILER
	MOVEM	17,XGPSAC+17
	MOVEI	17,XGPSAC
	BLT	17,XGPSAC+16
	MOVSI	17,CH4SA2
	BLT	17,17
↓P2CH4E:JEN	@P2CH4		;CHANNEL 4 EXIT LOCATION.  CLOBBERED BY CH2.

↓P2CH5:	0
IFN PTRNUM,<
PTRCN2:
	CONSZ	PTR,0		; PTR ON THIS PROCESSOR?
	JRST	PTRINT		; YES, SERVICE IT
>
	JEN	@P2CH5

↓P2CH6:	0
IFN PTPNUM,<
PTPCN2:
	CONSZ	PTP,0		; PTP ON THIS PROCESSOR?
	JRST	PTPINT
>
	JEN	@P2CH6

↓P2CH7:	0
	SKIPLE	CLKFLG+P2PID	; APR CLOCK INTERRUPT
	JRST	CL2INT
	SKIPGE CLKFLG+P2PID
	JRST CL2IN0
	JEN	@P2CH7

;CHANNEL SAVE AND RESTORE CODE.
;  AGAIN, THESE DEPEND ON THE CHANNEL VALUES.


CH1SAV:
	0		;JSR HERE
	MOVEM	17,CH1SAC+17
	MOVEI	17,CH1SAC
	BLT	17,CH1SAC+16
	MOVE	P,[IOWD INTPLN,CH1PDL]
	MOVEI	PID,P1PID
	PUSHJ	P,@CH1SAV
CH1RET:
	MOVSI	17,CH1SAC
	BLT	17,17
	JEN	@CH1

DTCSAV:
MTCSAV:

CH4SAV:
	0		;JSR HERE
	MOVEM	17,CH4SAC+17
	MOVEI	17,CH4SAC
	BLT	17,CH4SAC+16
	MOVE	P,[IOWD INTPLN,CH4PDL]
	MOVEI	PID,P1PID
	PUSHJ	P,@CH4SAV
↓CH4RET:
	MOVSI	17,CH4SAC
	BLT	17,17
	JEN	@CH4


KBDSAV:
SCNSAV:CDRSAV:LPTSAV:PKSAV:

CH5SAV:
	0		;JSR HERE.
	MOVEM	17,CH5SAC+17
	MOVEI	17,CH5SAC
	BLT	17,CH5SAC+16
	MOVE	P,[IOWD INTPLN,CH5PDL]
	MOVEI	PID,P1PID
	PUSHJ	P,@CH5SAV
CH5RET:

	MOVSI	17,CH5SAC
	BLT	17,17
	JEN	@CH5

DSKSAV:
TVSAV:
IFN ELFNUM <ELFSAV:ELDSAV:>

CH6SAV:
	0		;JSR HERE.
	MOVEM	17,CH6SAC+17
	MOVEI	17,CH6SAC
	BLT	17,CH6SAC+16
	MOVE	PDP,[IOWD INTPLN,CH6PDL]
	MOVE	PID,[P1PID]
	PUSHJ	PDP,@CH6SAV
CH6RET:
	MOVSI	17,CH6SAC
	BLT	17,17
	JEN	@CH6

INTPLN←←100	; LENGTH OF I-LEVEL PUSHDOWN LISTS

CH1PDL:
	BLOCK	INTPLN
↓CH4PDL:
	BLOCK	INTPLN
CH5PDL:
	BLOCK	INTPLN
CH6PDL:
	BLOCK	INTPLN

CH1SAC:
	BLOCK	20
CH4SAC:
	BLOCK	20
CH5SAC:
	BLOCK	20
CH6SAC:
	BLOCK	20

; P2 PI CHANNEL AC SAVE AND RESTORE ROUTINES

ADCSAV:

DACSAV:

CH1SV2:
	0
	MOVEM 17,CH1SA2+17
	MOVEI 17,CH1SA2
	BLT 17,CH1SA2+16
	MOVE PDP,[IOWD INTPLN,CH1PD2]
	MOVE PID,[P2PID]
	PUSHJ PDP,@CH1SV2
	MOVSI 17,CH1SA2
	BLT 17,17
	JEN @P2CH1

XGPSAV:

CH2SV2:
	0
	MOVEM	17,CH2SA2+17
	MOVEI	17,CH2SA2
	BLT	17,CH2SA2+16
	MOVE	P,[IOWD INTPLN,CH2PD2]
	MOVE	PID,[P2PID]
	PUSHJ	P,@CH2SV2
	MOVSI	17,CH2SA2
	BLT	17,17
	JEN	@P2CH2

REPEAT 0,<
CH4SV2:
	0
	MOVEM 17,CH4SA2+17
	MOVEI 17,CH4SA2
	BLT 17,CH4SA2+16
	MOVE PDP,[IOWD INTPLN,CH4PD2]
	MOVE PID,[P2PID]
	PUSHJ PDP,@CH4SV2
	MOVSI 17,CH4SA2
	BLT 17,17
	JEN @P2CH4
>

CH5SV2:
	0
	MOVEM 17,CH5SA2+17
	MOVEI 17,CH5SA2
	BLT 17,CH5SA2+16
	MOVE PDP,[IOWD INTPLN,CH5PD2]
	MOVE PID,[P2PID]
	PUSHJ PDP,@CH5SV2
	MOVSI 17,CH5SA2
	BLT 17,17
	JEN @P2CH5

CH6SV2:
	0
	MOVEM 17,CH6SA2+17
	MOVEI 17,CH6SA2
	BLT 17,CH6SA2+16
	MOVE PDP,[IOWD INTPLN,CH6PD2]
	MOVE PID,[P2PID]
	PUSHJ PDP,@CH6SV2
	MOVSI 17,CH6SA2
	BLT 17,17
	JEN @P2CH6

; P2 INTERRUPT AC STORAGE AND PD LISTS

CH1PD2:
	BLOCK INTPLN
CH2PD2:
	BLOCK INTPLN
;CH4PD2:	BLOCK INTPLN
CH5PD2:
	BLOCK INTPLN
CH6PD2:
	BLOCK INTPLN

CH1SA2:
	BLOCK 20
CH2SA2:
	BLOCK 20
CH4SA2:
	BLOCK 20
CH5SA2:
	BLOCK 20
CH6SA2:
	BLOCK 20

; INDIRECT AC SAVE LOCATIONS FOR 2-PROC SYSTEM

PTPSAV:
	CH6SAV
PTRSAV:
	CH5SAV
ADSAV:
	CH1SAV

; THESE ARE BLT'ED UP THERE FOR 2-PROC MODE

ALTSAV:
	CH6SV2
	CH5SV2
	CH1SV2

; HERE WE DEFINE THE CHANNEL NUMBERS, CHANNEL TRAP LOCATIONS AND
; THE PI CHANNEL ON AND OFF BITS

DEFINE X ! (A,B) <
↓A!CHN←←B
A!CHL←←CH!B
A!ON←←1B25+1⊗(7-B)
A!OFF←←1B26+1⊗(7-B)
>

X AD,1		;A/D ON CHANNEL 1.
X ADC,1		; NEW ANALOG-DIGITAL CONVERTER
X DAC,1		; NEW DIGITAL-ANALOG CONVERTER
X DCT,1		;DEC TAPE AND MAG TAPE DATA CONTROL CHANNEL.
X D2,2		;HIGH PRIORITY DISK CHANNEL
X XGP,2		;XEROX GRAPHICS PRINTER
X APR,3		;APR ON CHANNEL 3.
X DPY,3		; DISPLAY PROCESSOR ON CHANNEL 3.
X DTC,4		;DEC TAPE CONTROLLER.
X MTC,4		;MAG TAPE CONTROLLER.
X IMP,4		; ARPA IMP
X KBD,5		;KEYBOARDS FOR DISPLAY CONSOLES.
X SCN,5		;TELETYPE SCANNER.
X CTY,5		;CONSOLE TELETYPE.
X PTR,5		;PAPER TAPE READER.
X CDR,5		;CARD READER.
X LPT,5		;LINE PRINTER.
X DSK,6		;DISK INTERFACE.
X DIP,6		;IOP FOR DISK.
X IOP,6
X TV,6		;TV CAMERA.
X PTP,6		;PAPER TAPE PUNCH.
X DIL,6		;PHONE DIALER
X ELF,6		;PDP-11 ERRORS
X ELD,6		;PDP-11 DATA
X CLK,7		;CLOCK FOR SCHEDULING.

CL2CHL←←CAT(P2CH,\CLKCHN)
AP2CHL←←CAT(P2CH,\APRCHN)

↓XGPCHL←←CAT(P2CH,\XGPCHN)
↓XGPC2N←←4	;CHANNEL FOR XGP LINE COMPILER.

↓ADCCHL←←CAT(P2CH,\ADCCHN)	; DON'T FORGET US
↓DACCHL←←CAT(P2CH,\DACCHN)

DEFINE XP(S,V)<↑S←←V>
;: OUTER[J17,SYS] EOF.
;: JOBDAT[J17,SYS]
COMMENT ⊗   VALID 00004 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN JOBDAT - JOB DATA AREA
C00003 00003	M JOBAC,0,20		PLACE WHERE USER ACS ARE STORED ON UUO CALLS
C00007 00004	M JOBRL2,115,1
C00011 ENDMK
C⊗;

;;BEGIN JOBDAT - JOB DATA AREA
SUBTTL JOBDAT	31 AUG 67

;THIS AREA PROVIDES STORAGE OF ITEMS OF INTEREST TO BOTH
;THE MONITOR AND THE USER

;MACRO TO DEFINE SYMBOLS FOR MONITOR USE ONLY
;THESE MAY BE CHANGED TO SUIT MONITOR

DEFINE M'(SYMBOL,VALUE,LENGTH)
<SYMBOL←←VALUE
LOC←←VALUE+LENGTH>

;MACRO TO DEFINE SYMBOLS FOR USER USE
;THESE CANNOT BE CHANGED WITHOUT INVALIDATING OLD SAVED FILES

DEFINE U'(SYMBOL,VALUE,LENGTH)
<SYMBOL←←VALUE
LOC←←VALUE+LENGTH>

;MACRO TO DEFINE PARAMETERS OF INTEREST TO MONITOR ONLY
;THESE MAY BE CHANGED TO SUIT MONITOR
;MUST ASSEMBLE WITH SYSPAR TAPE FIRST

M JOBAC,0,20		;PLACE WHERE USER ACS ARE STORED ON UUO CALLS
			;IE RELATIVE 0-17 IN USER AREA
M JOBDAC,LOC,17		;PLACE WHERE HARDWARE ACS(0-16) ARE STORED
			;WHEN JOB IS INACTIVE. THESE ARE EITHER THE
			;USERS AC IF JOB WAS STOPPED IN USER MODE
			;OR ARE THE EXEC IF STOPED IN EXEC MODE
			;0-16 ALSO STORED HERE ON CLK INTERRUPTS
XP JOBDPG,JOBDAC+PROG	;AC PROG DUMPED HERE
XP JOBD15,JOBDAC+15	;AC 15 DUMPED HERE
XP JOBD16,JOBDAC+16	;AC 16 DUMPED HERE
XP JOBD17,JOBDAC+17	;AC 17 DUMPED HERE
U JOBUUO,40,1		;USER UUO TRAP LOC.(UUO STORED HERE)
U JOB41,41,1		;USER UUO JSR LOCATION
;42 UNUSED (PLEASE SEE JBR OR BH BEFORE SNARFING)
M JOBENB,43,1		;LH=PC CHNG,AR OVF ENABLE/DISABLE APR BITS
			;RH=APR CONSO FLAGS FOR USER APR TRAPPING
			;SET BY CALL [SIXBIT /APRENB/]
U JOBREL,44,1		;LH=0,RH=HIGHEST REL. ADR. IN USER AREA
M JOBTM1,LOC,1		; SOME TEMP CELLS TOO
M JOBTM2,LOC,1
M JOBTM3,LOC,1
M JOBTM4,LOC,1
M JOBTM5,LOC,1
M JOBPDL,LOC,1		; PUSHDOWN LIST FOR GETPDL AND GIVPDL TO USE
LOC←←71
XP JOBPLN,LOC-JOBPDL
U JOBINT,LOC,1		;TO SEPARATE OLD AND NEW INTERRUPT SYSTEMS
XP JOBPRT,LOC		;FIRST LOC PROTECTED BY BEING COPIED INTO MONITOR
XP JOBPR1,JOBPRT+1	;FIRST LOC+1
M JOBHCU,LOC,1		;HIGHEST USER IO CHANNEL IN USE
			;ONLY JOBJDA...JOBJDA+C(JOBHCU) ARE COPIED INTO
			;MONITOR WHEN JOB IS RUN. 0 MEANS NONE OR
			;CHAN. 0 IN USE, -1 MEANS SAVEGET HAS ACTIVE IO

M JOBPC,LOC,1		;JOB PC WHEN JOB INACTIVE
U JOBDDT,74,1		;LH UNUSED,RH=STARTING ADDRESS OF USER DDT
XP JOBSAV,JOBDDT-1	;FIRST LOC.-1 WRITTEN BY SAVE COMMAND
M JOBJDA,LOC,20		;JOB DEVICE ASSIGNMENT TABLE
			;LH=UUOS DONE SO FAR,RH=ADR. OF DEVICE DATA BLOCK IN MONITOR
XP JOBJMH,JOBHCU-JOBJDA	;JOBHCU-JOBJDA
			;USED BY ANYACT ROUT. IN CORE1
XP JOBPFI,JOBJDA+17	;HIGHEST LOC. IN JOB DATA AREA PROTECTED FROM IO
XP MJOBCK,JOBPFI-JOBDAC	;AREA CHECKSUMMED DURING SWAPPING

↓JOBPRT←←JOBPRT		;MAKE DOWNWARDS AVAILABLE
↓JOBPFI←←JOBPFI		;MAKE DOWNWARDS AVAILABLE

M JOBRL2,115,1
U JOBSYM,116,1	;POINTER TO LOADER AND DDT SYMBOL TABLE POINTER
U JOBUSY,117,1	;POINTER TO UNDEFINED SYMBOL TABLE
		;SET BY LOADER, NOT YET USED BY DDT
U JOBSA,120,1	;LH=FIRST LOC NOT LOADED BY RELOCATING LOADER
		;RH=STARTING ADDRESS OF USER PROGRAM
U JOBFF,121,1	;FIRST FREE LOCATION IN USER AREA
		;USED BY MONITOR TO ASSIGN I/O BUFFERS IN TOP
		;OF USER AREA
U JOBS41,122,1	;C(JOB41) SAVED HERE ON SAVE COMMAND
		;RESTORE FROM HERE ON GET
M JOBEXM,LOC,1	;LAST LOC EXAMINED OR DEPOSITED USING 
		;D OR E COMMANDS
U JOBREN,124,1	;REENTER ADDRESS FOR REENTER COMMAND
U JOBAPR,125,1	;PLACE TO TRAP TO IN USER AREA ON APR TRAP
		;ENABLED BY APRENB UUO
U JOBCNI,126,1	;APR IS CONIED INTO C(JOBCNI) ON APR TRAP
U JOBTPC,127,1	;PC IS STORED HERE ON USER APR TRAP
U JOBOPC,130,1	;OLD PC IS STORED HERE ON START,DDT,REENTER,
		;STARTC COMMANDS
U JOBCHN,131,1	;LH=FIRST LOC AFTER FIRST FORTRAN 4 LOADED PROGRAM
		;RH=FIRST LOC AFTER FIRST FORTRAN 4 BLOCK DATA
		;TO BE USED FOR JOB CHAINING
M JOBFDV,LOC,1	;DEV. DATA BLOCK ADR. FOR FINISH COMMAND
U JOBCOR,133,1	;SIZE OF CORE FOR JOB ON RUN,SAVE,GET COM.
M HINAME,134,1	;NAME OF UPPER SEGMENT OVER SAVE-GET
M HILOC,135,1	;LOC OF UPPER SEGMENT IN DUMP FILE OVER SAVE-GET
;134-137 USED BY LOADER FOR BLT TO MOVE PROGRAM DOWN(CAN BE REMOVED)
XP JOBDA,140	;FIRST LOC NOT USED BY JOB DATA AREA

;;;	BEND
;: JOBDAT[J17,SYS] EOF.
;: ALLDAT[J17,SYS]
COMMENT ⊗   VALID 00040 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00005 00002	DATA AREA FOR SAUNDERS DISK SERVICE - JAM 10-20-69
C00009 00003	BEGIN DSKDAT
C00015 00004	DSKDDB: THE DUMMY DEVICE DATA BLOCK IS THE FIRST ONE IN THE CHAIN.
C00019 00005	↑HA:	0
C00023 00006	↑D2INT:	0				JSR HERE FROM 144
C00025 00007	MORE DATA FOR D2CHN
C00026 00008	BEGIN DPYDAT
C00028 00009	   NOW THE DPY PROGRAM HEADERS.  
C00036 00010	↑STRTBL:BLOCK DPYNUM	THIS TABLE, INDEXED BY DISPLAY NO.,
C00039 00011	 DATA DISK DATA STORAGE
C00046 00012	BEGIN DTCDDB
C00048 00013	UNIT←DTCNUM-1
C00049 00014	TEMPORARY STORAGE FOR DECTAPE SERVICE
C00052 00015	IFN FTDISK,<
C00054 00016	BEGIN LPTDDB
C00056 00017	BEGIN XGPDDB	
 SUBTTL DATA STORAGE FOR XGP SERVICE
C00064 00018	BEGIN PTRDDB -- PAPER TAPE READER DEVICE DATA BLOCK
C00065 00019	BEGIN PTPDDB -- PAPER TAPE PUNCH DEVICE DATA BLOCK
C00069 00020	BEGIN SCNDDB
C00072 00021	FOLLOWING ARE DEFINITIONS OF THE RELATIVE BUFFER PARAMETER WORDS:
C00075 00022	SCANNER DEVICE DATA BLOCK.
C00078 00023	↑LINSAV: 0
C00079 00024	DIALER DATA AREA
C00080 00025	BEGIN MTCDDB  --  DEVICE DATA BLOCK FOR MAG TAPES.
C00081 00026		UNIT←MTCNUM-1
C00083 00027	BEGIN SPWDAT -- DATA FOR SPACEWAR
C00084 00028	SCHEDULER DATA AREA . . .
C00088 00029	SHARABLE DEVICE REQUEST TABLE(GENERALIZED FOR OTHER QUEUES TOO)
C00090 00030	DATA AREA FOR CORE MANAGEMENT SYSTEM
C00092 00031	FREE STORAGE PARAMETERS
C00095 00032	SPARE LIST CONTROL BLOCKS
C00097 00033	BEGIN TVDDB -- TV CAMERA DEVICE DATA BLOCK
C00098 00034	IFN ELFNUM <SUBTTL ELFDDB - PDP-11 BARE MACHINE MODE
C00099 00035	BEGIN ADDDB -- DEVICE DATA BLOCK FOR A/D AND D/A.
C00101 00036	BEGIN ADCDDB - NEW AD/DA CONVERTER - (JAM 2-5-74)
C00104 00037	BEGIN APRDAT	
	SUBTTL	APRDAT 7 NOV 68	APRSER DATA
C00113 00038	↑SYSBEG←←.		HERE TO SYSEND ZEROED AT RELOAD OR INITIALIZATION
C00124 00039		DATA AREA FOR PARITY SERVICE
C00126 00040	 STATISTICS COUNTERS
C00132 ENDMK
C⊗;

SUBTTL DATA AREA FOR SAUNDERS DISK SERVICE - JAM 10-20-69
;TEMP STORAGE &C. FOR DSKSER

↓DSKADR←←14B18		;3330 DEVICE ADDRESS
↓TRKCYL←←=19		;TRACKS PER CYLINDER
↓SNSLEN←←=24		;NUMBER OF SENSE BYTES
↓BKPTRK←←1		;1 BLOCK PER TRACK FOR NOW
↓RCPBLK←←22		;NUMBER OF RECORDS PER BLOCK
↓FPACKS←←3		;NUMBER OF FILE SYSTEM PACKS;
↓UPACKS←←1		;NUMBER OF USER DISK PACKS
↓NPACKS←←FPACKS+UPACKS	;NUMBER OF PACKS (INCLUDING SWAPPING/UDP PACK)

↓SECSIZ←←40		;WORDS/DISK SECTOR
↓RECSIZ←←200		;RECORD SIZE
↓RECWSH←←7		;RECSIZ LOG 2
↓CRMAX←←RCPBLK+1	;TOTAL RECORDS PER BLOCK (INCLUDING RETRIEVAL)
↓BKPGRP←←2*20		;16 WORDS OF HALFWORD PTRS.
↓BKDSIZ←←RECSIZ*RCPBLK	;BLOCK DATA AREA SIZE
↓BLKWDS←←BKDSIZ+SECSIZ	;TOTAL BLOCK SIZE (INCLUDING RTVL).
↓RCPGRP←←RCPBLK*BKPGRP	;RECORDS/GROUP.
↓RCPTRK←←BKPTRK*CRMAX	;NUMBER OF RECORDS PER TRACK INCL. RETRIEVAL


↓NSATBK←←1		;NUMBER OF BLOCKS NEEDED FOR SAT TABLE.

;PACKAD IS A TABLE THAT CONTAINS THE LAST LEGAL PHYSICAL TRACK NUMBER FOR
;ANY GIVEN DISK PACK.
	-1		;FOR REFERENCE TO PACKAD-1
PACKAD:

RADIX =10
ZZZ←←0			;PACK NUMBER
TTRK←←0			;TOTAL TRACKS SO FAR
FOR @' I IN (800,800,800,800) <
CAT(↓NCYL,\ZZZ)←←I			;NUMBER OF CYLINDERS FOR THIS PACK
CAT(↓NTRK,\ZZZ)←←I*TRKCYL		;NUMBER OF TRACKS FOR THIS PACK
CAT(↓TTRK,\ZZZ)←←TTRK←←TTRK+I*TRKCYL	;TOTAL TRACKS
ZZZ←←ZZZ+1
	TTRK-1				;LAST LEGAL TRACK IN THIS PACK
>
IFN .-PACKAD-NPACKS,<
	.FATAL NPACKS ≠ NUMBER OF PACKS AT PACKAD
>

↓NXTRA0←←11		;NUMBER OF EXTRA CYLINDERS ON PACK 0

RADIX 8

↓LSTBIT←←CAT(TTRK,\<FPACKS-1>)-NSATBK	;LAST LOGICAL TRACK # IN FILE SYS (NOT UDP)
↓SATWCT←←LSTBIT/=36+1	;NUMBER OF WORDS IN SAT BIT-TABLE FOR FILE DSK
↓LSTUBT←←CAT(NTRK,\FPACKS)-NSATBK	;LAST LOGICAL TRACK # IN FIRST UDP
↓SATUWC←←LSTUBT/=36+1	;NUMBER OF WORDS IN SAT BIT-TABLE FOR UDP
↓LSTADR←←TTRK-NSATBK	;LAST LOGICAL TRACK NUMBER (INCLUDING UDP)
↓LSTTRK←←TTRK-1		;LAST LEGAL PHYSICAL TRACK NUMBER (INCLUDING UDP)

;NCYLSH IS A TABLE CONTAINING THE NUMBER OF CYLINDERS FOR EACH PACK
;EACH ENTRY IS SHIFTED LEFT 4 BITS.  USED AT READDN IN HPIC
↓NCYLSH:	
FOR @' I ← 0,NPACKS-1 <
	NCYL'I⊗4
>

BEGIN DSKDAT

↑BADMAX←←=45			;MAX NO. OF BAD TRACKS.

↑QQSIZ←←30			;NEED NOT BE > NUMBER OF DDB'S.
;QBEGIN TO QUEND ZEROED BY DSKSER INITIALIZATION
↑QBEGIN:	BLOCK QQSIZ	;INTERRUPT SUBR REQUEST QUEUE
↑QEND:	0
↑QALT:	0			;0 SELECTS UDP QUEUE, -1 SELECTS DISK QUEUE
↑QUBEG:	BLOCK	10
↑QUEND:	0

↑MIPTR:	BLOCK	2		;DISK QUEUE, UDP QUEUE  INPUT POINTERS
↑MOPTR:	BLOCK	2		;AS ABOVE, OUTPUT POINTERS
↑MQEND:	QEND
	QUEND
↑MQBEG:	QBEGIN
	QUBEG

↑DFBUSY:	0		;FLAG TO INDICATE I-SUBR ACTIVITY.
↑DQCNT:	0			;NUMBER OF LOSERS CURRENTLY IN DISK QUEUE

↑TFRRTN:	0		;WHERE IN I-SUBR TO RTN TO WHEN XFER DONE
↑INTRTN:	0		;WHERE TO GO TO DISMISS INTERRUPT
	GLOBAL CH6SAC
↑UUOACS←←CH6SAC

↑DSKACS:	BLOCK 20	;I-LEVEL AC'S SAVED HERE BETWEEN INT'S
↑DSKPDL:	BLOCK 50	;PRIVATE PDL FOR DSKSER CH6 OPS

↑DSKSV:	0
	MOVEM 17,UUOACS+17
	MOVEI 17,UUOACS
	BLT 17,UUOACS+16	;SAVE USER'S ACS IN COMMON CH6 AREA.
	MOVE 3,[XWD -50,DSKPDL-1]
	PUSHJ 3,@DSKSV		;SERVICE INTERRUPT.
	MOVSI 17,UUOACS		;RETURN HERE TO DISMISS;
	BLT 17,17		;RESTORE USER'S AC'S.
	JEN @DSKCHL

↑DSKEDD:	0		;ERROR VERSION OF ABOVE
↑ACDDB:	0			;LAST DDB FOR BAD AUDIT
↑SWPDDB:	0		;UDP DDB FOR SWAPPING
↑ERRBIT:	0		;ERROR BITS FOR LAST XFER
↑DSKERB:	0		;ERROR BITS (LH=IOP, RH=DISC)
↑DSKJB:	0
↑DSKMA:	0
↑DXB:	0			;CURRENT DDB
↑DXC:	0			;CURRENT TFRCTL
↑DXJ:	0			;JOB NUMBER
↑DXP:	0			;LAST STACK PTR
↑DXS:	0			;CURRENT TFRSEC
↑DXW:	0			;CURRENT TFRIOW

↑SYSBUF:	BLOCK SECSIZ	;RETRIEVAL PART OF SYSTEM BUFFER
↑SYSDTA:	BLOCK BKDSIZ	;DATA PART
↑QBUF:		BLOCK SECSIZ
↑BKIN:	0			;PRESENT OCCUPANT OF SYSBUF
↑DFTEMP:	0		;SCRATCH CELL.

↑SATDIR:	-1		;I/O DIRECTION. USED BY ACISAT ETC.
				;-1:READ    0:WRITE	THE SAT TABLE.

;SAT TABLE AS STORED ON BLOCK 0 OF THE DISK
	DEFINE ZWD (A)<↑A←←.-SATTAB 
 0 >
	DEFINE ZLOC (A)<↑A←←.-SATTAB>

↑SATTAB:			;THIS IS SAT BIT AREA AS STORED ON DISK.
	ZWD(DSKUSE)		;BLOCKS USED ON DISK
	ZWD(LSTBLK)		;NUMBER OF LAST BLOCK ASSIGNED
	ZWD(SATID)		;IDENT.NO. OF ALL DISK INFO
	ZWD(SATCHK)		;XOR CHECKSUM OF SAT BITS BELOW
	ZWD(BADCNT)		;NO. OF BAD TRACKS IN TABLE BELOW.
	ZWD(BADCHK)		;CHECK (SUM) OF TABLE.
	ZLOC(BADTRK)
	BLOCK BADMAX		;TABLE OF BAD LOGICAL BLOCK NUMBERS (TRACKS)
	ZWD(IDSAT)		;CONTAINS 'SATID ' FOR NEW UDPS
	ZWD(DTIME)		;TIME SAT LAST WRITTEN
	ZWD(DDATE)		;DATE SAT LAST WRITTEN
↑P1OFF:		0		;# PDP-10 POWER FAILURES	(MAIN SAT ONLY!)
↑P2OFF:		0		;# OF PDP-6 POWER FAILURES	(MAIN SAT ONLY)
		0		;BUFFER WORD.			(NOT NEEDED)
	ZLOC(SATBIT)		;LOCATION OF THE BIT TABLE ITSELF
	BLOCK SATWCT	
↑SATEND:	0		;END OF MAIN BIT TABLE (UDP SATS ARE DIFFERENT SIZE)
↑SATSIZ←←SATEND-SATTAB
↑USATSZ←←SATBIT+SATUWC+2	;+2 FOR GOOD MEASURE

IFG SATSIZ-BLKWDS*NSATBK,<
.FATAL	SAT TOO BIG FOR THE DISK SPACE ALLOCATED. INCREASE NSATBK AND PRAY
>

;HERE ARE THE MAGIC TABLES FOR MULTIPLE FILE STRUCTURES. REG/BH 7-14-74
↑SATADR:	SATTAB			;CORE ADDRESS OF SAT FOR EACH STRUCTURE
	REPEAT UPACKS,<0>
↑TSATSZ:	SATSIZ			;LENGTH OF SAT FOR EACH STRUCTURE
	REPEAT UPACKS,<USATSZ>

↑BFSET:		0			;BLOCK NUMBER OFFSET TO FIRST BN IN STR
FOR UNUM←1,UPACKS<
	CAT(TTRK,\<FPACKS+UNUM-2>)	;OFFSET TO FIRST BLOCK OF THIS UDP
>
↑BFSETS:	0⊗6			;SAME AS BFSET ONLY SHIFTED LEFT 6 BITS
FOR UNUM←1,UPACKS<
	CAT(TTRK,\<FPACKS+UNUM-2>)⊗6
>
↑LSTRKT:	LSTTRK			;MAX TRK FOR GODMOD--DSK GETS ALL PACKS
FOR UNUM←1,UPACKS<
	CAT(NTRK,\<FPACKS+UNUM-1>)-1	;BUT EACH UDP ONLY GETS ITSELF
>

↑DKDBML:	DSKDDB			;ADDRESSES OF MODEL DDBS
FOR @$ UNUM←1,UPACKS<
		UDP$UNUM$DD
>

↑LSTBTB:	LSTBIT
REPEAT UPACKS,<	LSTUBT
>

↑UDPOWN:	REPEAT UPACKS,<-1>	;JOB # OF PRIVATE OWNER.  -1 IF PUBLIC

;UDPCNT THRU SATMOD+UPACKS ZEROED BY DSKINI
↑UDPCNT:	BLOCK UPACKS		;# DDBS REFERENCING THIS UDP
↑SATMOD:	BLOCK UPACKS+1		;-1 IF SAT NEEDS TO BE WRITTEN

;DSKDDB: THE DUMMY DEVICE DATA BLOCK IS THE FIRST ONE IN THE CHAIN.

	DEFINE ZWD' (A)<
	↑A←←.-DSKDDB
;	INTERNAL A
	0	>

	DEFINE ZLOC' (A)<
	↑A←←.-DSKDDB
;	INTERNAL A	>

REPEAT DDBSKW-1,<0>
	DEVAOA!DEVSHR,,0	;EXTRA WORD FOR MORE GOOD BITS
↑DSKDDB:SIXBIT /DSK/		;DEVNAM
	XWD =60*HUNGST,201	;DEVCHR  PUNIT=0!
	0			;DEVIOS
	XWD UDP1DD,DSKDSP	;DEVSER. NEXT DDB IS UDP.
	XWD DVOUT+DVIN+DVDIR+DVDSK+DVLNG,154403	;DEVMOD
	0			;DEVLOG
	0			;DEVBUF
	XWD PROG,0		;DEVIAD
	XWD PROG,0		;DEVOAD

	;NEXT 8 LOCATIONS COPIED FOR AUDITOR
	ZWD FILNAM
	ZWD FILEXT
	ZWD FILPRO
	ZWD FILPPN
	ZWD FILLOC
	ZWD FILLNG
	ZWD REFTIM
	ZWD DMPTIM

	ZWD USETP
	ZWD UFDPRO		;PROTECTION OF THE UFD FROM WHICH FILE CAME
	ZWD UFDPR1		;TEMP COPY OF ABOVE WHILE DOING RENAME
				;ALSO, RH← LH(DQINFO+3) OF UFD LAST ACCESSED
	ZWD UFDPPN		;PPN OF LAST UFD USED
	ZWD UFDADR		;DISK ADDR OF LAST UFD USED

	ZWD ACCNAM
	ZWD ACCEXT
	ZWD ACCPRO
	ZWD ACCPPN

	ZWD SRCNAM
	ZWD SRCEXT
	ZWD SRCPRO
	ZWD SRCLOC
	ZWD SRCTMP
	ZWD DMPBUF

	ZWD TFRSEC
	ZWD TFRIOW
	ZWD TFRCTL

	ZWD DSKFAD
	ZWD DSKLAD
	ZWD CORFAD
	ZWD CORLAD

	ZLOC DSKDAT;	BEGIN GRP-DEPENDENT PART OF DDB
	ZWD DDNAM
	ZWD DDEXT
	ZWD DDPRO
	ZWD DDPPN
	ZWD DDLOC
	ZWD DDLNG
	ZWD DREFTM
	ZWD DDMPTM
	ZWD DGRP1R;	FIRST USER RCRD NO. THIS GRP
	ZWD DNXTGP;	BLOCK NUMBER OF NEXT GROUP
	ZWD DSATID
	ZWD DQINFO	;START OF SPECIAL STORAGE FOR LOGIN ETC.
	BLOCK 17+DSKDDB+DSKDAT-.
↑↑DQLEN←←.-DSKDDB-DQINFO
	ZWD DOFFST	;RECORD OFFSET
	ZLOC DPTR;	RETRIEVAL DATA,
	BLOCK 20	;2 BLK NO.'S/WORD
	ZLOC DDEND
↑DDBSIZ←←.-DSKDDB+DDBSKW

FOR @$ UNUM←1,UPACKS
{REPEAT DDBSKW-1,<0>
	DEVSHR!DEVAOA!DEVLUP!DEVMAS,,0
↑UDP$UNUM$DD:
	SIXBIT /UDP$UNUM/
	=30*HUNGST,,UNUM⊗PUNITP+201
	0			
IFN UNUM-UPACKS,<
	CAT(CAT(UDP,\<UNUM+1>),DD),,DSKDSP
;>	PTRDDB,,DSKDSP			;FOR OLD STYLE USE UDPDSP INSTEAD!
	XWD DVDSK!DVUDP!DVOUT!DVIN!DVDIR!DVLNG,154403	;DVDSK!
	0			
	0			
	XWD PROG,0		
	XWD PROG,0		
	
	BLOCK <DDBSIZ-UDP$UNUM$DD+.>		;MAKE SAME SIZE AS DSKDDB.
}

↑SYSRTV←←SYSBUF-DSKDAT	;FOR REFERRING TO DDXXX IN SYSBUF


↑HA:	0
	0
	0

;HERE ARE VARIOUS PIECES OF DATA.

↑PMPCNI:	0
↑DSKLRN:	0		;LOGICAL DISK ADDRESS FOR THIS XFER.

↑DSKHNG:	0		;DISK HUNG COUNTING CELL, COUNTED DOWN BY DEVCHK
↑DHNGST:	0		;DSKHNG SET FROM HERE ON EACH DSK INTERRUPT
↑DRAUFO:	0
↑DSKOPS:	BLOCK	JOBN	;NUMBER OF DISK OPERATIONS FOR EACH JOB
↑DSKOVC:	0
↑STAC:		0
↑STAC1:		0
↑SAC3:		0
↑SDAT:		0
↑SAVP:		0
↑INTPDL:	0


↑SKCMD:		36007!DSKADR	;SEEK COMMAND.
↑SKWCMA:	SKDAT
↑SCCMD:		36461!DSKADR	;SEARCH COMMAND,WITH CHAIN & SKIP IF OFF
↑SCWCMA:	SCDAT

;FOLLOWING MUST BE IN ORDER:

↑RCMD:	22006!DSKADR		;READ COMMAND
↑WCMD:	22005!DSKADR		;WRITE COMMAND
	16555!DSKADR	;"USE" MODE. SRCH KEY/DATA EQ-HI.
	16455!DSKADR	;"OWN" MODE. SRCH KEY/DATA EQ.

;NEXT 2 LOCS ARE A TABLE!
		SKIPL TAC		;READ END TEST
↑ENDTAB:	CAML TAC,[-1,,0]	;WRITE END TEST

↑SNSCMD:	34004!DSKADR	;SENSE COMMAND.(4 BYTE MODE)
↑SNWCMA:	SNSDAT
↑SNSDAT:	BLOCK SNSLEN/4	;SENSE PUTS DATA HERE.(4 BYTES PER WORD)
		0
↑RCALCM:	23!DSKADR	;RECALIBRATE THE SEEK HYDRAULICS.
↑RDHACM:	34032!DSKADR	;READ HOME ADDRESS.(4 BYTE MODE)
↑NOPCMD:	3!DSKADR	;NO-OP COMMAND

;COMMANDS FOR DIAGNOSTIC LOAD AND WRITE

↑DWCMD:		36163!DSKADR	;DIAGNOSTIC WRITE
↑MSKCMD:	22037!DSKADR	;SET FILE MASK
↑DLCMD:		36123!DSKADR	;DIAGNOSTIC LOAD
↑RD1CMD:	34104!DSKADR	;READ DIAGNOSTIC STATUS 1

↑FILMSK:	BYTE(8)4	;PERMIT DIAGNOSTIC WRITE COMMAND


;COLLECT ERROR COUNTS HERE
↑ERRCL0:	0
↑ERRCL1:	0
↑ERRCL2:	0
↑ERRCL3:	0
↑ERRCL4:	0
↑ERRSNS:	0
↑ERRHA:		0
↑ERRRCL:	0
↑SHADPE:	0

;THESE ARE THE HARD ERROR MAXIMUMS!
↑MAXCL0:	100
↑MAXCL1:	100
↑MAXCL2:	100
↑MAXCL3:	100
↑MAXCL4:	100
↑MAXSNS:	10
↑MAXHA:		10
↑MAXRCL:	10

;THESE ARE THE MASKS FOR WHEN TO PRINT AN ERROR CLASS
;THEY MUST BE -2**N-1 FOR TDNE
↑TYMSK0:	¬10
↑TYMSK1:	¬10
↑TYMSK2:	¬10
↑TYMSK3:	¬10
↑TYMSK4:	¬20

;COLLECT TOTAL COUNTS HERE
↑TOTCL0:	0
↑TOTCL1:	0
↑TOTCL2:	0
↑TOTCL3:	0
↑TOTCL4:	0

;SET THESE FLAGS TO FORCE TYPEOUT OF EVERY ERROR
↑TYPCL0:	0
↑TYPCL1:	0
↑TYPCL2:	0
↑TYPCL3:	0
↑TYPCL4:	0

↑DSKACT:	0	;FLAG DISK CHANNEL ACTIVE

↑DEATH:		0	;ERROR ROUTINE HAS DECREED DEATH TO THE INFIDEL'S

↑TYPANY:	0
↑SNSTYP:	0
↑CSTOP:		0
↑ERRCMD:	0
↑CNISAV:	0
↑XDSKMA:	0

↑HNGFLG:	0
↑CT:		0
↑LCT:		0
↑WCT:		0
↑HAFLAG:	0
↑DSKFLG:	0

↑D2INT:	0				;JSR HERE FROM 144
	MOVEM TAC,TSAV
	CONI PMP,TAC			;GET STATUS
	TRNN TAC,NEWST!UNEND		;NEW STATUS OR UNUSUAL END?
	JRST ITEST			;NO.  PERHAPS CHDEMP
	XOR TAC,TSTXOR
	TDNN TAC,TSTBIT			;SKIP IF LOSING.
	TRNN TAC,DEVEND!CHNEND		;ONE OF THESE OUGHT TO BE ON IF NEW STATUS
	JRST D2XE			;SOMETHING EVIL THIS WAY COMES.
	XOR TAC,TSTXOR			;RESTORE ORIGINAL CONI BITS FOR COROUTINES
	CONO IBM,CNEWST			;CLEAR NEW STATUS
	CONSO PMP,CHDEMP		;GOT DEV END, CMD HLD EMPTY?
	JRST D2X1
	JRST @D2X			;CMD HLD EMPTY.  CONTINUE IN COROUTINE

↑D2X:	0
D2X1:
	CONO IBM,ACTCLR
D2X2:
	EXCH TAC,TSAV
	JRST 12,@D2INT

D2XE:
	XOR TAC,TSTXOR			;RESTORE CONI BITS
	CONO PMP,NEWST!UNEND!10!DSKCHN	;MAKE LOW PRIORITY CHANNEL HANDLE THIS
	EXCH TAC,LSTAT			;STORE LOSING STATUS
	JRST D2X2

ITEST:
	SKIPN DSKACT		;SHOULD WE BE HERE AT ALL?
	JRST D2BARF		;NO
	TRNE TAC,20		;IS DISK INTERRUPTING AT ALL?
	TRNE TAC,4		;IS HE IN LOWER CHANNEL?
	JRST D2BARF
	JRST @D2X		;ALL IS WELL?

↑D2BARF:EXCH P,ERRPD		;SAVE P AND GET A PDL
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ/
IN THE DISK CHANNEL WITHOUT AN INTERRUPT. GET A WIZARD.
/
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	HALT .+1
	POPACS
	EXCH P,ERRPD
	JRST D2X2

;MORE DATA FOR D2CHN
↑SKDAT:	BLOCK 2
↑SCDAT:	BLOCK 2
↑XWCMA:	0

↑LSTREC:	0

↑ENDTST:	0

↑XWRAP:		0
↑TSAV:		0
↑LSTAT:		0
↑D2DONE:	0
↑D2LUZ:		0
↑LWCMA:		0
↑LSTOP:		0
↑XCMD:		0
↑CHNEMP:	0
↑TSTXOR:	DSKADR⊗12!20		;PACK NUMBER DPB'ED HERE
TSTBIT:
		37700,,UNEND!ATTN!CUEND!BUSY!UCHK!UXCPTN!20
↑SATID1:	0		;FIRST COPY OF SATID
↑SATID2:	0		;SECOND COPY OF SATID
BEND DSKDAT

BEGIN DPYDAT
SUBTTL III AND DATA DISK DATA STORAGE

;; NOW SOME DISPLAY OPCODES AND MACROS FOR GENERATING DP INSTRS.

DISJMP←←20	;DP JMP INSTR. OPCODE.
DISJMS←←4	; JMS (STORES TWO WORDS)
DISJSR←←24	; STORES ONLY RETURN ADDR.
DISRST←←14	;RESTORE.
DISSEL←←10	;SELECT.
DISNOP←←14	;ACTUALLY RST, BUT A GOOD NOP WITH ALL BITS OFF.
DISSKP←←12	; TEST AND SKIP
DISKPN←←32	; TEST AND NOT SKIP

DEFINE LVW(X,Y,TYPE,MODE,BRT,SIZ)	;ASSEMBLES A LONG VECTOR.
  { MVW1 (MODE,TYPE,BRT,SIZ)	;TWIDDLE PARAMS.
	BYTE (11)<X>,<Y>(3)B,S(2)MD,TT(3)3 ⎇	;ASSEMBLE INSTR.
DEFINE MVW1 (M,T,BRT,SIZ)
 {IFIDN {M⎇{A⎇{MD←1;⎇MD←0	;MODE = `A' FOR ABSOLUTE.
  IFIDN {T⎇{I⎇{TT←2;⎇TT←0	;TYPE = `I' FOR INVISIBLE.
  IFIDN {BRT⎇{⎇{B←0;⎇B←BRT	;BRT = 0 IF OMITTED.
  IFIDN {SIZ⎇{⎇{S←0;⎇S←SIZ	;SAME FOR SIZ.
⎇
DEFINE CW (C1,B1,C2,B2,C3,B3) {<BYTE (8)<B1>,<B2>,<B3>(3)<C1>,<C2>,<C3>>!4}

COMMENT ⊗   NOW THE DPY PROGRAM HEADERS.  
 THERE IS ONE OF THESE FOR EACH DPY PROGRAM
 IN EXISTENCE; IN GENERAL, ONE FOR EACH CONSOLE PLUS
 ONE FOR EACH DETACHED JOB DOING DPY OUTPUT. THE HEADERS
 AND THE START,RESTART, AND STOP TABLES ARE THE ONLY PARTS
 OF THE WHOLE INCREDIBLE DPYSER DATA STRUCTURE WHICH DO NOT
 GO IN FREE STORAGE.
⊗

↑BUFL←←40		; EDITING BUFFER IS THIS MANY WORDS LONG
		ZZQ←←.
		DEFINE Z(FOO){↑FOO←←.-ZZQ
}		
 	
		XWD .+3,DISRST+40
			;PRGM. NORMALLY STARTED HERE. 
			;  RESTORE PRIOR STATE OF DP.
Z(PSELC)	BYTE (12),7777,DISSEL	;FIRST DESELECT ALL CONSOLES
Z(PSELA)	BYTE (12)1⊗(=11-0),,DISSEL	;THEN RESTORE OLD SELECTION
Z(PRGSTP)	0	;PRGM IS STOPPED BY A JMS TO HERE.
Z(PRGSAV)	0
Z(WHOCALL)	DISNOP	;CALL WHO LINE(IF ANY).
Z(PPCALL)	DISNOP	;HERE IS A JMP TO PAGE 0 OF PP.
Z(LEPOS)	DISNOP
Z(LEJMS)	XWD ZZQ+LEB,DISJMS
			;CALL THE LINE EDITOR.
Z(PGCALL)	DISNOP	;HERE A JMP TO PIECE OF GLASS CONT. BLK.
		0	;HERE PRGM NORMALLY HALTS.
Z(PSELB)		;ANOTHER COPY OF SELECT WORD. PRGM RESTARTS HERE.
400037770010;;replace;;BYTE (12)1⊗(=11-0),¬(1⊗(=11-0)),DISSEL
Z(RTJMP)	XWD WHOCALL+ZZQ,DISJMP

Z (PRGNUM)	0	;NO. OF DPY THIS PRGM ATTACHED TO.
Z (BLKTOT)	-7	;NO. OF BLOCKS OF STORAGE HE CAN USE.
Z(CURPP)	0	;PTR. TO CTRL. BLK. OF SELECTED P OF P.
Z(CURPG)	0
Z(PRGACT)	400000	;BITS TELL STATE OF ACTIVATION OF P OF P'S.
Z(USRACT)	0	;SAVED VERSION OF PRGACT.
Z(LSTPG)	0	;HIGHEST PG IN USE BY USER.
Z(LECLIN)	0	; FLAG THAT SAYS THIS BLOCK HAS A CLOCK REQUEST IN TO HAVE ITSELF KILLED, WHEN IT BECOMES FREE
;FORGET THIS CELL ;Z(DPKTIM)	0	; WORD INDICATING TIME KEY WAS STRUCK
;AND THIS ONE	  ;Z(DPGTIM)	0	; TIME GRAPHICS WENT OUT
Z(DPRLSF)	0	; FLAG THAT SAYS THIS PROGRAM HEADER BELONGS TO A DETACHED JOB AND IS TO BE RELEASED
Z(PRGCW)	0	; COMMAND WORD FOR USER GRAPHICS TRANSFERS
Z(PRGJMP)	0	; JUMP TO USER PROGRAM
Z(PRGCNT)	0	; DUMMY COUNT WORD
Z(DPHOLD)	0	; -1 IF HOLDING
Z(GWORD)	0	; GARBAGE WORD. HOLDS EVERYTHING WHAT WON'T FIT ELSEWHERE
			; B0 1-PAGE PRINTER SIZE SET LAST BY CONSOLE COMMAND, 0-BY UUO
			; B1 SAME FOR PAGE PRINTER Y-POSITION.
			; B2 SAME FOR LINE HOLD COUNT
			; B3 SAME FOR GLITCH HOLD COUNT
			; B9-17 LINE HOLD COUNT
			; B18-26 GLITCH HOLD COUNT
			; B27-35 CHAR WHICH ACTIVATED LINED
Z(LHCNT)	0	; LINE HOLD COUNTDOWN
Z(GLHCNT)	0	; GLITCH HOLD COUNTDOWN
Z(LEB)

		0	;DP DOES A JMS TO HERE TO DISPLAY EDITOR BUFFER.
		0
Z(LEPPV)	0	;POINTER POSITION VECTOR FOR EDITOR POINTER.
Z(III)		LVW (-5,-14)	;WILL BE 0 ON DD
			;DRAW THE POINTER.
Z(VDTMP)	LVW (12,0)	;TEMP MAPPING STORED HERE ON DD
Z(PPHPOS)	LVW (-5,14)	;USED AS TEMP FOR DD CURSOR ROUTINES
		XWD ZZQ+LEB+1,DISRST+40
			;RESTORE BEAM POSTION.
Z(LELMAR)	LVW(0,0,I)
			;LEFT MARGIN VECTOR... USED FOR SHIFTING LONG LINES.
Z(LEBUF)	REPEAT BUFL,<XWD ZZQ+LEB,DISJMP>
			;THE EDITOR BUFFER.

Z(LEHPOS)	0	;HORIZONTAL POSITION OF POINTER (IN COLUMNS).
Z(CCPOS)	0	;LOGICAL POSITION OF POINTER, IN CHRS. FROM START OF LINE.
Z(FCPOS)	0	;NO. OF CHRS. IN LINE.
Z(LELWD)	0	;POINTER TO LAST WORD OF BUFFER IN USE (ONE BEFORE THE RETURN JMP).
Z(LSTHP)	0	; SAVED HORIZONTAL POSITION
Z(LEENQ)	0	; NUMBER OF LINE EDITOR TASKS IN THE QUEUE
Z(LEENQ2)	0	; NUMBER OF SCREEN REFRESH AND/OR HELP TASKS IN QUEUE.
Z(LECHPS)	0	; SAVED VALUE OF HORIZONTAL POSITION
Z(MAXPT)	ZZQ+LEBUF+BUFL-4
			;MAXIMUM ALLOWABLE VALUE OF LELWD (I.E., END OF BUFFER).
Z(NUMARG)	0	;REPEAT ARGUMENT.
Z(LEARG)	0	; REPEAT ARGUEMENT SAVED FOR <ESC>G COMMAND AND ITS FRIENDS
Z(LEPNT1)	0	;BYTE POINTER CORRESPNDING TO EDITOR POINTER.
Z(NTABPT)	0	;BYTE PTR. TO NEXT TAB IN LINE TO RIGHT OF CURRENT POS.
Z(NTABCT)	0	;NUMBER OF SPACES IN NEXT TAB.
Z(LEACT)	0	; LINE EDITOR TELLS DPYKILL THAT A CHARACTER HAS BEEN TYPED HERE
Z(LEINV)	0	; MEANS LINE EDITOR BUFFER IS NOW INVALID
Z(LEWAKE)	0	; THIS IS SET BY A TRANSFER THAT IS ABORTED BECAUSE OF INVALID BUFFER
Z(NCRS)		0	; NUMBER OF LONG-LINE CRLFS IN LINE
Z(LEVP)		0	; VERTICAL POSITION OF LINE EDITOR LAST TIME IT WENT OUT
Z(LEHP)		0	; HORIZONTAL POSITION OF LINE EDITOR
Z(LENCRS)	0	; NUMBER OF LINES IT TOOK LAST TIME IT WENT OUT.
Z(LECVP)	0	; LAST CURSOR VERTICAL POSITION
Z(LECHP)	0	; LAST CURSOR HORIZONTAL POSITION
Z(LECLK)	0	; MEANS CLOCK REQUEST IS IN
Z(LETXC)	0	; MEANS LINE EDITOR TEXT HAS CHANGED
Z(LEMISS)	0	; INDICATES A TRANSFER MISSED DUE TO BUFFER INVALID
Z(LECC)		0	; SAYS WHETHER AN <ESC>C HAS BEEN TYPED
Z(LELINE)	0	; LINE NUMBER OF LINE EDITOR
Z(CVP)		0	; CURRENT CURSOR VERTICAL POSITION
Z(CHP)		0	; CURRENT CURSOR HORIZONTAL POSITION
Z(WHOTAB)	0	; WHO LINE TIME,,JOB #
Z(WHORUN)	0	; TIME WHEN RUN TIME SHOULD BE UPDATED ON WHO LINE
Z(LETBPT)	0	;PTR. TO THE LETAB ENTRY FOR THIS DPY.
Z(LCH)		0	;
Z(DPYLEN)

ORG ZZQ			; DON'T LOSE ANY STORAGE OVER THESE DEFINITIONS

↑STRTBL:BLOCK DPYNUM	;THIS TABLE, INDEXED BY DISPLAY NO.,
			;GIVES NORMAL START POINT FOR ITS PROGRAM.

	0		;STPTBL(-1) FOR HOLDING MESSAGE
↑STPTBL:BLOCK DPYNUM	;SAME THING FOR STOP POINTS.
	0		;STPTBL(DPYNUM)	FOR IDLE STATE

↑SELTBL:BLOCK DPYNUM	;POINTERS TO SELECT WORDS
↑RSTTBL:BLOCK DPYNUM	;RESTART (I.E. BEGINNING OF PRGM) POINTS.
↑LETAB:	BLOCK DPYNUM+DDNUM	; LINE EDITOR HEADERS ARE HERE
	BLOCK DPYNUM	;EXTRA 6 0'S FOR VDSMAP ROUTINES ADDRESSING "SHADOW" CHANNELS

↑DXFLAG:	0	;APAIR OF FLAGS FOR SYNCHRONIZING DP RESTARTING WITH
↑DRUNCT:	0	; NUMBER OF CURRENTLY RUNNING DISPLAY
↑SAVTAC:	0	; DPY NUMBER DURING ERROR TYPEOUT
↑DPCNI:		0	; DP CONI BITS
↑LCPDL←←100		;LENGTH OF CLOCK PUSHDOWN LIST.
↑DPYPDL:	IOWD LCPDL,CLKPD
			;SPECIAL CLOCK LEVEL PDL.
↑CLKPD:		BLOCK LCPDL+1
		0
↑CLKQUE:	BLOCK 6*<DPYNUM+DDNUM>

↑CLKQ:		POINT 36,CLKQUE-1,35
			;MAIN PTR. TO CLK QUE.

↑WTFLG:		0	;IF -1, WE ARE SUSPENDING NORMAL CLK. SERVICE TO WAIT FOR FREE STG.

↑SVAC:		BLOCK 20
↑DPYMAP:	BLOCK JOBN
↑NBS←←=100
↑TBL:		BLOCK NBS+1
			; PLACE TO BUILD BLOCK MAP FOR UPGMOVE
↑ERRP:		0	; ROUTINE THAT IS ENTERED WITH A JSA
		JRST ERRP2
↑FREEHD:	0
↑FSWTHD:	0
↑FSWT2H:	0
↑FREEC:		0
↑FREETL:	0
↑FRETOT:	0
↑FSWC:		0
↑CLKLVL:	0	; SAYS WE ARE AT CLOCK LEVEL
↑CLKQTMP:	0	; TEMP CELL
↑FSW2C:		0

; DATA DISK DATA STORAGE

↑DDSTART:	0	; UUO LEVEL SETS THIS TO START UP DD. SEEN BY APRINT.
↑DDCNT:		3B2	; NUMBER OF TIX THIS PROGRAM IS ALLOWED TO RUN BEFORE IT IS TIMED OUT.
↑DDDSP:		0	; THIS IS THE I-LEVEL DISPATCH ADDRESS.
↑DDRET:		0	; WE JUMP INDIRECT HERE TO RETURN FROM I-LEVEL
↑DDRTN:		0	; EVERYONE JSRS HERE TO RETURN
		JRST @DDRET
↑DDSAC1:	0	; ACCUMULATORS . . .
↑DDSAC2:	0
↑DDSAC3:	0
↑DDSTAC:	0
↑DDSDAT:	0
↑DDNXT:		0	; ADDRESS OF NEXT TASK TO BE DONE
↑DDCUR:		0	; DATA BLOCK ADDRESS CURRENTLY IN USE
↑DDCURT:	0	; TASK BLOCK ADDRESS CURRENTLY IN USE
↑DDCURQ:	0	; THIS IS WHERE I-LEVEL PUTS THE CONTROL BLOCK ADDRESS BEFORE DISMISSING
↑DDCOL:		0	; HERE WE KEEP COLUMN ADDRESSES
↑DDLST:		0	; ADDRESS OF LAST FRAME LOOKED AT
↑DDOFF:		0	; SET TO -1 TO INHIBIT DD TRANSFERS
↑DDQUE:		0	; HERE LIES THE DATA DISC QUEUE
↑DDSQ:		0	; WE SAVE THE ENTIRE TASK QUEUE HERE
↑DDLFD:		0	; WE SAVE THE FIELD WORD OF THE LAST FRAME HERE.
↑LEBFR:		CW 1,46,2,0,3,2
		CW 3,2,4,0,5,0
		0
		0
↑DDCURS:	0
		CW 3,1,4,0,5,0
		REPEAT 20,<2>
		CW 0,0,3,1,3,1
		0
↑CZPNT:		POINT 36,CURZWD-1,35
↑CURZWD:	BLOCK 4
↑DDCRLF:	REPEAT =40,<ASCID /  
/>
		0
↑DDRUN:		0	; TELLS IF DD IS CURRENTLY RUNNING
↑DDERRS:	CW 1,46,2,0,3,1
		CW 3,2,4,0,5,0
		XWD DDCRLF,DISJMP

↑WSERC:		CW 1,17,2,0,3,2
		CW 1,46,2,0,3,2
		0
↑DPYARN:	0	; DENOTES THAT 'CONSOLE AVAILABLE' MESSAGE HAS BEEN RUN THIS TICK
↑DPYAVL:	LVW -600,0,I,A,2,4
		XWD 770000,DISSEL
		<BYTE (8)377>!DISSKP
		XWD TTYLOK,20!DISRST
		<BYTE (8)367,0,367>!DISKPN
		XWD DPYAV2,DISJMP
		XWD MAINTMODE,20!DISRST
		<BYTE (8)367,0,367>!DISSKP
		XWD DPYAV1,DISJMP
DPYAV2:
		ASCID /SYSTEM IS DOWN!!!/
		0

DPYAV1:
		ASCID /TAKE ME I'M YOURS!/
		0
;*** RPH PATCH TO CATCH LOSING DP
		XWD .+1,24
		0
		XWD .-2,20
;END PATCH

↑AVLWHO:	CW 1,17,2,0,1,46	;WE SEND AN ERASE DURING FIRST FIELD ONLY
		0
		AVLWDD,,DISJMP
		ASCID / 
/
↑DDWMES:	1				;PATCH HERE TO DISPLAY OTHERS
		ASCID /                                 Take Me I'm Yours!
/
		0

AVLWDD:
		ASCID /             DD JBS,TCOR  R,RCOR UCOR  NL DSKQ
/
		COMDD,,DISJMP

↑DDUNMS:	ASCID /                             No Data Disk Channels Left
/
		0

↑DDDMES:	ASCID /                                   System Is Down!
/
		0

↑AVLLN:		0		;XWD FIRST,SECOND TEXT LINE FOR AVL MSG
↑AVLVP:		CW 3,2,4,2,5,4	;GETS CLOBBERED BY PHANTOM STARTER
↑WHOKLU:	0		;COUNTS DOWN TO AVL MSG SHIFT OR -1 TO GOOSE WHOSER

↑DDSTRS:	CW 1,46,2,0,3,2
		CW 3,2,4,1,5,11
		ASCID /   ********************** →HOLDING← **********************/
		CW 0,0,3,2,3,2
		0

↑DPYHOL:	0
↑DPYHLD:	XWD 77,DISSEL
		LVW (-600,660,I,A,2,2)
		ASCID /   ********************** →HOLDING← **********************/
		COMIII,,DISJMP			;GO DISPLAY SYSTEM LINE OF WHO LINE

;MODEL WHO LINE BLOCK (COPIED INTO FREE STORAGE)
↑TITLE:		0		;III JSRs to here.  FOR DD, COMMAND WORD GOES HERE
		BYTE(11)<-1000>,740(3)2,2(2)1,2(3)3 ;III POSITION WORD.  DDs PUT CMD WORD HERE
		COMDD,,DISJMP	;IIIs get a no-op deposited here.
↑WTEND←←.-TITLE
↑WTTYS:		REPEAT 3,<ASCID/     /
		>		;SPACE FOR FIRST PART OF USER WHO LINE
		ASCID	/  /	;three nulls here (NOT TO MENTION 2 SPACES)
		REPEAT 3,<ASCID/     /
		>
		ASCID	/   K        -             -        / ;7 words of constants
		REPEAT 4,<12
		>		;SPACE FOR SEGMENT NAME AND ALIAS
		ASCID	/
/				;CRLF TO FINISH USER LINE
↑WLINK←←.-TITLE
		0		;DD HALT.  FOR III, A JMP TO TITLE GETS PUT HERE

;DISPLAY SUBROUTINE FOR SYSTEM DATA ON FIRST LINE OF WHO LINE
↑COMIII:	BYTE(11)<-1000>,770(3)2,2(2)1,2(3)3	;III POSITION WORD.
↑WHOSEL:	770000,,DISSEL	;HERE WE SELECT WHICH III'S GET THE SYSTEM WHO LINE
↑COMDD:				;DDD PROCESSOR ENTRY POINT
↑COMWHO:	ASCID/                   ,       ,       K    %   D          / 
		ASCID/              :  
/				;CONSTANTS IN SYSTEM LINE
		DISKPN		;SKIP ALWAYS, IF III
		.+2,,DISJMP	;NO COMMENT!
		0		;III HALTS HERE
		CW (3,2,3,2,3,2);SELECT COL 2.  DISKPN ISN'T QUITE A NO-OP ON DDD!
↑DDDRET:	DISJMP		;DD JMP TO USER LINE OF WHO LINE.  ADR PLACED IN LH

↑DDTAB:	BLOCK 40	;CHANNEL TABLE
↑DDFLST:	0	;FREE LIST HEADER, MUST FOLLOW DDTAB
↑DDFCNT:	0	;# FREE CHANS
↑AVLCHN:	11	;CHAN FOR AVAIL MSG
↑AVLBIT:	0	;BIT   "    "    "
↑VDMAP:	BLOCK DDNUM	;THE PERMANENT MAP
	BLOCK DPYNUM	;CELLS FOR "SHADOW" CHANNELS

BEND DPYDAT

BEGIN DTCDDB
SUBTTL	DTCDDB 06-AUG-68 DECTAPE DATA BLOCK

;DTA DEVICE DATA BLOCKS

DEFINE CAT6'(A,B),<SIXBIT /A'B/>
	
DEFINE DTCDDX!(UNIT),<
	REPEAT	DDBSKW-1,<0>	;SKEW-ZEROES
	DEVLUP,,0		;DEVCMR
	ZZ←.
IFE UNIT,<↑DTCDDB←.>
	CAT6(DTA,\<UNIT+1>)
	XWD	=10*HUNGST,200+<UNIT+1>⊗PUNITP	;LONG HUNG COUNT IS INSERTED WHEN A DUMP
						;MODE OPERATION HAPPENS.
	0
;;replaced;;	XWD	IFE UNIT-(DTCNUM-1),<MTCDDB,DTCDSP;>LINK,DTCDSP
IFE UNIT-(DTCNUM-1),<XWD MTCDDB,DTCDSP> ;;with;;
IFN UNIT-(DTCNUM-1),<XWD LINK,DTCDSP> ;;with;;
	LINK←.-4
	XWD	DVDIR+DVIN+DVOUT+DVDTA+DVLNG,154403
	0
	0
	XWD	PROG,0
	XWD	PROG,0
	XP	DTNEXT,.-ZZ	;LH=NEXT OUTPUT BLOCK NO.
					;RH NEXT INPUT BLOCK NO.
	0
	XP	DTERR,.-ZZ	;ERROR COUNT OF FATAL ERRORS
	0
	XP	CURENT,.-ZZ	;POINTER TO CURRENT DIR ENTRY(ABSOLUTE)
	0
	XP	UFREE,.-ZZ	;RH=LAST BLOCK USED. 1 FOR A CLEARED DIRECTORY
	XWD	0,0		;LH=BLKCNT WHILE TAPE INACTIVE, INIT AT BLD TIME
	XP	UDIR,.-ZZ		;LINK TO DIRECTORY IN DATA BLOCK
	.+1		;ADDR DTA DIRECTORY
	BLOCK	200		;DTA DIRECTORY
>


UNIT←DTCNUM-1
; THE FOLLOWING EXPANSION OF THE MANY DECTAPE DEVICE DATA BLOCKS
; HAS BEEN XLIST'ED OUT FOR YOUR READING CONVENIENCE.
; THEY ACTUALLY LOOK LIKE THIS:
; REPEAT DTCNUM,<DTCDDX(UNIT)
;         UNIT←UNIT-1>
XLIST
REPEAT DTCNUM,<DTCDDX(UNIT)
	UNIT←UNIT-1>
LIST

;TEMPORARY STORAGE FOR DECTAPE SERVICE
↑BLKPTR:	0	;BLKI/BLKO POINTER.
↑DMPPTR:	0	;DUMP MODE BLKI/BLKO POINTER
			;MOVED TO BLKPTR AT INTERRUPT
↑DMPLST:	0	;RELATIVE POINTER TO CURRENT DUMP MODE
			;COMMAND LIST WORD
↑DTOTAL:	0	;TOTAL ERROR COUNT FOR SYSTEM SINCE IT WAS
			;LOADED(COUNT NOT CLEARED AT SYSTEM INITIALIZATION)
↑DFTOTAL:	0	;TOTAL FATAL ERROR COUNT FOR SYSTEM SINCE LOADED
			;IE FAILED DTTRY (3 USUALLY) TIMES
↑DTTAC:		0	;PLACE TO SAVE TAC ON DT CHANNEL
↑DTUNIT:	0	;DT UNIT IN BITS 30-32,DT PI CHAN. BITS 33-35
↑ERRFLG:	0	;DATA MISSED BY DC IF NON-ZERO
↑RBNCNT:	0	;COUNT DOWN NUMBER OF REVERSALS SEEKING BLOCK
↑UBUF:		0	;ABS. ADR. OF SECOND WORD OF USER BUFFER
↑UERRCN:	0	;NO. OF ERROR SO FAR ON THIS OPERATION
↑UPROG:		0	;XWD PROTECTION,RELOCATION FOR JOB USING DECTAPES
↑UDPROG:	0	;XWD 0,RELOCATION(USED BY DUMP MODE ONLY)
↑USVDB:		0	;ADR. OF DEVICE DATA BLOCK FOR CURRENT UNIT
↑BLKCNT:	0	;COUNT OF NO. OF BLOCKS WHICH CURRENT JOB
			;USING DECTAPES CAN DO BEFORE HAVING TO GIVE
			;THEM TO ANOTHER JOB IF ONE IS WAITING
			;THIS IS SETUP AT UUO LEVEL AND DECREMENTED AT
			;JOB DONE TIME AT INTERRUPT LEVEL
			;IF TAPE MUST SEARCH FOR BLOCK, COUNT IS SET TO ZERO
			;MEANING THAT QUANTUM IS EXCEEDED IMMEDIATELY


↑UBKN:		0
↑BNDISP:	0
↑CONSZ1:	0
↑RDBN:		0
		JRST RDBN1
↑WTRV:		0
		JRST WTRV1
↑RDRV:		0
		JRST RDRV1
↑ENPT:		0
		JRST ENPT0
↑ENPT1:		0
		JRST ENPT2
↑DMPADV:	0
		JRST DMPA0
↑DCLOC:		0
↑DCLOC1:	0

BEND DTCDDB

IFN FTDISK,<
;;TASK BLOCK DEFINITIONS . . .

FBADR←←0
FBWC←←1
FBDONE←←2
FBDA←←3
FBRETRY←←4
FBBND←←5
FBJOB←←6
FBLINK←←7

↓FBSIZ←←FBLINK+1

;;NUMBER OF BANDS THE THING HAS . . .

↓NBANDS←←170
MAXFB←←40

BEGIN FBDAT
SUBTTL DATA FOR LIBRASCOPE SWAPPER AND FAST BAND PACKAGE

↑IEARLY:	0	;ENABLE IOP EARLY RESPONSE PRINTOUT

↑FBQUE:		0	; TOP OF TASK LIST

↑SYSBAND:	100B23
↑SYSBND:	100		; BAND WHERE SYSTEM LIVES
↑DDTBAND:	101B23

↑FBBANDLIST:	REPEAT 60,<-1>	;0-57	;NO DISK HERE ANY MORE
		REPEAT 70-57,<0>	;60-70 OK
		-1			;71 EATS IT
		0			;72 OK
		0
		0
		-1			;75 LOSES
		REPEAT 101-75,<0>	;76-101 OK
			-1	;102	PERMANENT READ ERROR
			-1	;103	PERMANENTLY BAD!
			-1	;104	PERMANENT READ ERROR
			-1	;105	PERMANENT READ ERROR
			0	;106	OK
			-1	;107	BAD BAND 2-22-73
			0	;110	OK
			0	;111	OK
			-1		;112 BAD
		REPEAT 131-112,<0>	;113-131 OK
			-1		;132 BAD
			0		;133 OK
			0		;134 OK
			0		;135 OK
			-1		;136 BAD
		REPEAT NBANDS-136,<0>	;REST OK

↑FBBUSY:	-1
↑FBTASK:	0
↑FBACT:		0
↑FBSPARE:	BLOCK FBSIZ
↑FBSBUSY:	0
↑LASTADR:	0		;LAST SECTOR, TRACK, AND BAND
↑LASTWC:	0		;LAST WCMA SENT
↑IOPWRD:	0		;WORD IOP GOT PAR ERR ON
↑IOPWCM:	0		;IOP WCMA FOR PARITY ERROR, DATA MISS.

BEND FBDAT
>

BEGIN LPTDDB
SUBTTL LPTDDB - 10 SEPT 68 - JAM


;LPT  DEVICE DATA BLOCK
REPEAT DDBSKW-1,<0>	; PUT IN PROPER NUMBER OF ZEROS FOR SKEW PURPOSES
		DEVIBF!DEVLUP,,0		;INTERNALLY BUFFERED DEVICE
↑LPTDDB:	SIXBIT	/LPT/
		XWD	=10*HUNGST,LPTSIZ+2
↑LPTIOS:	0
		XWD	XGPDDB,LPTDSP
		XWD	DVOUT!DVLPT,4403	;MODES 13,10,1,0
		0
		0
		0
		XWD	PROG,0
↑LPTIBF:	BLOCK LPTBLN	; SYSTEM BUFFER
↑LPTDCN:	0		; DANGLING CHARACTER COUNT
↑LPTBG1:	0		;SET TO EJECT FORMS BEFORE FIRST OPERATION
↑LPTUBP:	POINT 7,LPTIBF	; UUO LEVEL POINTER
↑LPTIBP:	LPTIBF		; INTERRUPT LEVEL POINTER
↑LPTCC:		5*LPTBLN	;  TOTAL CHARACTER COUNT
↑LPTLCC:	LPTCPL		; CHARS PER LINE

BEND LPTDDB

BEGIN XGPDDB	
 SUBTTL DATA STORAGE FOR XGP SERVICE
;REG JAN 11 1973.  REVISED THRU 8 JUNE 1973

REPEAT DDBSKW-1,<0>
		DEVIBF!DEVLUP,,XGPCSC		;DEVICE HAS INTERNAL BUFFER.
						;(SOMETIMES)
↑XGPDDB:	SIXBIT	/XGP/
		5*HUNGST,,401			;RH = BUFFER SIZE.
↑XGPIOS:	0
		ADDDB,,XGPDSP
		DVLPT!DVLNG!DVOUT,,104401	;MODES 0,10,17,13
		0				;DEVLOG
		0				;DEVBUF
		PROG,,0				;DEVADR
		PROG,,0				;DEVOAD
		0
		0
		0

↑XGPCSC:	BLOCK	PSYNCN			;INTER PROCESSOR SYNCHRONIZATION.

↑XGPP1F:	0				;SET TO SIGNAL PDP-10
↑XGPP2F:	0				;SET TO SIGNAL PDP-6

↑XYNCNT:	0				;SYNC COUNT
↑XGPCNT:	0				;COUNTS VARIOUS THINGS
↑XGPCNY:	0				;COUNTS PAPER FEED AT END
↑XGPKIL:	0				;SET WHEN PDP-10 WANTS XGP TO DIE.

↑XGPIWD:	0				;IOWD FOR CURRENT DUMP COMMAND
↑XGPBIG:	0				;REMAINDER OF IOWD
↑XGPMDP:	0				;POINTER TO CURRENT DUMP COMMAND
↑XGPNXC:	0				;POINTER TO NEXT DUMP COMMAND
↑XGPROG:	0				;RELOC OF USER.
↑XGPGCW:	0				;GROUP CONTROL WORD.

↑XDISP1:	0				;DISPATCH LEVEL 1
		JEN	@XGPCHL			;DISMISS INTERRUPT.
						;JSR XDISP1 TO CHANGE DISPATCH AND
						;DISMISS.

↑XDISP2:	0				;DISPATCH LEVEL 2
		POPJ	P,

↑XGPAOK:	0				;PDP-6 SETS THIS ON EACH INTERRUPT.
↑XGPBIT:	0				;PDP-10 TELLS WHAT IT WANTS HERE
↑XGPGO:		0				;SET BY PDP-10 WHEN JOB LOCKED IN.
↑XGPTMP:	0				;1 CELL FOR I-LEVEL.
↑XPGOOD:	0				;CELL FOR 'GOOD CUTS'.

↑XTAKE:		0				;POINTER FOR PDP-6.
↑XPUT:		0				;POINTER FOR PDP-10
↑XIBUF:		0				;CONTAINS THE ADDRESS OF THE BUFFER.
↑XIBFND:	0				;ADDRESS OF END OF BUFFER.
↑XBFCNT:	0				;COUNT OF WORDS USED IN BUFFER.
↑XGPWSZ:	0				;SIZE NEEDED BEFORE REACTIVATION.
↑XGPBFL:	0				;FLAG SET FOR MODE 10, ZEROED FOR 17

↑XGPOST:	BLOCK	20			;OLD STATUS OF FC
↑XGPNST:	BLOCK	20			;NEW STATUS OF FC.
↑XGPFC1:	0				;SET WHEN WE WAIT FOR FC
↑XGPFC2:	0				;SET WHEN FC WAITS FOR US
↑XCLKNM:	0				;CLOCK REQUEST IDENTIFIER
↑XFCJN:		0				;FC JOB NUMBER
↑FCRQER:	0				;FLAG FOR FC NOT RESPONDING.
↑XFCADR:	0				;RELATIVE ADDRESS OF THE FC
↑XFTADR:	BLOCK	20			;ADDRESS OF FONT TABLE IN FC

↑XGPSLS:	0				;SPECIAL LINE SPACE COUNT. '177'1'42

↑XCFH:		0				;CURRENT FONT HEIGHT
↑XCFBL:		0				;CURRENT BASE LINE
↑XCFCPA:	0				;CURRENT COLUMN POSITION ADJUSTMENT.
↑XHMAX:		0				;MAXIMUM HEIGHT IN CURRENT LINE.
↑XLBL:		0				;XLBL CURRENT LINE'S BASE LINE.
↑XFTCAD:	0				;CURRENT FONT ADDRESS (RELOCATED)
↑XSCNLN:	0				;CURRENT SCAN LINE IN LINE
↑XGPERC:	BLOCK	4			;ERROR CONDITION CODES.
↑XGPPG2:	0				;"PAPER PAGE" COUNT
↑XGPHIP:	0				;"HEADING IN PROGRESS"
↑XGPHDW:	0				;IOWD FOR HDB
↑XGPHDB:	BLOCK	=26			;TEXT FOR HEADINGS. USE HDW
↑XGPAT0:	0				;THREE TEMP CELLS FOR 
↑XGPAT1:	0				;PAPER PAGE MACRO EXPANSION.
↑XGPAT2:	0
↑XSVCAD:	0				;SAVE OLD FONT WHILE IN HEADING.
↑XGPIGO:	0				;SET TO -1 BY PDP6 WHEN DATA XFER
↑XUSBEG:	0				;COLUMN OF BEGINNING UNDERSCORE.
↑XCHBGO:	0				;SET TO ADDRESS OF FIRST TEXT NODE.
↑XVNODE:	0				;SET TO ADDRESS OF VECTOR NODE.

;LIST HEADERS FOR COMPILER/TEXT PROCESS
↑XVNFL:		0				;VECTOR NODE FREE LIST
↑XTNFL:		0				;TEXT NODE FREE LIST
↑XATLH:		0				;ACTIVE TEXT LIST
↑XASVLH:	0				;ACTIVE NARROW VECTOR LIST
↑XALVLH:	0				;ACTIVE WIDE VECTOR LIST
↑XPENDH:	0				;PENDING QUEUE HEAD
↑XPENDT:	0				;PENDING QUEUE TAIL

XGPPDX:
		BLOCK	20			;PDL FOR CHANNEL 4 COMPILER.
↑XGPPDL:	IOWD	20,XGPPDX		;POINTER TO PDL

↑XACT4:		0				;FLAG CH4 NEEDS ACTIVATION.
↑XCYPOS:	0				;Y POSITION FOR CURRENT LINE.
↑XGPLYP:	0				;LAST Y POSITION QUEUED
↑XFREBA:	0				;POINTER TO BLOCK IN FC.
↑XNODUS:	0				;# OF TEXT NODES IN USE.
↑XTOFRM:	0				;SET TO -1 WHEN THERE IS TEXT Q'ED
↑XLFTKF:	0				;SET TO -1 WHEN WE DID KERN ADJUST
↑XGPSAC:	BLOCK	20			;CH4 CO-ROUTINE AC'S


↑XFLAPA:	0				;MORE BITS FOR FLAPPER
↑XFLAPB:	0				;BITS TO DECIDE WHEN TO FLAP
↑XFLAPC:	0				;FLAPPER COUNT
↑XCUTQ:		BLOCK	=48			;QUEUE OF CUT POINTS
↑XCUTBP:	POINT 36,XCUTQ-1,35		;BYTE POINTER TO XCUTQ

;THE REST OF THIS IS INITIALIZED BY RESET
↑NTNODE←←=16					;(DEFAULT) NUMBER OF TEXT NODES
↑NVNODE←←=100					;(DEFAULT) NUMBER OF VECTOR NODES
↑XGPBL1←←4000					;(DEFAULT) SIZE OF SYSTEM BUFFER

↑XGPPS1:	=200				;TOP TO FIRST LINE MARGIN
↑XGPPS2:	=1790				;TOP LINE TO LAST LINE SIZE.
↑XGPPS3:	=200				;LAST LINE TO BOTTOM MARGIN
↑XGPLMR:	=200				;LEFT MARGIN
↑XGPRMR:	=1650				;RIGHT MARGIN
↑XGPILS:	=4				;INTER-LINE SPACING
↑XNTNOD:	NTNODE				;NUMBER OF TEXT NODES
↑XNVNOD:	NVNODE				;NUMBER OF VECTOR NODES
↑XGPBLN:	XGPBL1				;SIZE OF SYSTEM BUFFER

↑XMSET:	=200					;SET MARGINS (ETC) FROM THIS BLOCK
	=1790
	=200
	=200
	=1650
	=4
	NTNODE
	NVNODE
	XGPBL1

BEND XGPDDB

BEGIN PTRDDB -- PAPER TAPE READER DEVICE DATA BLOCK
SUBTTL PTRDDB - J. SAUTER - 10-NOV-68

		REPEAT DDBSKW-1,<0>	; PUT IN ALL THE EXTRA WORDS
		DEVLUP,,PTRCSC		; PUT IN ADDRESS OF CONTROL CELLS
↑PTRDDB:	SIXBIT /PTR/
		XWD =10*HUNGST,41
		0
		XWD PTPDDB,PTRDSP
		XWD DVPTR+DVIN,14403
		0
		0
↑PTRADR:	XWD PROG,0
↑PTRPTR:	0
		0			;PTR COUNTER
↑PTRACT:	0
↑PTRIN1:	0
↑PTRADV:	0
↑PTRSTR:	0
↑PTRCHR:	0
↑PTRDSC:	0			;SET TO -1 TO MAKE PTR DISCONNECT.
↑PTRCSC:	BLOCK PSYNCN
↑PTRCON:	0			;SET TO PTRCN1 OR PTRCN2.

BEND PTRDDB

BEGIN PTPDDB -- PAPER TAPE PUNCH DEVICE DATA BLOCK
SUBTTL PTPDDB - JAM - 10-NOV-68

REPEAT DDBSKW-1,<0>		; PUT IN PROPER NUMBER OF SKEW WORDS
		DEVIBF!DEVLUP,,PTPCSC
				; TELL WORLD THAT THIS IS AN INTERNALLY BUFFERED DEVICE . . .
				; AND THAT IT HAS CONTROL CELLS
↑PTPDDB:	SIXBIT /PTP/
		XWD =20*HUNGST,41
↑PTPIOS:	0
IFE IMPSW,<	XWD LPTDDB,PTPDSP>
IFN IMPSW,<	XWD DDBMDL,PTPDSP>
		XWD DVPTP+DVOUT,14403
		0
		0
↑PTPPTR:	0
↑PTPADR:	XWD PROG,0
↑PTPIBP:	0		; INTERRUPT-LEVEL BYTE POINTER
↑PTPUBP:	0		; UUO-LEVEL POINTER
↑SYSPDL:			;SYS INIT PDL MOVED HERE FROM TTY DDB 5/6/74 BH
↑PTPBUF:	BLOCK PTPBLN	; BUFFER ITSELF
↑PTPFCN:	0		; PUNCH FEED COUNT
↑PTPBCN:	0		; BUFFER CHARACTER COUNT
↑PTPIDS:	0		; INTERRUPT-LEVEL DISPATCH LOCATION
↑PTPUDS:	0		; UUO-LEVEL DISPATCH LOCATION
↑PTPCPW:	0		; CHARACTERS PER WORD
↑PTPACT:	0		; FLAG ASKING TO TURN ON PTP
↑PTPMOD:	0		; MODE OF OPERATION
↑PTPSID:	0		; P2 ASKING P1 TO CALL SETIOD
↑PTPCSC:	BLOCK PSYNCN	; 2-PROCESSOR SYNCHRONIZATION CONTROL REGISTERS
↑PTPCON:	0		; SET TO PTPCN1 OR PTPCN2

BEND PTPDDB

BEGIN SCNDDB
;DESCRIPTION OF DEVICE DATA BLOCK FOR TELETYPES

;THE FUNCTIONS OF THE FIRST EIGHT WORDS ARE AS DESCRIBED IN THE
;COMMENTS IN THE SYSTEM PARAMETER TAPE( FILE NAME S). LOCATIONS 11
;THROUGH 27 (OCTAL) RELATIVE TO SCNDDB PERTAIN DIRECTLY TO THE
;SCANNER SERVICE BUFFERING SCHEME. THE SUBSEQUENT 2*20(OCTAL) LOCATIONS
;ARE CURRENTLY THE TWO TELETYPE BUFFERS. THEY NEED NOT BE IN THE DDB
;AS LONG AS THEIR ADDRESSES ARE PLACED IN THE RIGHT HALF OF TTIBUF,
;AND TTOBUF EITHER AT ASSEMBLY, BUILD OR RUN TIME. IF DYNAMIC
;BUFFER CONSTRUCTION IS TO BE ADDED THESE BUFFERS MAY BE PLACED ANYWHERE IN
;FRE CORE STORAGE, AND THE RIGHT HALF OF THE REQUIRED TTXBUF(WHERE "X"
;MAY BE "I" OR "O")MAY BE LOADED ONLY WHEN THAT BUFFER IS REQUIRED.

;THERE ARE TWO BUFFERS, EACH OF WHICH IS A "RING" UNTO ITSELF:
;INPUT---POINTED TO BY TTIBUF
;	ALL CHARACTERS TYPED GO INTO THIS BUFFER. IN ADDITION, ALL
;OTHER COMMANDS TO BE READ BY THE COMMAND INTERPRETER IN COMCON
;(APRSER) ARE STORED HERE.
;OUTPUT BUFFER---POINTED TO BY TTOBUF
;	ALL CHARACTERS THAT ARE OUTPUT ARE PLACED SEQUENTIALLY IN THIS
;BUFFER; THIS INCLUDES ECHOED CHARACTERS AS WELL AS NORMAL OUTPUT OF
;CHARACTER STRINGS.

;THERE ARE NINE BUFFER PARAMETER WORDS ASSOCIATED WITH EACH BUFFER
;(EXCEPT FOR THE OUTPUT BUFFER, WHICH ONLY NEEDS SIX). THE LAST
;FOUR CHARACTERS IN THE MNEMONIC DESCRIBES THE FUNCTION OF THE WORD
;WHILE THE FIRST TWO CHARACTERS IDENTIFY WHICH BUFFER THAT THE
;FUNCTION APPLIES TO. THE FORMULA FOR THESE WORDS IS TX'FUNC, WHERE
;THE RELATIVE POSITION OF ALL TX'FNC1 TO TTX'BUF IS THE SAME FOR
;ALL BUFFERS.  IN THIS MANNER, THE ADDRESS OF TTX'BUF IS LOADED INTO
;ACCUMULATOR DAT, AND THE RELATIVE POSITIONS FUNCT1-FUNCT9 ARE
;DEFINED TO BE 0-10 (OCTAL); I.E., FUNCT(DAT) WILL IDENTIFY THE DESIRED
;BUFFER PARAMETER WORD REGARDLES OF BUFFER.

;FOLLOWING ARE DEFINITIONS OF THE RELATIVE BUFFER PARAMETER WORDS:
;TTX'BUF OR BUF(DAT)---THE LEFT HALF CONTAINS NUMBER OF BYTES IN BUFFER AND THE RIGHT
;	HALF THE ADDRESS OF THE FIRST WORD OF THE BUFFER. THIS WORD IS
;	ONLY READ BY THE CURRENT CODE.  UPON THE ADDITION OF DYNAMIC
;	BUFFER ALLOCATION, THIS WORD WOULD BE LOADED IN THE SAME FORMAT
;	AT THE TIME THAT THE BUFFER WOULD BE BUILT.
;
;SCNINI SETS BUFFERS TO LENGTH TTYCHR AT PRESENT. ALSO
;PRESENT CODE OCCASIONALLY USES TTYCHR RATHER THAN READING LH
;OF TTXBUF
;
;TX'PUTR OR PUTR(DAT)---BYTE POINTER USED TO PLACE CHARACTERS INTO THE
;	BUFFER. IT MUST ALWAYS BE AHEAD OF OR EQUAL TO THE TAKER POINTER.
;TX'PCTR OR PCTR(DAT)---COUNT OF NUMBER OF TIMES THAT PUTR MAY BE INCREMENTED
;	BEFORE REACHING THE LAST BYTE IN THE LAST WORD OF THE BUFFER
;	(NOT THE AMMOUNT OF FREE SPACE LEFT)
;TX'TAKR OR TAKR(DAT)---BYTE POINTER USED BY ALL ROUTINES TO PICK UP
;	CHARACTERS FROM THE BUFFER. WHEN THE TAKR IS EQUAL TO THE PUTR,
;	THE BUFFER IS "EMPTY".
;TX'TCTR OR TCTR(DAT)---COUNT OF THE NUMBER OF TIMES THAT THE TAKR CAN
;	BE INCREMENTED BEFORE REACHING THE PHYSICAL END OF THE BUFFER.
;TX'FCTR OR FCTR(DAT)---FREE CHARACTER COUNT; I.E., HOW MANY TIMES MAY THE
;	PUTR BE INCREMENTED BEFORE IT WOULD COME AROUND AND "STEP ON"
;	THE TAKR. WHEN THE FREE CHAR. COUNT IS ZERO, NO MORE CHARACTERS
;	MAY BE PLACED IN THE BUFFER (USUAL RESULT IS GOING INTO IO WAIT)
;TX'SYNC OR TSYNC(DAT)---COUNT OF NUMBER OF "LINES" THAT HAVE BEEN TYPED
;	INTO INPUT BUFFER.

;SCANNER DEVICE DATA BLOCK.
;REMAINING SCN DDB'S ARE GENERATED
;OUT OF LINE AT BUILD TIME.
;THIS DDB IS USED FOR THE CTY AND NEVER KILLED   BH 5/6/74

↑OFFSET←←5	;NUMBER OF COMPILED IN DDBS
↑TTPLEN←←SCNNUM+DPYNUM+DDNUM+PTYNUM+1

Z←←0;
LINK←←0
REPEAT DDBSKW,<XWD DEVAOA,0>		;IGNORE IOACT FOR OUTPUT UUO
↑SCNDDB:
↑TTYLST:
	ZZ←.
	SIXBIT /CTY/			;DEVNAM
	TCONLN⊗13+UTTYBF+1		;DEVCHR(NO HUNG TIME),,BUFFER SIZE+1
	Z				;DEVIOS
	XWD	LINK,SCNDSP		;DEVSER
	XWD	DVTTY+DVIN+DVOUT,15403	;DEVMOD (ALLOWS MODES 0,1,10,11,13,14)
	Z				;DEVLOG
	Z				;DEVBUF
	XWD	PROG,0			;DEVIAD
	XWD	PROG,0			;DEVOAD
	XP	ACTBTS,.-ZZ		;BREAK TABLE
	-1
	777700,,37600
	374000
	XP	ACTMOD,.-ZZ		;END OF TABLE AND SPECIAL BITS
	7,,600000
	XP	TTYPTR,.-ZZ		;TTYPTR
	Z
	XP	TTIBUF,.-ZZ
	XP	TTICHR,STTIBF*4		;9 BIT CHARACTERS FOR INPUT
	XWD	TTICHR,TTYLST+TIBF-1
	XP	TIPUTR,.-ZZ
	1100,,TTYLST+TIBF
	XP	TIPCTR,.-ZZ
	1
	XP	TITAKR,.-ZZ
	1100,,TTYLST+TIBF
	XP	TITCTR,.-ZZ
	1
	XP	TIFCTR,.-ZZ
	TTICHR
	XP	TISYNC,.-ZZ
	Z
	XP	TTOBUF,.-ZZ
	XP	TTOCHR,STTOBF*5		;7 BIT OUTPUT
	XWD	TTOCHR,TTYLST+TOBF-1
	XP	TOPUTR,.-ZZ
	700,,TTYLST+TOBF
	XP	TOPCTR,.-ZZ
	1
	XP	TOTAKR,.-ZZ
	700,,TTYLST+TOBF
	XP	TOTCTR,.-ZZ
	1
	XP	TOFCTR,.-ZZ
	TTOCHR
	XP	PTYPTR,.-ZZ
	Z
	XP	SAVDDB,.-ZZ		;FOR FILES COMMAND
	Z
	XP	IMLHAC,.-ZZ		;BITS 34:35 HOLD IMLAC BUCKY BITS.
	Z
	XP	TIBF,.-ZZ
	BLOCK	STTIBF			;THE ACTUAL INPUT BUFFER
	XP	TOBF,.-ZZ
	BLOCK	STTOBF			;THE ACTUAL OUTPUT BUFFER
;NO. OF CHAR. IN MON. BUF.
	XP	SCNDDS,.-ZZ		;SIZE OF SCN DDB

↑LINSAV: 0
↑LINSV1: 0
↑↑TTYLOK:	0
↑DKBCHR:	0
GLOBAL TTPLEN
	0	;LINTAB(-1) FOR DDBSRC
↑LINTAB: BLOCK TTPLEN
GLOBAL PTYNUM
↑PTYJOB:	BLOCK PTYNUM

BEND SCNDDB

;DIALER DATA AREA
BEGIN DILDAT

;AC SAVE LOCS
↑DILLIN:	0
↑DILTAC:	0
↑DILJ:		0

;THIS PART ZEROED AT DILINI
↑DILZBG←←.
↑DILJOB:	BLOCK DILNUM	;JOB # OF JOB OWNING THIS DIALER
↑DILCNI:	BLOCK DILNUM	;LAST CONI BITS FROM DILINT
↑DILIDS:	BLOCK DILNUM	;DILINT DISPATCH ADDRESS
↑DILZND←←.-1

BEND DILDAT

BEGIN MTCDDB  --  DEVICE DATA BLOCK FOR MAG TAPES.
SUBTTL MTCDDB - J. SAUTER, STANFORD, MAG. TAPE DEVICE DATA BLOCKS


GLOBAL SCNDDB
LINK←SCNDDB

DEFINE CAT6'(A,B),<SIXBIT /A'B/>

DEFINE MTCDDX(UNIT),<
	REPEAT DDBSKW-1,<0>	;SKEW-ZEROS
	DEVLUP,,0
	ZZ←.
IFE UNIT,<↑MTCDDB←.>
	CAT6(MTA,\UNIT)
	XWD	=60*HUNGST,MTSIZ+1+<UNIT>⊗PUNITP
	0
	XWD LINK,MTCDSP
	LINK←.-4
	XWD DVMTA!DVIN!DVOUT!DVLNG,154403
	0
	0
	XWD PROG,0
	XWD PROG,0
↑MTCENT←.-ZZ
	0	;ERROR COUNT FOR THIS UNIT:
			;0-8 = LOGN. P.E.
			;9-17 = LAT. P.E.
			;18-26 = ILL OP.
			;27-35 = DATA MISSED.
↑MTCBKN←.-ZZ
	0	;RECORD COUNTER
>

	UNIT←MTCNUM-1
; THE FOLLOWING IS XLIST'ED OUT FOR YOUR READING CONVENIENCE
; IT ACTUALLY LOOKS LIKE THIS:
; REPEAT MTCNUM,<MTCDDX(UNIT)
;       UNIT←UNIT-1>
XLIST
	REPEAT MTCNUM,<MTCDDX(UNIT)
	UNIT←UNIT-1>
LIST

;TEMP CELLS AND CONTROL DATA
↑MTEOFF:	0	;EOF FLAG
↑MTDEV:		0	;XWD COMMAND,DDB ADDR
↑MTDCCN:	0	;BLKO/BLKI POINTER FOR REDO
↑DCWRD:		0	;BLKO/BLKI POINTER FOR DC
MTCSAV:
		0	;DC COMMAND
↑MISSED:	0	;-1 IF DC HAS PARTIAL WORD
↑MTERCN:	0	;ERROR COUNTER
↑MTREWN:	0	;UNITS REWINDING AND IN IOW -1=NONE, 0=ONE
↑MTCMDP:	0	;DUMP COMMAND LIST POINTER
↑SVCNTR:	0	;DUMP COMMAND IOWD NEG. WORD COUNT
↑MDCSAV:	0
↑MTIDSP:	0	;ADDRESS TO TRANSFER TO ON NEXT MAG TAPE INTERRUPT

↑MTDCND:	0	;JSR HERE WHEN BLKO/BLKI COUNTED OUT
		JRST MTDCN1

BEND MTCDDB

BEGIN SPWDAT -- DATA FOR SPACEWAR
SUBTTL SPWDAT - JAM, STANFORD, 7-NOV-68, DATA FOR SPACEWAR SERVICE


↑SPWA:	BLOCK 20	; P1 ACCUMULATORS
↑SPWB:	BLOCK 20	; P2 ACCUMULATORS
↑SPWSAC:BLOCK 20	; USER'S ACCUMULATORS
↑SP2SAC:BLOCK 20
	0		; JOB NUMBER OF JOB WHICH HAS 
			; PDP-6 SPACEWAR ASSIGNED.
↑SPWBUT:
	0		; SPACEWAR BUTTONS
↑SPWACT:
	0		; FLAG MEANING A SPACEWAR JOB EXISTS
↑SPWCSC:
	BLOCK PSYNCN	; SPACEWAR 2-PROCESSOR SYNCHRONIZATION CELLS

;WARNING! DON'T CHANGE POSITION OF SPWGO,SP2GO,JBTST2 - SEE SPWINI - REG
↑SPWGO:	BLOCK	JOBN	
↑SP2GO:	BLOCK	JOBN
↑JBTST2:BLOCK	JOBN

BEND SPWDAT

;SCHEDULER DATA AREA . . .
BEGIN SCHDAT
SUBTTL	SCHDAT 11 SEPT 67 SCHEDULER DATA AREA

;SCHEDU DATA


↑SCHMQT:	QQMQT
↑JOBQUE:	BLOCK JOBN	; MINUS THE QUEUE NUMBER THE JOB IS IN
; TABLES FOR JOB PRIORITY CALCULATIONS

↑SCHBEG:			;HERE TO SCHEND ZEROED BY NXTINI
↑JLCYET:	0
↑JLFACTOR:	0		;JLFACTOR/JLTIME = USEFUL PROCESSOR LEVEL
↑RJLFACTOR:	0		;RECIPROCAL JLFACTOR
↑OINTIME:	0		;HERE WE SAVE INTIME+P1PID FROM LAST JLCAL CYCLE
↑OUTIME:	0		;HERE WE SAVE UPTIME+P1PID FROM LAST JLCAL CYCLE
↑JLRIT:		0		;RECENT INTERUPT FRACTION *1000
↑ORDYET:	0
↑JBTPRI:	BLOCK JOBN	; JOB'S PRIORITY
↑JBTNPR:	BLOCK JOBN	; JOB'S NEW PRIORITY
↑JBTJL:		BLOCK JOBN	; POINTER TO FS TABLE OF INSTANTANEOUS JOB LOAD
↑JBTJLH:	BLOCK JOBN	; OLDEST JOB LOADING.
↑SCHEND←←.-1

↑GCBITS:	BLOCK 2		;BIT TABLE FOR GCMCK ROUTINE

; QUEUE TABLES . . .
		BLOCK MXQUE
↑JBTQ:		BLOCK JOBN

IFN FTSWAP,<
; SWAPPER TABLES . . .

↑SWPJMX:	0
↑SWPMXP:	0
↑SWPLMX:	0
↑SWPLMJ:	0
↑JBTSWP:	BLOCK JOBN
↑JB2SWP:	BLOCK JOBN	;LH LIKE JBTSWP FOR SPARE COPY OF SEGMENTS
				;30-35 DATA DISC CHANNEL LIST. 18-29 AVAILABLE.
;LEAVE NEXT LOCS IN ORDER FOR WHO
↑BIGHOL:	0		;CURRENT BIGGEST HOLE IN CORE (1K BLOCKS)
↑FINISH:	0		;FINISH,FORCE,FIT AND XPANDF ARE FLAGS IN SWAP
↑FORCE:		0		; NUMBER OF THE JOB THAT WILL GO OUT NEXT
↑FIT:		0		; NUMBER OF THE JOB THAT WILL COME IN NEXT
↑XPANDF:	0
↑FULCNT:	0		;PRINT DISK IS FULL EVERY 30 SECONDS
↑SEGWAIT:	0		; NUMBER OF JOB WAITING FOR UPPER SEGMENT
↑MAXSIZ:	0		;SIZE OF LARGEST JOB WHICH MIGHT BE SWAPPED OUT
↑MAXJBN:	0		;NUMBER OF THAT JOB
↑MAXRSZ:	0		; SIZE OF LARGEST RUNNABLE JOB
↑MAXRJB:	0		; JOB NUMBER OF LARGEST RUNNABLE JOB.
↑MAXSSZ:	0		; SIZE OF LARGEST SEGMENT.
↑MAXSJB:	0		; JOB NUMBER OF LARGEST SEGMENT.
↑SUMCOR:	0		; THE SWAPPER TOTALS THE CORE SIZES OF THE JOBS
				; IT IS CONSIDERING FOR SWAPOUT AND PUTS THAT TOTAL HERE
↑NEEDED:	0		;THE AMOUNT NEEDED TO SWAP JOB IN FIT IN
>

;SHARABLE DEVICE JUST BECOME AVAILABLE(EXTENDED TO OTHER QUEUES TOO)
;APPROPRIATE ENTRY IS SET NON-ZERO WHEN SCHEDULER SHOULD LOOK
;AT THAT QUEUE TO FIND A JOB TO RUN
;WSAVAL CONTAINS THE NO. OF JOBS WITH IO WAIT SATISFIED(0=NONE)

DEFINE X!(A)
<
↑A!AVAL:	0
>

↑AVALTB:	QUEUES		;GENERATE THE AVAL FLAGS

;SHARABLE DEVICE REQUEST TABLE(GENERALIZED FOR OTHER QUEUES TOO)
;CONTAINS THE NUMBER OF JOB WAITING TO USE SHARBLE DEVICE
;WSREQ AND RNREQ ARE UNUSED

DEFINE X!(A)
<↑A!REQ:	0
>


↑REQTAB:	QUEUES	;GENERATE REQ TABLE

;WORDS USED TO "REMEMBER" JOB NUMBERS
;BITS 35--9 CORRESPOND TO JOB NO'S 1--27


↑QJOB:	BLOCK JOBN	;Q TRANSFERS AT OTHER THAN CLOCK LEVEL
IFN FTSWAP,<
↑XJOB:	BLOCK JOBN	;CORE EXPANSION BY SWAPOUT-IN
>

;DATA AND STORAGE AREA USED FOR SWAPPING.  ON THE LIBRASCOPE
;   DISK, BANDS 1-15 ARE USED FOR SWAPPING, EACH BAND
;   CONTAINING 76K WORDS.

↑SQREQ:	0			;C(LH)=NEG. OF SIZE OF READ/WRITE
				;C(RH)=LOC. OF FIRST WORD TO READ/WRITE
↑SERA:	0			;SIGN IS 1 IF A READ
				;C(RH)=BLOCK NUMBER BEFORE READING,
				;    ERROR BITS AFTER READING.
↑SWPCNT:	0		;SWAPPER COUNTER.  WHEN LEQ 0, RESET TO
				;INITIAL VALUE AND RUN SWAPPER.
↑SERACT:	0			;COUNTER FOR ERRORS
↑CORMX:		0			; MAXIMUM CORE AVAILABLE TO LOSERS
↑ISONE:		0			; BOOLEAN SAYING THERE IS A JOB WHICH CAN FIT IN WITH THIS UPPER

XP CONVMD,3
	;CONVERSION FROM 1K CORE BLOCKS TO DISK BLOCKS
	;(SHIFT COUNT)
BEND SCHDAT

SUBTTL	DATA AREA FOR CORE MANAGEMENT SYSTEM
;	 - JAM 8-24-69		- REG 2-24-72

RMEMSI:
	0		;FIRST PHYSICAL NXM ADDRESS
MEMSIZ:
	0		;LOGICAL NXM FOR SYSTEM = FREE STORAGE LOCATION
CORCSC:
	BLOCK	PSYNCN	;P2 CAN PLAY WITH CORE CELLS!
CORBEG←←.		;HERE TO COREND ZEROED BY CORINI
FSBPT:
	0		;BYTE POINTER TO 2ND BYTE IN CORTAB
CORBLK←←=256		;THE MAXIMUM NUMBER OF K WE MIGHT HAVE
CORTAB:
	BLOCK 101	;9 BITS PER K OF MEMORY
CORLST:
	0		;BYTE POINTER TO 2 ND BIT OF NXM IN CORTAB
CORTAL:
	0		;THE NUMBER OF 1K HOLES IN CORE
IFN FTSWAP,<
CORMAX:
	0		;LARGEST POSSIBLE JOBREL
>
SHFWAT:
	0		;# OF JOB WAITING TO BE SHUFFLED
HOLEF:
	0		;ADDRESS OF 1ST HOLE IN CORE
CORE2P:
	0		;POINTER TO LAST BYTE OF SYSTEM IN CORTAB
COREND←←.-1		;END OF AREA ZEROED BY CORINI
↓%SWPL←←=196*2000	;SWAPPING LIMIT - MAX JOB SIZE
SWAPLI:
	%SWPL		;CORE CELL WITH SWAPPING LIMIT SET.
↓JBTPLN←←136		;SIZE OF JOB PDL HELD IN FREE STORAGE.
			;SOME OF THE JOBPDL IS RESERVED FOR JOBDATA AREA

LOCKNO:
	0		;JOB NUMBER OF USER OF THE LOCK UUO.
LOKPOS:
	0		;PROT,,REL WE DESIRE FOR JOB IN LOCKNO.
LOKTOP:
	0		;BOTTOM OF USER CORE.

SUBTTL	FREE STORAGE PARAMETERS
IFN FTSWAP,<FSNINIT←←1;>;;else;;FSNINIT←←5	;NUMBER OF K TO CLAIM INITIALY
TSHF←←3			;COARSENESS OF FREE STORAGE (EXPONENT OF 2)
↓TRIVIAL←←1⊗TSHF	;SIZE OF MINIMUM BLOCK
NFSB←←20		;NUMBER OF DISTINGUISHABLE BLOCK SIZES
FSBEG←←.		;ADDRESS TO ZERO AT FSINI
FSCSC:
	BLOCK	PSYNCN	;SYNCHRONIZATION CELLS FOR FS
FSCNT:
	0		;COUNT OF PEOPLE WAITING FOR F.S.
FSLIST:
	BLOCK	JOBN	;AND THEIR JOB NUMBERS
JBTPDL:
	BLOCK	JOBN	;PDL POINTER FOR UUO PDL FOR EACH JOB
FSCLKF:
	0		;FLAG TO THE SWAPPER THAT FS IS EXPANDING
FSGVKF:
	0		;FLAG TO SAY LOOK FOR A K TO GIVE BACK
FSRTL:
	0		;LIST OF BLOCKS TO BE RETURNED
FSNEWK:
	0		;SET TO -1 WHEN MERGING IN A NEW 1K CHUNK
FSCKCT:
	0		;COUNT TICKS UNTIL COMPUTING CHECKERBOARDING
FSBUSY:
	0		;AMOUNT OF FS THAT'S IN USE RIGHT NOW.
FSAVB:
	BLOCK	2*NFSB	;BASES FOR LISTS OF FREE BLOCKS
FSRPQ:
	BLOCK	NFSB	;COUNT OF FS REQUESTS BY SIZE
FSBLUZ:
0		;COUNT NUMBER OF TIME FSBUSY IS FUCKED UP.
FSNCLK:
	0		;SET WHEN YOU NEED FSCLK CALLED.
			;OR OF FSRTL,FSCLKF, AND FSGVKF
FSIPTR:
	FSLIST		;POINTER TO ADD JOBS TO FSLIST
FSOPTR:
	FSLIST		;POINTER TO TAKE JOBS FROM FSLIST
FSHUNG:
	0		;SET TO -1 TO INDICATE A DISASTER.
FSGTUF:
	0		;FLAG FOR SPECIAL FSGET
SPFSNT:
	0		;TOTAL # SPARES NEEDED
FSEND←←.-1		;END OF BLOCK ZEROED BY FSINI

;SPARE LIST CONTROL BLOCKS
;FORMAT OF SPARE LIST HEADER

		;WD0 LIST HEADER
SFSIZE←←1	;B0 AVOID REG FS, 1-8 # TO KEEP, RH SIZE
SFLINK←←2	;HEADER LINK (BOTH WAYS)
SPFSN←←3	;# SPARES CURRENTLY NEEDED
SFLOSS←←4	;LH TYPE (TEXT) RH LOSS COUNT

SFNWT←←200000	;PREVENTS WAITING AT UUO LEVEL

NSPLN←←3	;# SPARES OF STUFF ALLOC PER LINE

SFHEAD:
	DPYFS,,DDFS	;THE HEADER HEADER

DDFS:
	0		;DD Q BLOCKS
	400000+NDDSPQ⊗9,,QLENGT
	TTYFS
	0
	[ASCIZ /DATA DISK QUEUE/],,

TTYFS:
	0		;TTY DDBS
	NSPLN⊗9,,SCNDDS+DDBSKW+1
	DDFS,,DHFS
	0
	0

DHFS:
	0		;DPY HEADERS
	NSPLN⊗9,,DPYLEN
	TTYFS,,LPFS
	0
	0

LPFS:
	0		;LINE PNTR TABLES
	NSPLN⊗9,,=80
	DHFS,,PPFS
	0
	0

PPFS:
	0		;PAGE PRINTER INITIAL BLOCKS
	NSPLN*2⊗9,,BLKSIZ	;2 OF THESE PER PP
	LPFS,,DPYFS
	0
	0

DPYFS:
	0		;RANDOM DPYSER DATA
	BLKSIZ
	PPFS,,
	0
	0

BEGIN TVDDB -- TV CAMERA DEVICE DATA BLOCK
SUBTTL TVDDB - J. SAUTER, STANFOR, 25-FEB-68, TV CAMERA DEVICE DATA BLOCK



	REPEAT DDBSKW-1,<0>	; EXTRA STANDARD DDB WORDS
	DEVLUP,,0
↑TVDDB:	SIXBIT /TV/
	XWD =2*HUNGST,0
	0		;TVIOS, NOT USED.
IFE ELFNUM <XWD	DTCDDB,TVDSP>
IFN ELFNUM <XWD ELFDDB,TVDSP>
	XWD DVTV!DVIN!DVLNG,100000
	0
	0
	XWD PROG,0
	XWD PROG,0
	0
	0
	0		;DEVACC
	0		;DEVCNT
	0		;DEVBLK
	0		;DEVBKO
	0		;DSKBUF
	0		;DSKCNT
	0		;SETCNT


BEND TVDDB

IFN ELFNUM <SUBTTL ELFDDB - PDP-11 BARE MACHINE MODE
BEGIN ELFDDB - 7 MAY 74 BO

REPEAT DDBSKW-1,<0>
		DEVIBF!DEVLUP,,0	;It sort of has an internal buffer
↑ELFDDB←.				;(at least, it doesn't set IOACT).
		SIXBIT /ELF/
		0
		0
		XWD DTCDDB,ELFDSP
		XWD DVOUT+DVIN+DVLNG,140000	;Dump mode only for now.
		0
		0
		XWD PROG,0
		XWD PROG,0
↑ELFLOC←.
		0			;ELFSER defines its variables
		0			;in terms of ELFLOC.
		0
		0

BEND ELFDDB
↓ELFDDB←ELFDDB
↓ELFLOC←ELFLOC
>;IFN ELFNUM

BEGIN ADDDB -- DEVICE DATA BLOCK FOR A/D AND D/A.
SUBTTL ADDDB - J. SAUTER, STANFORD, 25-FEB-68, AD DEVICE DATA BLOCK
	REPEAT DDBSKW-1,<0>	; EXTRA DDB WORDS
		DEVLUP,,0
↑ADDDB:		SIXBIT /AD/
		XWD =24*HUNGST,0
		0		;ADIOS
		XWD	ADCDDB,ADDSP
		XWD DVOUT+DVIN+DVLNG,140000	;FLUSH MODE 15 8/7/73
		0
		0
		XWD PROG,0
		0
↑ADLOC1:	0
↑ADLOC2:	0
↑ADLOC3:	0
↑ADLOC4:	0
↑ADBKO:		0
↑ADERR:		0
↑ADADV:		0
↑ADBLK:		0
↑ADACT:		0
↑ADBKX:	0
↑ADJSR:	0
↑ADJSRL:	0

↑AD2INT:  0
	EXCH TAC,ADBKO
	EXCH TAC,ADADV
	JUMPL TAC,CONT
	MOVE TAC,AD2INT	;MAKE IT LOOK LIKE THE INTERRUPT WENT OFF ON
	MOVEM TAC,@ADJSR		;THE NORMAL CHANNELL.
	MOVE TAC,ADBKO
	JRST ADINT
CONT:
	EXCH TAC,ADBKO
	JRST 12,@AD2INT

BEND ADDDB

BEGIN ADCDDB - NEW AD/DA CONVERTER - (JAM 2-5-74)
SUBTTL ADCDDB - DEVICE DATA BLOCK FOR NEW AD/DA CONVERTER

	REPEAT DDBSKW-1,<0>
	DEVLUP,,ADCCSC
↑ADCDDB:SIXBIT /ADC/		; ANALOG-DIGITAL. INPUT ONLY.
	77*HUNGST,,0
↑ADCIOS:0
	DACDDB,,ADCDSP
	DVIN!DVLNG,,140000
	0
	0
	0
	0
↑ADCCSC:BLOCK PSYNCN
↑ADCZB:		; BEGINNING OF BLOCK TO ZERO AT INITIALIZE TIME
↑ADCBKI:0	; CURRENT IOWD
↑ADCNBK:0	; NEXT IOWD
↑ADCRCB:0	; STARTUP IOWD FOR RECYCLE MODE
↑ADCTHR:0	; THRESHHOLD FOR RECYCLE MODE
↑ADCCNO:0	; CONO WORD TO START UP
↑ADCERA:PROG,,0	; ADDRESS OF PLACE IN USER CORE TO PUT ERROR CODES
↑ADCRUN:PROG,,0	; ADDRESS OF USER CORE WD TO 'SETOM' WHILE ADC RUNNING
↑ADCRCW:PROG,,0	; ADDRESS OF USER CORE WD TO PUT RECYCLE IOWD WHEN DONE
↑ADCP1L:0	; P1'S SYNC LOCATION
↑ADCP2L:0	; P2'S SYNC LOCATION
↑ADCSTI:0	; STRAY ADC INTERRUPTS
↑ADCWPS:0	; WORDS PER SECOND AT THIS CLOCK RATE AND PACKING
↑ADCZND:	; END OF BLOCK TO ZERO

↑ADCTAC:0	; SAVED ACCUMULATOR FOR I-LEVEL (MUSN'T ZERO THIS!)
↑ADCNOH:0	; WHEN ≠0, INHIBITS HUNG TIMEOUT


	REPEAT DDBSKW-1,<0>
	DEVLUP,,DACCSC
↑DACDDB:SIXBIT /DAC/
	77*HUNGST,,0
↑DACIOS:IO,,0
	TVDDB,,DACDSP
	DVOUT!DVLNG,,140000
	0
	0
	0
	0
↑DACCSC:BLOCK PSYNCN
↑DACZB:		; BEGINNING OF BLOCK TO ZERO AT INITIALIZE TIME
↑DACBKO:0	; CURRENT IOWD
↑DACNBK:0	; NEXT IOWD
↑DACCNO:0	; CONO WORD TO START UP
↑DACERA:PROG,,0	; ADDRESS OF USER CORE WD TO PUT ERROR CODES
↑DACRUN:PROG,,0	; ADDRESS OF USER CORE WD TO `SETOM' WHILE DAC RUNNING
↑DACP1L:0	; P1'S SYNC LOCATION
↑DACP2L:0	; P2'S SYNC LOCATION
↑DACSTI:0	; STRAY DAC INTERRUPTS
↑DACWPS:0	; WORDS PER SECOND AT THIS CLOCK RATE AND PACKING
↑DACZND:	; END OF BLOCK TO ZERO

BEND ADCDDB

BEGIN APRDAT	
	SUBTTL	APRDAT 7 NOV 68	APRSER DATA
IFN FTBAT,<
↑BATYET:	=10*JIFSEC		;START AFTER 10 SECONDS
↑BATPNT:	0			;POINTER INTO BATMAN, ROBIN AND BATFLG

;ZERO IN EITHER BATMAN OR ROBIN MEANS NO RUN!
↑BATMAN:	'[ONCE]'	;SYSTEM STARTUP HELPER
		'*SPY* '	;ACCOUNTING
		'[LIST]'	;NEW SPOOLER
		'[XSPL]'	;XGP SPOOLER
		'*-SL-*'	;SERVICE LEVEL MONITOR
		'[-NS-]'	;NEWS SERVICE (AP)
		'<RMND>'	;REMINDER FANTOM
IFN IMPSW,<	'LOGGER'	; IMP MESSAGE SWITCHER  >
IFN FTHG, <	'*-HG-*'	;STATISTIC GATHERER	>
		'PONYSY'	;PRANCING PONY BILLING SYSTEM
		0		;1 PATCH SPACE
↑BATLEN←←.-BATMAN

↑ROBIN:		'  1  2'	;SYSTEM STARTUP HELPER, (HEAVY)
		'ACTSYS'	;ADDRESS OF THIS GUY
		'SPLSYS'	;NEW SPOOLER
		'SPLSYS'	;XGP SPOOLER
		' SLSYS'	;LOC OF SL MONITOR
		' NSSYS'	;NEWS SERVICE (AP)
		'RMDSYS'	;REMINDER
IFN IMPSW,<	'NETSYS' >
IFN FTHG, <	' HGSYS'	;STATISTICS PROPRIETOR	>
		'PNYSYS'	;PRANCING PONY SYSTEM
		0		;PATCH AREA

;ALFRED, THE FAITHFUL BUTLER.
↑ALFRED:	BLOCK	BATLEN	;SPACE FOR TIME REQUESTS

;POLICE COMMISSIONER GORDON MEMORIAL TABLE (PLEASE REMOVE YOUR FEET)
;PRIVILEGES FOR PHANTOMS
↑GORDON:	PRIPRV!DEVPRV!LUPPRV,,0	;SYS STARTER CAN DO ANYTHING!
		MESPRV!LUPPRV,,0	;SPY (NEEDS MES FOR AUTOLOGOUT)
		REAPRV!MESPRV!LUPPRV,,0	;LPT SPOOLER
		REAPRV!MESPRV!LUPPRV,,0	;XGP SPOOLER
		SSLPRV!LUPPRV,,0	;SERVICE LEVEL SYSTEM
		REAPRV!LUPPRV,,0	;NEWS SERVICE (AP)
		LUPPRV,,0		;REMINDER
IFN IMPSW,<	0			;LOGGER		>
IFN FTHG, <	ACWPRV!LUPPRV,,0	;HE DIDDLES HGYET	>
		LUPPRV,,0		;PRANCING PONY SYSTEM
		0			;PATCH AREA
>;END OF FTBAT


↑ONCEI:		JSR ONCE
↑SYSTHERE:	0			;-1 => SYSTEM IS ON THE L'SCOPE DISK

↑DAMESS:	ASCIZ /-JAN-/
↑DISMON:	ASCIZ /-JAN-/		;RPH FOR DISDATE
↑MONPTR:	0
↑FIXBUF:	BLOCK FIXLEN
↑ERRYET:	-1

IFN FTSHF1K,<
↑SHFTAC:	0
↑SHFEND:	0
↑SHFJOB:	0
↑SHFBLK:	0
>

↑TIMDAT:	0		;<DATE>,,<TIME IN SECS>
↑INITIM:	0		;AS TIMDAT, TIME OF LAST RELOAD/RE-INITIALIZATION.

; BEGINNING 2-PROCESSOR SPLIT DATA AREAS

↑P1DATA:
↑SPWUUF:	0		;SET WHEN SPACEWAR IS ACTIVE
↑SPWTMO:	0		;SPACEWAR TIMEOUT COUNT
↑SPWBLO:	0		;LOCATION OF BLOWN UP SPACEWAR JOB
↑SPWXCT:	0		;CONTAINS JRST 2,@UUO0 OR SOMETHING ELSE
↑INTACT:	0
↑INTNF:		0
↑INTACS:	BLOCK 20
↑INTSAC:	BLOCK 20
↑INTDISP:	0
↑INTSP:		0
↑INTREQ:	0
↑INTQUANT:	0
↑CLKSV:		CLKSAVE
↑CLKESV:	CLKESAVE
↑...TMP:	0
↑APRTAC:	0
↑APRAC1:	0
↑APRAC2:	0
↑APRJ:		0
↑APRCN:		APRCON
↑APRIN1:	0
↑APRIN2:	0
↑APRIN3:	0
↑APRID:		P1PID
↑APRCH:		APRCHL
↑APRERR:	0		;APR ERROR BITS ON NON-EX MEM, ETC.
				;SET BY APRSER, CLEARED BY CLK ROUTINE(CLOCK)
↑APRPC:		0		;PC WHEN APR ERROR DETECTED
↑APRPLN←←140
↑APRPDL:	IOWD APRPLN,APRPD
↑APRPD:		BLOCK APRPLN
↑ERRPLN←←200
↑ERRPD:		IOWD ERRPLN,ERRPDL
↑ERRPDL:	BLOCK ERRPLN
↑DSFLAG:	0
↑JOB:		0
↑SJOB:		0
↑JOBDAT:
↑JOBADR:	0
↑LASTPR:	0
↑USRREL:	0

;LOCATIONS COPIED FROM JOB DATA AREA INTO MONITOR WHEN A JOB RUNS
;THIS PREVENTS THE USER FROM CLOBBERING THEM AND MAKES IT
;EASIER FOR THE MONITOR TO LOCATE THESE QUANTITIES WHEN IT
;NEEDS TO FOR THE CURRENT JOB
;CONTENTS ARE COPIED BACK WHEN JOB BECOMES INACTIVE(SEE CLOCK)
;COMPARE WITH JOB DATA AREA(SEE JOBDAT)

↑USRPRT:			;FIRST LOC. OF PROTECTED JOB DATA
↑USRHCU:	0		;HIGHEST USER IO CHANNEL IN USE
				;0 MEANS EITHER NONE OR CHAN. 0 IN USE
				;NEG, MEANS SAVE-GET HAS ACTIVE IO EVEN THOUGH USRJDA
				;TABLE IS OVERWRITTEN BY GET.
				;RH=ADR. OF SAVE-GET DEVICE(USED BY ANY ACT ROUT. IN
				;IN CORE SHUFFLER
				;ONLY CHAN. ASSIGNMENTS IN USE ARE COPIED INTO
				;MONITOR WHEN JOB RUNS
↑USRPC:		0		;JOB PC WHEN SCHEDULER IS CALLED
↑USRDDT:	0		;RH=STARTING ADR. OF USER DDT,LH UNUSED
↑USRJDA:	BLOCK	20	;RH=JOB DEVICE ASSIGNMENTS (DEVICE DATA BLOCK ADDRESSES)
				;LH=UUOS DONE SO FAR FOR THIS CHANNEL(SEE SYSPAR)
				;0 MEANS NO DEVICE INITIALIZED ON THIS CHANNEL
↑USRLO←←USRJDA
				; FIRST LOC CLEARED BY SETUSR ROUTINE
				;ON A CALL [SIXBIT /RESET/]
				;ALSO CLEARS USRHCU
↑USRLO1←←USRLO+1		; FIRST LOC+1
↑USRHI←←.-1			; FIRST LOC CLEARED BY SETUSR

↑CHKYET:	0
↑UUO0:		0
		JRST UUO1
↑UUO2:		0	;JSR HERE FOR OPCODES 100-127
		JRST UUO3
↑UUOLOC:	0
↑CLOCK:		POINT 36,CIPWT-1,35
↑MONSUM:	0
↑NULDAT:	BLOCK 140
↑PALIVE:	0
↑NULBAD:	0
↑CIPWT:		BLOCK 2*JOBN
↑USRSAV:	0		;TEMPORARY FOR UUO HANDLER(IMPURE ROUTINE!)
↑CLKFLG:	0		;NON-ZERO WHEN CLK INTERRUPT FORCED FOR ANY REASON
↑CLKS17:	0
↑USAVPC:	0		; SAVED PC ON ILM TRAPS
↑CLKPDL:	BLOCK CLKPLN
↑CLKCH:		CLKCHL
↑OTHERID:	0		; CONTAINS THE OTHER PROCESSOR'S IDENTIFICATION
↑TIMEFF:	0
↑TIMEF:		0		;NON-ZERO FOR CLOCK INTERRUPT ON APR
				;SET BY APRSER, TESTED AND CLEARED BY CLK ROUTINE
↑TIME:		0		; TIME OF DAY IN TICKS SINCE MIDNIGHT
↑THSDAT:	0		;TODAY'S DATE((Y-1964)*12+M-1))*31+(D-1)
↑UPTIME:	0
↑INTIME:	0
↑SCHEDF:	0		;FORCED RESCHEDULING FLAG FOR CLK ROUTINE
				;USED TO FORCE RESCHEDULING WHEN JOB IS IN EXEC MODE
↑UUOXIT:	JEN @UUO0	;UUO EXIT INST, SOMETIMES CONO PI,PIOFF (SEE USRXIT CODE)
↑UUOXI:		JEN @UUO0	;BACKUP COPY FOR RESTORING ABOVE
↑INTHLD:	0		;FLAG TO DISABLE INTNOW (SEE USRXIT)

↑PDATALEN←←.-P1DATA

↑P2DATA:
		BLOCK PDATALEN

↑P1PID←←0
↑P2PID←←PDATALEN

↑SYSBEG←←.		;HERE TO SYSEND ZEROED AT RELOAD OR INITIALIZATION
;	↑AFOOL:		0	;PART OF APRIL 1 HACK
↑UUO.SA:	BLOCK 20	;HACK TO SAVE AC'S AT THE VERY LAST UUO.
↑...TAC:	0
↑LASTDI:	0	;LAST DISASTER TIME
↑LASTRE:	0	;LAST RESTART TIME
↑SHFWRD:	0	;TOTAL COUNT OF WORDS SHUFFLED BY SYSTEM
↑COMCNT:	0	;# OF COMMANDS TYPED-IN BUT NOT DECODED.
			;SET BY SCNSER, DECREMENTED BY COMCON
↑HNGTIM:	0	;HUNG DEVICE TIME COUNT CHECK FOR HUNG IO
			;DEVICES WHEN THIS GOES TO ZERO (ONCE A SECOND)
↑STUSER:	0	;JOB CURRENTLY USING THE SYSTEM TAPE
			;NEEDED SO CONTROL C WILL NOT TIE UP SYSTEM TAPE
↑ASSLGN:	0	;TEMP FOR ASSIGN COMMAND FOR LOGICAL NAME
↑ASSJBN:	0	;TEMP FOR ASSIGN COMMAND FOR JOB # OF PART MATCH DDB

↑APRLST:	0		; CLOCK INTERRUPT LIST
↑ESTINT:	0		; -1 → GOT INTO CH7 FROM ESTOP WITH INTACT SET
↑JBTSTS:	BLOCK	JOBN	;JOB STATUS BITS
REPEAT 0,<
↑JB2STS:	BLOCK	JOBN	;TWO PROCESSOR INTERLOCKED STATUS BITS
↑JBTOWN:	BLOCK	JOBN	; WHAT PROCESSOR OWNS WHICH JOB
↑JBTCSC:	BLOCK	PSYNCN
>
↑PDLCSC:	BLOCK	PSYNCN	; PDL SETUP INTERLOCK
↑JBTDVW:	BLOCK	JOBN	; DDB ADDRESS OF DEVICE THIS JOB WAITS FOR
↑JBTGSL:	BLOCK	JOBN	; JOB'S GUARANTEED SERVICE LEVEL
↑NJOBS:		BLOCK	JOBN	; NUMBER OF JOBS POINTING TO THIS SEGMENT
↑CJOBS:		BLOCK	JOBN	; COUNT DOWN TABLE FOR SCHEDU
↑UUOPC:		BLOCK	JOBN	; THIS IS WHERE THE UUO-LEVEL PC IS STORED
↑UUOOPC:	BLOCK	JOBN	; THIS IS WHERE THE UUO PC ONE BACK IS SAVED
↑JBTUPC:	BLOCK	JOBN	; SAVE UUO-LEVEL PC HERE FOR DEBREAK
↑JBTADR:
↑JBTDAT:	BLOCK	JOBN
↑JBTPR2:	BLOCK	JOBN	;PEEK-POKE TABLE
↑JBTLIN:	BLOCK	JOBN	;TTY LINE NO. OF JOB. (=-1 IF DETACHED.)
IFN FTLOGIN,<
↑JBTPRV:	BLOCK	JOBN	;JOB ACTIVE PRIVELEGE BITS
↑JB2PRV:	BLOCK	JOBN	;JOB PASSIVE PRIVELEGE BITS
↑JBTTPV:	BLOCK	JOBN	;JOB TEMPORARY PRIVILEGE BITS
↑PRJPRG:	BLOCK	JOBN	;PROJECT PROGRAMMER NAME OF JOB OWNER
IFN FTDSKPPN,<
↑DSKPPN:	BLOCK	JOBN	;DISK ALIAS PPN
>;FTDSKPPN
↑SLRMAX←←20			;MAXIMUM NUMBER OF SL RESERVATIONS
↑SLCOST:	0		;=0,1,2 DEPENDS ON TIME OF DAY,TIME OF WEEK
↑SLNRES:	0		;NUMBER OF SL RESERVATIONS
↑SLRES:		BLOCK	SLRMAX	;TABLE OF SL RESERVATIONS
>
↑JOBNAM:	BLOCK	JOBN	;NAME OF CURRENT PROGRAM (FOR WHO)
↑JBTKCJ:	BLOCK	JOBN	;KILO CORE JIFFIES USED BY THIS JOB
↑JBTBTM:	BLOCK	JOBN	;LOGIN TIME FOR A JOB
↑JOBPPN:	BLOCK	JOBN	; DIRECTORY CURRENT PGM CALLED FROM
↑JOBCRD:	BLOCK	JOBN	;PROGRAM'S CREATION DATE (FROM FILE RETRIEVAL)
IFN FTDISK,<
↑JBTUFD:	BLOCK	JOBN	;LOGICAL ADDR OF USER'S UFD.
↑CUSLOC:	0		;SAME OF [1,3] UFD.
>
↑JOBDEV:	BLOCK	JOBN	; DEVICE THAT JOB WAS CALLED IN FROM
↑JOBLOG:	BLOCK	JOBN	; LOGICAL DEVICE NAME
↑RTIME:		BLOCK	JOBN	; RUN TIME AT LAST "TIME" COMMAND
↑TTIME:		BLOCK	JOBN	;TOTAL RUN TIME
↑FTIME:		BLOCK	JOBN	;<DATE>,,<TIME IN SECS> WHEN JOB LAST RUN
↑XTIME:		BLOCK	JOBN	;RUN TIME WHEN LAST ACTIVATED OUT OF TTY INPUT WAIT
↑JBTWAT:	BLOCK	JOBN	; TIME WAITING FOR SYSTEM (NOT IN IOWQ OR STOPQ)
↑JB2WAT:	BLOCK	JOBN	; RECENTLY SAVED VALUE OF JBTWAT (FOR WHO LINE)
↑JBTRNB:	BLOCK	JOBN	;CPU TIME USED SINCE JOB'S LAST PRIORITY CALCULATION
IFN FTSWAP,<
↑STIME:		BLOCK	JOBN	; SET TO -1 WHEN CORE IMAGE IS MODIFIED
>
GLOBAL TTPLEN
IFN FTTTYBUG,<	↑TTCBCK:	BLOCK	3	>;TEMP FOR COMCNT BUG TRAP
↑ASTAB:		BLOCK	DDNUM+DPYNUM	;MAPPING TABLE FOR AUDIO SWITCH
↑ASBTAB:	BLOCK	DDNUM+DPYNUM	;BEEP DURATION
↑PAGNOW:	0		;-1 => PAGING NOW
↑TTYTAB:	BLOCK	TTPLEN
↑TPYTAB:	BLOCK	PTYNUM
↑PTYTAB:	BLOCK	PTYNUM
↑CRKYET:	0
↑RSTBEG←←.			;THIS AREA CLEARED ON RESTARTS
IFN FTDISK,<
↑JBTIOP:	BLOCK	JOBN	;IO PUSH/POP POINTERS
>
↑JBTSIN:	BLOCK	JOBN	;SWAPIN LIST FOR COMMAND DECODER, INTS, ETC.
↑SAVSAI:	BLOCK	JOBN
↑JBTDTS:	BLOCK	JOBN	; LIST OF SEGMENTS THIS JOB HAS DETACHED
↑JBTGLU:	BLOCK	JOBN	;NON-ZERO GLUES JOB IN PLACE IN CORE.
↑JBTFS:		BLOCK	JOBN	; TEMPORARY FREE STORAGE
↑JBTMAIL:	BLOCK	JOBN	;PTR. TO LETTER ADDRESSED TO JOB.
↑JBTTCR:	BLOCK JOBN	;PNTR TO TMPCOR FILES
↑JBTMSK:	BLOCK	JOBN	;NEW STYLE INTERRUPT SYSTEM MASKS
↑JBTIEN:	BLOCK	JOBN	; INTERRUPT ENABLINGS
↑JBTIRQ:	BLOCK	JOBN	; REQUESTS PENDING
↑JBTWKM:	BLOCK	JOBN	; TELLS WHICH BITS CAUSE WAKEUP
↑JBTIIP:	BLOCK	JOBN	; INTERRUPT IN PROGRESS
↑INTDTM:	BLOCK	JOBN	; DATUM OF INTERUPT
↑UUOPTR:	BLOCK JOBN	;PNTR TO UUO SIMULATOR TABLE
↑RSTEND←←.			;END OF AREA CLEARED ON RESTARTS
IFN FTSTAT, <
↑STATS:		BLOCK	STATLEN	; STATISTICS GATHERING SERVICE
↑STATNUM:	0		; NUMBER OF TIMES WE'VE WRAPPED AROUND
>
↑JOBNM1:	0		; MAXIMUM JOB NUMBER

; WHO LINE DATA STORAGE

↑LASTUP:	0		; NEGATIVE UPTIME WHEN SYSTEM WHO LINE LAST DONE
↑LASTNL:	0		; RECENT VALUE OF NEGATIVE RUN TIME FOR NULL JOB
↑JBSRUN:	BLOCK	2	; BITS FOR JOBS THAT HAVE BEEN RUN LATELY
↑WHONXT:	0		; NUMBER OF THE III WHOSE WHO LINE WAS DONE LAST
↑WHDDNX:	0		; NUMBER OF NEXT DATA DISK CHANNEL TO GET WHO LINE
↑WHOPTR:	0		; POINTER TO THE DD THAT WAS DONE LAST (SEE DPYSER&WHOQUE)
↑WHODAT:	0		; DATE ON CURRENT WHO LINE
↑FREWAT:	0		; FREE STORAGE RELEASE WAIT LIST
↑FRETAB:	BLOCK DPYNUM+DDNUM ; FREE STORAGE POINTER FOR EACH WHO LINE
↑T15CNT:	0		;COUNT FOR 1/4 TH SECOND CLOCK
↑DKBCNT:	0		;WHEN THIS GOES NEGATIVE, DKB HARDWARE
				;  IS CHECKED (CODE IS IN CLKSER).
↑NDDXOL:	0		;OLD VALUE OF NDDXCT
↑NDDLOL:	0		;OLD VALUE OF NDDLCT
↑NDSTAT:	0		;COUNTS DOWN TO RUN FROB IN 5 SECONDS.
↑SYSEND←←.
IFN FTSTAT,<
↑STATPTR:	POINT 18,STATS	; BYTE POINTER TO STATISTICS TABLE
>
↑AUTOSYNC:	0
↑SYSTOP:	0		;FIRST LOCATION USED BY USER PROGRAMS.

;;ADDRESS BREAK CRAP . . .
↑BRKMAX←←20			; MAXIMUM NUMBER OF LEGAL PCS
↑BRKTAC:	0
↑BRKAC1:	0
↑BRKNUM:	0		; CURRENT NUMBER OF LEGAL PCS
↑BRKTAB:	BLOCK BRKMAX	; PUT GOOD PCS HERE

; DISASTER MESSAGE BUFFERS AND STUFF

↑DISLEN←←400
↑DISBUF:	BLOCK	DISLEN
↑DISPTR:	POINT	7,DISBUF
↑DISOPT:	POINT	7,DISBUF
↑DISFLAG:	0
↑DISCTR:	5*DISLEN

; ACCUMULATOR SAVE ROUTINE FOR CLKING

↑CLKSAVE:
	0
	SKIPN 17,JOBDAT+P1PID	; CURRENT JOB DATA AREA
	MOVEI 17,NULDAT+P1PID	; NO, USE NULL JOB'S
	MOVEM 16,JOBD16(17)
	MOVEI 16,JOBDAC(17)
	BLT 16,JOBD15(17)
	MOVE TAC,CLKS17
	MOVEM TAC,JOBD17(17)
	MOVE PID,[P1PID]
	JRST @CLKSAVE

↑CL2SAVE:
	0
	SKIPN 17,JOBDAT+P2PID	; CURRENT JOB DATA AREA
	MOVEI 17,NULDAT+P2PID	; NO, USE NULL JOB'S
	MOVEM 16,JOBD16(17)
	MOVEI 16,JOBDAC(17)
	BLT 16,JOBD15(17)
	MOVE TAC,CLKS17
	MOVEM TAC,JOBD17(17)
	MOVE PID,[P2PID]
	JRST @CL2SAVE

↑CLKESAVE:
	0
	HRRZ 17,JOBADR+P1PID
	ADDI 17,JOBDAC
	MOVEM 16,16(17)
	HRRZI 16,15(17)
	BLT 17,(16)
	MOVE PID,[P1PID]
	JRST CLKES1

↑CL2ESAVE:
	0
	HRRZ 17,JOBADR+P2PID
	ADDI 17,JOBDAC
	MOVEM 16,16(17)
	HRRZI 16,15(17)
	BLT 17,(16)
	MOVE PID,[P2PID]
CLKES1:
	MOVE TAC,CLKS17(PID)
	MOVE PROG,JOBDAT(PID)
	MOVEM TAC,JOBD17(PROG)
	MOVE J,JOB(PID)
	SKIPN TAC,USAVPC(PID)
	MOVE TAC,@CLKCH(PID)
	SETZM USAVPC(PID)
	TLNN TAC,USRMOD		; IS PC IN EXEC?
	JRST CLKES2		; YES, CAN'T SAVE HIS PC.
	MOVEM TAC,JOBPC(PROG)
	CAMN J,SJOB(PID)
	MOVEM TAC,USRPC(PID)
CLKES2:
	MOVE P,INTSP
	MOVE TAC,@CLKESV(PID)
	JRST @TAC


BEND APRDAT

;	DATA AREA FOR PARITY SERVICE
PARBLK:
	0			;SET BY CORE ROUTINES - OLD LOC OF SHUFFLED JOB
PARSJB:
	0			;SAVE JOB NUMBER OF JOB BEING SHUFFLED.
PARSJN:
	0			;FLAG WITH JOB NUMBER OF SHUFFLED JOB.
PARFLG:
	0			;SET BY P2 WHEN IT HAS ERROR
P2RFLG:
	0			;SET BY P1 WHEN IT SEES PARFLG
P2SA:
	0			;PLACE FOR P2RINT TO SAVE AN AC
ERRLOC:
	-1			;IF > 0 THEN LAST LOC SEEN WITH BAD PARITY
RERLOC:
	0			;RELATIVE ERROR LOCATION.
PARPSA:
	0			;SAVE P HERE WHILE WE USE APRPDL
ERRPC:
	-1			;PC AT TIME OF ERROR

SYSERR:
	0			;LEFT SIDE = -1 WHEN PARITY ERROR IS FOUND
				;IN THE SYSTEM (OR INDETERMINATE)
				;RIGHT SIDE = APR CONI BITS TO PRESERVE 
				;STATE OF SYS WR REF KLUGE.

LASLOS:
	0			;SET TO JOB NUMBER OF LAST JOB THAT LOST
ERRJOB:
	BLOCK	2		;BIT TABLE OF JOBS THAT HAVE LOST DURING
				;THIS PASS THROUGH CORE.


; STATISTICS COUNTERS
;  CAUTION:  THE RELATIVE ORDER OF THESE COUNTERS SHOULD NOT BE CHANGED,
;    BECAUSE THE PROGRAM MONUSE THINKS IT KNOWS WHERE THINGS ARE

IFN FTHG, <	XWD HGXMAX,HGNMAX;STBEG-2 CONTAINS # OF EACH KIND OF HG CNTR
		HGCNTS	;LOCATION STBEG-1 POINTS TO HISTOGRAM COUNTERS!  >
STBEG←←.
NCORCALLS:
	0	; NUMBER OF CALLS ON THE CORE ROUTINES
NFSGETS:
	0	; NUMBER OF TIMES FREE STORAGE IS GOTTEN
NFSGIVES:
	0	; NUMBER OF TIMES FREE STORAGE IS RELEASED
NCOMS:
		0	; NUMBER OF COMMANDS THAT HAVE BEEN DISPATCHED TO
NDLYCMS:
	0	; NUMBER OF COMMANDS THAT HAVE BEEN DELAYED
NUUOS:
		0	; NUMBER OF UUOS
NSCHEDS:
	0	; NUMBER OF TIMES WE HAVE ENTERED THE JOB SCHEDULING LOOP
NQXFERS:
	0	; NUMBER OF QUEUE TRANSFERS
NOUTSWPS:
	0	; NUMBER OF SWAPOUTS - 10
NINSWPS:
	0	; NUMBER OF SWAPINS
NDDQUE:
		0	; NUMBER OF TASKS CREATED FOR THE DATA DISC QUEUE
NNUUOS:
		0	; NUMBER OF NEW UUO DISPATCHES
NFSWAITS:
	0	; NUMBER OF TIMES WE HAD TO WAIT FOR FREE STORAGE
NFSLP1:
		0	; NUMBER OF LOOPS (TYPE 1) IN FSGET
NNULLJS:
	0	; NUMBER OF SCHEDULINGS THAT CHOSE THE NULL JOB
NJSWITCHES:
	0	; NUMBER OF TIMES JOBS WERE SWITCHED
NWSCHEDS:
	0	; NUMBER OF TIMES JOBS TURN THEMSELVES OFF - 20
NTMOS:
		0	; NUMBER OF TIMES JOBS GET TIMED OUT
NJRNULLS:
	0	; NUMBER OF TIMES A JOB IS RUNNABLE WHILE THE NULL JOB IS RUNNING
NPWAITS:
	0	; NUMBER OF FAILURES IN SYNCHRONIZATION
NLERRS:
		0	; NUMBER OF TIMES THROUGH FININ1 WITH ERRORS
NSAERR:
		0	; NUMBER OF TIMES THROUGH FININ1 WITH SUCCESS AFTER ERROR RETRIES
NLREQS:
		0	; NUMBER OF TRANSFERS
NLRERS:
		0	; NUMBER OF TRANSFERS PLUS NUMBER OF ERROR RETRIES
NFSGFA:
		0	;NUMBER OF FAILURES FROM FSGET - 30
NABFE:
		0	; NUMBER OF TIMES WE ADVANCED AN OUTPUT BUFFER
NABFF:
		0	; NUMBER OF TIMES WE ADVANCED AN INPUT BUFFER
NFSLP2:
		0	;NUMBER OF LOOPS (TYPE 2) IN FSGET
NPUSHD:
		0	;MAXIMUM PUSH DOWN DEPTH USED IN A UUO PDL.
NDDFRM:
		0	; NUMBER OF FRAMES CREATED FOR THE DATA DISC QUEUE
NDDLCT:
		0	;-(NUMBER OF LINES SENT TO DD)
NDDLMX:
		0	;MAX COUNT FOR 5 SECONDS
NDDXCT:
		0	;NUMBER OF ENTRIES MADE TO DD QUEUE.-40
NDDXMX:
		0	;MAX COUNT FOR 5 SECONDS
NDDL1C:
		0	;COUNT OF 1 AND 2 LINE TRANSFERS TO DD.
↑NIOTS:		0	;HOW MANY NEW UUOS (700-777) HAVE BEEN CALLED
↑NSCALL:	0	;HOW MANY STANFORD CALLIS HAVE BEEN CALLED
STEND2 ←← .-1		;END OF STATISTICS SECTION (FOR *SPY*)
IFN FTHG, <
HGNMAX ←← 40		;NUMBER OF HISTOGRAM COUNTERS
HGXMAX ←← 1		;NUMBER OF "EXTRA" COUNTERS
HGSET:
		0	;RESET VALUE FOR HGYET
HGYET:
		0
HGCNTS:
	BLOCK	HGNMAX	;HISTOGRAM COUNTERS - INCREMENTED IN HG ROUTINE
	BLOCK	HGXMAX	;EXTRA COUNTERS - NOT INCREMENTED IN HG ROUTINE
HGCH2 ← .-1		;CH2 (DISK XFER) ACTIVE TIME (AN "EXTRA" COUNTER)
HGCH6:
		0	;NUMBER OF TIMES CH5 ENTERED WITH CH6 ACTIVE
			;IF HGCH6 ISN'T INCREMENTED, THEN ONE OF NEXT 4 IS:
HGSYS:
		0	;# OF OCCURRENCES OF ¬(USRMOD) ∧  (CH7 ACTIVE)
HGUSR:
		0	;# OF OCCURRENCES OF  (USRMOD) ∧ ¬(CH7 ACTIVE)
HGUUO:
		0	;# OF OCCURRENCES OF ¬(USRMOD) ∧ ¬(CH7 ACTIVE)
HGSPW:
		0	;# OF OCCURRENCES OF  (USRMOD) ∧  (CH7 ACTIVE)
HGNULL:
		0	;NUMBER OF TIMES NULL JOB RUNNING ∧ ∃ JOB WAITING
HGIDLE:
		0	;NUMBER OF TIMES NULL JOB RUNNING W/ EMPTY RUNQ
HGCODE:
		0	;VARIOUS CLKINT SUBROUTINES SET THIS VARIOUSLY
	>
STEND←←.-1		;END OF STATISTICS SECTION
;: ALLDAT[J17,SYS] EOF.
;: IMPDDB[J17,SYS]
COMMENT ⊗   VALID 00007 PAGES 
RECORD PAGE   DESCRIPTION
 00001 00001
 00002 00002	SUBTTL DATA AREA FOR INTERMINABLE MESSAGE PROTESTOR - JAM SEPT, '71
 00003 00003	 MODEL DEVICE DATA BLOCK FOR IMP CONNECTIONS
 00005 00004	 OUTPUT ROUTINE STORAGE
 00008 00005	 STORAGE FOR CLOCK LEVEL WAIT ROUTINE
 00010 00006	 HOST AND LINK TABLES
 00012 00007	 THE FOLLOWING ARE COUNTERS OF THE NUMBER OF TIMES VARIOUS EVENTS HAVE HAPPENED
 00016 ENDMK
⊗;

SUBTTL DATA AREA FOR INTERMINABLE MESSAGE PROTESTOR - JAM SEPT, '71

; MODEL DEVICE DATA BLOCK FOR IMP CONNECTIONS

DEFINE Z(NAME,VAL) <NAME←←.-DDBMDL 
 VAL>

	DEVSHR,,0		; DEVCMR
DDBMDL:
	SIXBIT /IMP/
	TDLEN+1			; DEVCHR, BUFFER SIZE
	0			; DEVIOS
	LPTDDB,,IMPDSP		; DEVSER, UUO DISPATCH TABLE ADDRESS
	DVIMP!DVLNG!DVIN!DVOUT,,154403
	0			; DEVLOG
	0			; DEVBUF
	0			; DEVIAD
	0			; DEVOAD
	0			; DEVFIL
	0			; DEVEXT
	Z(INL,0)		; INPUT LIST
	Z(MAL,0)		; MESSAGE ALLOCATION
	Z(BAL,0)		; BIT ALLOCATION
	Z(NHMA,0)		; NOMINAL MESSAGE ALLOCATION
	Z(NHBA,0)		; NOMINAL BIT ALLOCATION
	Z(NHMA2,0)		; 1/2 OF THE NOMINAL MESSAGE ALLOCATION
	Z(NHBA2,0)		; 1/2 OF THE NOMINAL BIT ALLOCATION
	Z(HMA,0)		; HIS MESSAGE ALLOCATION
	Z(HBA,0)		; HIS BIT ALLOCATION
	Z(MIIL,0)		; NUMBER OF MESSAGES IN INPUT LIST
	Z(BIIL,0)		; NUMBER OF BITS IN INPUT LIST
	Z(TIMES,<BYTE (6) 5,5,0,40,0>)
				; CLS, RFNM, ALL, RFC, INP WAIT TIMEOUTS
	Z(TIM,-1)		; TIMEOUT COUNT
IMPDLN←←.-DDBMDL+1

IMPDIE:
		0	; SET TO NON-ZERO TO KEEP IMP SYSTEM DOWN

IMPST←←.		; NOTE IMP DATA AREA TO BE CLEARED BEGINS HERE

; OUTPUT ROUTINE STORAGE

IMPDEAD:
	0	; SET TO -1 IF IMP DECLARED DEAD
IMPOACT:
	0	; SET TO -1 IF OUTPUT IS ACTIVE
IMPOBK:
		0	; OUTPUT BLKO POINTER
IMPOCUR:
	0	; CURRENT BUFFER BEING OUTPUTTED
OLIST:
		0	; OUTPUT LIST. XWD <LAST ELEMENT>,<FIRST ELEMENT>
IMPOFC:
		0	; COUNT OF WDS TO GO IN 36B MODE
IMPOFM:
		0	; SET TO -1 FOR FULL WORD (36B) MODE
IMPOCT:
		0	; OUTPUT TIME-OUT COUNT
IMPOPD:
		0	; OUTPUT SIDE PUSHDOWN LIST
IMPOPL:
		BLOCK INTPLN

; INPUT ROUTINE STORAGE

IMPBKO:
		0	; INPUT BLKI WORD
IMPICUR:
	0	; CURRENT INPUT BUFFER
IMPITOP:
	0	; TOP OF CURRENT INPUT LIST
ILIST:
		0	; INPUT LIST, XWD <LAST ELEMENT>,<FIRST ELEMENT>
IMPIFM:
		0	; -1 FOR 36B MODE, OTHERWISE, 32B MODE
IMPHELP:
	0	; IF NO BUFFER AVAILABLE AT I-LEVEL, INPUT WORD IS PLACED HERE
IMPHLF:
		0	; FLAG THAT SAYS WE ARE WAITING FOR AN INPUT BLOCK
IMPIHD:
		0	; SET TO -1 IF WORD IN IMPHELP IS LAST WORD IN MESSAGE
IMPSPARE:
	0	; SPARE INPUT BUFFER
IMPCLN:
		0	; SET TO -1 WHEN A CLOCK REQUEST FOR A NEW SPARE IS PLANTED
IMPINW:
		0	; NUMBER OF WORDS OF REGULAR MESSAGE
IMPIMS:
		0	; MASK FOR CLEANING OUT LAST WORD OF REGULAR MESSAGE
IMPIPD:
		0	; INPUT SIDE PUSHDOWN LIST
IMPIPL:
		BLOCK INTPLN

; I-LEVEL GENERAL STORAGE
; IN IMPCHAN WE HAVE . . .
;	CONSZ IMP,IDONE!IEND
;	JRST IMPINT
;	CONSZ IMP,ODONE
;	JRST IMPOUT
;	CONSZ IMP,IMPERR
;	JRST IMPERB

IMPAC1:
		0	; ACCUMULATOR STORAGE
IMPAC2:
		0
IMPAC3:
		0
IMPPID:
		P1PID
IMPIDSP:
	IBEGIN
IMPODSP:
	OBEGIN
IMPECT:
		0	; ERROR BIT COUNT DOWN

; STORAGE FOR CLOCK LEVEL WAIT ROUTINE

IMPCLW:
		0	; -1 MEANS WE ARE WAITING FOR FREE STORAGE
IMPPDP:
		0	; WHERE PUSHDOWN POINTER IS STORED WHILE WAITING
IMPFP:
		0	; THIS IS STACK AS IT LOOKS WHEN WE ENTER AT IMPCLK
IMPSAV:
		BLOCK CLKPLN
			; WHERE CLOCK LEVEL PUSHDOWN LIST IS STORED WHILE WAITING

; STORAGE FOR CLOCK COUNTING SYSTEM TIMEOUTS

TIMCNT:
		0	; COUNT DOWN FOR CHECKING TIMED WAITS
TIMWAIT:
	0	; NUMBER OF PEOPLE WAITING FOR A TIMEOUT

; STORAGE FOR FREE STORAGE MANAGER

IMPFSL:
		0	; FREE STORAGE LIST
IMPSPN:
		0	; COUNT OF NUMBER OF SPARE BLOCKS NEEDED

; STORAGE FOR POLLING ROUTINE

POLTIM←←30*JIFSEC	; 60 MINUTES BETWEEN POLLS
POLCNT:
		POLTIM

; FOR CLEANUP ROUTINE (ACTUALLY PART OF POLLING ROUTINE)

HCLSTM←←6		; 3 MINUTES BETWEEN CLEANUPS
HCLSCT:
		0	; COUNTER FOR CLEANUPS

; OTHER STORAGE . . .

RECOVER:
	0	; FLAG FOR ERROR RECOVERY SYSTEM
IMPPMS:
		0	; SET ≠ 0 TO PRINT ALL ERROR MESSAGES
RSTHST:
		377	; HOST TO BE RESET NEXT

NOPCNT:
		4	;COUNT OF NOPS YET TO BE SENT TO IMP TO INITIALIZE

; HOST AND LINK TABLES

; STORAGE FOR ROUTINE THAT ASSIGNS NEW AND UNIQUE LINKS

LSTLNK:
		0	; LAST LINK NUMBER ASSIGNED

; HOST TABLES AND LINK TABLE

L0WAIT:
	0		; COUNT OF NUMBER OF JOBS IN IO WAIT FOR LINK 0 TO BECOME UNBLOCKED
L0CWTL:
	0		; LIST OF MESSAGES INITIATED AT CLOCK LEVEL FOR LINK 0
SYSTBS←←.		; BEGINNING OF SYSTEM DATA TABLES
L0BLOK:
	BLOCK 10	; BLOCKED-LINK-0 BIT FOR EACH HOST, 32. BITS PER WORD

MAXNLK←←40		; CURRENT MAXIMUM NUMBER OF CONNECTIONS
LNKMAX:
	MAXNLK		; FOR THE SYSTEM TABLE READERS
LNKTAB:
	BLOCK MAXNLK	; BITS 28-35 ARE LINK NUMBER, 20-27 ARE HOST NUMBER
IMPDDB:
	BLOCK MAXNLK	; CONTAINS ADDRESS OF DDB ON THIS CONNECTION
IMPLS:
	BLOCK MAXNLK	; LOCAL NUMBER
IMPFS:
	BLOCK MAXNLK	; FOREIGN SOCKET
IMPBS:
	BLOCK MAXNLK	; CONNECTION BYTE SIZE
IMPSTB:
	BLOCK MAXNLK	; STATUS BIT TABLE
IMPRFQ:
	BLOCK MAXNLK	; LIST OF RFCS WAITING FOR CONNECTION ON THIS SOCKET
FFLNK:
	0		; INDEX OF FIRST FREE LINK.

; THE FOLLOWING ARE COUNTERS OF THE NUMBER OF TIMES VARIOUS EVENTS HAVE HAPPENED

FRMIMP:
	0	; NUMBER OF MESSAGES FROM IMP
FLNOPS:
	0	; NUMBER OF NO-OPS RECEIVED
TRACES:
	0	; TRACE MESSAGES
ERWOMI:
	0	; ERRORS WITHOUT MASSAGE IDENTIFICATION
NIMPDN:
	0	; NUMBER OF IMP GOING DOWN MESSAGES
NBLNKS:
	0	; BLOCKED LINK
LTFULL:
	0	; LINK TABLE FULL
ERWMI:
	0	; ERROR WITH MASSAGE IDENTIFICATION
INCMTR:
	0	; INCOMPLETE TRANSMISSION
ILLMT:
	0	; ILLEGAL MESSAGE TYPE
BDRFNM:
	0	; RFNM RECEIVED ON AN UNBLOCKED LINK
NODDBS:
	0	; NO DDB WHEN ONE WAS CALLED FOR
UNKLNK:
	0	; NUMBER OF MESSAGES TO A NON-EX LINK
NRFNL:
	0	; NUMBER OF RFNMS WITH NO LINK IN LINK TABLE
NILLOP:
	0	; ILLEGAL SECOND LEVEL PROTOCAL OP CODE
BSILL:
	0	; BYTE SIZE FOR SECOND LEVEL COMMAND ILLEGAL
BCMM:
	0	; BYTE COUNT TOO SMALL FOR SECOND LEVEL COMMAND
RERRM:
	0	; NUMBER OF ERROR MESSAGE WE HAVE RECEIVED
SPRRP:
	0	; RESET REPLY WITH NO RESET GIVEN
N2RFCS:
	0	; NUMBER OF TIMES TWO RFCS FROM THE SAME HOST WERE RECEIVED
NNOCLS:
	0	; NUMBER OF TIMES NO CLOSE WAS SENT WHEN ONE WAS RECEIVED
NILLST:
	0	; NUMBER OF TIMES THE TABLES WERE IN AN ILLEGAL STATE
NNCOR:
	0	; NUMBER OF TIMES WE DIDN'T HAVE ANY FREE STORAGE AT UUO LEVEL
NNOCLW:
	0	; NUMBER OF TIMES WE DIDN'T ACKNOWLEDGE A CLS
NOLKS:
	0	; NUMBER OF TIMES WE COULDN'T ASSIGN A LINK NUMBER
NHOST0:
	0	; NUMBER OF TIMES WE GOT A MESSAGE FOR HOST ZERO
SLNOPS:
	0	; NUMBER OF SECOND LEVEL NO-OPS RECEIVED
NHANGS:
	0	; INPUT STOPPED DUE TO LACK OF FREE STORAGE
NDPBLK:
	0	; NUMBER OF TIMES WE TRIED TO STEAL F.S. FROM DPYSER
NSPSUS:
	0	; SPARE F.S. BLOCKS WE USED
NRSETS:
	0	; NUMBER OF RESETS WE HAVE RECEIVED
NMESIN:
	0	; MESSAGES RECEIVED
NMESOU:
	0	; MESSAGES SENT
NNOLNK:
	0	; WE RAN OUT OF TABLE SPACE
NSCLSS:
	0	; NUMBER OF UNSOLICITED CLSS WE RECEIVED
NOPADB:
	0	; NO PADDING BIT FOUND
OPTMO:
	0	; NUMBER OF TIMES THE INTERFACE TIMED OUT
IERBIT:
	0	; NUMBER OF TIMES THE IMP ERROR BIT CAME UP
SLUNLK:
	0	; SECOND-LEVEL UNKNOWN LINKS.
RWNOSS:
	0	; REGULAR MESSAGE WITH NO SEND OR RECEIVE SOCKET
NIWCNO:
	0	; NUMBER OF INPUTS (REGULAR MESSAGES) WITHOUT CONNECTION OPEN
NSSC:
	0	; NUMBER OF REGULAR MESSAGES FOR CLOSED SOCKET
NALWNC:
	0	; NUMBER OF ALLOCATES FOR UNCONNECTED LINK

IMPEND←←.		; END OF AREA CLEARED AT INITIALIZE TIME
;: IMPDDB[J17,SYS] EOF.
;: LOWCOR[J17,SYS]
COMMENT ⊗   VALID 00006 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	LOWCOR 6 SEPT 67
C00005 00003	BEGIN PWAIT
C00010 00004	DEVOPR:	SIXBIT /CTY/		OPERATORS CONSOLE DEVICE = CTY.
C00013 00005	MONTH TABLE FOR DAYTIME PRINTING
C00014 00006	  HISTOGRAM STATISTIC GATHERING ROUTINE.
C00017 ENDMK
C⊗;

SUBTTL LOWCOR 6 SEPT 67

SHDACS:
	BLOCK 20	;ACS STORED HERE DURING ZSHAD

; BEGINNING OF PROTECTED PART OF MONITOR . . .
CHKBEG←←.

;; ON THIS PAGE LIE SOME VERY COMMON AND USEFUL ROUTINES . . .

TPOPJ1:
	AOS	-1(P)		;RESTORE TAC THEN SKIP RETURN
TPOPJ:
	POP	P,TAC		;RESTORE TAC
	POPJ	P,		;AND RETURN

CPOPJ2:
	AOS	(P)		;DOUBLE SKIP SUBROUTINE RETURN
CPOPJ1:
	AOSA	(P)		;SKIP SUBROUTINE RETURN
PIONJ:
	CONO	PI,PION
CPOPJ:
	POPJ	P,

FMCHK:
	PUSHJ	P,ZSHAD
	JRST	CPOPJ1		;FM ENB OK
	MOVE	TAC,[440700,,[ASCIZ/TURN ON FM ENB.  THEN CONTINUE.
/]]
	JSR	DDTTYP
	POP	P,DDTTYP
	JRST	4,@DDTTYP

ZSHAD:
	CONSO	APR,MAOFF	;ARE WE THE PDP-10?
	POPJ	P,		;NO. DO NOTHING.
	PUSH	P,140		;SAVE THE UUO LOCATIONS
	PUSH	P,141
	PUSH	P,LASTPR
	MOVEM	17,SHDACS+17	;SAVE THE REAL AC'S SO WE DON'T ZERO THEM
	MOVEI	17,SHDACS
	BLT	17,SHDACS+16
	MOVE	0,[JRST ZSHAD1]
	MOVEM	0,141		;SET TO TRAP OUR ILLEGAL INSTRUCTION
	MOVE	17,[776000,,2000]
	MOVEM	17,LASTPR
	DATAO	APR,17
	MOVSI	17,USRSHD
	BLT	17,17
	JRST	1,1		;RUN USER MODE CODE IN ACS

ZSHAD1:
	EXCH	SHDACS		;SHDACS←0 IF NO FM ENB
	MOVE	17,[SHDACS+1,,1]
	BLT	17,17
	POP	P,LASTPR
	POP	P,141
	POP	P,140
	DATAO	LASTPR
	SKIPN	SHDACS
	AOS	(P)		;SKIP RETURN IF FM ENB OFF
	POPJ	P,

USRSHD:
	-1			;GETS LOADED INTO ACS (STARTING AT ZERO)
	SETZM	-2000		;CLEAR SHADOW ZERO
	BLT	17,-2000+17	;BLT ACS INTO SHADOW MEM
	JRST 4,			;GET BACK TO EXEC MODE
	BLOCK USRSHD-.+17
	0,,-2000		;17

BEGIN PWAIT
;COMMENT ⊗
;NEW, SIMPLE-MINDED PWAIT ... ALGORITHM (?) BY D.POOLE
;REQUIRES SYNINI TO SETZM A (SETOM A FOR OLD PWAIT CODE)
;0(TAC) > 0 => P1 WANTS/HAS IT
;1(TAC) > 0 => P2 WANTS/HAS IT

↑PWAIT:	PUSH P,TAC
	XCT @-1(P)		;PICK UP ARG AFTER CALL
	JUMPN PID,P2L0
P1L0:
	AOS (TAC)
	SKIPG 1(TAC)		;SKIP IF P2 ALSO WANTS/HAS IT
	JRST PWAITX		;GOTCHA
	SOS (TAC)		;GIVE IT UP AND TRY AGAIN
	JRST P1L0

P2L0:
	AOS 1(TAC)
	SKIPG (TAC)
	JRST PWAITX
	SOS 1(TAC)
	JRST P2L0

↑XWAIT:	PUSH P,TAC
	XCT @-1(P)		;PICK UP ARG AFTER CALL
	JUMPN PID,XWAIT1
	SOSL (TAC)
	JRST PWAITX
XWAITE:
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /ππππPDP8+-2 OVER XSYNCED.  CALL FROM /
	HRRZ TAC,-21(P)		;-1 FOR PUSH P,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISCRLF
	PUSHJ P,DISMES
	ASCIZ /GET A WIZARD TO CHECK PID FOR ERROR, OR
ON PDP-10    TYPE POPJ 3,$X
ON PDP-6     PRESS CONTINUE
/
	PUSHJ P,DISFLU
	CONSO APR,MAOFF
	JRST 4,.+2
	PUSHJ P,DDTCAL
	POPACS
	JUMPN PID,[SETZM 1(TAC)
		JRST PWAITX]
	SETZM (TAC)
	JRST PWAITX

XWAIT1:
	SOSGE 1(TAC)
	JRST XWAITE
PWAITX:
	POP P,TAC
	JRST CPOPJ1
;⊗

COMMENT ⊗ THIS IS THE OLD PWAIT...NOT USED SINCE 12/3/73
;REQUIRES SYNINI TO SETOM A (SETZM A FOR NEW CODE)
;; DUAL-PROCESSOR WAIT ROUTINES . . .		JAM, 1968 (?)
;;						JHS, APR 1972
;; REFERENCES:	COMMUNICATIONS OF THE ACM, VOL. 8, NUM. 9, P 569.
;;		COMMUNICATIONS OF THE ACM, VOL. 9, NUM. 5, PP 320-22.
;;	THESE ROUTINES ARE A MODIFICATION OF THE TWO COMPUTER ALGORITHM
;; BY KNUTH ON PAGE 322 OF THE ABOVE REFERENCE.  THE FOLLOWING CORRE-
;; SPONDENCES EXIST:	0(TAC) ←→ K
;;			1(TAC) ←→ CONTROL[I]	(PROCESSOR 1)
;;			2(TAC) ←→ CONTROL[J]	(PROCESSOR 2)
;;	IN ADDITION,	3(TAC) IS USED AS A DEPTH COUNTER, SINCE A 
;; PROCESSOR IN ITS CRITICAL SECTION CAN BE INTERRUPTED BY  ITSELF AT A
;; HIGHER LEVEL AND SUCCEED IN ENTERING A HIGHER PRIORITY CRITICAL SECTION.
;;	NOTE: CARE MUST BE TAKEN ON THE STANFORD SYSTEM, WHERE P2 IS THE
;; PDP-6, WHICH DOES READ-MODIFY-WRITES TO MEMORY ON SKIP INSTRUCTIONS!

↑PWAIT:	PUSH P,TAC
	XCT @-1(P)		;PICK UP ARG AFTER CALL
	SKIPN P2NUM		;P2 IS RUNNING?
	JRST PWAIT2		;NO, DON'T BOTHER (BUT DO AOS SINCE XWAIT IGNORES P2NUM)
	JUMPN PID,P2L00
P1L0:
	SETOM 1(TAC)
P1L1:
	AOS NPWAITS
	SKIPE (TAC)
	JRST P1L2
	SKIPE 2(TAC)
	JRST P1L1
P1L2:
	MOVNS 1(TAC)
	SKIPLE 2(TAC)
	JRST P1L0
	SETOM (TAC)
PWAIT2:
	AOS 3(TAC)		;INCREMENT DEPTH COUNT
PWAITX:
	POP P,TAC
	JRST CPOPJ1

P2L00:
	PUSH P,TAC1		;  P2 CAN'T DO SKIP'S, SAVE AN ACCUMULATOR
	MOVEI TAC1,		;AND SET IT TO 0 FOR TESTS
P2L0:
	SETOM 2(TAC)
P2L1:
	CAMN TAC1,(TAC)
	JRST P2L2
	CAME TAC1,1(TAC)
	JRST P2L1
P2L2:
	MOVNS 2(TAC)
	CAMGE TAC1,1(TAC)
	JRST P2L0
	SETZM (TAC)
	POP P,TAC1		;  RESTORE P2'S EXTRA ACCUMULATOR
	JRST PWAIT2

↑XWAIT:	PUSH P,TAC
	XCT @-1(P)		;GET ARG
	SOSLE 3(TAC)		;ARE WE BACK UP TO TOP LEVEL?
	JRST PWAITX		;  NO
	JUMPN PID,XWAIT2	;ARE WE P1 OR P2?
	SETZM (TAC)		;  P1
	SETZM 1(TAC)
	JRST PWAITX

XWAIT2:
	SETOM (TAC)		;  P2
	SETZM 2(TAC)
	JRST PWAITX

⊗	END OF OLD PWAIT CODE

BEND PWAIT

DEVOPR:
	SIXBIT /CTY/		;OPERATORS CONSOLE DEVICE = CTY.
				;PUBLIC LOGICAL NAME "OPR" WILL BE THIS DEVICE
				;ALSO UNEXPLAINED MONITOR ERROR MESSAGE WILL BE TYPED
				;ON TTY OPR(FIRST TTY TYPED ON IF DEVOPR=0)
DEFINE FIGMAC!(NUM)
<ASCIZ ?Stanford NUM!.17/J 07-25-74?>
PRINTS /Did you remember to change CONFIG?
/

IFE FTDISK,<
CONFIG:
	FIGMAC (2)
SYSTAP:
	SIXBIT /DTA4/
>
IFN FTDISK,<
CONFIG:
	FIGMAC (6)
SYSTAP:
	SIXBIT /DSK/
>


;BYTE POINTERS

PUUOAC:
	POINT	4,UUO,12		;UUO AC FIELD
PIOMOD:
	POINT	4,IOS,35		;MODE BITS
PJOBN:
	POINT	6,DEVCHR(DDB),5		;DEVICE JOB ASSIGNMENT
PDVBLN:
	POINT	PUNITP,DEVCHR(DDB),35	; DEVICE BUFFER LENGTH
PUNIT:
	POINT	PUNITS,DEVCHR(DDB),35-PUNITP	;DEVICE UNIT NO.
PSEGN:
	POINT	6,JBTSTS(J),35		; NUMBER OF HIGH SEGMENT THIS JOB HAS
PDSEGN:
	POINT	6,(AC1),35		; NUMBER OF SEGMENT IN JBTDTS
PSINF0:
	POINT	6,JBTSIN,35		; HEAD OF LIST, FORWARD LINK
PSINFJ:
	POINT	6,JBTSIN(J),35		; FORWARD LINK (J)
PSINFT:
	POINT	6,JBTSIN(TAC),35	; FORWARD LINK (TAC)
PSINB0:
	POINT	6,JBTSIN,29		; HEAD OF LIST, BACKWARD LINK
PSINBJ:
	POINT	6,JBTSIN(J),29		; BACKWARD LINK (J)
PSINBT:
	POINT	6,JBTSIN(TAC),29	; BACKWARD LINK (TAC)

REPEAT 0,<
PRUNB:
	POINT	2,JB2STS(J),16		; POINTER TO PROCESSOR RUN BITS
>

PDVTIM:
	POINT	6,DEVCHR(DDB),17	;TIME IN SECONDS BEFORE DEVICE
					;IS SAID TO BE HUNG
PDVCNT:
	POINT	6,DEVCHR(DDB),11	;COUNTER DOWN EACH SECOND,
					;1 TO 0 TRANSITION MEANS HUNG DEVICE


IFN	FTSWAP,<
IMGIN:
	POINT	8,JBTSWP(J),35		;POINTER TO INCORE IMAGE (1K BLOCKS)
IMGOUT:
	POINT	8,JBTSWP(J),26		;POINTER TO OUTCORE IMAGE
IMGINT:
	POINT	8,JBTSWP(DDB),35	;POINTER TO INCORE IMAGE
>
IFN FTLOGIN,<
↓SYSPPN:	SIXBIT /  1  1/			;1,1 IS SYSPPN ;JS
↓DUMPPN:	SIXBIT /  1  2/			;1,2 IS DUMPPP  ;JS
↓CUSPPN:	SIXBIT /  1  3/			;1,3 IS CUSP AREA
HELPPP:
		SIXBIT /100100/			;100,100 IS HELPPP AND DEMOS ;JS
>

;MONTH TABLE FOR DAYTIME PRINTING

MONTAB:
	=30B5+"JAN"
	=27B5+"FEB"
	=30B5+"MAR"
	=29B5+"APR"
	=30B5+"MAY"
	=29B5+"JUN"
	=30B5+"JUL"
	=30B5+"AUG"
	=29B5+"SEP"
	=30B5+"OCT"
	=29B5+"NOV"
	=30B5+"DEC"
MIDNIT:
 =60*=60*=24*JIFSEC		;NO OF JIFFIES TILL MIDNIGHT


; THE FOLLOWING IS A LIST OF THE ASCII NAMES OF THE QUEUES
; SO SYSTAT CAN READ THEM

QNAMS:

DEFINE X!(A) {<ASCII /A!Q   />}
	QUEUES
	CODES
	PQUEUES
	ASCII /CMQ  /	; DON'T FORGET COMMAND WAIT!!

;  HISTOGRAM STATISTIC GATHERING ROUTINE.
;
;	CALL:	PUSHJ	P,HG
;		RETURN HERE ALWAYS
;
;	CURRENTLY, THIS ROUTINE IS CALLED (ONLY) BY KDBINT.
;	THUS, STATISTICS ARE GATHERED ON EVERY KEYSTROKE OF EVERY
;MICROSWITCH KEYBOARD.
;	THIS ROUTINE, ONCE EVERY HGSET TIMES IT IS CALLED, WILL
;INCREMENT ONE & ONLY ONE OF THE 5 COUNTERS: HGCH6,HGUSR,HGSPW,HGUUO,
;HGSYS.  IN ADDITION, IF HGSYS IS INCREMENTED, THEN ONE OF THE
;COUNTERS HGCNTS WILL BE INCREMENTED, AND IF HGUSR IS INCREMENTED
;AT A TIME WHEN THE NULL JOB IS RUNNING, THEN EITHER HGNULL OR HGIDLE
;DEPENDING ON THE STATE OF <TQ+RUNQ>.
;
;	THIS ROUTINE CLOBBERS ACCUMULATOR TAC, RETURNS WITH POPJ, P.
;NO OTHER ACCUMULATORS ARE USED.

IFN FTHG,<
HG:

	SOSE	HGYET		;TIME TO DO OUR THING YET?
	POPJ	P,		;NO.
	MOVE	TAC,HGSET
	MOVEM	TAC,HGYET	;RESET TIMER
	CONSZ	PI,40		;CH2 ACTIVE?
	AOS	HGCH2		;YES. COUNT IT
	CONSZ	PI,1000		;CHANNEL 6 IN PROGRESS?
	AOSA	HGCH6		;YES, INCREMENT OUR COUNTER AND RETURN
	SKIPA	TAC,CH5		;ELSE, GET PC WORD
	POPJ	P,		;RETURN FOR CH6 ACTIVE.
	SKIPE	SPWUUF
	JRST	ISHGSP		;CATCH SPCWAR UUO'S ALSO
	TLNN	TAC,USRMOD	;WE INTERRUPTED A USER?
	JRST	HG4		;NO. WE'RE IN THE SYSTEM
	CONSZ	PI,400		;USER IN CHANNEL 7?
ISHGSP:
	AOSA	HGSPW		;YES - SPACEWAR USER
	AOSA	HGUSR		;NO. PLAIN USER CODE.
	POPJ	P,
	SKIPE	JOB		;NULL JOB RUNNING?
	POPJ	P,		;NO
	SKIPGE	JBTQ-RUNQ	;IS THIS IDLE OR WASTED
	SKIPL	JBTQ-TQ
	AOSA	HGNULL		;WASTED TIME (RUNQ OR TQ NOT EMPTY)
	AOS	HGIDLE		;IDLE TIME.
	POPJ	P,

HG4:
	CONSO	PI,400		;CHANNEL 7 IN PROGRESS?
	AOSA	HGUUO		;NO WE'RE IN A UUO.
	AOSA	HGSYS		;WE INTERRUPTED CHANNEL 7.
	POPJ	P,
	HRRZ	TAC,HGCODE	;GET IDENTIFICATION CODE
	CAIL	TAC,HGNMAX	;A LEGAL CODE?
	MOVEI	TAC,0		;NO, MAKE IT THE DEFAULT CODE
	AOS	HGCNTS(TAC)	;INCREMENT APPROPRIATE HISTOGRAM COUNTER
	POPJ	P,
>
;: LOWCOR[J17,SYS] EOF.
;: PARSER[J17,SYS]
COMMENT ⊗   VALID 00005 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN PARSER 
	SUBTTL	PARSER - PARITY ERROR SERVICE ROUTINE
C00006 00003		SUBTTL	HERE WE SEARCH FOR REAL ERRORS.
C00012 00004		SUBTTL	HERE WHEN A REAL ERROR IS FOUND.
C00026 00005		SUBTTL	P2 PARITY ERROR INTERRUPT
C00031 ENDMK
C⊗;

BEGIN PARSER 
	SUBTTL	PARSER - PARITY ERROR SERVICE ROUTINE
;R. E. GORIN 7 AUG 72.  

AP2CHL←CAT(P2CH,\APRCHN)

↑PARCLK:				;CALLED BY:	SKIPE	PARFLG
					;		PUSHJ	P,PARCLK
	CONO	PI,APROFF		;TURN OFF APR TO AVOID TIMING ERRORS
	SETOM	P2RFLG			;SET SECOND LEVEL FLAG
	SETZM	PARFLG			;CLEAR PRIMARY FLAG
	JRST	PARIN0			;JOIN PARITY ERROR INTERRUPT CODE

↑PARINT:				;HERE FROM APR CHANNEL FOR P1 PARITY ERROR,
	CONO	PI,APROFF		;TURN OFF APR SO WE CAN TEST FOR BAD PARITY.
PARIN0:
	MOVEM	P,PARPSAV		;ASSUME WE HAVE NO AC'S.
	MOVE	P,APRPDL		;GET A STACK.
	PUSHACS				;SAVE ALL THE AC'S
	MOVEI	PID,P1PID		;SET PROCESSOR IDENTIFICATION
	PUSHJ	P,DISCRLF		;START STUFFING THE TYPEOUT BUFFER
	PUSHJ	P,DISDATE		;ANNOUNCE THE DATE AND TIME
	SKIPN	P2RFLG			;IS THE PDP-6 HALUCINATING AGAIN?
	JRST	PARIN1			;NO IT MUST BE P1

	PUSHJ	P,DISMES		;BLAME ON THE STONES
	ASCIZ	/πππππPDP-6 DETECTED PARITY ERROR.  PC  = /
	MOVE	TAC,AP2CHL		;GET THE PC OF PDP-6'S ERROR.
	TLNE	TAC,USRMOD		;IS THIS IN USER MODE?
	TRNN	TAC,777760		;YES. IS THIS ABOVE THE AC'S
	JRST	PARIN3			;EXEC MODE OR RUNNING IN THE AC'S
	HRRZ	TAC1,LASTPR+P2PID	;GET CURRENT RELOCATION DATA
	ANDI	TAC1,776000		;LOWER PART OF THE RELOCATION ONLY
	ADDI	TAC,(TAC1)		;ADD RELOCATION
	JRST	PARIN3			;SAVE ERROR PC AND PRINT IT.

PARIN1:
	PUSHJ	P,DISMES		;HERE FOR P1 PARITY ERROR
	ASCIZ	/πππππPARITY ERROR.  PC = /
	MOVE	TAC,APRCHL		;GET THE PC FROM 
	TLNE	TAC,USRMOD		;IS THIS IN USER MODE?
	TRNN	TAC,777760		;YES. IS THIS ABOVE THE AC'S
	JRST	PARIN3			;EXEC MODE OR RUNNING IN THE AC'S
	TRNN	TAC,400000		;POSSIBLE UPPER?
	JRST	PARIN2			;NO THIS HAS TO BE A LOWER.
	HRRZ	TAC1,APRCHL		;GET THE USER MODE PC.
	HLRZ	AC3,LASTPR+P1PID	;GET THE CURRENT PROTECTION
	TRO	AC3,1777		;TURN ON LOW ORDER BITS.
	CAIG	TAC1,(AC3)		;IS THIS PC IN THE LOWER?
	JRST	PARIN2			;YES
	CAIGE	AC3,400000		;IS THE LOWER GREATER THAN 128K (HA HA)
	MOVEI	AC3,400000		;NO. THIS IS THE NUMBER TO SUBTRACT FROM PC
	SUBI	TAC,(AC3)		;LEAVING RELATIVE PC IN UPPER
	HRRZ	AC3,LASTPR+P1PID	;GET THE RELOCATION
	LSH	AC3,=9			;SHIFT IT TO SELECT RELOC OF UPPER.
	ANDI	AC3,776000		;MASK
	TRC	AC3,400000		;UN-BUGGER IT -- RPH 2-7-73
	ADDI	TAC,(AC3)		;ADD IT TO THE PC.
	MOVEM	TAC,ERRPC		;SAVE ERROR PC.
	PUSHJ	P,DISMES
	ASCIZ	/#/			;DENOTE BY THIS A PC IN THE UPPER
	JRST	PARIN4


	SUBTTL	HERE WE SEARCH FOR REAL ERRORS.
PARIN2:
	HRRZ	TAC1,LASTPR+P1PID	;GET CURRENT RELOCATION DATA
	ANDI	TAC1,777000		;LOWER PART OF RELOCATION
	ADDI	TAC,(TAC1)		;ADD RELOCATION
PARIN3:
	MOVEM	TAC,ERRPC		;SAVE ERROR PC.
PARIN4:
	PUSHJ	P,DISOCT		;WRITE THE ERROR PC
	PUSHJ	P,DISCRLF		;AND A CRLF

	CONO	PI,@PARCON		;TURN OFF ERROR FLAG.
	SETOM	ERRLOC			;SET TO SIGNIFY NONE FOUND YET.
	SETOM	LASLOS			;JOB NUMBER OF LAST LOSER FOUND.
	SETZB	TAC1,PARSJN
	SETZM	SYSERR			;ASSUME NO ERRORS SYSTEM CORE.
	MOVE	TAC,ERRPC		;GET THE ERROR PC
	TLNE	TAC,USRMOD		;USER MODE?
	JRST	PARIN5			;YES.
	SETOM	SYSERR			;EXEC MODE. PROBABLE SYSTEM ERROR.
	ANDI	TAC,-1			;PC ONLY
	CAIE	TAC,SHFBLT		;IS THIS THE BLT IN THE SHUFFLER?
	CAIN	TAC,SHFBLT+1		;OR POSSIBLY HERE.
	MOVE	TAC1,PARSJB		;SHUFFLE OPERATION. GET THE JOB NUMBER
	MOVEM	TAC1,PARSJN		;SET FLAG IF A SHUFFLER OPERATION.

PARIN5:
	SETZM	ERRJOB			;ZERO OUR TABLE OF LOSING JOBS
	SETZM	ERRJOB+1		;

REPEAT 0,<				;12/3/73
	CONI	APR,TAC			;GET STATE OF SYS WR REF KLUGE
	HRRM	TAC,SYSERR		;SAVE IN RIGHT SIDE OF SYSERR.
	DATAO	PTR,[0]			;DISABLE SYS WR REF KLUGE.
>

	MOVE	TAC1,RMEMSIZ		;GET SIZE OF REAL MEMORY
	CAILE	TAC1,400000		;IS IT SMALL ENOUGH FOR ONE AOBJN?
	MOVEI	TAC1,400000		;NO. WE'LL DO THIS MUCH AT ONCE.
	MOVNI	TAC1,-20(TAC1)		;OFFSET TO SKIP ACS
	HRLZ	TAC1,TAC1		;SWAP COUNT
	HRRI	TAC1,20			;OFFSET PAST ACS
	MOVEI	AC3,@PARCON		;GET THE MASK FOR THE CONO
PARL0:
	MOVE	0,(TAC1)		;LOOK AT MEMORY
	CONSO	PI,(AC3)		;SKIP IF ERROR
PARL1:
	AOBJN	TAC1,PARL0		;LOOP AND COUNT
	JUMPGE	TAC1,PARL2		;JUMP IF COUNT WAS EXHAUSTED.
	CONO	PI,(AC3)		;SHUT OFF ERROR INDICATOR.
	MOVEM	0,(TAC1)		;STORE GOOD PARITY IN MEMORY
	PUSH	P,TAC1			;HAVE TO SAVE THIS FOR LATER.
	PUSHJ	P,PARERF		;PARITY ERROR FOUND
	POP	P,TAC1			;RESTORE COUNTER
	MOVEI	AC3,@PARCON		;RESTORE CONO MASK
	JRST	PARL1			;RESTORE COUNT AND REJOIN THE LOOP.

PARL2:
	MOVE	TAC1,RMEMSIZ		;GET THE SIZE OF OUR MEMORY
	CAIG	TAC1,400000		;IS IT TOO BIG TO HAVE BEEN SEARCHED?
	JRST	PARL5			;SMALL MEMORY HAS ALL BEEN SEARCHED.
	SUBI	TAC1,400000		;LEAVE US WITH COUNT OF HOW MUCH TO LOOK AT
	MOVN	TAC1,TAC1		;NEGATE
	HRLZ	TAC1,TAC1		;SWAP
	HRRI	TAC1,400000		;OFFSET TO UPPER REACHES OF MEMORY
	MOVEI	AC3,@PARCON		;GET MASK FOR CONSO/CONO
PARL3:
	MOVE	0,(TAC1)
	CONSO	PI,(AC3)		;ANY ERROR?
PARL4:
	AOBJN	TAC1,PARL3		;LOOP
	JUMPGE	TAC1,PARL5		;JUMP IF ALL DONE
	CONO	PI,(AC3)		;SHUT OFF ERROR INDICATORS
	MOVEM	0,(TAC1)		;STORE GOOD PARITY IN MEMORY.
	PUSH	P,TAC1			;SAVE COUNTER
	PUSHJ	P,PARERF		;SERVICE THIS ERROR
	POP	P,TAC1
	MOVEI	AC3,@PARCON		;RESTORE CONSO/CONO MASK
	JRST	PARL4			;AND RETURN TO LOOP

PARL5:
	SKIPL	ERRLOC			;HAS THIS BEEN SET UP?
	JRST	PARL6			;YES. WE MUST HAVE PRINTED SOMETHING
	PUSHJ	P,DISMES		;WE DIDN'T FIND ANY.
	ASCIZ	/LOCATION INDETERMINATE
/
	PUSHJ	P,ZSHAD			;ZERO SHADOW MEMORY IN CASE WE LOST THERE.
	JFCL				;SKIPS IF NO FAST ACS
	HRROS	SYSERR			;CHECK THE SYSTEM.   DEPT. OF REDUNDANCY DEPT.
PARL6:

	MOVE	TAC,SYSERR		;ERROR IN SYSTEM CORE?
REPEAT 0,<				;12/1/73
	TRNE	TAC,SWRENB		;WAS SYS WR REF KLUGE ENABLED?
	DATAO	PTR,[1]			;YES. RE-ENABLE IT
>
	JUMPGE	TAC,PARL7		;JUMP IF ERROR WAS NOT IN SYSTEM
	PUSHJ	P,SYSFIX		;JUST IN CASE WE NEED THIS
	JFCL				;NO ERROR
	JFCL				;ERROR AND DIDN'T FIX
					;ALL FIXED.
PARL7:
	PUSHJ	P,DISCRLF
	POPACS				;RESTORE ALL THE AC'S THAT WE SAVED
	MOVE	P,PARPSAV		;GET STACK BACK (OR WHATEVER WAS IN IT).
	SKIPN	P2RFLG			;WAS THIS THE PDP-6 HACKING?
	JRST	PARL9			;NO. THIS WAS THE PDP-10
	SETZM	P2RFLG			;CLEAR ERROR FLAG 
	CONO	PI,APRON		;RESTORE INTERRUPT SYSTEM
	POPJ	P,			;RETURN TO P1 CLOCK LEVEL

PARL9:
	CONO	PI,APRON		;TURN ON THE APR CHANNEL
	JEN	@APRCHL			;DISMISS THIS INTERRUPT



	SUBTTL	HERE WHEN A REAL ERROR IS FOUND.
PARERF:
	MOVE	TAC,ERRLOC		;REMEMBER OLD VALUE OF ERRLOC
	HRRZM	TAC1,ERRLOC		;SAVE PRESENT ERROR LOCATION
	JUMPGE	TAC,PARER1		;JUMP IF THIS IS NOT THE FIRST TIME HERE.
	PUSHJ	P,DISMES		;PUT OUT THE HEADING
	ASCIZ	/LOC	DATA		RELOC	NAME(J)
/
PARER1:
	HRRZ	TAC,ERRLOC		;GET LOCATION
	PUSHJ	P,DISLOC		;WRITE LOCATION
	PUSHJ	P,DISTAB		;WRITE A TAB
	HRRZ	TAC,ERRLOC		;GET LOCATION
	MOVE	TAC,(TAC)		;GET DATA
	PUSHJ	P,DISOCH		;WRITE LOSING DATA AS OCTAL HALF WORDS
	PUSHJ	P,DISTAB		;PUT NEXT THING UNDER HEADING
	HRRZ	DSER,ERRLOC		;GET THE LOCATION AGAIN (LOC = DSER)
	PUSHJ	P,CORGBP		;MAKE A BYTE POINTER TO CORTAB
	ILDB	J,TAC			;LOAD JOB NUMBER INTO J
	CAIGE	J,JOBN			;IS THIS A SPECIAL CODE?
	JUMPG	J,PARER4		;JUMP IF CORE IS ASSIGNED TO NORMAL JOB
	SKIPE	PARSJN			;ARE WE IN A SHUFFLE?
	JUMPE	J,PARR4B		;YES.  JUMP IF ALLEGED UNASSIGNED CORE.
PARR1A:
	CAMN	J,LASLOS		;SAME AS LAST LOSER?
	JRST	DISCRLF			;YES. JUST TYPE A CRLF AND RETURN
	MOVEM	J,LASLOS		;SAVE CODE FOR LAST LOSER
	JUMPG	J,PARER2		;JUMP IF NOT UNASSIGNED CORE
	PUSHJ	P,DISMES		;FOR UNASSIGNED CORE
	ASCIZ	/UNUSED
/
	POPJ	P,			;RETURN LOOK FOR MORE.

PARER2:
	CAIE	J,101			;IS THIS THE SYSTEM?
	JRST	PARER3			;NO. MUST BE FREE STORAGE.
	HRROS	SYSERR			;REMEMBER TO CHECKSUM THE SYSTEM
	PUSHJ	P,DISMES
	ASCIZ	/SYS
/
	POPJ	P,

PARER3:
	PUSHJ	P,DISMES
	ASCIZ	/FS
/
	POPJ	P,


PARR4B:
	MOVE	J,PARSJN		;JOB NUMBER OF GUY BEING SHUFFLED.
	HRRZ	TAC,PARBLK		;GET LOC OF OLD CORE
	SUBI	DSER,(TAC)		;MAKE RELATIVE LOCATION.
	JUMPL	DSER,PARR4C		;THIS ISN'T PART OF THE OLD CORE.
	HLRZ	TAC,PARBLK		;GET SIZE OF OLD CORE
	CAILE	DSER,(TAC)		;SKIP IF ERROR IS IN OLD SHUFFLED CORE.
PARR4C:
	MOVEI	J,0
	JUMPE	J,PARR1A		;TREAT THIS AS UNUSED CORE.
PARER4:
	PUSH	P,J			;SAVE JOB NUMBER
	HRRZ	TAC1,JBTADR(J)		;GET THE BASE ADDRESS OF THIS JOB
	CAMN	J,PARSJN		;THIS JOB SHUFFLE IN PROGRESS?
	HRRZ	TAC1,PARBLK		;YES. GET THE OLD JOB LOCATION.
	HRRZ	TAC,ERRLOC		;GET THE ERROR LOCATION
	SUBI	TAC,(TAC1)		;FORM THE USER RELATIVE ADDRESS
	MOVEM	TAC,RERLOC		;SAVE RELOCATED ERROR LOCATION.
	PUSHJ	P,DISLOC		;TYPE 6 CHARACTERS
	MOVE	J,(P)			;GET THE JOB NUMBER INTO J AGAIN
	CAMN	J,LASLOS		;SAME AS LAST TIME?
	JRST	PARR4A			;YES. DON'T TELL JOB NAME AGAIN
	MOVEM	J,LASLOS		;REMEMBER FOR NEXT TIME
	PUSHJ	P,DISTAB		;TYPE A TAB FOR SEPARATION
	MOVE	J,(P)			;MAKE SURE NO ONE CLOBBERS J.
	PUSHJ	P,DISJOB		;TYPE JOB NUMBER(JOB NAME)
	CAME	J,PARSJN		;IS THIS A SHUFFLE OPERATION?
	JRST	PARR4A
	PUSHJ	P,DISMES
	ASCIZ	/	SHUFFLE/
PARR4A:
	PUSHJ	P,DISCRLF
	MOVE	J,(P)			;RESTORE J (AGAIN) 
	MOVE	TAC,JBTSTS(J)		;GET THE JOB STATUS WORD
	TLNN	TAC,JSEG		;IS THIS REALLY AN UPPER?
	JRST	PARER8			;NO, JUST A SIMPLE LOWER.
	PUSHJ	P,MARKERR		;HAS THIS UPPER LOST BEFORE (OR IS IT FIXABLE)?
	JRST	TPOPJ			;YES. DON'T TELL LOWERS AGAIN
	MOVEI	TAC,400000		;IN CASE OF A SEGMENT
	ADDM	TAC,RERLOC		;ADD 400000 TO RELOCATED ERROR ADDRESS
	MOVEI	J,JOBN-1		;FOR ALL THE JOBS IN THE WORLD....
PARER5:
	LDB	TAC,PSEGN		;GET THE JOB NUMBER OF THIS GUY'S UPPER
	CAME	TAC,(P)			;SAME AS THIS UPPER?
	SOJG	J,PARER5		;NO.
	JUMPLE	J,PARER6		;JUMP IF NO MORE USERS OF THIS UPPER
 	PUSH	P,J			;SAVE THIS JOB ON THE STACK
	PUSHJ	P,TELUSR		;TELL A LOWER SEGMENT.
	POP	P,J
	SOJG	J,PARER5		;DECREMENT J AND LOOK FOR MORE.
PARER6:
	POP	P,J			;GET THE NUMBER OF THIS UPPER.
	MOVE	TAC,PRJPRG(J)		;GET A RIDICULOUS NAME
	MOVEM	TAC,JOBNAM(J)		;SAVE IT AS THE JOB NAME
	POPJ	P,			;NO ONE WILL ATTACH TO THIS AGAIN.

PARER8:
	PUSHJ	P,TELUSR		;TELL THE USER ABOUT WHAT BEFELL HIM
	JRST	TPOPJ			;ADJUST STACK AND RETURN.

TELUSR:
	PUSHJ	P,MARKERR		;MARK THIS JOB HAS ERROR
	POPJ	P,			;HE'S BEEN TOLD BEFORE.
	MOVSI	TAC,INTPAR		;PICKUP PARITY ERROR ENABLE BIT
	TDNN	TAC,JBTIEN(J)		;IS THIS USER ENABLED FOR THIS?
	JRST	TELUS1			;NO. TELL HIM AND STOP HIM
	IORM	TAC,JBTIRQ(J)		;SET PARINT BIT FOR THIS USER
	SETOM	INTREQ(PID)		;REQUEST A USER INTERRUPT
	MOVE	TAC1,RERLOC		;GET THE RELOCATED ADDRESS OF ERROR
	MOVEM	TAC1,INTDTM(J)		;SAVE IT FOR THIS USER.
	CONO	PI,1B24!1(7-CLKCHN)	;REQUEST INTERRUPT ON CLOCK CHANNEL
	POPJ	P,

TELUS1:
	PUSHJ	P,TTYERR		;GET THE USER'S TTY
	MOVE	TAC,RERLOC
	HLRZ	AC3,JBTADR(J)
	CAMN	J,PARSJN		;SHUFFLED JOB?
	HLRZ	AC3,PARBLK		;YES. USE THIS ADDRESS.
	CAILE	TAC,(AC3)		;IN LOWER?
	JRST	TELUS2			;NO. IT IS IN THE UPPER
	PUSHJ	P,INLMES		;STUFF DATA INTO TTY
	ASCIZ	/PARITY ERROR IN YOUR CORE IMAGE. LOC = /
	JRST	TELUS3

TELUS2:
	PUSHJ	P,INLMES
	ASCIZ	/PARITY ERROR IN YOUR UPPER SEGMENT. LOC = /
TELUS3:
	MOVE	TAC,RERLOC		;GET THE RELOCATED ERROR
	PUSHJ	P,OCTPNT		;TELL HIM THE LOCATION.
	PUSHJ	P,PRCRCC
	PUSHJ	P,TTYSTR		;START THE USER'S TTY TYPING
	SKIPL	JBTSTS(J)		;IS THIS GUY RUNNABLE?
	POPJ	P,			;NO.
TELSTP:
	MOVE	TAC,JBTSTS(J)
	TLNE	TAC,JLOG		;LOGGED IN?
	JRST	STOP1			;YES. JUST STOP IT.
	JRST	ESTOP			;NO. KILL THE PHANTOM

;CALL THIS ROUTINE TO SEE IF HE NEEDS TO BE TOLD
;WILL TRY TO REPEAT SWAPIN IF POSSIBLE

MARKERR:
				;PUSHJ HERE TO MARK JOB IN J AS HAVING ERROR.
	JUMPLE	J,CPOPJ			;IMPOSSIBLE JOB NUMBER
	CAIL	J,JOBN
	POPJ	P,			;IMPOSSIBLE JOB, UNNATURAL ACTS
	MOVEI	TAC,(J)			;GET JOB NUMBER
	SETZ	TAC1,
	LSHC	TAC,-5
	ROT	TAC1,5
	MOVEI	AC3,1
	ROT	AC3,-20(TAC1)		;ROTATE TO AN UNUSUAL POSITION
	TDNE	AC3,ERRJOB(TAC)		;IS THIS BIT SET ALREADY?
	POPJ	P,			;YES.
	IORM	AC3,ERRJOB(TAC)		;NO. SET IT
	MOVE TAC,RERLOC
	HLRZ AC3,JBTADR(J)
	CAIG TAC,(AC3)		;CAN'T FIX HIS UPPER HERE
	SKIPE STIME(J)		;NOW SEE IF THE SWAPPER CAN FIX IT
	JRST CPOPJ1		;MODIFIED SINCE SWAPIN
	HLRZ TAC,JBTSWP(J)
	JUMPE TAC,CPOPJ1	;NOT SWAPPED OUT YET
	SKIPN XJOB(J)
	AOS XJOB
	AOS XJOB(J)		;THIS SHOULD MAKE IT GET SWAPPED
	POPJ P,

	SUBTTL	P2 PARITY ERROR INTERRUPT
↑P2RINT:
	CONO	PI,@P2RCON		;ZERO ERROR BIT
	MOVEM	TAC,P2SA		;SAVE TAC
	MOVEI	TAC,17			;SCAN THE AC'S
	MOVES	(TAC)
	SOJGE	TAC,.-1			;LOOP
	CONSZ	PI,@P2RCON		;IS THAT WHERE IT IS?
	JRST	PARACS			;YES
	SETOM	PARFLG			;NO, TELL THE TEN
	MOVE	TAC,PARFLG		;WAIT FOR THE PDP-10 TO SEE THE FLAG
	JUMPN	TAC,.-1			;WAIT UNTIL IT GOES ZERO
	MOVE	TAC,P2RFLG		;WAIT FOR THE PDP-10 TO FINISH PARSER
	JUMPN	TAC,.-1			;
	JRST	P2ROUT			;RESTORE TAC AND DISMISS
PARACS:
	CONO	PI,@P2RCON		;CLEAR PARITY ERROR
P2ROUT:
	MOVE	TAC,P2SA		;RESTORE ACCUMULATOR
	JEN	@AP2CHL			;DISMISS INTERRUPT

BEND PARSER
;: PARSER[J17,SYS] EOF.
;: SYSINI[J17,SYS]
COMMENT ⊗   VALID 00007 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN	SYSINI 
  SUBTTL	SYSTEM INITIALIZATION - 1 SEPT 67
C00007 00003		MOVE	TAC,[XWD DVDIRIN+TTYATC+TTYUSE,ASSCON+ASSPRG]
C00009 00004	INITIALIZE ALL IODEVICES
C00016 00005	 HERE WE SETUP ALL JOB STATUS BITS
C00020 00006		MOVEI	TAC,[ASCIZ /SYSTEM STARTED ON /]
C00022 00007	 P2 INITIALIZE ROUTINE
C00026 ENDMK
C⊗;

BEGIN	SYSINI 
  SUBTTL	SYSTEM INITIALIZATION - 1 SEPT 67
;INITIALIZE SYSTEM DATA STORAGE
LIBPNT:
	POINT 7,.+1
	ASCIZ/
PUT THE LIBRASCOPE ON LINE OR YOU'LL SWAP ON THE 3330!
THEN PUSH CONTINUE.
/

↑SYSINI:JSP	TAC,.+1
	TLNE	TAC,10000	;USER MODE?
	JRST	START		;YES. SOMEONE IS RUNNING THE DMP COPY.
	CONO	APR,200000	;I/O RESET
	CONO	PI,10400	;PI RESET
↑JSR2:	XCT	ONCEI		;DO ONCE-ONLY OPERATORS DIALOGUE
	CONO	APR,200000	;I/O RESET AGAIN (D.R.D)
	CONO	PI,10400	;CLEAR PI'S
	CONSO	DSK,1B27	;LIBRASCOPE ON LINE?
	JRST	ONLINE		;YES!
	MOVE	TAC,LIBPNT	;GET A POINTER TO THE MESSAGE
	JSR	DDTTYPE		;PRINT MESSAGE
	HALT	ONLINE		;AND WAIT FOR GO AHEAD
ONLINE:
	SETZM	SYSBEG		;ZERO SYSTEM STORAGE
	MOVE	TAC,[XWD SYSBEG,SYSBEG+1]
	BLT	TAC,SYSEND	;CLEAR IT
	SETZM	STBEG
	MOVE	TAC,[XWD STBEG,STBEG+1]
	BLT	TAC,STEND
	SETZM	UPTIME
	MOVE	P,[IOWD ERRPLN,ERRPDL]

IFN FTDDT,<
	DATAI	APR,TAC		;READ THE CONSOLE SWITCHES
	TLC 	TAC,777		;COMPLEMENT 9 BITS ON THE LEFT
	SKIPN	NOTDDT		; ANY DDT AT ALL?
	TLNE	TAC,-1		;SKIP IF WE HAVE TO TAKE SWITCHES SERIOUSLY
	JRST	INIDDT		;IGNORE SWITCHES OR NO DDT
	TRNN	TAC,10000	;DOES HE WANT NO DDT
	JRST	CKDSWP		;HE WANTS DDT, CHECK ABOUT SWAPPING
	SETOM	NOTDDT		;FLAG TO GET RID OF DDT
	MOVE	TAC1,[HALT AUTOLOAD]	;MAKE A HALT 
	MOVEM	TAC1,DDT	;AND PLANT IT ON TOP OF DDT
	MOVEI	TAC1,DDT+1	;GET THE ADDRESS BEYOND DDT
	MOVEM	TAC1,SYSSIZ	;SAVE AS SYSSIZ
	SETZM	36		;NO SYMBOL TABLE POINTER
	JRST	INIDDT		;CONTINUE
CKDSWP:

IFN FTDSWP,<
	SETOM	DDTSWP		;ASSUME THAT HE WANT'S SWAPPING DDT
	TRNE	TAC,20000	;CHECK FLAGS
	SETZM	DDTSWP		;HE WANTS NO SWAPPING
INIDDT:
	SKIPN	NOTDDT		;DOES HE WANT DDT?
	PUSHJ	P,DDTINI	;YES INITIALIZE IT.
;>;;edit;;omit macro tail as ELSE CLAUSE abuse;;INIDDT:
>;FTDDT

	DATAI	APR,TAC			;READ THE DATA SWITCHES
	TLC	TAC,777		
	TLNE	TAC,-1			;DO WE HAVE TO TAKE THESE SERIOUSLY?
	JRST	SYSIN2			;NO
	TRNE	TAC,1			;DOES HE WANT DDT NOW?
	PUSHJ	P,DDTCAL		;YES GET IT FOR HIM.
	MOVSI	TAC1,-NMCELS	
SYSIN1:
	SKIPGE	MCELTB(TAC1)		;SKIP IF NORMAL SENSE
	TRC	TAC,400000		;INVERSE SENSE. COMPLEMENT THE BIT
	TRNN	TAC,400000		;SKIP IF WE'RE SETTING.
	SETZM	@MCELTB(TAC1)		;¬ SETTING: CLEAR THE CELL
	TRNE	TAC,400000		;SKIP IF ¬ SETTING
	SETOM	@MCELTB(TAC1)		;SET THE CELL
	ROT	TAC,1			;SHIFT TO INSPECT MORE BITS
	AOBJN	TAC1,SYSIN1		;LOOP
SYSIN2:


	MOVE	TAC,SYSSIZ	;PICKUP REAL SYSTEM SIZE
	ADDI	TAC,1777
	ANDCMI	TAC,1777
	MOVEM	TAC,SYSTOP	;AND SAVE IT

	PUSHJ	P,CORINI	; INITIALIZE CORE TABLES
	MOVEI	TAC,[ASCIZ /SYSTEM INITIALIZED ON /]
	SKIPN	INIMES		;JUST LOADED?
	MOVEM	TAC,INIMES	;NO. STORE MESSAGE.

	MOVE	TAC,[XWD DVDIRIN+TTYATC+TTYUSE,ASSCON+ASSPRG]
	HLRZ	DEVDAT,DEVLST	;SCAN ALL DEVICES
SYS1:
	ANDCAM	TAC,DEVMOD(DEVDAT)	;CLEAR DEVICE BITS
				;DIRECTORY IN CORE, ASSIGNED BY CONSOLE, PROGRAM
	SETZM	DEVLOG(DEVDAT)	;CLEAR LOGICAL NAME
	HLRZ	DEVDAT,DEVSER(DEVDAT)	;LINK ONWARDS
	JUMPN	DEVDAT,SYS1
	MOVEI	TAC,IOGO		;GET ADDRESS FOR 200 RESTART
	HRRM	TAC,SYSDSP		;STUFF IT IN SYSDSP (200)

	MOVEI	TAC,P2INI		; CRANK UP P2. IT IS WAITING FOR US
	HRRM	TAC,P2XFR		; ALLOW P2 TO CONTINUE

; HERE WE MUST DETACH AD AND XGP FROM THE SYSTEM IF THE PDP-6
; IS NOT ON LINE. THE ONCE ONLY CODE SETS THE FLAG 'DETFLG'

	SKIPN	DETFLG		; DO WE HAVE TO DETACH?
	JRST	IOGO		; NO, PROCEED WITH SYSINI
	MOVEI	TAC,ASSCON	; YES, GET THE 'ASSIGN' BIT
	IORM 	TAC,ADDDB+DEVMOD	; OR INTO DEVICE DATA BLOCK


	MOVEI	DEVDAT,ADDDB	; GET ADDRESS OF DDB FOR PJOBN'S SAKE
	DPB	TAC,PJOBN	; MAKE SURE THEY ARE ASSIGNED TO JOB 0

	IORM	TAC,XGPDDB+DEVMOD
	MOVEI	DDB,XGPDDB
	DPB	TAC,PJOBN

	IORM	TAC,ADCDDB+DEVMOD
	MOVEI	DDB,ADCDDB
	DPB	TAC,PJOBN

	IORM	TAC,DACDDB+DEVMOD
	MOVEI	DDB,DACDDB
	DPB	TAC,PJOBN

;INITIALIZE ALL IODEVICES
IOGO:
	CONO	APR,733550+APRCHN	;APR RESET (IO RESET)
	CONO	PI,11577		;CLEAR PI SYSTEM
	MOVE	P,[IOWD ERRPLN,ERRPDL]
	PUSHJ	P,FMCHK			;ARE WE USING FAST MEMORY?
	JRST	IOGO			;NO. LET'S TRY THAT ALL AGAIN
IOGO1:
	MOVE	AC1,TIME+P1PID		;GET THE CURRENT TIME
	MOVE	AC2,THSDAT+P1PID	;AND THE DATE
	MOVE	TAC,[XWD P1DATA,P1DATA+1]
	SETZM	P1DATA			;ZERO DATA AREA FOR P1
	BLT 	TAC,P1DATA+PDATALEN-1	;
	SETZM	RTIME			
	SETZM	TTIME			;CLEAR NULL TIME TOO.
	SETZM 	LASTDISASTER		;AND LAST DISASTER TIME
	MOVEM	AC1,TIME+P1PID		;RESTORE THE TIME
	MOVEM	AC1,TIME+P2PID		;SAVE FOR BOTH PROCESSORS
	MOVEM	AC2,THSDAT+P1PID	;SAVE THE DATE TOO
	MOVEM	AC2,THSDAT+P2PID	;
	IDIVI	AC1,JIFSEC		;CONVERT TIME TO SECONDS
	HRL	AC1,THSDAT		;PUT DATE IN LEFT HALF OF AC1
	MOVEM	AC1,TIMDAT		;AND SAVE <DATE>,,<TIME IN SECS>
	SKIPE	INIMES			;SKIP IF THIS IS A RESTART
	MOVEM	AC1,INITIM		;SAVE TIME OF (RELOAD OR 203 RESTART).
IFN FTBAT,<
	MOVEI	TAC,=10*JIFSEC		;WAIT 10 SECONDS 
	MOVEM	TAC,BATYET		;BEFORE STARTING THE PHANTOM JOBS
	SETZM	ALFRED			;ZERO WAKEUP TIME FOR ALL PHANTOMS
	MOVE	TAC,[XWD ALFRED,ALFRED+1]
	BLT	TAC,ALFRED+BATLEN-1
>

	MOVE	TAC,[JRST UUO1]		; SET UP PROCESSOR DATA STORAGE
	MOVEM	TAC,UUO0+1
	MOVE	TAC,[JRST UUO3]
	MOVEM	TAC,UUO2+1
	MOVEI	TAC,40
	MOVE	TAC1,P1NUM
	TLNE	TAC1,MAOFF	
	MOVEI	TAC,140
	MOVEM	TAC,UUOLOC+P1PID
	MOVE	TAC,[POINT 36,CIPWT-1,35]
	MOVEM	TAC,CLOCK
	MOVEI	TAC,CH3;CAT(CH,\APRCHN)
	MOVEM	TAC,APRCH+P1PID
	MOVEI	TAC,CH7;CAT(CH,\CLKCHN)
	MOVEM	TAC,CLKCH+P1PID
	MOVE	TAC,[P2PID]
	MOVEM	TAC,OTHERID+P1PID
	MOVEI	TAC,APRCON
	MOVEM 	TAC,APRCN+P1PID
	MOVEI	TAC,CLKSAVE
	MOVEM	TAC,CLKSV+P1PID
	MOVEI	TAC,CLKESAVE
	MOVEM	TAC,CLKESV+P1PID
	MOVE	TAC,[JEN @UUO0]
	MOVEM	TAC,UUOXIT
	MOVEM	TAC,UUOXI
	MOVE	PID,[P1PID]
	MOVEM	PID,APRID+P1PID
	MOVE	P,[IOWD ERRPLN,ERRPDL]
	MOVEM	P,ERRPD(PID)
	MOVE	TAC,[IOWD APRPLN,APRPD]
	MOVEM	TAC,APRPDL(PID)
	SETOM	JBTMSK
	MOVE	TAC,[JBTMSK,,JBTMSK+1]
	BLT	TAC,JBTMSK+JOBN-1
	SETOM	JBTWKM
	MOVE	TAC,[XWD JBTWKM,JBTWKM+1]
	BLT	TAC,JBTWKM+JOBN-1

	PUSHJ	P,NXTINI	;ALWAYS INITILIZE SCHEDULER FIST
				;SO DEVICES MAY RESET QUEUES IF DESIRED
	PUSHJ	P,SPWINI	;INITIALIZE SPACEWAR SERVICE
	PUSHJ	P,QINI		; INITIALIZE QUEUE STRUCTURE
	PUSHJ	P,FSINIT	; AND FREE STORAGE SYSTEM
	PUSHJ	P,DISINIT	; INITIALIZE DISASTER TYPEOUT SYSTEM.

;HERE WE INITIALIZE ALL THE DEVICES IN THE DEVICE LIST
;NOTE THAT FREE STORAGE MUST BE SET UP
;ALSO NOTE THAT EACH DEVICE MUST CORRECTLY LINK TO
;THE NEXT BEFORE RETURNING

	HLRZ	DDB,DEVLST	;GO UP THE DEVICE LIST, DOING GOOD THINGS
	SETZM	SAVITM		;DSP OF LAST DEVICE
IOG0:
	HRRZ	TAC,DEVSER(DDB)	;GET THE DEVICE SERVICE DISPATCH
	CAMN	TAC,SAVITM	;SAME AS LAST MEANS INITIALIZED ALREADY.
	JRST	IOG01		;YES
	MOVEM	TAC,SAVITM	;SAVE THE DEVICE DISPATCH
	PUSH	P,DDB
	PUSHJ	P,DINI(TAC)	;INITIALIZE THE DEVICE
	POP	P,DDB
IOG01:
	MOVEI	TAC,ASSPRG
	ANDCAB	TAC,DEVMOD(DDB)	;TURN OF ASSIGNED BY PROG BIT
	HRLOI	TAC1,77		;MAKE MASK FOR MODE BITS AND HUNG COUNT
	TDNE	TAC,[TTYATC,,ASSCON]	;IF ASSIGNED BY CONSOLE THEN OR ATTACHED
	TLO	TAC1,770000	;SAVE JOB NUMBER ALSO
	ANDM	TAC1,DEVCHR(DDB);GLONK!
	TLNN	TAC,DVTTY!DVLPT	;THESE GUYS ARE RIGHT(?)
	SETZM	DEVIOS(DDB)
	SETZM	DEVBUF(DDB)
	HLRZ	DDB,DEVSER(DDB)	;LINK ON MACDUFF
	JUMPN	DDB,IOG0
	MOVE	TAC,[RSTBEG,,RSTBEG+1]
	BLT	TAC,RSTEND-1

; HERE WE SETUP ALL JOB STATUS BITS
; STOP ALL LOGGED IN JOBS
; AND FLUSH ALL UN-LOGGED-IN JOBS

	MOVEI	J,JOBN-1
	SETZM	JOB
IOG2:

REPEAT 0,<
	MOVSI	TAC1,RUN1			;GET HIM RUN SOMEWHERE
	MOVEM	TAC1,JB2STS(J)
>
	MOVE	TAC1,[XWD JNA!JLOG!SWP!JSEG!JWP,77]	;KEEP THESE
	AND	TAC1,JBTSTS(J)
	TLO	TAC1,JERR			;DON'T LET HIM CONTINUE
	MOVEM	TAC1,JBTSTS(J)
	TLNN	TAC1,JNA			;JOB HERE AT ALL?
	JRST	IOG4				;NO, LOOP AROUND FOR NEXT
	TLNN	TAC1,JLOG			;JOB LOGGED IN?
	JRST	IOGKIL				;NO, FLUSH HIM
	TLNE	TAC1,JSEG			;SEGMENT?
	JRST	IOG6				;YES. ONLY REQUE TO STOPQ

	PUSHJ	P,PRIBUF			;SETUP JOB PRIORITY TABLE
	PUSHJ	P,MAKPDL			;MAKE A PDL FOR THIS JOB.
	MOVEI	AC1,0				;NO FREE STORAGE AVAIALABLE.
	MOVEM	AC1,JBTPDL(J)			;SAVE PDL FOR USER.
	TLNN	TAC1,SWP			;SWAPPED IN?
	JRST	IOG5				;YES FLUSH DATA AREA
	LDB	TAC,IMGIN			;IS THERE ANY CORE?
	JUMPE	TAC,IOG4			;JUMP IF NO CORE: LEAVE IN NULQ
	TRO	TAC1,WIPEJD			;MAKE SURE JOB DATA AREA GETS WIPED
	MOVEM	TAC1,JBTSTS(J)			;NEXT TIME THIS IS SWAPPED IN.
	JRST	IOG6				;NO, JUST STOPQ

IOGKIL:
	TRNE	TAC1,77				;RH WAS ANDED WITH 77
	SOS	NJOBS(TAC1)			;NO LONGER USING SEGMENT
	PUSHJ	P,IOGZ				;FLUSH HIS CORE IMAGE
	PUSHJ	P,KSTOP				;REMOVE THE CRETIN
	JRST	IOG4

IOGZ:
	PUSHJ	P,FBFLUSH			;RELEASE SWAP SPACE
	SETZB	TAC,JBTSWP(J)			;KILLING A PHANTOM.
	SETZM	JB2SWP(J)
	SKIPN	PROG,JBTADR(J)
	POPJ	P,
	SOS	(P)
	JRST	CORE1				;RELEASE CORE

IOG5:
	SKIPN	JDAT,JBTDAT(J)			;JOB DATA AREA?
	JRST	IOG4				;NO, LEAVE IN NULQ
	PUSH	P,JOBDDT(JDAT)
	PUSHJ	P,CLRJB1
	POP	P,JOBDDT(JDAT)
IOG6:
	MOVNI	TAC,STOPQ			;TO STOPQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
IOG4:
	SOJG	J,IOG2

	MOVEI	 J,JOBN-1			;FLUSH UNUSED SEGMENTS ON NEXT PASS
IOGS1:
	MOVE	TAC,JBTSTS(J)
	TLNE	TAC,JSEG
	SKIPE	NJOBS(J)			;ANYONE USING THIS SEGMENT?
	JRST	IOGS2
	SETZM	JBTSTS(J)			;NO USERS: BLAST THIS SEGMENT
	SETZM	JOBNAM(J)
	SETZM	PRJPRG(J)
	PUSHJ	P,IOGZ
	MOVNI	TAC,NULQ			;QUEUE TO NULL Q
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
IOGS2:
	SOJG	J,IOGS1				;LOOP
	SETZM	JOB				;AGAIN?
;FORM INITIAL CHECKSUM.
	
	MOVE	TAC,[XWD CHKBEG-CHKEND,CHKBEG]	;AOBJN POINTER
	MOVEM	 TAC,MONPTR
	PUSHJ	 P,CHECK
	MOVEM	 TAC1,MONSUM
IFN FTSTAT, <
	MOVE	TAC,[POINT 18,STATS]
	MOVEM	TAC,STATPTR	; INITIALIZE STATISTICS POINTER
>
	XCT	PICON		;PION, CH 3,5,6,7, AND PARITY ERROR ENABLE
REPEAT 0,<	DATAO	PTR,[1]		;ENABLE SYSTEM WR DETECTOR >

	MOVEI	TAC,[ASCIZ /SYSTEM STARTED ON /]
	SKIPN	INIMES		;LOAD OR INITIALIZE?
	MOVEM	TAC,INIMES	;NO, IT MUST BE A START
	MOVSI	J,-TCONLN-1	;NO. OF TTY LINES(REAL ONES).
IOG3:
	SKIPN	DEVDAT,TTYTAB(J) ;GET DDB FOR NEXT TTY.
	JRST	IOG3A		;OOPS, NO DDB.
	PUSHJ	P,CRLF		;TYPE A CRLF
	MOVE	TAC1,DEVNAM(DEVDAT)
	PUSHJ	P,PRNAME	;PRINT NAME OF CONSOLE
	MOVEI	TEM,11
	XCT	TYO		;TAB
	MOVEI	TAC,[ASCIZ/ (DOWN) /]
	SKIPN	MAINTMODE
	SKIPE	TTYLOK
	PUSHJ	P,CONMES	;TELL THEM THAT WE'RE DOWN
	MOVE	TAC,INIMES	;GET THE ADDRESS OF MESSAGE
	PUSHJ	P,CONMES	;SEND IT
	PUSHJ	P,DAYT2		;TIME OF DAY
	PUSHJ	P,PRCNTC
	PUSHJ	P,TTYSTR	;START THE TTY TYPING
IOG3A:
	AOBJN	J,IOG3		;SEND MESSAGE TO ALL TTY'S.

IFN FTDDT,<
	PUSHJ	P,DISMES	;INCASE LOWCOR GETS CLOBBERED.
	ASCIZ	/DDT STARTS AT /
	HRRZ	TAC,SYSDSP+1
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
>
;	MOVE	TAC,THSDAT	;APRIL 1 HACK.
;	IDIVI	TAC,=12*=31	;DIVIDE TO GET YEARS IN TAC, DAY OF YEAR IN TAC1
;	CAIN	TAC1,=31*3	;APRIL 1?
;	SETOM	AFOOL		;YES.
	

	SETZM	INIMES		;CLEAR FOR NEXT TIME
	SETZB	J,JOB		;INDICATE JOB ZERO
	MOVE	PID,[P1PID]	;INDICATE P1
	JRST	NULJOB		;START THE NULL JOB.

; P2 INITIALIZE ROUTINE

↑P2INI:	MOVE	TAC,[XWD P2DATA,P2DATA+1]
	CONO	PI,10400	; CLEAR PI SYSTEM
	SETZB	J,P2DATA
	BLT	TAC,P2DATA+PDATALEN-1
	CONO	APR,733550+APRCHN	; CLEAR EVERYTHING, ENABLE EVERYTHING
	MOVE	P,[IOWD ERRPLN,ERRPDL+P2PID]
	MOVE	TAC,[JRST P2UUO1]
	MOVEM	TAC,UUO0+P2PID+1
	MOVE	TAC,[JRST P2UUO3]
	MOVEM	TAC,UUO2+P2PID+1
	MOVEI	TAC,40
	MOVE	TAC1,P2NUM
	TLNE	TAC1,MAOFF
	MOVEI	TAC,140
	MOVEM	TAC,UUOLOC+P2PID
	MOVE	TAC,[POINT 36,CIPWT+P2PID-1,35]
	MOVEM	TAC,CLOCK+P2PID
	MOVEI	TAC,P2CH3;CAT(P2CH,\APRCHN)
	MOVEM	TAC,APRCH+P2PID
	MOVEI	TAC,P2CH7;CAT(P2CH,\CLKCHN)
	MOVEM	TAC,CLKCH+P2PID
	MOVE	TAC,[P1PID]
	MOVEM	TAC,OTHERID+P2PID
	MOVEI	TAC,AP2CON
	MOVEM	TAC,APRCN+P2PID
	MOVEI	TAC,CL2SAVE
	MOVEM	TAC,CLKSV+P2PID
	MOVEI	TAC,CL2ESAVE
	MOVEM	TAC,CLKESV+P2PID
	MOVE	TAC,[JEN @UUO0+P2PID]
	MOVEM	TAC,UUOXIT+P2PID
	MOVEM	TAC,UUOXI+P2PID
	SETZM	JOB+P2PID
	SETZM	JOBADR+P2PID
	SETZM	USRREL+P2PID
	MOVE	PID,[P2PID]
	MOVEM	PID,APRID(PID)
	MOVE	TAC,[IOWD ERRPLN,ERRPDL+P2PID]
	MOVEM	TAC,ERRPD(PID)
	MOVE	TAC,[IOWD APRPLN,APRPD+P2PID]
	MOVEM	TAC,APRPDL(PID)
	MOVE	TAC,CH3
	CAMN	TAC,CH3			; WAIT FOR P1 TO START TAKING CLOCK BREAKS
	JRST	.-1
	XCT	P2CON			; ENABLE PI, PARITY, ETC.

	PUSHJ	P,XGPIN2		;INITIALIZE XGP FROM P2
	PUSHJ	P,PTRREL		;INITIALIZE PTR FROM P2

	PUSHJ	P,DISMES
	ASCIZ/↓
PDP-6 STARTED /
	PUSHJ	P,DISDATE


	JRST	NULJOB

; POWER DOWN ROUTINES

↑PWROFF:
	CONO	PI,PIOFF		; NO MORE INTERRUPTS NOW
	EXCH	17,PWRCNT		; AND COUNT DOWN
	SOJG	17,.			;LOOP
	MOVEI	17,-1			; COUNT DONE, NO POWER DOWN AFTER ALL
	EXCH	17,PWRCNT		;RESTORE 17
	AOS	P1OFF			;COUNT FAILURES
	CONO	PI,PION			;ENABLE INTERRUPTS
	JEN	@CH3	

↑P2ROFF:
	CONO	PI,PIOFF
	EXCH	17,P2RCNT
	SOJG	17,.
	MOVEI	17,-1
	EXCH	17,P2RCNT
	AOS	P2OFF			;COUNT FAILURES ON SIX ALSO
	CONO	PI,PION
	JEN	@P2CH3

MCELTB:
	TTYLOK
	MAINTM
	DDOFF
	DEBMOD
	XWD	400000,DDTSWP		;COMPLEMENT SENSE OF SWITCH
	0				;R. HELLIWELL MEMORIAL CELL
	EXPMOD				;SET TO MAKE LOGIN TYPE X.TXT[2,2]
	NOLOGIN				;SET TO PREVENT LOGIN
IFN IMPSW,<IMPDIE;>;;else;;0			;NO IMP TODAY
IFN IMPSW,<IMPPMS;>;;else;;0			;SET TO ALLOW IMP TO COMPLAIN ON CTY
	BLTSWP				;SET FOR BLT AFTER SWAPIN.
	IEARLY				;PRINTOUT EACH IOP EARLY RESPONSE
NMCELS←←.-MCELTB
BEND SYSINI
;: SYSINI[J17,SYS] EOF.
;: COMCSS[J17,SYS]
COMMENT ⊗   VALID 00113 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00012 00002	BEGIN APRSER 
 SUBTTL	SAVGET	4 AUG 67
C00014 00003	ROUTINE TO SCAN COMMAND STRING ARGUMENTS FOR SAVE,GET,RUN AND R
C00019 00004	THIS JOB SAVES A JOB AREA ON RETRIEVABLE STORAGE
C00021 00005	THIS JOB GETS A JOB AREA FROM A RETRIEVABLE DEVICE
C00023 00006	JOB HAS JUST A JOB DATA AREA ASSIGNED WHEN CONTROL GETS HERE
C00025 00007	ROUTINE TO SETUP ACS,RESET IO,ASSIGN DEVICE, AND DO LOOKUP
C00027 00008	 COMMON SAVEGET ROUTINE, OPEN FILE, DO LOOKUP (ENTER?)
C00029 00009	 COME HERE ON SAVE DEVICE NOT AVAILABLE
C00030 00010	ROUTINE TO SET DUMP MODE COMMAND LIST IN USER AREA
C00033 00011	ROUTINE TO RELEASE DEVICE AND FIND TTY
C00034 00012	ROUTINE TO GET FILE FROM DEVICE
C00037 00013	HERE WE DISCOVER IF WE HAVE A HIGH SEGMENT TO SET-UP
C00039 00014	END OF GET, REMAP ERROR, SETPR2 KLUDGE
C00042 00015	 ROUTINE TO STUFF A FILE ON A DEVICE
C00045 00016	 SAVE ROUTINE
C00047 00017	BEGIN SEGCSS 
 SUBTTL	SEGCSS	8 SEPT 69	JAM
C00049 00018	 ROUTINE TO INVENT AN UPPER SEGMENT
C00051 00019	 THIS ROUTINE DEFINES A SEGMENT. IT SEARCHES FOR AN EXISTING
C00055 00020	 ROUTINE TO KILL A HIGH SEGMENT
C00058 00021	 ROUTINE TO ERASE A SEGMENT ENTIRELY
C00060 00022	 ROUTINE TO FLUSH A JOB'S HIGH SEGMENT AND ALL THE SEGMENTS HE MAY HAVE
C00064 00023	 UAPPLY - APPLY A ROUTINE TO ALL LOWERS OF AN UPPER.
C00066 00024	SUBTTL	COMCSS	4 AUG 67
C00067 00025	CTEX0:	PUSHJ PDP,GETLCCHR
C00069 00026	ROUTINE TO IGNORE LEADING SPACES, TABS, AND NULLS
C00071 00027	ROUTINE TO APPEND A "?" TO INPUT STRING AND SET AS OUTPUT
C00074 00028	ROUTINE TO PRINT A COMMAND ERROR MESSAGE
C00076 00029	ROUTINE TO PRINT INLINE ASCIZ MESSAGE - INLMES, PRCRCC, PRCNCC
C00078 00030	ROUTINE TO DEASSIGN A DEVICE
C00080 00031	ROUTINE TO READ CONSOLE AND CONVERT ANY RADIX NUMBER
C00083 00032	GET PROJECT-PROGRAMMER NUMBERS
C00085 00033	ROUTINE TO PRINT TIME AS HOURS,MINUTES,SECONDS, AND HUNDRETHS
C00087 00034	SUBTTL	ERRCON	4 AUG 67
C00089 00035	APRNXM:	TRNN TAC,NXM		NON-EX MEM?
C00090 00036	 ROUTINE TO PRINT ERROR MESSAGE FOR SPW MODULES
C00092 00037	ADDRESS CHECK ERROR AT ANY LEVEL
C00093 00038	CALL:	JSP DAT,ERROR
C00094 00039	 UERROR IS FOR UUO LEVEL, BLAMES CURRENT JOB
C00095 00040	 USER TRIED TO GIVE LPT OR PTP A BUFFER LARGER THAN
C00097 00041	UUOERR: ILLEGAL UUO 
C00100 00042	ILLEGAL INSTRUCTION  -  ILLINS, HALT
C00102 00043	ROUTINE FOR HUNG IO DEVICE
C00104 00044	ROUTINE TO HALT A JOB WHEN A DEVICE IS NOT READY FOR I/O
C00105 00045	 ROUTINE TO PRINT A MESSAGE AND STOP A JOB IN A WAY
C00106 00046	COMMON ERROR MESSAGE SETUP ROUTINES - ERRPTU
C00109 00047	ROUTINE TO PRINT UUO PC AND STOP JOB - UUOMES, UUOPCP, PCPNT
C00111 00048	ROUTINE TO PRINT EITHER: - PCSTOP, PCP
C00113 00049	ROUTINE TO PRINT 36 BIT OCTAL NO
C00114 00050	ROUTINE TO PRINT "DEVICE XXX"
C00115 00051	 ROUTINE TO TYPE OUT DISASTER BUFFER ON CTY AT CLOCK LEVEL
C00117 00052	 ROUTINE TO CALL WITH PIS OFF TO FINISH FLUSHING
C00119 00053	 THIS ROUTINE TYPES ONE CHARACTER IN TEM THROUGH
C00121 00054	DISMES, DISCRLF, DISTAB, DISJOB
C00123 00055	CALLING SEQUENCE
C00124 00056	 HERE ARE THE VARIOUS PRINTOUT ROUTINES FOR DISERR
C00125 00057	DISLOC PRINTS OUT 6 DIGIT OCTAL LOCATION WITHOUT LEADING ZEROES
C00128 00058	 SIXBIT PRINT ROUTINE FOR DISASTER MESSAGES
C00129 00059	 INITIALIZE ROUTINE FOR DISASTER MESSAGES . . .
C00130 00060	 ROUTINE TO TYPE ON THE CTY WITH PIS OFF
C00132 00061	 ROUTINE TO SHOVE THE TIME AND DATE INTO THE BUFFER
C00134 00062	SUBTTL	IOCSS	4 AUG 67
C00137 00063	 ROUTINE TO PUSH CURRENT PR ON STACK AND SET UP NEW PR
C00138 00064	 ROUTINE TO ADDRESS CHECK SOMETHING
C00140 00065	ROUTINE TO ADVANCE INPUT BUFFER AT INTERRUPT LEVEL
C00143 00066	ROUTINE TO ADDRESS CHECK AT UUO LEVEL ONLY
C00144 00067	ROUTINE TO ADDRESS CHECK AT UUO LEVEL ONLY
C00146 00068	ROUTINE TO ADDRESS CHECK AT ANY LEVEL
C00147 00069	ROUTINE TO CHECK VALIDITY OF A DUMP MODE COMMAND LIST
C00149 00070	COMCK1:	SOJLE ITEM,COMCKE	EXCEEDED 100 YET?
C00151 00071	ASSASG	ASSIGN DEVICE IF UNASSIGNED
C00154 00072	ROUTINE TO SEARCH FOR A DEVICE
C00156 00073	SEARCH PHYSICAL NAMES
C00158 00074	ROUTINE TO SETUP N-RING IO BUFFER IN USER AREA
C00161 00075	 HERE, WE WANT TO EXPAND CORE TO FIT IN A RING OF BUFFERS
C00163 00076	 END OF LOOP FOR SETTING UP AN N-RING BUFFER
C00165 00077	ROUTINE TO CLEAR IO BUFFER IN USER AREA
C00167 00078	ROUTINE TO COMPUTE 12 BIT FOLDED CHECKSUM
C00169 00079	ROUTINE TO CLEAR RESIDUE OF WORD POINTED TO BY A BYTE POINTER
C00170 00080	IOALL, IOALLR, IORELS,IOWAIT
C00175 00081	IOKILL, CLRUSR
C00177 00082	ROUTINE TO FLAG DEVICE ACTIVE  - ORACT, SETACT, CLRACT, STOIOS
C00178 00083	 THIS ROUTINE UPDATES EACH DEVICE'S HUNG COUNT AND DISPATCHES
C00180 00084	 OTHER USEFUL ROUTINES FOR SETING UP USER BUFFER POINTERS
C00181 00085	 SET UP WORD COUNT IN AC2
C00182 00086	ROUTINE TO SETUP PROG AND ITEM FOR INTERRUPT SERVICE ROUTINE
C00183 00087	CALLING SEQUENCE
C00185 00088	ROUTINE TO RETURN NO. OF ITEMS IN BUFFER
C00186 00089	ROUTINE TO SET DEVICE STATUS WORD FROM UUO
C00187 00090	SETUP BYTE POINTER AND ITEM COUNT
C00188 00091	ROUTINE TO SETUP BYTE POINTER ACCORDING TO DATA MODE
C00189 00092	 ROUTINE TO STORE DATA IN IOBUFFER FOR INPUT DEVICES THAT
C00191 00093	↑STODAT:
C00193 00094	↑STOSQD:
C00195 00095	RUNCSS	4 AUG 67 - KSTOP
C00198 00096	ROUTINE TO STOP JOB, SET ERROR BIT AND PRINT MESSAGE - HOLD, PHOLD
C00199 00097	ROUTINE TO STOP USER AND FLAG AS ERROR STOP - ESTOP, MSTOP
C00204 00098	ROUTINE TO STOP ANY JOB FROM BEING SCHEDULED - STOP1, SETSTP
C00207 00099	DLYCOM     ROUTINE TO REQUE JOB WHICH HAS HAD A COMMAND TYPED
C00208 00100	ROUTINE TO PUT JOB IN NO CORE QUEUE
C00209 00101	ROUTINE TO SETUP MONITOR JOB TO RUN LATER AT UUO LEVEL - MONJOB
C00210 00102	MONSTR ROUTINE TO SETUP ACS FOR MONITOR JOB STARTING AT UUO LEVEL
C00212 00103	ROUTINE TO SET JOB STATE TO BE SCHEDULED TO RUN - USTART, MSTART
C00216 00104	ROUTINE TO SET JOB STATUS RUN BIT(RUN)
C00218 00105	ROUTINE TO PUT A JOB TO SLEEP AND WAKE UP AGAIN LATER
C00220 00106	ROUTINE TO GET DATA CONTROL AND ANOTHER SHARABLE DEVICE
C00222 00107	ROUTINE TO WAIT FOR A SHARABLE DEVICE
C00224 00108	SETIOD - ROUTINE TO SET JOB TO RUN AFTER IT HAS BEEN STOPPED
C00226 00109	ROUTINE TO CAUSE CLK ROUTINE TO RESCHEDULE - WSCHED
C00228 00110	ROUTINE TO WAIT TILL DEVICE CATCHES UP WITH USER AND BECOMES INACTIVE
C00230 00111	WSYNC IS CALLED TO WAIT UNTIL 
C00232 00112	 WE GET HERE IF THIS DEVICE HAS CONTROL CELLS
C00234 00113	REPEAT 0,<
C00235 ENDMK
C⊗;

BEGIN APRSER 
 SUBTTL	SAVGET	4 AUG 67

;SPECIAL LOCATION IN USER JOB DATA AREA FOR STORING ARGUMENTS
;USED IN UUO CALLS TO THE MONITOR

;FOR LOOKUP UUO
FILNAM←←0		;FILE NAME
FILEXT←←FILNAM+1	;FILE EXTENSION
FILDAT←←FILNAM+2	;DATE WRITTEN
FILLEN←←FILNAM+3	;LH=-LENGTH,RH=FIRST LOC-1 DUMPED ON ENTER
			;PROJECT PROGRAMMER ON LOOKUP

DMPEND←←FILLEN+1	;LAST WORD OF DUMP COMMAND LIST=0

;FOR OPEN UUO
MODWRD←←5		;IOS MODE WORD FOR OPEN UUO
DEVWRD←←MODWRD+1	;DEVICE NAME
HEDWRD←←MODWRD+2	;INPUT AND OUTPUT BUFFER HEADER ADDRESSES


DMPWRD←←11	;DUMP WORD FOR SAVE COMMAND
NEWCOR←←12	;NEW CORE ASSIGNMENT FOR RUN AS SPECIFIED BY THIRD
		;ARGUMENT TO PREVIOUS SAVE.
↑INCWRD←←13	;STARTING INCREMENT STORAGE FOR MONITOR JOB.

COMWRD←←17	;TO PASS COMMAND TO PROG
CHRWRD←←16	;DITTO DELIMITER

;ROUTINE TO SCAN COMMAND STRING ARGUMENTS FOR SAVE,GET,RUN AND R
;COMMANDS AND STORE THEM IN JOB DATA AREA WHICH MUST BE IN CORE
;WHEN SGSET IS CALLED FROM COMMAND DECODER
;CALL:	MOVE TAC,INPUT BYTE POINTER
;	MOVE TAC1,SIXBIT DEVICE NAME
;	MOVE DAT,OUTPUT BYTE POINTER
;	MOVE IOS,ADR. OF MONITOR JOB(SAVJOB,GETJOB,RUNJOB)
;	MOVE PROG, ADR. OF JOB AREA
;	PUSHJ P,SGSET

;SET AC2 TO EXPLICIT PPN OF FILE AND ENTER BY:  PUSHJ P,SGSET0

C←←BUFPNT

SGDVOK:
	PUSH	P,TAC			;CHECK TO SEE IF ARG IS LEGAL SAVEGET DEV
	PUSH	P,IOS
	PUSH	P,DAT
	PUSH	P,DDB
	MOVE	TAC,TAC1
	PUSHJ	P,DEVSRC		;IS THERE SUCH A DEVICE
	JRST	SGSETB			;NOT A LEGAL DEVICE. ASSUME IT WAS FILENAME
	MOVE	TAC,DEVMOD(DDB)
	TLNE	TAC,DVDSK!DVDTA!DVMTA	;ONLY LEGAL DEVICES FOR SAVE GET
	AOS	-4(P)
SGSETB:
	POP	P,DDB
	POP	P,DAT
	POP	P,IOS
	JRST	TPOPJ

SGSET:
	MOVEI	AC2,0			;NORMAL ENTRY - DISABLE PPN KLUDGE
SGSET0:
					;THIS IS THE RUN FROM ANOTHER AREA KLUDGE
IFN FTLOGIN,<	MOVEM	AC2,JOBPPN(J)>
	MOVEM	TAC1,DEVWRD(PROG)	;STORE FIRST ARG. MAY BE DEVICE, OR FILE
	JUMPE	TAC1,SGSETC		;ASSUME DSK IF NO ARG
	PUSHJ	P,SGDVOK		;SEE IF IT'S A VALID DEVICE NAME
	JRST	SGSETC			;WASN'T A DEVICE NAME
	SKIPN	TAC1,JOBNAM(J)		;WAS DEVICE.   AUTOMATIC FILENAME?
	JRST	SGSET3			;NO. READ ONE FROM THE COMMAND STRING
SGSETA:
	MOVEM	TAC1,FILNAM(PROG)	;OK. SET FILE NAME
	MOVSI	TAC1,'DMP'
	MOVEM	TAC1,FILEXT(PROG)	;DEFAULT EXTENSION
IFN FTLOGIN,<	SETZM	FILLEN(PROG)
		XCT	SGPPN	>	;LOAD AC1 WITH DEFAULT PPN
	JRST	SGSET1

SGSETC:
	MOVSI	TAC1,'DSK'		;NO TRY TO ASSUME DISK
	EXCH	TAC1,DEVWRD(PROG)	;USE THIS FOR FILENAME
	JUMPN	TAC1,SGSETD
	SKIPN	TAC1,JOBNAM(J)
	JRST	NOTENF
	JRST	SGSETA

SGSET3:
	PUSHJ	P, CTEXT1		;GET FILE NAME FROM COMMAND STRING
	JUMPE	TAC1,NOTENF		;THERE MUST BE A FILE NAME
SGSETD:
	MOVEM	TAC1,FILNAM(PROG)	;STORE FILE NAME
	MOVEM	TAC1,JOBNAM(J)		;STORE ALSO FOR SYSTAT
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	MOVSI	TAC1,'DMP'		;ASSUME EXTENSION
	CAIN	TEM,"."			;EXTENSION EXPECTED?
	PUSHJ	P,CTEXT1		;YES. GET EXTENSION, OTHERWISE USE DEFAULT
	HLLZM	TAC1,FILEXT(PROG)	;STORE IT FOR LOOKUP

IFN FTLOGIN,<
	SETZM	FILLEN(PROG)
	PUSHJ	P,PJPGNO		;GET PROJ. PROG. NO.
SGPPN:
					;THIS IS A SUBROUTINE CALLED BY XCT SGPPN
IFE FTDSKPPN,<	MOVE	AC2,PRJPRG(J)>
IFN FTDSKPPN,<	JSP	AC1,[SKIPN AC2,DSKPPN(J)
			MOVE AC2,PRJPRG(J)
			JRST (AC1)]	>;FTDSKPPN
>;FTLOGIN

	PUSHJ	P,DECIN1	;AMOUNT OF CORE (OPTIONAL THIRD ARG.)
	JRST	SGSET1		;DOES NOT RETURN IF ERROR, RETURN HERE IF NO ARG.
	JRST	COMERA		;ILLEGAL CHARACTER
	LSH	TAC1,12		;CONVERT TO HIGHEST REL. LOC.
	SUBI	TAC1,1
SGSET1:
	HRRZM	TAC1,JOBCOR(PROG)	;STORE FOR RUN COMMAND AND SAVE
IFN FTLOGIN,<	SKIPN	JOBPPN(J)	;SKIP IF EXPLICIT PPN KLUDGE.
		MOVEM	AC2,JOBPPN(J)>	;SAVE PPN
	MOVE	TAC1,IOS		;SCHEDULE MONITOR JOB
	JRST	MSTART			;START JOB WITH PC IN MONITOR MODE

;THIS JOB SAVES A JOB AREA ON RETRIEVABLE STORAGE
;THIS JOB RUNS IN EXEC. MODE AND CALLS IO ROUTINES DIRECTLY
;NO ATTEMPT IS MADE TO SAVE STATUS OF IO DEVICES, JOBPDP, OR AC'S
;IN FACT THE ONLY USEFUL THING WHICH MAY BE DONE WITH A JOB AREA
;AFTER IT HAS BEEN SAVED IS TO START EXECUTION OVER AT THE STARTING
;ADDRESS


↑SSAVJB:
	JSP TAC1,SG1		;SET UP FOR SAVE
	JFCL
	PUSHJ P,SSAVJA		;NON-FLUSH SEGMENT ENTRANCE
	JRST SAVJB1

↑SAVJOB:
	JSP TAC1,SG1		; SET UP ACS AND ASSIGN DEVICE AND LOOKUP
	JFCL			;FILE DOES NOT ALREADY EXIST RETURN
	PUSHJ PDP,SAVJB		; THIS ROUTINE ACTUALLY DOES THE WORK
SAVJB1:
	PUSHJ P,INLMES
	ASCIZ/JOB SAVED IN /
	HLRO TAC,FILLEN(PROG)
	MOVNS TAC
	ADDI TAC,JOBSAV
	LSH TAC,-12
	ADDI TAC,1
	PUSHJ P,RADX10		;TELL HIM HOW MUCH WE SAVED IT IN
	SKIPE NEWCOR(JDAT)
	JRST SAVEUP		;AND UPPER
	LDB TAC,PSEGN
	JUMPE TAC,SAVNUP	;ANY UPPER AT ALL?
	JSP TAC,PHOLD		;YES, TELL HIM NOT SAVED
	ASCIZ/K
UPPER NOT SAVED!
/

SAVEUP:
	PUSHJ P,INLMES
	ASCIZ/K
UPPER SAVED IN /
	HLRO TAC,NEWCOR(JDAT)
	MOVNS TAC
	ADDI TAC,1777
	LSH TAC,-12
	PUSHJ P,RADX10
SAVNUP:
	JSP TAC,PHOLD
	ASCIZ/K
/

;THIS JOB GETS A JOB AREA FROM A RETRIEVABLE DEVICE
;THIS JOB RUNS IN EXEC. MODE AND CALLS IO ROUTINES DIRECTLY
;NO ATTEMPT IS MADE TO RESTORE STATUS OF IO DEVICES, PC, OR AC'S
;JOBPC IS SET TO STARTING ADDRESS OF JOB
;CORE MUST ALREADY HAVE BEEN ASSIGNED AND THE FOLLOWING LOC. SETUP IN
;JOB DATA AREA:
;JOBPDP, JOBREL


↑GETJOB:
	JSP TAC1,SG1		; SET UP ACS AND ASSIGN DEVICE AND DO LOOKUP
	JRST NOFILE		;FILE NOT FOUND RETURN
	PUSHJ PDP,GETJB		;GET THE JOB
GETJ1:
	PUSHJ P,INLMES		;RETURN ONLY IF EVERYTING OK
	ASCIZ /JOB SETUP IN /
	HLRZ TAC,JBTADR(J)
	LSH TAC,-12
	ADDI TAC,1
	PUSHJ P,RADX10
	LDB AC3,PSEGN
	JUMPE AC3,GETNUP
	PUSH P,AC3
	PUSHJ P,INLMES
	ASCIZ/K
YOUR UPPER IS /
	POP P,AC3
	HLRZ TAC,JBTADR(AC3)
	ADDI TAC,1777
	LSH TAC,-12
	PUSHJ P,RADX10
GETNUP:
	JSP TAC,PHOLD
	ASCIZ/K
/
NOFILE:
	PUSHJ P,CLRTPV		;NOT FOUND--CLEAR TEMPORARY PRIVILEGES
	PUSHJ PDP,SGREL		;RELEASE DEVICE, FIND TTY
	PUSHJ PDP,PRQM
	PUSHJ PDP,CRLF
	MOVE TAC1,FILNAM(PROG)	;PRINT FILE NAME
	PUSHJ PDP,PRNAME
	PUSHJ PDP,PRPER		;PRINT PERIOD
	HLLZ TAC1,FILEXT(PROG)
	PUSHJ PDP,PRNAME	;PRINT EXTENSION
	JSP TAC,PHOLD		;PRINT MESS. AND STOP JOB
	ASCIZ / NOT FOUND/

;JOB HAS JUST A JOB DATA AREA ASSIGNED WHEN CONTROL GETS HERE
;THIS MONITOR JOB GETS A JOB AREA FROM A RETRIEVABLE DEVICE
;ASSIGNS CORE AND START


↑RUNJOB:
	JSP TAC1,SG1		; SETUP ACS, ASSIGN DEVICE, AND DO LOOKUP
	JRST NOFILE		;NO FILE FOUND RETURN
	PUSHJ P,GETJB		;GET THE FILE
	HRRZ TAC,JOBSA(JDAT)	;GET STARTING ADDRESS
	TRNN TAC,-1
	JRST NOSTRT
	ADD TAC,SAVSAI(J)	;ADD STARTING ADDRESS INCREMENT
	HRLI TAC,USRMOD		;SET USER MODE BIT
	MOVEM TAC,UUOPC(J)	;MAKE IT LOOK LIKE UUO RETURN
	MOVE TAC,JOBPPN(J)	;GET PRJPRG OF FILE
	MOVEM TAC,DMPEND(PROG)	;GIVE IT TO THE USER
	JRST USRXIT		;AND GO START USER

NOSTRT:
	PUSHJ P,INLMES
	ASCIZ /NO STARTING ADDRESS.
/
	JRST GETJ1

;ROUTINE TO SETUP ACS,RESET IO,ASSIGN DEVICE, AND DO LOOKUP
;CALL:	JSP TAC1,SG1
;	FILE NOT FOUND RETURN
;	FILE FOUND RETURN
;	IOWD FOR THIS SIZE CORE RETURNED IN AC TAC
;	DEVMOD IN TAC1



SG1:
	JSP TAC,MONSTR		;SETUP PROG,PDP,RESET DEVICES
				;PUT TAC1 ON END OF PD LIST
	PUSHJ PDP,RESETUUO	;RELEASE ALL DEVICES
	MOVEI TAC,2		;SAVE MODE
	MOVEM TAC,MODWRD(PROG)	;STORE FOR OPEN UUO
	SETZM HEDWRD(PROG)	;CLEAR BUFFER HEADER ARG.
	SKIPN TAC,JOBCOR(PROG)	;WAS CORE SIZE SPECIFIED
	JRST SGCOR		;NO
	CAMG TAC,USRREL(PID)	;YES, MUST WE GET SOME MORE
	JRST SGCOR1		;NO
	PUSHJ P,RUNCOR		;TRY FOR ENOUGH
	JRST SG2		;CAN'T GET IT, GIVE HIM UP TO USRREL
SGCOR1:
	MOVN TAC,JOBCOR(PROG)
	JRST SGCOR2

SGCOR:
	HRRZ TAC,JOBFF(JDAT)	; PICK UP FIRST FREE LOCATION
	CAMLE TAC,USRREL(PID)	; IS IT IN BOUNDS?
	JRST SG2		; NO, USE HIGHEST RELOCATABLE ADDRESS
	JUMPE TAC,SG2		; ZERO IS PRETTY SILLY TOO
	MOVNS TAC		; NEGATE TO FORM HALF OF IOWD
	SKIPE USRDDT(PID)	; IF DDT IS IN, SAVE UP TO JOBREL
SG2:
	MOVN TAC,USRREL(PID)	;YES, DUMP ALL OF CORE INSTEAD
SGCOR2:
	ADDI TAC,JOBSAV		;LOWER CORE NOT DUMPED
	HRLI TAC,JOBSAV
	MOVSM TAC,DMPWRD(PROG)	;STORE IOWD WORD OF THIS SIZE CORE

; COMMON SAVEGET ROUTINE, OPEN FILE, DO LOOKUP (ENTER?)

	OPEN 0,MODWRD		;TRY TO ASSIGN DEVICE
	JRST SGERRA		;NOT AVAILABLE
	MOVE TAC1,DEVNAM(DEVDAT)
	MOVEM TAC1,JOBDEV(ITEM)
	MOVE TAC1,DEVLOG(DEVDAT)
	MOVEM TAC1,JOBLOG(ITEM)
	MOVE TAC1,DEVMOD(DEVDAT)
	HLRZ TAC,FILEXT(PROG)	;CHECK FOR DMP
	CAIN TAC,'DMP'
	TLNN TAC1,DVDTA		;IS IT ON DTA?
	JRST .+2
	MOVEI TAC,SAVDMP	;YES. CHANGE TO "SAV" IF WE HAVE
	HRLM TAC,FILEXT(PROG)	;"RECLAIMING FORMAT" DECTAPES
	MOVE AC1,JOBPPN(ITEM)	; GET PROJECT-PROGRAMMER NUMBER
	MOVEM AC1,FILLEN(PROG)	; SET IT INTO PLACE
	TLNN TAC1,DVDSK		; IS THIS A DISK?
	MOVEM TAC,FILLEN(PROG)	; NO, STORE WORD COUNT
	LOOKUP 0,FILNAM		;LOOKUP FILE NAME
	SOS (PDP)		;NOT FOUND
	MOVE TAC,DMPWRD(PROG)	;FOUND, RETURN IOWD FOR THIS SIZE CORE
	MOVE TAC1,DEVMOD(DEVDAT)
	MOVE ITEM,JOB(PID)	; RESTORE JOB NUMBER FOR THOSE WHO NEED IT
	TLNE TAC1,DVDSK
	JRST SG3
	SETZM JOBPPN(ITEM)
	JRST CPOPJ1
SG3:
	MOVE AC1,FILPPN(DEVDAT)
	EXCH AC1,JOBPPN(ITEM)
	JRST CPOPJ1		;SKIP RETURN, UNLESS FILE NOT FOUND

; COME HERE ON SAVE DEVICE NOT AVAILABLE
; PRINT ERROR MESSAGE AND STOP JOB

SGERRA:
	JUMPE DEVDAT,SGERR1
	MOVEM DEVDAT,(PDP)	; PRINT DEVICE XXX
	PUSHJ PDP,TTYFNU	; FIND TTY
	PUSHJ PDP,PRQM
	PUSHJ PDP,CRLF
	PUSHJ PDP,ERNAM	
	JSP TAC,PHOLD		;PRINT AND STOP JOB
	ASCIZ / NOT AVAILABLE/

SGERR1:
	PUSHJ PDP,TTYFNU
	JSP	TAC,PHOLD
	ASCIZ	/?
NO SUCH DEVICE/

;ROUTINE TO SET DUMP MODE COMMAND LIST IN USER AREA
;AND CHECK TO SEE IF ROOM IN CORE
;THEN EXECUTE INPUT OR OUTPUT UUO,RELEASE DEVICE AND CHECK FOR
;ERRORS
;CALL:	PUSHJ PDP,SGDO
;	INPUT 0,FILLEN OR OUTPUT 0,FILLEN
;	OK RETURN(NO ERRORS)



SGDO:
	SETZM DMPEND(PROG)		;SET 2ND WORD OF DUMP LIST TO 0
	HLRO TAC,FILLEN(PROG)		;GET - NO. WORDS TO READ OR WRITE
	SUBI TAC,JOBSAV			;NO. OF LOWER CORE LOC. NOT DUMPED
	ADD TAC,USRREL(PID)		;HIGHEST LOC. IN USER AREA
	JUMPL TAC,NOROOM		;WILL IT FIT?
	MOVEM DEVDAT,USRHCU(PID)	;SET HIGHEST IO CHAN IN USE NEGATIVE
					;ALSO ADDRESS OF SAVE GET DEVICE.
	XCT @(PDP)			;EXECUTE INPUT OR OUTPUT UUO
					;READ INTO PROTECTED PART OF JOB DATA AREA
	PUSHJ PDP,CLRUSR		;CLEAR OUT POSSIBLE GARBAGE
					;AND SET USRHCU BACK TO 0
	MOVEM DEVDAT,USRJDA(PID)	;RESTORE CHANNEL 0 ASSIGNMENT
	PUSH P,IOS			;SAVE POSSIBLE ERROR BITS
	PUSHJ PDP,SGREL			;RELEASE DEVICE,FIND TTY
	MOVE TAC,JOBS41(JDAT)		;RESTORE USER UUO JSR LOC.
	MOVEM TAC,JOB41(JDAT)		;IN CASE THIS IS GET OR RUN
	POP P,TAC			;GET BACK BITS
	TRNN TAC,IOBKTL+IODERR+IODTER+IOIMPM		;ANY ERRORS ON SAVE-GET DEVICE?
	JRST CPOPJ1			;NO, GIVE OK RETURN
SGTERR:
	JSP TAC,PHOLD			;YES, PRINT MESS. AND STOP JOB
	ASCIZ \?
SAVE/GET IO ERROR\

NOROOM:
	PUSHJ PDP,SGREL			;RELEASE DEVICE, FIND TTY
	PUSHJ PDP,PRQM
	PUSHJ PDP,CRLF
	SKIPLE TAC,JOBCOR(JDAT)		;GET MIN. HIGHEST REL.LOC. FOR JOB TO RUN
	JRST NOROM1			;USE IT IF SPECIFIED.
	HLRO TAC1,FILLEN(PROG)		;-LENGTH OF FILE
	MOVNS TAC1			;+LENGTH
	HRRZ TAC,FILLEN(PROG)		;FIRST LOC-1 DUMPED
	ADD TAC,TAC1			;LAST LOC DUMPED
NOROM1:
	LSH TAC,-12			;CONVERT TO NO. OF 1K BLOCKS-1
	ADDI TAC, 1
	PUSHJ PDP,RADX10
	JSP TAC,PHOLD			;GO START TTY, AND STOP JOB
	ASCIZ /K OF CORE NEEDED/

;ROUTINE TO RELEASE DEVICE AND FIND TTY



SGREL:
	SKIPN USRJDA(PID)	;HAS CHANNEL BEEN RELEASED ALREADY?
	JRST TTYFUW		;YES. FIND TTY AND WAIT FOR OUTPUT TO FINSIH
	MOVE TAC,DEVMOD(DEVDAT)
	TLNE TAC,DVMTA		;MAGTAPE?
	TLNN DEVDAT,INPB	;YES. WAS AN INPUT DONE?
	JRST SGREL1		;NO
	CLOSE 0,CLSOUT		;YES. CLOSE INPUT.
	STATO 0,IOTEND		;AT END OF TAPE?
	MTAPE 0,6		;NO. SKIPTO EOF
SGREL1:
	RELEASE 0,		;NO, RELEASE DEVICE
	JRST TTYFUW		;FIND TTY AND WAIT FOR OUTPUT TO FINISH

;ROUTINE TO GET FILE FROM DEVICE


GETJB:
	PUSHJ P,RESETSEG	; FLUSH HIS UPPER SEGMENT IF ANY
	SETZM JOBINT(JDAT)	; THIS WON'T GET CLEARED BY DMP FILE--RPH 1-6-74
	MOVE TAC,FILDAT(PROG)
	MOVEM TAC,JOBCRD(J)	;COPY CREATION DATE FOR SEGMENT ACCESS
	MOVE TAC,DMPWRD(PROG)
	TLNE TAC1,DVDSK		;DISK?
	HRRM TAC,FILLEN(PROG)	;YES.
	HRRZ TAC,JOBCOR(PROG)	;HIGHEST REL.LOC. REQUESTED
	MOVEM TAC,NEWCOR(PROG)	;SAVE IT
	SETZM JOBCOR(PROG)	;CLEAR JOBCOR SO NOROOM MESSAGE ALWAYS WORKS
	JUMPG TAC,GETJB1	;WAS CORE SPECIFIED IN COMMAND STRING?
	TLNE TAC1,DVMTA		;MAGTAPE?
	JRST GETJB3
	HLRO TAC1,FILLEN(PROG)	;NO, USE AMOUNT SPECIFIED IN DIRECTORY
	JUMPGE TAC1,GETERR	;DUMP FILE?
	HRRZ TAC,FILLEN(PROG)	;FIRST LOC.-1
	SUB TAC,TAC1		;TOTAL NO. OF WORDS NEEDED - 1=
				;HIGHEST LOCATION DUMPED.
	IORI TAC,1777		;HIGHEST LOC. IN 1K BLOCKS
GETJB1:
	MOVE ITEM,JOB(PID)	;SETUP JOB NUMBER
	PUSHJ PDP,RUNCOR	;TRY TO ASSIGN CORE
	JRST NOROOM		;PRINT NO. OF BLOCKS NEEDED
	MOVE TAC1,DEVMOD(DEVDAT)
	TLNN TAC1,DVMTA		;MAGTAPE?
	JRST GETJB2		;YES
GETJB3:
	HLRZ TAC1,PROG		;NO. SET FILLEN TO CURRENT CORE SIZE.
	SUBI TAC1,JOBSAV
	MOVNS TAC1
	HRLI TAC1,JOBSAV
	MOVSM TAC1,FILLEN(PROG)
GETJB2:
	PUSHJ PDP,SGDO		;DO INPUT, RELEASE, FIND TTY
	 INPUT 0,FILLEN		;EXECUTED FROM SGDO
	MOVE TAC,JOBPPN(J)
	MOVEM TAC,FILLEN(PROG)	;RESTORE PPN FOR PROG TO SEE
	HLRZ TAC,HILOC(JDAT)	;SEGMENT PROTECTION SAVED HERE
				;IF NO SEGMENT WAS SAVED, PROT WILL BE 0.
	ANDI TAC,377		;FLUSH UNUSED BITS
	DPB TAC,[POINT 9,JOBCRD(J),8]

;HERE WE DISCOVER IF WE HAVE A HIGH SEGMENT TO SET-UP
;FIRST TRY TO ATTACH TO THE SAVED NAME (IF ANY)
;MAKE SURE IT IS WRITE PROTECTED, AND THAT IS WHAT WE WANT
;IF ALL THIS FAILS, TRY A REMAP ON OUR SEGMENT.

	SKIPN TAC,HILOC(JDAT)	; DOES THIS JOB HAVE A HIGH SEGMENT?
	JRST GETDN1		; NO, FIX UP CORE SIZE AND LEAVE
	TLZ TAC,777777		;ONLY INTERESTED IN RIGHT HALF
	IORI TAC,1777		;WHERE IT WILL BE MOVED TO
	CAML TAC,USRREL(PID)	;ADDRESS ABOVE TOP
	JRST GETERA		;YES, EVIL EVIL(NOT A DUMP FILE)
	PUSH P,DDB		;DDB CLOBBERED BY SEGMENT UUOS
	SKIPN TAC,HINAME(JDAT)	;GET SAVED HIGH SEGMENT NAME!
	JRST GETJ5
	MOVEM TAC,FILLEN(PROG)
	ATTSEG FILLEN,		;ATTACH TO IT?
	JRST GETJ5
	LDB TAC,PSEGN		;GET ITS JOB NUMBER
	MOVE TAC,JBTSTS(TAC)
	SKIPL HILOC(JDAT)	;DO WE WANT WRITE PROT?
	JRST GETJ7
	TLNE TAC,JWP		;YES, IS HE WRITE PROTECTED
	JRST GETDON		;PROT MATCHES
	JRST GETJ8
GETJ7:
	TLNN TAC,JWP		;IS HE UNPROTECTED?
	JRST GETDON		;THAT'S IT!
GETJ8:
	DETSEG			;DETACH THIS ONE
GETJ5:
	HRRZ TAC,HILOC(JDAT)	;CURRENT BOTTEM OF SEGMENT
	SUBI TAC,1
	PUSHJ P,BLTUP		;MOVE UPPER TO NEXT 1K BOUNDARY
	MOVE TAC,HILOC(PROG)
	SUBI TAC,1
	IORI TAC,1777
	MOVEM TAC,FILLEN(PROG)
	REMAP FILLEN,		; REMAP US
	CAIA
	JRST GETDN2

;END OF GET, REMAP ERROR, SETPR2 KLUDGE

	POP P,DDB		;GET BACK TTY DDB
	MOVEI DAT,TTOBUF(DDB)	;AND SET UP THIS GUY
	PUSHJ P,INLMES
	ASCIZ /
COULDN'T GET YOU A SEGMENT.  WILL TRY TO LET YOU WIN WITH SETPR2.
/
	HLRZ TAC,PROG
	MOVEM TAC,JOBCOR(PROG)	;DON'T LET HIM CORE DOWN BELOW UPPER
	ADDI TAC,1
	MOVEM TAC,JOBFF(PROG)	;AND TELL HIM NOT TO WRITE OVER IT
	HRLM TAC,JOBSA(PROG)	;IN BOTH WAYS
	SUB TAC,FILLEN(PROG)	;LENGTH OF UPPER+1
	MOVSI TAC,-2(TAC)
	SKIPL HILOC(PROG)
	TLZ TAC,1		;SET UP W.P. BIT
	HRR TAC,FILLEN(PROG)
	ADDI TAC,1+3		;REMOVE OFFSET AND SET "RELATIVE" & "PSEUDO-UPPER" BITS
	PUSHJ P,STPR2
	JRST GETDN1

GETERR:
	PUSHJ PDP,SGREL		;RELEASE DEVICE AND FIND TTY
GETERA:
	JSP TAC,PHOLD
	ASCIZ /?
NOT A DUMP FILE/

GETDN2:
	SKIPN TAC,HINAME(JDAT)
	JRST GETDON
	LDB TAC1,PSEGN
	MOVE DDB,NJOBS(TAC1)
IFE FTSTAT,<CAIG DDB,1		;MORE THAN ONE JOBS MEANS WE'RE NOT THE FIRST
	MOVEM TAC,JOBNAM(TAC1)
>;IFE FTSTAT
IFN FTSTAT,<
	CAILE DDB,1
	JRST GETDON
	MOVEM TAC,JOBNAM(TAC1)
	PUSH P,J
	MOVE J,TAC1
	PUSHJ P,NAMSTT
	POP P,J
>;FTSTAT
GETDON:
	POP P,DDB		;GET BACK TTY DDB
	MOVEI DAT,TTOBUF(DDB)
GETDN1:
	SKIPE TAC,NEWCOR(PROG)	;DID USER TYPE 3RD ARGUMENT?
	CAMG TAC,JOBCOR(JDAT)	;YES, IS 3RD ARG GREATER THAN
				;MIN SIZE SPECIFIED BY THIRD
				;ARG TO SAVE (IF ANY)?
	MOVE TAC,JOBCOR(JDAT)	;NO, ASSIGN NEW BIGGER AMOUNT OF CORE
	JUMPLE TAC,CPOPJ	; IF 0 OR NEG, DOESN'T MAKE SENSE.
	IORI TAC,1777
	HLRZ TAC1,PROG		; HOW MUCH DOES HE HAVE NOW
	CAMN TAC1,TAC		; DIFFERENT?
	POPJ P,			;NO
	PUSHJ PDP,RUNCOR
	JFCL			;IGNORE IF CAN'T
	POPJ P,

; ROUTINE TO STUFF A FILE ON A DEVICE

SAVJB:
	SETZM NEWCOR(PROG)	;SIGNAL NO SAVE OF UPPER SEGMENT
	CAIA
				; RESTORE PROJECT-PROGRAMMER NUMBER
SSAVJA:
	SETOM NEWCOR(PROG)	;FLAG TO SAVE UPPER(IF ANY)
	MOVEM AC1,FILLEN(PROG)	; TO THE LAST WORD OF THE LOOKUP BLOCK
				; PLEASE NOTE THAT THIS MEANS THAT YOU CAN'T CLOBBER TAC OR AC1 BETWEEN CALLS ON SG1 AND SAVJB
	TLNN TAC1,DVDSK		;DISK?
	MOVEM TAC,FILLEN(PROG)	;NO. SET FILE LENGTH IN DIRECT. HEADER
	SETZM FILDAT(PROG)	;MAKE SURE WE GET TODAY'S DATE
	TLNE TAC1,DVDSK		;DISC?
	CLOSE 0,CLSOUT		;YES, CLOSE INPUT
	ENTER 0,FILNAM		;ENTER FILE NAME IN DIRECTORY
	JRST SAV4		;DIRECTORY FULL
	MOVE TAC,DMPWRD(PROG)	;RESTORE FILLEN AFTER DISC ENTER
	MOVEM TAC,FILLEN(PROG)
	MOVE TAC,JOB41(JDAT)	;SAVE USER UUO HANDLING JSR
	MOVEM TAC,JOBS41(JDAT)	;IN UPPER PART OF JOB DATA AREA
	SKIPN NEWCOR(PROG)	;SHALL WE SAVE UPPER?
	JRST SAVJ1		;NO
	LDB TAC,PSEGN
	JUMPE TAC,SAVJ1
	HLRZ TAC1,JBTADR(TAC)
	ADDI TAC1,1
	MOVNS TAC1
	MOVSS TAC1
	HRRI TAC1,377777
	MOVEM TAC1,NEWCOR(PROG)
	HLRO TAC1,FILLEN(PROG)
	SETCM TAC1,TAC1		;COMPUTE +(LENGTH OF FIRST PART)-1
	IORI TAC1,177		;MAKE IT A DISK BLOCK BOUNDARY-1
	ADDI TAC1,JOBSAV+1+1	;ROUNDING UP AND MAKING INTO CORE LOC
	LDB TAC,PSEGN
	LDB TAC,[POINT 9,JOBCRD(TAC),8]
	HRL TAC1,TAC		;SET SEGMENT PROT BITS IN LEFT HALF OF JOBRL2 TO GET SAVED
	LDB TAC,PSEGN		;GET THIS BACK
	MOVE TAC,JBTSTS(TAC)
	TLNE TAC,JWP
	TLO TAC1,(1B0)
	MOVEM TAC1,JOBRL2(PROG)	;MAKE COMPATIBLE
	MOVEM TAC1,HILOC(PROG)

; SAVE ROUTINE

	LDB TAC,PSEGN		;AND AGAIN
	MOVE TAC,JOBNAM(TAC)
	CAMN TAC,JOBNAM(J)	;SAME NAMED UPPER AS LOWER
	SETZ TAC,		;YES, FLAG AS SUCH
	MOVEM TAC,HINAME(JDAT)	;SAVE IN THIS NEW PLACE!
	JRST SAVJ3

SAVJ1:
	SETZM HILOC(JDAT)
	SETZM JOBRL2(PROG)
	SETZM HINAME(JDAT)
	SETZM NEWCOR(JDAT)	;MAKE SURE NO SAVE HAPPENS!
SAVJ3:
	SETZM DMPEND(PROG)
	HLRO TAC,FILLEN(PROG)
	SUBI TAC,JOBSAV
	ADD TAC,USRREL(PID)
	JUMPL TAC,NOROOM
	HLRO TAC,FILLEN(PROG)
	MOVNS TAC
	ADDI TAC,JOBSAV
	MOVEM TAC,JOBCOR(PROG)	;MAKE SURE HE GETS TO BE RIGHT SIZE WHEN HE COMES BACK IN
	OUTPUT 0,FILLEN
	TRNE IOS,IOBKTL!IODERR!IODTER!IOIMPM
	JRST SGTERA
	SKIPN NEWCOR(PROG)
	JRST SGREL
	SETZM NEWCOR+1(PROG)
	OUTPUT 0,NEWCOR
	LDB TAC,PSEGN
	JUMPE TAC,SAVJ2
	HLRZ TAC1,JBTADR(TAC)
	TRO TAC1,400000
	MOVEM TAC1,HILOC(PROG)
	MOVEM TAC1,JOBRL2(PROG)
SAVJ2:
	TRNN IOS,IOBKTL!IODERR!IODTER!IOIMPM
	JRST SGREL
SGTERA:
	PUSHJ P,SGREL
	JRST SGTERR

SAV4:
	PUSHJ PDP,SGREL		;RELEASE,DEVICE, FIND TTY
	JSP TAC,PHOLD		;PRINT MESSAGE AND STOP JOB
	ASCIZ /?
ENTER FAILED!/

BEGIN SEGCSS 
 SUBTTL	SEGCSS	8 SEPT 69	JAM
; SEGMENT ACCESS CONTROL
; PUT JOB NUMBER OF MASTER ON STACK AND NUMBER OF SEGMENT IN J
; CALLING . . .
;	PUSH PDP,ITEM
;	MOVE ITEM,<SEGMENT NUMBER>
;	PUSHJ PDP,ACCESS
;	<NO ACCESS POSSIBLE>
;	<READ ACCESS ONLY>
;	<ALL ACCESS LEGAL>

↑ACCESS:MOVE TAC,-1(P)		; PICK UP MASTER JOB NUMBER
	MOVE TAC1,JBTPRV(TAC)	; GET PRIV BITS OF MASTER
	TLNE TAC1,SEGPRV	; DO WE HAVE THE PRIVILEGE?
	JRST CPOPJ2		; YES, AUTOMATIC SUCCESS
	MOVE TAC1,PRJPRG(TAC)
	LDB TAC,[POINT =9,JOBCRD(J),8]
	TRZE TAC,400		;UNPURIFIED?
	JRST ACCES2		;YES - DIFFERENT TEST (TAC IS NOW JOB # OF DEFILER)
	CAMN TAC1,JOBPPN(J)	; IS THIS THE SAME JOB?
	JRST ACCES1		; YES, USE OWNER'S PROTECTION
	XOR TAC1,JOBPPN(J)
	TRNE TAC1,-1		;SAME PROGRAMMER?
	LSH TAC,3		; NO, MOVE OVER TO GENERAL PROTECTION
	LSH TAC,3		; MOVE OVER TO PROGRAMMER PROTECTION
ACCES1:
	TRNN TAC,300		; NOW, IS THERE ANY PROTECTION?
	JRST CPOPJ2		; NO, EVERYTHING GOES
	TRNN TAC,200		; IS IT READ PROTECTED?
	AOS (P)			; NO, IT CAN BE READ
	POPJ P,			; OTHERWISE INACCESSABLE

ACCES2:
	CAMN TAC,-1(P)		;ONLY ORIGINAL OWNER WINS HERE
	JRST CPOPJ2
	POPJ P,

; ROUTINE TO INVENT AN UPPER SEGMENT
; SKIP RETURNS WITH JOB NUMBER OF SEGMENT IN J; NON SKIP IF JOB CAPACITY EXCEEDED
; SETS CORE SIZE TO ZERO, SETS PPN TO *SEG*, SETS AS DETATCHED

↑ESTSEG:
	MOVEI	J,1
	MOVSI	TAC,JNA!JLOG!JACCT!CMWB		;JNA IS PROBABLY ENOUGH
ESTSE1:
	TDNN	TAC,JBTSTS(J)			;SKIP IF JOB SLOT IN USE.
	JRST	ESTSE2				;WE HAVE A SLOT TO USE.
	CAMGE	J,JOBNM1			;HAVE WE SEEN ALL SLOTS?
	AOJA	J,ESTSE1			;NOT YET.
	MOVEI	J,0				;RETURN A ZERO
	POPJ	P,				;FAILURE.

ESTSE2:

		SKIPE	JBTADR(J)	;BUG TRAP
		PUSHJ	P,INIJXX	;MAKE LOSE MESSAGE
	SETZM	JBTADR(J)			;NO CORE ANYWHERE.
	MOVSI	TAC,JSEG!JNA!JLOG		;SET SEGMENT, SLOT USED, LOGGED IN
	IORM	TAC,JBTSTS(J)			;IN JOB STATUS FOR SEGMENT
	SETZM	NJOBS(J)			;NO ONE USING THIS UPPER YET
	SETOM	JBTLIN(J)			;DETACHED
	SETZM	TTIME(J)			;NO RUN TIME FOR THIS UPPER
	SETZM	XTIME(J)			;NO XTIME
	SETZM	DSKOPS(J)			;NO DISK OPS
	MOVE	TAC,TIMDAT
	MOVEM	TAC,FTIME(J)			;SET UP JOB LAST RUN TIME.
	MOVE	TAC,[SIXBIT /*SEG*/]		;PPN = *SEG*
	MOVEM	TAC,PRJPRG(J)
	MOVEI	TAC,STOPQ			;QUEUE US INTO THE STOPQ
	MOVNM	TAC,JOBQUE(J)
	AOS	(P)				;SETUP SKIP RETURN
	JRST	REQUE

; THIS ROUTINE DEFINES A SEGMENT. IT SEARCHES FOR AN EXISTING
; SEGMENT FIRST WITH THE PROPER CREDENTIALS AND GIVES YOU ITS NUMBER FIRST.
; OTHERWISE, IT MAKES ONE UP AND PUTS YOUR ID IN ITS CREDENTIALS. RETURNS
; THE NUMBER OF THE SEGMENT IN JBTSTS, 0 FOR FAILURE.

↑LINKSEG:
	PUSHJ	P,KILSEG	;GET RID OF EXISTING UPPER.
	PUSH	P,J
	MOVE	AC1,J		; SAVE NUMBER OF MASTER JOB
	MOVE	J,JOBNM1
DEFSE1:
	MOVE	TAC,JBTSTS(J)	;LOOK FOR AN UPPER.
	TLNN	TAC,JSEG
	JRST	DEFSE2		;NOT AN UPPER. SKIP IT.
	MOVE	TAC,JOBNAM(J)
	MOVE	TAC1,JOBPPN(J)
	CAMN	TAC,JOBNAM(AC1)	;DOES THE JOB NAME MATCH?
	CAME	TAC1,JOBPPN(AC1);AND DOES THE PROJ-PROG NAME MATCH?
	JRST	DEFSE2		; NO
	MOVE	TAC,JOBCRD(J)
	MOVE	TAC1,JOBDEV(J)
	CAMN	TAC,JOBCRD(AC1)	;DOES THE CREATION DATE AND PROTECTION MATCH?
	CAME	TAC1,JOBDEV(AC1);AND DOES THE DEVICE MATCH?
	JRST	DEFSE2		;NO
	MOVE	TAC,JOBLOG(J)	;CHECK LOGICAL NAME TOO
	CAMN	TAC,JOBLOG(AC1)
	PUSHJ	P,ACCESS	;NOW, CAN WE LEGALLY ACCESS THIS SEGMENT?
	JRST	DEFSE2		;NO
	JFCL
DEFSE3:
	MOVE	TAC,J
	POP	P,J
	DPB	TAC,PSEGN
IFN FTSTAT, <PUSHJ P,SEGSTT
	LDB TAC,PSEGN
>
	AOS	NJOBS(TAC)	;BUMP COUNT OF NUMBER OF PEOPLE POINTING TO HIM
	SKIPE	TAC
	AOS	(P)
SEGXIT:
	CAME J,JOB(PID)
	JRST SEGXT1
	PUSHJ P,GETPR
	DATAO APR,TAC
SEGXT1:
	POPJ P,

DEFSE2:
	SOJG J,DEFSE1
	POP P,J
	POPJ P,

↑MAKESEG:
	PUSHJ	P,KILSEG
	PUSH	P,J
	PUSHJ	P,ESTSEG	; IF NO EXISTING ONE, MAKE ONE UP
	JRST	DEFSE3		; IF NOT AVAILABLE, JUST LEAVE
	MOVE	TAC,J		;SAVE SEGMENT NUMBER
	POP	P,J
	DPB TAC,PSEGN
IFN FTSTAT,<
	PUSHJ P,SEGSTT
	LDB TAC,PSEGN
>;FTSTAT
↑MAKSE2:AOS NJOBS(TAC)		; BUMP COUNT OF PEOPLE POINTING TO HIM
	MOVE TAC1,JOBNAM(J)	; NOW ESTABLISH ITS CREDENTIALS
	MOVEM TAC1,JOBNAM(TAC)
IFN FTSTAT,<
	PUSH P,J
	MOVE J,TAC
	PUSHJ P,NAMSTT
	POP P,J
>;FTSTAT
	MOVE TAC1,JOBPPN(J)
	MOVEM TAC1,JOBPPN(TAC)
	MOVE TAC1,JOBCRD(J)
	MOVEM TAC1,JOBCRD(TAC)
	MOVE TAC1,JOBDEV(J)
	MOVEM TAC1,JOBDEV(TAC)
	MOVE TAC1,JOBLOG(J)
	MOVEM TAC1,JOBLOG(TAC)
	POPJ P,

; ROUTINE TO KILL A HIGH SEGMENT
; ENTER WITH JOB NUMBER OF OWNER IN J
; IF OTHER PEOPLE POINT TO IT, IT WILL REMAIN
; IF NO-ONE ELSE POINTS TO IT, IT WILL GO AWAY

↑↑KILSEG:
	SKIPE	JBTPR2(J)		;IS HE DOING PEEK-POKE?
	JRST	[SETZM	JBTPR2(J)	;YES, MUST KILL IT HERE
		JRST	SEGXIT]
	PUSH	P,J			;SAVE JOB NUMBER.
	LDB	J,PSEGN			;GET OUR SEGMENT NUMBER
	JUMPN	J,KILSE6		;JUMP IF THERE IS A SEGMENT
	POP	P,J			;THERE'S NO SEGMENT. FORGET IT
	POPJ	P,

KILSE6:
	PUSH	P,J			;SAVE SEGMENT NUMBER.
	SKIPA	J,JOBNM1		;SEARCH FOR ANY OTHERS POINTING HERE
KILSE3:
	SOJLE	J,KILSE1		;DECREMENT J. JUMP IF JOB LIST EXHAUSTED
	CAMN	J,-1(P)			;IS THIS THE CURRENT JOB?
	JRST	KILSE3			;YES. WE KNOW ABOUT HIM, SO SKIP IT.
	LDB	TAC,PSEGN
	CAMN	TAC,(P)			;DOES HE POINT TO OUR SEGMENT?
	JRST	KILSE4			;YES. - DON'T KILL SEGMENT.
KILSE7:
	SKIPN	AC1,JBTDTS(J)		;DOES THIS GUY HAVE A DETACHED SEGMENT LIST?
	JRST	KILSE3			;NO.
KILSE5:
	LDB	TAC,PDSEGN		;LOOK THRU DET SEG LIST
	JUMPE	TAC,KILSE3		;JUMP WHEN DET SEG LIST IS EMPTY
	CAME	TAC,(P)			;SAME AS THIS SEGMENT?
	AOJA	AC1,KILSE5		;NO. KEEP LOOKING.
KILSE4:
	POP	P,J			;SOMEONE ELSE POINTS TO THIS SEGMENT
KILSE2:
	SOSGE	NJOBS(J)
	PUSHJ	P,[
		PUSHACS
		PUSHJ	P,DISMES
		ASCIZ	/NJOBS WENT NEGATIVE AT KILSE2
/
		POPACS
		SETZM	NJOBS(J)
		POPJ	P,]
	POP	P,J			;POP CURRENT JOB NUMBER
	MOVEI	TAC,0
	DPB	TAC,PSEGN		;ZERO SEGMENT FIELD
IFN FTSTAT,<
	PUSHJ P,SEGSTT
	LDB TAC,PSEGN
>;FTSTAT
	JRST	SEGXIT

;HERE  IF THERE ARE NO FURTHER REFERENCES TO THIS SEGMENT.
KILSE1:
	POP	P,J			;GET THE SEGMENT NUMBER
	PUSHJ	P,ZEROSEG		;EXPUNGE SEGMENT
	MOVE	TAC,NJOBS(J)
	CAIE	TAC,1			;THERE SHOULD BE ONLY 1 POINTER TO THIS
	PUSHJ	P,NZERR
	JRST	KILSE2

NZERR:
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/NJOBS NOT ZERO AT KILSEG
/
	POPACS
	POPJ	P,

; ROUTINE TO ERASE A SEGMENT ENTIRELY

ZEROSEG:
PUSH	P,JDAT
ZERO1:
	MOVE	JDAT,JBTADR(J)
	SETZM	TAC
	PUSHJ	P,CORE0			;GIVE BACK THIS SEGMENT'S CORE
	JRST	ZERO5
	MOVE	TAC,JOBNM1		;LOOK FOR FATHER JOB.
ZERO3:
	LDB	TAC1,[POINT 6,JBTSTS(TAC),35]
	CAME	TAC1,J
ZERO4:
	SOJG	TAC,ZERO3
	JUMPE	TAC,ZERO2
	SKIPN	JBTST2(TAC)		; WAS THERE A SPW MODULE HERE
	JRST	ZERO4			; NO.
	MOVSI	TAC1,SPWST1!SPWST2	; YES, CLEAR THE SPACEWAR STOPPED BITS
	PSYNC	SPWCSC
	ANDCAM	TAC1,JBTST2(TAC)
	XSYNC	SPWCSC
	JRST	ZERO4			;THERE AREN'T SUPPOSED TO BE ANY MORE ...

ZERO2:
	MOVSI	TAC,JSEG!JWP!JNA!JLOG!JACCT!RUN
	ANDCAM	TAC,JBTSTS(J)
	SETZM	JOBNAM(J)
	SETZM	PRJPRG(J)
	MOVEI	TAC,NULQ
	MOVNM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
	PUSHJ	P,FBFLUSH
	POP	P,JDAT
	POPJ	P,

ZERO5:
	PUSHJ	P,WSCHED		; WAIT FOR SPW TO STOP.
	JRST	ZERO1

; ROUTINE TO FLUSH A JOB'S HIGH SEGMENT AND ALL THE SEGMENTS HE MAY HAVE
; PREVIOUSLY DETACHED, IF AND ONLY IF NO ONE ELSE IS POINTING AT THEM.
; CALL FROM UUO OR CLOCK LEVEL ONLY!!!!!!

↑↑FLUSHSEG:
	PUSHJ	P,KILSEG		;KILL HIS IMMEDIATE UPPER
	SKIPN	AC1,JBTDTS(J)		;IS THERE A DET SEG LIST?
	POPJ	P,			;NO. THIS IS EASY.
	PUSH	P,J			;SAVE CALLING JOB'S NUMBER
FLUSH1:
	MOVE	J,(AC1)			;GET THE NUMBER OF THE DETACHED SEGMENT
	JUMPE	J,FLUSH2		;JUMP IF THERE ARE NO MORE.
	JUMPL	J,FLUSH6		;JUMP IF THIS IS SPECIAL DETACHED.
	MOVE	TAC1,JOBNM1
	ANDI	J,77			;SEGMENT NUMBER ONLY.
FLUSH3:
	LDB	TEM,[POINT 6,JBTSTS(TAC1),35]		;DO OTHERS POINT HERE?
	CAMN	TEM,J			;DIRECT MATCH?
FLUSH6:
	AOJA	AC1,FLUSH1		;YES. CAN'T BE FLUSHED.
	CAME	TAC1,(P)		;DON'T MATCH AGAINST OUR OWN JOB
	SKIPN	DAT,JBTDTS(TAC1)	;DOES THIS JOB HAVE A DETACH LIST?
	JRST	FLUSH5			;NO, GO TO NEXT JOB
FLUSH4:
	LDB	TEM,[POINT 6,(DAT),35]	;YES, PICK UP ITS SEGMENT NUMBER
	JUMPE	TEM,FLUSH5		;JUMP IF END OF LIST
	CAMN	TEM,J			;DOES HE POINT TO US?
	AOJA	AC1,FLUSH1		;YES, CAN'T ZERO THIS SEGMENT
	AOJA	DAT,FLUSH4		;NO, TRY NEXT DETACHED SEGMENT

FLUSH5:
	SOJG	TAC1,FLUSH3		;LOOP AROUND FOR NEXT JOB
	MOVE	TAC,JBTSTS(J)		;NOW, DOES THIS SEGMENT STILL EXIST?
	TLNN	TAC,JNA
	AOJA	AC1,FLUSH1		;NO, DON'T BOTHER
	PUSH	P,AC1
	PUSHJ	P,ZEROSEG		;WIPE OUT THAT SEGMENT, NO OTHER REFERENCES TO IT
	SKIPE	NJOBS(J)
	PUSHJ	P,NZERR
	POP	P,AC1
	AOJA	AC1,FLUSH1

FLUSH2:
	POP	P,J
	MOVE	AC1,JBTDTS(J)		;SEARCH FOR SPECIAL DET SEG.
	MOVEI	AC2,(AC1)		;AC1 POINTS AT HOLE. AC2 POINTS AT DATUM
FLUSH7:
	SKIPLE	TAC,(AC2)		;SKIP IF SPECIAL OR EMPTY
FLUSH8:
	AOJA	AC2,FLUSH7		;NORMAL DET SEG. GET NEW DATUM
	MOVEM	TAC,(AC1)		;DATUM IS BUBBLED DOWN.
	JUMPE	TAC,FLUSH9		;JUMP IF DONE.
	AOJA	AC1,FLUSH8		;ADVANCE HOLE, ADVANCE DATUM.

FLUSH9:
	CAME	AC1,JBTDTS(J)		;IS HOLE IS STILL IN THE SAME PLACE?
	POPJ	P,			;NO. WE STILL HAVE A DET SEG LIST.
	PUSHJ	P,FSGIVE
	SETZM	JBTDTS(J)
	POPJ	P,

↑↑DSFLUSH:				;MAKE SPECIAL DET SEG INTO ORDINARY.
	SKIPN	AC1,JBTDTS(J)
	POPJ	P,
DSFL1:
	MOVSI	TAC,400000
	ANDCAB	TAC,(AC1)
	JUMPE	TAC,CPOPJ
	AOJA	AC1,DSFL1



; UAPPLY - APPLY A ROUTINE TO ALL LOWERS OF AN UPPER.
;CALL:
;	MOVE	J,<UPPER'S NUMBER>
;	PUSHJ	P,UAPPLY
;	<INSTRUCTION TO XCT>	;J HAS LOWER'S NUMBER, DDB HAS UPPER'S NUMBER
;	RETURN HERE
;THE SUBJECT INSTRUCTION SHOULD NOT SKIP.  NO AC'S ARE CLOBBERED EXCEPT BY
;THE XCT'ED INSTRUCTION.  DDB AND J SHOULD NOT BE USED TO RETURN ARGUMENTS, ETC.

↑↑UAPPLY:	
	PUSH	P,DDB
	PUSH	P,J
	MOVEI	J,JOBN-1
UAPP1:
	LDB	DDB,PJOBN	;GET NUMBER OF THIS LOWER'S UPPER
	CAMN	DDB,(P)
	JRST	UAPP3		;MATCHES.
UAPP2:
	SOJG	J,UAPP1
	POP	P,J
	POP	P,DDB
	JRST	CPOPJ1

UAPP3:
	PUSH	P,J
	XCT	@-3(P)		;J = JOB NUMBER OF LOWER, DDB = JOB NUMBER OF UPPER.
	POP	P,J
	JRST	UAPP2

BEND SEGCSS

SUBTTL	COMCSS	4 AUG 67

;ROUTINE TO RETURN NEXT ALPHANUMERIC STRING
; IN COMMAND LINE (SIXBIT)
;CALL:	MOVE TAC,BYTE POINTER TO PREVIOUS CHAR.
;	PUSHJ PDP, CTEXT
; SIXBIT STRING RETURN LEFT JUSTIFIED IN AC TAC1


↑CTEXT:	PUSHJ PDP,SKIPS		; SKIP LEADING SPACES, TABS, NULLS, AND CLEAR TAC1
	CAIA
↑CTEXT1:
	PUSHJ PDP,SKIPS1
				;DO NOT RETURN IF CR WAS PREVIOUS BREAK
	MOVE UCHN,[POINT 6,TAC1]
	LDB TEM,TAKR(DAT)
	ANDI TEM,177
	CAIG TEM,"Z"+40
	CAIGE TEM,"A"+40
	JRST CTEX1
	SUBI TEM,40
	JRST CTEX1

CTEX0:
	PUSHJ PDP,GETLCCHR
CTEX1:
	PUSHJ PDP, CTEX		;IS IT ALPHANUMERIC
	TRC TEM,40		;CONVERT TO SIXBIT
	TLNE UCHN,770000		; HAVE WE ACCUMULATED 6 CHARS?
	IDPB TEM,UCHN		;NO, STORE AWAY
	JRST CTEX0		; YES

;SCAN FOR ALPHANUMERIC CHAR IN TEM
CTEX:
	CAIL TEM, "0"
	CAILE TEM, "Z"		;LETTERS ARE LARGER THAN NOS.
	JRST CTEXA		;NEITHER
	CAILE TEM, "9"
	CAIL TEM, "A"
	POPJ PDP,		;LETTER OR NUMBER RETURN
CTEXA:

	CAIN TEM,":"		; DEVICE NAME?
	PUSHJ PDP,GETLCCHR	; YES, SKIP COLON
	CAIE TEM,0		; ↑C?
	JRST TPOPJ		; NO, RETURN UP ONE LEVEL
CTXCNC:
	MOVSI TAC1,'HAL'	; CUE UP A PHONY 'HALT'
	MOVEI TEM,12		; TERMINATE WITH LINE FEED
	DPB TEM,TAKR(DAT)	; STORE IN INPUT BUFFER DO ↑C NOT SEEN
	JRST TPOPJ		; AND RETURN UP A LEVEL


↑GETLCCHR:
	PUSHJ P,GETCHR
	CAIG TEM,"Z"+40
	CAIGE TEM,"A"+40
	POPJ P,
	SUBI TEM,40
	POPJ P,

;ROUTINE TO IGNORE LEADING SPACES, TABS, AND NULLS
;ALSO CLEARS TAC1
;DOES NOT RETURN IF PREVIOUS CHAR. OR NEXT NON-SPACING
;CHAR. IS CR(IE POPS SUBROUTINE LEVEL UP 1 ON RETURN)
;CALL:	MOVE TAC,BYTE POINTER TO PREVIOUS BREAK CHAR.
;	PUSHJ PDP, SKIPS1


SKIPSJ:
	PUSHJ P,SKIPS1
	POPJ P,

SKIPS:
	PUSHJ PDP,GETLCCHR	; GET FIRST CHAR ON LINE
SKIPS1:
	MOVEI TAC1,0		; FOR CTEXT AND DECIN
	LDB TEM,TAKR(DAT)	; IN CASE TEM IS CLOBBERED
	ANDI TEM,177
	CAIE TEM,"."		; IF A PERIOD, GET NEXT CHARACTER
	CAIN TEM,15		; SKIP TO L.F. IF C.R.
SKIPSA:
	PUSHJ PDP,GETLCCHR	; GET NEXT CHARACTER
SKIPSB:
	JUMPE TEM,SKIPS3	; LEAVE IF NO MORE CHARS
CAIN TEM,073;;replaced;;CAIN TEM,";"		; STOP HIM AT SEMI-COLON
	JRST SKIPS3		; MAKE IT LOOK LIKE END OF LINE
	PUSHJ PDP,SPCHEK	; IS THIS A SPECIAL CHAR?
	JRST SKIPS2		; NO
	TLNE TAC,BREAKB		; BREAK? END OF LINE?
	JRST SKIPS3		; YES, LEAVE
SKIPS2:
	CAIG TEM,40		; SPACE OR CONTROL CHAR?
	JRST SKIPSA		; YES
	POPJ PDP,		; NO, RETURN

SKIPS3:
	JUMPE TEM,CTXCNC	; ↑C?
	MOVEI TEM,12		; WE USE LINE FEEDS FOR BREAK CHARS
	JRST TPOPJ		; RETURN UP ONE LEVEL

;ROUTINE TO APPEND A "?" TO INPUT STRING AND SET AS OUTPUT
;CALLED FROM OCTIN, RETURNS TO SECOND LEVEL ON PDL
;CALL:	MOVE TAC, BYTE POINTER TO LAST CHAR. IN INPUT STRING
;	PUSHJ PDP, COMERA


↑COMEND:
	PUSHJ P,SKIPS1		; IF ANYTHING LEFT IN INPUT LINE, FALL INTO COMERA
↑COMERP:
	POP PDP,UCHN		; REMOVE SUBROUTINE RETURN BEFORE CALLING COMERA
↑COMERA:
	PUSHJ PDP,GETCHR


;ROUTINE TO REPLACE LAST CHARACTER IN INPUT STRING BY "?"
;AND SET AS OUTPUT
;CALL:	MOVE TAC, BYTE POINTER TO LAST CHAR. IN INPUT STRING
;	PUSHJ PDP, COMERR



↑COMERR:
	MOVE UCHN,TITCTR(DEVDAT)	; SAVE POSITION IN SCAN
	PUSHJ PDP,TRESCN	; BACK UP TO START OF COMMAND
COMERL:
	PUSHJ PDP,GETCHR	; GET A CHARACTER FROM COMMAND LINE
	JUMPE TEM,COMER1	;QUIT ON NULL HERE!
	CAMN UCHN,TITCTR(DEVDAT)	; HAVE WE PASSED A BAD CHAR YET?
	JRST COMER1		; YES
	PUSHJ PDP,OUTCHS	; NO, TYPE CHARACTER
	JRST COMERL		; AND LOOP FOR ANOTHER

COMER1:
	PUSHJ PDP,SETBFI	; CLEAR ANY MORE TYPE IN
	MOVEI TEM,"?"		; APPEND ? TO ERRONEOUS WORD
	PUSHJ PDP,OUTCHS	; AND PRINT IT
	MOVSI J,NOJOBN!NOINCK	;NOW WE PAINSTAKINGLY FAKE OUT COMRET
	IORM J,-1(P)		;*** IF YOU CALL COMERR FROM ANYPLACE THAT
	MOVSI J,NOPER!NOCRLF	;*** DOESN'T HAVE COMRET NEXT ON THE PDL
	ANDCAM J,-1(P)		;*** BOY ARE YOU IN BAD TROUBLE!
	TDZA ITEM,ITEM		; CLEAR JOB NUMBER AND SKIP INTO CRLF ROUTINE

;ROUTINE TO PRINT A COMMAND ERROR MESSAGE
;SAME CALL AS CONMES


				;COMERR SKIPS THIS ROUT.(SEE ABOVE)
↑ERRMES:
	TDZA ITEM,ITEM		; CLEAR JOB NUMBER TO INDICATE ERROR
				;SKIP INTO CONMES ROUTINE

;ROUTINE TO PRINT CARRIAGE RETURN-LINE-FEED
;CALL:	MOVE DAT,BYTE POINTER TO OUTPUT
;	PUSHJ PDP,CRLF


				;COMERR SKIPS TO HERE(SEE ABOVE)
↑CRLF:	MOVEI TAC,[BYTE (7) 15,12,0]

;ROUTINE TO MOVE ASCII CHAR. STRING TO CONSOLE OUTPUT BUFFER
; CALL:	MOVE DAT, BYTE POINTER TO LAST OUTPUT CHARACTER
;	MOVEI TAC,  ADDRESS OF ASCII MESSAGE
;	PUSHJ PDP, CONMES
; STRING TERMINATED BY NULL
; CONMES DOES NOT START TTY

				;ERRMES SKIPS TO HERE
↑CONMES:
	HRLI TAC,440700		; FORM ASCIZ BYTE POINTER
	PUSH PDP,TAC		;SAVE BYTE POINTER
CON0:
	ILDB TEM,(PDP)		;GET NEXT CHAR.
	JUMPE TEM,TPOPJ		;IS IT NULL?(IF YES, DO POP P,TAC, POPJ)
↑TYO:
↑CONTYO:
	PUSHJ PDP,OUTCHS
	JRST CON0		;KEEP GOING

;ROUTINE TO PRINT INLINE ASCIZ MESSAGE - INLMES, PRCRCC, PRCNCC
;CALL:	PUSHJ PDP,INLMES
;	ASCIZ /THE MESSAGE/
;RETURN TO NEXT LOC AFTER MESSAGE


↑INLMES:
	POP PDP,TAC		; SETUP PRINT ADRESS FOR CONMES
	PUSHJ PDP,CONMES
	JRST 1(TAC)		;RETURN TO NEXT LOC AFTER MESSAGE

;ROUTINE TO APPEND ? TO ERROR MESSAGE
;CALL	PUSHJ PDP,PRQM
;	RETURN


↑PRQM:	MOVEI	TEM,"?"
	XCT	TYO
	POPJ	P,

PRSPC:
	MOVEI TAC,[ASCIZ /    /]	;DEC 3.16
	JRST CONMES			;DEC 3.16

;ROUTINE TO PRINT "TOO FEW ARGUMENTS"
;CALL:	MOVE DAT,BYTE POINTER
;	PUSHJ PDP,NOTENF


↑NOTENF:
	JSP TAC,ERRMES

ASCIZ /TOO FEW ARGUMENTS
/

;ROUTINE TO PRINT A PERIOD
;CALL:	PUSHJ PDP,PRPER


↑PRCRCC:PUSHJ P,CRLF
↑PRCNTC:PUSHJ P,INLMES
	ASCIZ /↑C
/
↑PRPER:	MOVEI	TEM,"."
	JRST	OUTCHS


;ROUTINE TO DEASSIGN A DEVICE
;CALL:	MOVE DEVDAT, DEVICE DATA BLOCK
;	MOVE ITEM, JOB NUMBER
;	PUSHJ PDP, DEASG
;	ERROR NOT PREVIOUSLY ASSIGNED
;	OK RETURN WITH DEVICE DEASSIGNED



↑DEASG:	LDB UCHN, PJOBN		;WAS DEVICE ASSIGNED TO THIS JOB?
	CAME UCHN, ITEM
	POPJ PDP,		;NO, RETURN
	PUSH PDP,ITEM		;SAVE JOB NUMBER
	MOVSI UCHN,DVDIRIN		;CLEAR DIRECTORY IN CORE BIT
	ANDCAM UCHN,DEVMOD(DEVDAT)
	SETZM DEVLOG(DEVDAT)	;CLEAR LOGICAL NAME
	MOVEI TAC1,ASSCON	;IS DEVICE ASSIGNED BY CONSOLE?
	TDNE TAC1,DEVMOD(DEVDAT)
	AOS -1(PDP)		;YES, DO OK RETURN
	PUSHJ PDP,RELEA6	;CLEAR JOB NO. IN DDB IF DDB NOT NEEDED
	POP PDP,ITEM		;BY THIS JOB ANY MORE
	POPJ PDP,

;ROUTINE TO DEASSIGN ALL DEVICES EXCEPT LOGICAL TTY
;CALL:	MOVE ITEM, JOB NUMBER
;	MOVE DEVDAT,ADR. OF DEVICE NOT TO BE DEASSIGNED
;	PUSHJ PDP, DEASTY




↑DEASTY:
	HRRZS DDB		; CLEAN OUT THE LH SHIT
	PUSH PDP,DEVDAT		; SAVE TTY DDB ADDRESS
	HLRZ DEVDAT,DEVLST	;SEARCH ALL DDB'S
DEA1:
	CAIE DEVDAT,@(PDP)	;IS THIS DEVICE NOT TO BE DEASSIGNED?
	PUSHJ PDP, DEASG	;NO, TRY TO DEASSIGN IT
	JFCL			;IGNORE IF CAN'T
	HLRZ DEVDAT, DEVSER(DEVDAT)
	JUMPN DEVDAT, DEA1
	POP PDP,DEVDAT		;RESTORE TTY DDB ADDRESS
	POPJ PDP,

;ROUTINE TO READ CONSOLE AND CONVERT ANY RADIX NUMBER
; CALL:	MOVE R,  DESIRED RADIX
;	PUSHJ PDP, ANYRIN
;	NO ARG. TYPED RETURN, TAC1=0
;	ILLEGAL CHARACTER RETURN
;	NORMAL EXIT	;AC TAC1 CONTAINS NUMBER
;SCAN STOPS ON FIRST CR,DASH,SPACE,OR TAB OR ILLEGAL CHAR.
;IF IT IS ILLEGAL CHAR.,SUBROUT. LEVEL IS POPED AND COMERA IS CALLED
;WHICH PRINTS MONITOR COMMAND ERROR. THUS CALLER NEVER SEES RETURN
;SKIPS LEADING SPACES AND TABS



C←BUFPNT			;CHARACTER AC
R←DSER				;RADIX AC

↑DECIN1:
↑DECIN:	MOVEI R,=10		;DECIMAL INPUT
	JRST ANYRIN

↑OCTINS:PUSHJ P,GETLCCHR	;SKIP PRECEEDING + OR -
↑OCTIN:	MOVEI R,10		;OCTAL INPUT
ANYRIN:
	PUSHJ PDP,SKIPS1	;SKIP LEADING SPACES, TABS, NULLS
				;DO NOT RETURN IF CR WAS PREVIOUS BREAK
				;OR THIS BREAK
OCT0:
	CAIL TEM,175		; ALT MODE?
	JRST CPOPJ2
CAIE TEM,073;;replaced;;	CAIE TEM,";"		;SEMICOLON?
	CAIN TEM," "		;SPACE?
	JRST CPOPJ2		;YES, SKIP RETURN
	CAIE TEM,"-"		;NO, DASH?
	CAIN TEM,15		;CR?
	JRST CPOPJ2		;YES, ONLY LEGAL TERMINATORS
	CAIE TEM,","		;COMMA?
	CAIN TEM,"["		;LEFT BRACKET?
	JRST CPOPJ2		;YES.
	SUBI TEM,60
	JUMPL TEM,CPOPJ1	;ERROR IF NEG.,REMOVE SUB. RETURN AND PRINT
	CAML TEM, R		;OR .GE. RADIX
	JRST CPOPJ1		;ERROR, GREATER OR EQUAL TO RADIX
	IMUL TAC1, R
	ADD TAC1,TEM
↑CONTYI:		;PATCHED BY ONCE.
XXTYI:

	PUSHJ PDP,GETCHR
	JRST OCT0

;GET PROJECT-PROGRAMMER NUMBERS
;CALL:	MOVE TAC,INPUT BYTE POINTER
;	PUSHJ PDP,PJPGNO
;	ERROR RETURN
;	OK RETURN
;
;(AC2)LH ← PROJECT NUMBER
;(AC2)RH ← PROGRAMMER NUMBER

IFN FTLOGIN,<
PJPGNO:
	PUSHJ PDP,SKIPS1	;SKIP LEADING BLANKS.
	CAIE TEM,"["		;IS THERE A [?
	POPJ PDP,		;NO. NO PPN.
	PUSHJ PDP,PJPG1		;READ PROJ. "NUMBER".
	HLL AC2,TAC1
	CAIE TEM,","		;SHOULD BE FOLLOWED BY A COMMA.
	JRST PJPG2
	PUSHJ PDP,PJPG1		;NOW PROG. NO.
	HLR AC2,TAC1
	CAIN TEM,"]"		; ] IS OPTIONAL.
	PUSHJ PDP,GETLCCHR	;THROW IT AWAY IF PRESENT.
	JRST CPOPJ1

PJPG1:
	PUSHJ PDP,CTEXT		;SCAN NEXT THING.
	JUMPE TAC1,TPOPJ	;RETURN UPLEVEL IF NOTHING.
	TLNN TAC1,7777
	LSH TAC1,-14		;JUSTIFY NOW IN CASE SKIPSB DOESN'T COME BACK
	TLNN TAC1,77
	LSH TAC1,-6
	PUSHJ PDP,SKIPSB	;MAKE SURE WE SEE TERMINATOR.
	POPJ P,			;PROGRAM BUMMERS BEWARE OF UPLEVEL RETURN!

PJPG2:
	CAIE TEM,12
	POPJ P,
	SKIPN TAC1,DSKPPN(J)	;COPY PRG FROM APPROPRIATE PLACE
	MOVE TAC1,PRJPRG(J)
	HRR AC2,TAC1
	JRST CPOPJ1
>

;ROUTINE TO PRINT TIME AS HOURS,MINUTES,SECONDS, AND HUNDRETHS
;FORMAT IS HHMM:SS.HH
;CALL:	MOVE TAC,TIME IN JIFFIES(60THS,50THS OR MILLISECONDS)
;	MOVE DAT,OUTPUT TEXT BYTE POINTER
;	PUSHJ PDP,PRTIME

JIFMIN←←JIFSEC*=60		;NUMBER OF JIFFIES PER MINUTE.
JIFSC2←←JIFSEC/2		;NUMBER OF JIFFIES PER HALF SEC.

REPEAT 0,<	;THIS ROUTINE HAS BEEN REPLACED BY ONE OF THE SAME NAME IN CLKSER

PRTIME:
	PUSHJ PDP,HHMM		;DEC 3.16
	JUMPE TAC,PR1		;DO NOT PRINT HOURS OR MINUTES IF 0
	PUSHJ PDP,RADX10	;PRINT BASE 10
	PUSHJ PDP,INLMES	;PRINT COLON
	ASCIZ /:/
PR1:
	MOVE TAC,TAC1		;MOVE TAC,TAC1
	IDIVI TAC,JIFSEC	;JIFFIES PER SECOND
	PUSHJ PDP,RADX10	;PRINT SECONDS
	PUSHJ PDP,PRPER		;PRINT PERIOD
	MOVE TAC,TAC1		;NO OF JIFFIES(HUNDRETHS)
	IMULI TAC,=100		;CONVERT TO HUNDRETHS
	IDIVI TAC,JIFSEC
	CAIL TAC1,JIFSC2	;ROUND IF GREATER THAN HALF
	AOS TAC
	MOVEI TEM,"0"		;PRINT LEADING 0 IF NO.
	JRST PR2		;DEC 3.16

HHMM:
	IDIVI TAC,JIFMIN	;DEC 3.16, REST OF PAGE.
	PUSH PDP,TAC1
	IDIVI TAC,=60
	IMULI TAC,=100
	ADD TAC,TAC1
	POP PDP,TAC1
	POPJ PDP,

PRTIM1:
	PUSHJ PDP,HHMM
	MOVEI TEM,"0"
	CAIGE TAC,=1000
	XCT TYO
	CAIGE TAC,=100
	XCT TYO
PR2:
	CAIGE TAC,=10
	XCT TYO
	JRST DECLF
>;END REPEAT 0

SUBTTL	ERRCON	4 AUG 67

;THESE ERROR ROUTINE PRINT "ERROR IN JOB N"
;FOLLOWED BY AN APPROPRIATE ERROR MESSAGE
;THEN THE JOB IS STOPPED AND CONSOLE IS RETURNED TO
;MONITOR COMMAND MODE

;APR DETECTED ERRORS
;PUSHDOWN OVERFLOW,ILLEGAL MEMORY, NONEXISTENT MEMORY
;FOR WHICH THE USER IS NOT ENABLED.
;SEE APRSER TO SEE HOW APR INTERRUPTS ARE HANDLED
;CALL:	SKIPE TAC,APRERR	;RESULT OF CONI APR,APRERR
;	PUSHJ PDP,APRILM	;FROM CLK SERVICE ROUT.(LOWEST PRIOTITY PI)
;	RETURN TO RESCHEDULE NEW USER

↑APRILM:
	SETZM APRERR(PID)	; ZERO ERROR FLAG
	MOVE ITEM,JOB(PID)	; BLAME CURRENT JOB, WHOMEVER IT MAY BE
	TRNN TAC,ILM		; ILLEGAL MEMORY REFERENCE?
	JRST APRNXM		;NO
	MOVE TAC,APRPC(PID)
	TLNE TAC,USRMOD
	JRST APRIL2
	PUSHJ P,KILSPW		; KILL HIS SPW JOB SO IT WON'T HAPPEN AGAIN
	JRST APRIL1
APRIL2:
	HRRZS TAC
	CAMG TAC,USRREL(PID)	;IS IT IN BOUNDS?
	JRST APRIL1
	TRNN TAC,400000
	JRST APRJRS
	LDB TAC1,PSEGN
	JUMPE TAC1,APRJRS
	HLRZ TAC1,JBTADR(TAC1)
	CAILE TAC,400000(TAC1)
	JRST APRJRS
APRIL1:
	JSP TAC,ERRPNT		;YES
	ASCIZ /ILL MEM REF/
	JRST APRSCD		;PRINT LOC, THEN STOP JOB

APRJRS:
	JSP TAC,ERRPNT
	ASCIZ /PC EXCEEDS MEM BOUND/
	JRST APRSCD		;PRINT LOC, THEN STOP JOB

APRNXM:
	TRNN TAC,NXM		;NON-EX MEM?
	JRST PDLAPR		;NO
	JSP TAC,ERRPNT		;YES
	ASCIZ /NON EX MEM/
	JRST APRSCD		;PRINT LOC, THEN STOP JOB

PDLAPR:
	TRNN TAC,POV		;PUSHDOWN OVERFLOW?
	JRST APRCNS		;NO	;JS
	JSP TAC,ERRPNT		;YES
	ASCIZ /PDL OV/
APRSCD:
	MOVE TAC1,APRPC(PID)	;PRINT APR PC 
	JRST PCPNT		;AS:
				;1)"AT USER LOC XXX" OR
				;2)"AT EXEC LOC XXX; EXEC CALLED FROM
				;   EXEC/USER LOC YYY

APRCNS:
	TRNN TAC,CNS		;JS, REST OF PAGE.  CONS TRAP?
	JSP DAT,UERROR		;NO. HARDWARE PROBLEM.
	JSP TAC,ERRPNT
	ASCIZ /CONS TRAP/
	JRST APRSCD
;JS REST OF PAGE			;REG

; ROUTINE TO PRINT ERROR MESSAGE FOR SPW MODULES

↑SPWMES:
	JSP TAC,ERRPNT
	ASCIZ /SPACEWAR LOSSAGE/
	MOVE TAC,JBTST2(J)		;GET GOOD BITS
	TLNN TAC,ILMSPW			;ILL MEM REF?
	JRST SPWNXM			;NO
	HRRZS TAC
	HLRZ TAC1,JBTADR(J)
	CAMG TAC,TAC1
	JRST SPWILM
	TRNN TAC,400000
	JRST SPWIPC
	LDB TAC1,PSEGN
	JUMPE TAC1,SPWIPC
	HLRZ TAC1,JBTADR(TAC1)
	TRO TAC1,400000
	CAMLE TAC,TAC1
	JRST SPWIPC
SPWILM:
	PUSHJ P,INLMES
	ASCIZ/ - ILL MEM REF/
	JRST SPWMS1
SPWIPC:
	PUSHJ P,INLMES
	ASCIZ/ - PC EXCEEDS MEM BOUNDS/
	JRST SPWMS1
SPWNXM:
	TLNN TAC,NXMSPW
	JRST SPWPDL
	PUSHJ P,INLMES
	ASCIZ/ - NON EX MEM/
	JRST SPWMS1
SPWPDL:
	TLNN TAC,POVSPW
	JRST SPWCNS
	PUSHJ P,INLMES
	ASCIZ/ - PDL OV/
	JRST SPWMS1
SPWCNS:
	TLNN TAC,CNSSPW
	JRST SPWTMX
	PUSHJ P,INLMES
	ASCIZ/ - CONS TRAP/
SPWTMX:
	TLNN TAC,ILLTMO
	JRST SPWMS1
	PUSHJ P,INLMES
	ASCIZ/ - TIME OUT/
SPWMS1:

	HRRZ TAC1,JBTST2(ITEM)
	HRLI TAC1,USRMOD
	PUSHJ PDP,KILSPW
	JRST PCPNT

;ADDRESS CHECK ERROR AT ANY LEVEL
;DEVDAT MUST BE SET UP TO POINT TO OFFENDING DEVICE


↑ADRERR:
	JSP TAC,ERRDEV		; GET JOB NO. FROM DEVICE DATA BLOCK
UADER1:
	ASCIZ /ADDRESS CHECK FOR /
	JRST DEVEXC		;PRINT "DEVICE XXX; EXEC CALLED FROM
				;   EXEC/USER LOC YYY"
				;THEN STOP JOB

↑UADRER:
	MOVEI TAC,UADER1	;ADDRESS CHECK AT UUO LEVEL.
	JRST ERRPTU		;WE WILL RETURN TO UADER1.

; ROUTINE TO PRINT OUT MESSAGE FOR NON-IO UUOS
; CALL BY <JRST UADERR>, DOES NOT RETURN

↑UADERR:
	JSP TAC,UUOMES
	ASCIZ /ADDRESS OUT OF BOUNDS, UUO /

;CALL:	JSP DAT,ERROR
;
;TYPES "ERROR IN MONITOR" FOLLOWED BY CONTENTS OF DAT
;THEN GOES TO AUTOLOAD



↑ERROR:
	MOVEM P,ERRPDL(PID)	;SAVE IT WHERE WE CAN FIND IT
	MOVE P,ERRPD(PID)
	AOBJN P,.+1
	PUSHACS
	PUSH P,DAT		;SAVE CALLING ADDR
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ /πππERROR IN MONITOR AT /
	POP P,TAC
	SUBI TAC,1
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ/
/
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	POPACS
	DEBCHECK
	JRST AUTOLOAD		;THIS IS A LOSE ALWAYS NOW

; UERROR IS FOR UUO LEVEL, BLAMES CURRENT JOB
; CERROR IS FOR CLOCK LEVEL AND LOSES

↑UERROR:
	MOVE ITEM,JOB(PID)	; PRINT FOR CURRENT JOB NUMBER
↑CERROR:
	JSP TAC,ERRPNT		; ITEM ALREADY SET UP
	ASCIZ /?
ERROR IN MONITOR/
	MOVE TAC1,-1(PDP)	;GET LOC OF JSP DAT,ERROR
	JRST PCPNT		;PRINT "AT EXEC LOC XXX;
				;  EXEC CALLED FROM EXEC/USER YYY"
				;THEN STOP JOB

;INPUT UUO FOR OUTPUT DEVICE
;CALLED AT UUO LEVEL ONLY


↑ILLINP:
	JSP TAC,ERRPTU
	ASCIZ /OUTPUT /
	PUSHJ PDP,ERNAM		;PRINT "DEVICE XXX"
	JSP TAC,UUOMES		;PRINT MESSAGE,UUOPC,STOP JOB
	ASCIZ / CANNOT DO INPUT/

; USER TRIED TO GIVE LPT OR PTP A BUFFER LARGER THAN
; THE INTERNAL SYSTEM BUFFER
; CALLED FROM UUO LEVEL ONLY

↑BTLERR:
	JSP TAC,ERRPTU		; SET UP TTY DEVDAT
	ASCIZ /?
/
	PUSHJ PDP,ERNAM		; "DEVICE XXX"
	JSP TAC,UUOMES
	ASCIZ / BUFFER TOO LARGE, UUO/

;OUTPUT UUO FOR INPUT DEVICE
;CALLED AT UUO LEVEL ONLY


↑ILLOUT:
	JSP TAC,ERRPTU
	ASCIZ /INPUT /
	PUSHJ PDP,ERNAM		;PRINT "DEVICE XXX"
	JSP TAC,UUOMES		;PRINT MESSAGE,UUOPC,STOP JOB
	ASCIZ / CANNOT DO OUTPUT/

;ILLEGAL DEVICE DATA MODE (INIT, OPEN, OR SETSTS UUOS)
;CALLED AT UUO LEVEL ONLY


↑ILLMOD:
	JSP TAC,ERRPTU
	ASCIZ /ILLEGAL DATA MODE FOR /
	JRST DEVEXC		;PRINT "DEVICE XXX",UUO PC

;IO UUO TO USER CHANNEL WITH NO PREVIOUS INIT OR OPEN
;CALLED AT UUO LEVEL ONLY


↑IOIERR:
	JSP TAC,ERRPTU
	ASCIZ /IO TO UNASSIGNED CHANNEL/
	JRST UUOPCP		;PRINT UUO PC

;UUOERR: ILLEGAL UUO 
;CALLED AT UUO LEVEL ONLY - liar!


↑UUOERR:
	SKIPE	SPWUUF(PID)	;DON'T GIVE MESSAGE IN SPACEWAR MODE
	CONSZ	PI,77000	;YES, CH7?
	CAIA			;NO TO EITHER
	JRST	SPWERR		;WE MIGHT BE ON THE PDP-6
	MOVEM	J,TSAVJ#	;I HATE VARIABLES, BUT SAVE J
	MOVE	J,JOB(PID)	;SOMETIMES NOT SET UP BY DPYSER
	MOVE	TAC1,UUOPC(J)
	JUMPE	J,UUOER3
	TLNE	TAC1,USRMOD
	JRST	UUOER1		;USER MODE CALL
UUOER3:
	MOVEM	P,ERRPDL	;UUO CALLED FROM EXEC STORE LOSER'S P.
 	MOVE	P,ERRPD(PID)
	ADD	P,[1,,1]
UUOER1:
	JSP	TAC,ERRPTU	;RETURNS WITH DAT AND DDB PUSHED
	ASCIZ	/ILLEGAL UUO/
	MOVE	TAC1,UUOPC(J)	;GET LAST UUO PC
	TLNE	TAC1,USRMOD	;USER ERROR?
	SOJA	TAC1,PCPNT
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ππππILLEGAL UUO FROM EXEC AT UUO LEVEL
UUO AT /
	MOVE	TAC,UUOPC(J)
	MOVEI	TAC,-1(TAC)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISTAB
	PUSHJ	P,DISJOB
	PUSHJ	P,DISMES
	ASCIZ	/ UUOOPC = /
	MOVE	TAC,UUOOPC(J)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/  P= /
	MOVE	TAC,ERRPDL
	PUSHJ	P,DISOCT
	CAMN	J,TSAVJ
	JRST	UUOER2
	PUSHJ	P,DISMES
	ASCIZ	/J WAS: /
	MOVE	TAC,TSAVJ
	PUSHJ	P,DISOCT		;ONLY MAKES SENSE IN DECIMAL IF A JOB NUMBR
UUOER2:
	PUSHJ	P,DISMES
	ASCIZ	/
FIND A WIZARD OR TYPE: POPJ 3,$X
/
	PUSHJ	P,SYSFIX
	JFCL			;NO ERRORS
	JFCL			;FOUND TROUBLE, BUT COULDN'T FIX IT!
	PUSHJ	P,DISFLUSH	;TELL THE WORLD
	POPACS
	PUSHJ	P,DDTCALL
	MOVE	TAC1,UUOPC(J)
	SOJA	TAC1,PCPNT	;ALWAYS TRY JUST FLUSHING LOSER

;ILLEGAL INSTRUCTION  -  ILLINS, HALT
;HALT INSTRUCTION IS A SPECIAL CASE WHICH STOPS JOB BUT
;THE USER MAY CONTINUE FROM IT(EFFECTIVE ADR.)
;CALLED AT UUO LEVEL WITH A JRST


↑ILLINS:
	HLRZ TAC,UUO		; ILLEGAL OPCODE
	ANDI TAC,777600		;LOOK AT OPCODE AND HIGH 2 AC BITS
	CAIN TAC,(<JRST 4,>)	;IS IT A HALT?
	JRST HALT		;YES, PRINT DIFFERENT MESSAGE
	JSP TAC,ERRPTU
	ASCIZ /ILL INST./
	JRST UUOPCP		;PRINT UUO PC AND STOP JOB

↑HALT:	MOVE J,JOB(PID)		; PICK UP JOB NUMBER
	PUSHJ P,TTYERP		; SET TTY IN MONITOR MODE
	PUSHJ P,INLMES
	ASCIZ /HALT/
	SOS TAC1,UUOPC(J)	;UUOPC = LOCATION OF HALT PLUS ONE
	PUSHJ P,PCP		;PRINT "USER LOC XXX"
	PUSHJ P,PRCRCC		;PRINT MONITOR MODE RESPONSE
	HRRM UUO,UUOPC(J)	; SAVE EFFECTIVE ADDRESS OF HALT
	PUSHJ P,TTYSTC		;START TTY TYPING
	PUSHJ P,SETSTP		;STOP JOB, BUT FINISH THIS UUO
	SKIPN INTACT(PID)
	JRST USRXIT		;"RETURN" TO ADDRESS OF HALT (WILL NEVER GET THERE)
	JRST ESTOP

;ROUTINE FOR HUNG IO DEVICE
;CALL	MOVE DEVDAT,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ PDP,DEVHNG


↑DEVHNG:
	MOVEI TAC,IOACT		; TURN OFF IO DEVICE ACTIVE BIT IN
	ANDCAM TAC,DEVIOS(DEVDAT);MEMORY AND IOS
	TRZ IOS,IOACT
	JSP TAC,ERRDEV
	ASCIZ /HUNG /
	JRST DEVEXC

;BAD DECTAPE DIRECTORY
;CALLED AT INTERRUPT AND UUO LEVELS WITH DEVDAT AND ITEM SETUP


↑BADDIR:
	JSP TAC,ERRPNT
	ASCIZ /BAD DIRECTORY FOR /

;ROUTINE TO PRINT "DEVICE XXX; EXEC CALLED FOR EXEC/USER YYY"
;THEN STOP JOB
;TO BE USED BY DEVICE DEPENDENT ERROR MESSAGES AFTER JSP TAC,DEVERR


↑DEVEXC:
	PUSHJ PDP,ERNAM		; PRINT "DEVICE XXX"
	MOVE TAC,(P)		; GET DEVICE DDB
	MOVE TAC1,DEVMOD(TAC)	;RPH PATCH TO CLEAR GOBIT ON DISK ERRORS
	TLNN TAC1,DVDSK
	JRST EXCALP
	MOVSI IOS,GOBIT
	ANDCAB IOS,DEVIOS(TAC)	;CLEAR GO BIT IF STOPPING DISK
	JRST EXCALP		;PRINT "EXEC CALLED FROM EXEC/USER LOC YYY"

;ROUTINE TO HALT A JOB WHEN A DEVICE IS NOT READY FOR I/O
;CALLED FROM XXXSER AT UUO LEVEL
;CALL	MOVE DEVDAT,ADDR OF DEVICE DDB
;	MOVE ITEM,JOB NUMBER
;	PUSHJ PDP,HNGSTP


↑HNGSTP:
	PUSH PDP,IOS		; SAVE STUFF FOR DEVICE
	PUSH PDP,DEVDAT
	PUSHJ PDP,TTYFUW
	PUSHJ PDP,PRQM
	PUSHJ PDP,ERNAM		;PRINT "DEVICE XXX"
	PUSHJ PDP,INLMES	;AND MESSAGE
ASCIZ / OK?
/
	PUSHJ P,PRCRCC
	PUSHJ PDP,TTYSTC	;START TTY IN COMMAND MODE
	POP PDP,DEVDAT
	POP PDP,IOS
	PUSHJ PDP,STOP1		;STOP JOB
	JRST WSCHED		;AND RESCHEDULE

; ROUTINE TO PRINT A MESSAGE AND STOP A JOB IN A WAY
; THAT CAN BE CONTINUED FROM.
; CALLING . . .
;	MOVEI TAC,[ASCIZ /MESSAGE HERE/]
;	PUSHJ P,HNGMES

↑HNGMES:
	PUSH P,IOS
	PUSH P,DEVDAT
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,DAT
	PUSH P,TEM
	PUSH P,TAC1
	PUSH P,TAC
	MOVE J,JOB(PID)
	PUSHJ P,TTYFUW
	POP P,TAC
	PUSHJ P,CONMES
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC
	PUSHJ P,STOP1
	POP P,TAC1
	POP P,TEM
	POP P,DAT
	POP P,AC3
	POP P,AC2
	POP P,AC1
	POP P,DEVDAT
	POP P,IOS
	JRST WSCHED

;COMMON ERROR MESSAGE SETUP ROUTINES - ERRPTU
;CALL:	JSP TAC,ERRPTU, ERRDEV, OR ERRPNT
;	ASCIZ /MESSAGE/
;	RETURNS HERE WITH DEVDAT SAVED 0(PDP)
;	C(DEVDAT)=TTYDDB, DAT TO TTY OUTPUT BUFFER POINTER
;	ITEM=JOB NUMBER

;USE ERRPTU IF AT UUO LEVEL FOR SURE
;ERRDEV IF ERROR FOR AN ASSIGNED DEVICE AT ANY LEVEL
;ERRPNT WITH ITEM ALREADY SET TO OFFENDING JOB NUMBER
;THE JSP CALL IS USED IN CASE PUSHDOWN SPACE BECOMES CRITICAL
;AGAIN AND ERRPNT HAS TO WIPE EXISTING LIST OUT

↑ERRPTU:
	SKIPN J,JOB(PID)	; BLAME CURRENT JOB IF NOT 0
↑ERRDEV:
	LDB J,PJOBN		; JOB NUMBER FROM DEVICE DATA BLOCK
↑ERRPNT:
	JUMPN J,.+2
	SETOM NULBAD(PID)
	PUSH P,DAT		; SAVE CALL TO ERROR
	SKIPL J
	CAIL J,JOBN		;REASONABLE JOB NUMBER?
	CAIA
	JRST ERRZZ2
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ/ππππERRPTU CALLED WHEN NULL JOB RUNNING
/
	POPACS
	DEBCHECK
	SKIPN DISFLAG
	JRST ERRZZ2
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

ERRZZ2:
	PUSH P,DDB		;SAVE ADR. OF DEV. DATA BLOCK
	PUSH P,TAC		;SAVE RETURN FROM ERRPNT
	MOVE JDAT,JBTDAT(J)	;EVEN NULL JOB HAS JOB DATA AREA
IFN JDMPRG,<
	MOVE PROG,JBTADR(J)	;JOB RELOCATION
>
	PUSHJ P,TTYERP		;FIND JOB'S TTY AND SET UP DDB.
	PUSHJ P,INLMES
	ASCIZ /?
ERROR IN JOB /
	PUSHJ P,PJOB		;PRINT JOB NO.
	JRST INLMES		;PRINT MESSAGE SPECIFIED BY CALLER

;ROUTINE TO PRINT UUO PC AND STOP JOB - UUOMES, UUOPCP, PCPNT
;IF IN USER MODE PC WILL PRINT AS "AT USER LOC XXX"
;IF IN EXEC MODE "AT EXEC LOC XXX; EXEC CALLED FORM EXEC/USER/ LOC YYY


↑UUOMES:
	MOVE J,JOB(PID)		;MAKE SURE J IS SET UP
	SKIPE SPWUUF(PID)
	CONSZ PI,77000
	CAIA
	JRST SPWERR		;MIGHT BE ON PDP-6
	PUSH P,TAC
	PUSHJ P,TTYERP
	POP P,TAC
	PUSHJ P,CONMES		; PRINT MESSAGE POINTED TO BY TAC
↑UUOPCP:
	MOVE TAC1,UUOPC(J)	; UUO PC STORED AT BOTTOM OF PDL
				;FIRST LOC ON PD LIST
	SOJA TAC1,PCPNT		;DECREMENT TO POINT TO UUO IN USER AREA

;ROUTINE TO PRINT ONE OF THREE MESSAGES AND STOP JOB
;1) "AT EXEC LOC XXX; EXEC CALLED FROM EXEC LOC YYY"
;2) "AT EXEC LOC XXX; EXEC CALLED FORM USER LOC YYY"
;3) "AT USER LOC YYY"

;CALL:	MOVE TAC1, XXX		;WITH PC FLAGS IN LH
;	PUSHJ PDP,PCPNT
;	NEVER RETURN IF AT UUO LEVEL


↑PCPNT:	PUSHJ P,PCP		;PRINT " AT EXEC XXX" OR " AT USER "
	TLNE TAC1,USRMOD	;WAS PC IN USER MODE?
	JRST PCSTOP		;YES, ENOUGH INFO.

;ROUTINE TO PRINT EITHER: - PCSTOP, PCP
;1) "; EXEC CALLED FROM EXEC LOC YYY"
;2) "; EXEC CALLED FROM USER LOC YYY"
;AND STOP JOB
;CALL:	PUSHJ PDP,EXCALP
;	NEVER RETURNS IF AT UUO LEVEL


↑EXCALP:
	PUSHJ P,INLMES
	ASCIZ /; UUO/
	MOVE TAC1,UUOPC(J)	; UUO PC ON PDL
	SUBI TAC1,1		;BACK IT UP TO POINT TO UUO
	PUSHJ P,PCP		;PRINT "EXEC LOC " OR USER LOC
↑PCSTOP:
	PUSHJ P,HOLD		; STOP JOB, START TTY AND SET JOB ERROR BIT
	POP P,DDB		;RETURN ONLY IF AT INTERRUPT LEVEL
	JRST TPOPJ		;REMOVE ERROR CALL AND RETURN

;ROUTINE TO PRINT PC AS:
;1) "EXEC LOC XXX" OR "USER LOC XXX"
;CALL:	MOVE TAC1,PC TO PRINT(LH=PC FLAGS)
;	PUSHJ PDP,PCP


XMODE:
	ASCIZ / AT EXEC /
UMODE:
	ASCIZ / AT USER /

PCP:
	MOVEI TAC,XMODE		;ASSUME PC IN EXEC MODE
	TLNE TAC1,USRMOD	;IS IT?
	MOVEI TAC,UMODE		;NO, USER MODE
	PUSHJ PDP,CONMES	;PRINT ONE OR OTHER
	HRRZ TAC,TAC1		;PRINT RIGHT HALF IN OCTAL
				;FALL INTO OCTPNT

;ROUTINE TO PRINT 36 BIT OCTAL NO
;CALL:	MOVE DAT, TTY OUTPUT BYTE POINTER
;	MOVE TAC,OCTAL NO
;	PUSHJ PDP,OCTPNT


↑OCTPNT:
	PUSH	P,TAC1		; SAVE TAC1
	MOVEI	TAC1,10		;OCTAL BASE
ANYRDX:
	PUSH	P,ITEM
	MOVEI	ITEM,(TAC1)
	PUSHJ	P,OCTP1
	POP	P,ITEM
	POP	P,TAC1
	POPJ	P,

OCTP1:
	IDIV	TAC,ITEM
	HRLM	TAC1,(P)
	JUMPE	TAC,.+2
	PUSHJ	P,OCTP1
	HLRZ	TEM,(P)
	MOVEI	TEM,"0"(TEM)
	XCT	TYO
	POPJ	P,

;ROUTINE TO PRINT DECIMAL NO.
;CALL:	SAME AS OCTPNT
;TAC1 IS PRESERVED

↑RADX10:
	PUSH	P,TAC1		; OUTPUT DECIMAL
	MOVEI	TAC1,12
	JRST	ANYRDX

;ROUTINE TO PRINT "DEVICE XXX"
;CALL	MOVE DAT,ASCII OUTPUT BYTE POINTER
;	PUSH PDP,DEVDAT
;	PUSHJ PDP,ERNAM


↑ERNAM:	PUSHJ	P,INLMES
	ASCIZ	/DEVICE /
	SKIPE	TAC1,-1(P)		;IS DEVDAT = 0?
	MOVE	TAC1,DEVNAM(TAC1)	;NO, GET DEVICE NAME


;ROUTINE TO PRINT SIXBIT NAME
;CALL	MOVE DAT,ASCII OUTPUT BYTE POINTER
;	MOVE TAC1,NAME
;	PUSHJ PDP,PRNAME

↑PRNAME:
	JUMPE	TAC1,CPOPJ	;DONE IF NULL
	MOVEI	TAC,0
	LSHC	TAC,6		;SHIFT IN NEXT CHAR.
	MOVEI	TEM,40(TAC)
	XCT	TYO		;TYPE OUT IN ASCII.
	JRST	PRNAME

; ROUTINE TO TYPE OUT DISASTER BUFFER ON CTY AT CLOCK LEVEL
; RECCOMMENDED CALLING . . .
;	MOVE TAC,DISPTR
;	CAME TAC,DISOPT
;	PUSHJ P,DISOUT
; PUTS AS MUCH TEXT AS IT CAN INTO THE CTY OUTPUT BUFFER AND INITIATES
; CTYTYO.

↑DISOUT:
	SETZ J,
	PUSHJ P,TTYFND		; SET UP DDB AND DAT TO THE CTY
DISOU1:
	MOVE TAC,FCTR(DAT)	; HOW FULL IS THE BUFFER?
	CAIG TAC,1
	JRST TYPGO		; FULL TO THE GILLS. INITIATE TYPEOUT
	ILDB TEM,DISOPT		; THERE IS ROOM. PICK UP A CHARACTER.
	AOS DISCTR
	XCT TYO
	MOVE TAC,DISOPT
	MOVE AC1,TAC
	IBP AC1
	HRRZS AC1
	CAIGE AC1,DISBUF+DISLEN
	JRST DISOU2
	MOVEI AC1,DISBUF-1	; WRAP POINTER AROUND
	HRRM AC1,DISOPT
DISOU2:
	CAME TAC,DISPTR
	JRST DISOU1		; BUFFER NOT EMPTY. TRY TO STUFF ANOTHER CHARACTER IN.
	JRST TYPGO		; EMPTY. INITIATE TYPEOUT.

; ROUTINE TO CALL WITH PIS OFF TO FINISH FLUSHING
; DISASTER BUFFER. SERVOS CTY ALL BY ITSELF
; CALLING . . .
;	PUSHJ P,DISFLUSH

↑DISFLUSH:
	CONSO APR,MAOFF		;ARE WE THE PDP-6
	POPJ P,			;YES, NOTHING TO FLUSH.
	CONI CTY,AC1
	HRLM AC1,(P)		;SAVE PI CHANNEL
	CONO CTY,0		;AND SET TO 0 SO WE WON'T INT
	MOVEI AC1,100000	; WAIT FOR THE CTY TO COOL OFF
	SOJG AC1,.
	SKIPN DAT,TTYTAB+TCONLN	;IS THE CTY THERE AT ALL?
	JRST DISFL1		;NO, SKIP ALL THIS CRAP
	ADDI DAT,TTOBUF		;POINT TO OUTPUT BUFFER
DISFL3:
	MOVE TAC,TAKR(DAT)
	CAMN TAC,PUTR(DAT)
	JRST DISFL1		; OUTPUT BUFFER EMPTY, EXIT
	PUSHJ P,GETCHO		; PICK UP A CHARACTER FROM THE OUTPUT BUFFER
	PUSHJ P,CTYTYO		; AND TYPE IT OUT
	JRST DISFL3

DISFL1:
	MOVE TEM,DISOPT
	SKIPLE DISCTR		; MAY BE FULL
				; (BYTE POINTERS THE SAME WHEN FULL TOO)
	CAME TEM,DISPTR		; NOW IF THE SAME, THEN EMPTY
	CAIA
	JRST DISFLX		;SO LEAVE
	IBP TEM
	HRRZS TEM
	CAIGE TEM,DISBUF+DISLEN
	JRST DISFL4
	MOVEI TEM,DISBUF-1
	HRRM TEM,DISOPT
DISFL4:
	ILDB TEM,DISOPT		; PICK UP A CHARACTER
	AOS DISCTR
	PUSHJ P,CTYTYO		; TYPE OUT ON CTY
	JRST DISFL1

DISFLX:
	HLRZ AC1,(P)
	ANDI AC1,7	;GET BACK OLD PI CHAN
	CONO CTY,(AC1)
	POPJ P,

; THIS ROUTINE TYPES ONE CHARACTER IN TEM THROUGH
; THE DISASTER BUFFER.
; CALLING . . .
;	MOVE TEM,<CHARACTER>
;	PUSHJ P,DISTYO

↑DISTYO:
	CONSO APR,MAOFF		;ARE WE THE PDP-10
	JRST CTYTYO		;NO, JRST HANG THINGS UP WHILE WE TYPE
	SKIPLE DISCTR		; ANY ROOM IN BUFFER?
	JRST DISTY1		; YES, JUST PLUNK THE CHARACTER IN
	SKIPN DISFLAG		; ARE PIS OFF YET?
	CONO PI,PIOFF		; NO, TURN THEM OFF
	PUSH P,TEM
	PUSHJ P,DISFLUSH	; EMPTY THE DISASTER BUFFER
	POP P,TEM
	SKIPN DISFLAG
	CONO PI,PION
	JRST DISTYO

DISTY1:
	SOSL DISCTR
	JRST DISTY2
	AOS DISCTR
	JRST DISTYO

DISTY2:
	CONO PI,PIOFF
	IDPB TEM,DISPTR
	CONO PI,PION
	MOVE AC1,DISPTR
	IBP AC1
	HRRZS AC1
	CAIGE AC1,DISBUF+DISLEN
	POPJ P,
	CONO PI,PIOFF
	MOVE AC1,DISPTR
	IBP AC1
	HRRZS AC1
	CAIGE AC1,DISBUF+DISLEN
	JRST DISTY3
	MOVEI AC1,DISBUF-1
	HRRM AC1,DISPTR
DISTY3:
	CONO PI,PION
	POPJ P,

;DISMES, DISCRLF, DISTAB, DISJOB
; ROUTINE TO DO A DISASTER OUTPUT OF A STRING
; CALL BY:
;	PUSHJ P,DISMES
;	ASCIZ /<STRING>/

↑DISMES:
	POP	P,AC1		;GET RETURN ADDRESS
	HRLI	AC1,(<POINT 7,0>)
DISME1:
	ILDB	TEM,AC1
	JUMPE	TEM,1(AC1)	; END OF STRING. RETURN
	PUSH	P,AC1		;KEEP THIS SAFE FROM TIGERS
	PUSHJ	P,DISTYO
	POP	P,AC1
	JRST	DISME1


↑DISCRLF:			;CALL TO DO DISASTER OUTPUT OF CRLF ON THE CTY
	MOVEI	TEM,15
	PUSHJ	P,DISTYO
	MOVEI	TEM,12
	JRST	DISTYO

↑DISTAB:			;CALL TO DO DISASTER OUTPUT OF A TAB ON THE CTY
	MOVEI	TEM,11		;LOAD TAB
	JRST	DISTYO

↑DISJOB:			;TYPE JOBNUMBER(JOBNAME). J IS SET WITH JOBNUMBER
				;J IS PRESERVED.
	PUSH	P,J		;SAVE JOB NUMBER
	MOVE	TAC1,JOBNAM(J)	;GET THE JOBNAME
	PUSHJ	P,DISSIX
	MOVEI	TEM,050;;"("
	PUSHJ	P,DISTYO
	MOVE	TAC,(P)
	PUSHJ	P,DISDCP	;TYPE JOB NUMBER IN DECIMAL WITH DECIMAL POINT
	MOVEI	TEM,051;;")"
	PUSHJ	P,DISTYO
	POP	P,J
	POPJ	P,


;CALLING SEQUENCE
;	PUSHJ P,DISERR
;	XWD CODE,ADDR
;	XWD CODE,ADDR
;	      .
;	      .
;	      .
;	      .
;	     -1
;

DISER1:
	AOS (P)		;NEXT ARG
↑DISERR:SKIPGE TAC,@(P)
	JRST CPOPJ1			;SKIP RETURN
	ASH TAC,-=23			;ONLY CODE BITS PLEASE
	MOVEI AC1,@(P)			;GET EFFECTIVE ADDRESS
	MOVEI AC1,@(AC1)		;NOW GET IT'S EFFECTIVE ADDRESS
	CAILE TAC,ERRLEN-1
	JRST DISER1
	JRST @ERRTAB(TAC)		;DISPATCH

DEFINE ERRMAC $ (I)
<	ERR$I
>
ERRTAB:
	QQQNAM
ERRLEN←←.-ERRTAB

; HERE ARE THE VARIOUS PRINTOUT ROUTINES FOR DISERR

ERRSTR:
	HRLI AC1,(<POINT 7,0>)
ERRST1:
	ILDB TEM,AC1
	JUMPE TEM,DISER1	;QUIT ON ZERO
	PUSH P,AC1
	PUSHJ P,DISTYO
	POP P,AC1
	JRST ERRST1

ERRCHR:
	HRRZ TEM,AC1
	PUSHJ P,DISTYO
	JRST DISER1

ERROCT:
	MOVE TAC,(AC1)
	PUSHJ P,DISOCT
	JRST DISER1

ERRLOC:
	MOVE TAC,(AC1)
	PUSHJ P,DISLOC
	JRST DISER1

ERRDEC:
	MOVE TAC,(AC1)
	PUSHJ P,DISDEC
	JRST DISER1

ERRSIX:
	MOVE TAC1,(AC1)
	PUSHJ P,DISSIX
	JRST DISER1

ERRDCP:
	MOVE TAC,(AC1)
	PUSHJ P,DISDCP		;DECIMAL WITH PERIOD
	JRST DISER1

;DISLOC PRINTS OUT 6 DIGIT OCTAL LOCATION WITHOUT LEADING ZEROES
;CALL	MOVE TAC,<LOCATION>
;	PUSHJ P,DISLOC
↑DISLOC:
	PUSH P,[=6]
	HRLZ TAC1,TAC
DISLC1:
	TLNE TAC1,700000	;DO WE HAVE A DIGIT YET?
	JRST DSOCT2		;YES, PRINT ADDRESS
	LSH TAC1,3		;SHIFT LEFT 3 BITS
	SOSLE (P)
	JRST DISLC1
	JRST DSOCT2		;PRINT ONE ZERO.

; OCTAL PRINT ROUTINE FOR DISASTER MESSAGES
; CALLING . . .
;	MOVE TAC,<NUMBER>
;	PUSHJ P,DISOCT

↑DISOCT:
	PUSH P,[=12]
	MOVE TAC1,TAC
DSOCT2:
	SETZ TAC,
	LSHC TAC,3
	MOVEI TEM,"0"(TAC)
	PUSH P,TAC1
	PUSHJ P,DISTYO
	POP P,TAC1
	SOSLE (P)
	JRST DSOCT2
	JRST TPOPJ

;ANOTHER OCTAL PRINT ROUTINE. PRINTS  HALFWORD COMMA COMMA HALFWORD
↑DISOCH:
	PUSH	P,TAC		;SAVE THE ARGUMENT
	HLLZ	TAC1,TAC	;GET LEFT SIDE IN LEFT SIDE
	PUSH	P,[DSOCH1]	;"RETURN" ADDRESS
	PUSH	P,[6]		;6 CHARACTERS PLEASE
	JRST	DSOCT2		;DO IT
DSOCH1:
	MOVEI	TEM,","
	PUSHJ	P,DISTYO
	MOVEI	TEM,","
	PUSHJ	P,DISTYO
	POP	P,TAC1
	HRLZ	TAC1,TAC1
	PUSH	P,[6]
	JRST	DSOCT2		;WRITE IT AND RETURN

↑DISDCP:PUSHJ P,DISDEC
	MOVEI TEM,"."
	JRST DISTYO		;APPEND . TO DECIMAL NUMBER

↑DISDEC:
	JUMPGE TAC,DISDC1
	MOVEI TEM,"-"
	PUSHJ P,DISTYO
DISDC1:
	MOVM TAC,TAC

DISNUM:
	IDIVI TAC,=10
	HRLM TAC1,(P)
	JUMPE TAC,.+2
	PUSHJ P,DISNUM
	HLRZ TAC,(P)
	MOVEI TEM,"0"(TAC)
	JRST DISTYO

; SIXBIT PRINT ROUTINE FOR DISASTER MESSAGES
; CALLING . . .
;	MOVE TAC1,<WORD>
;	PUSHJ P,DISSIX

↑DISSIX:
	JUMPE TAC1,CPOPJ
	SETZM TAC
	ROTC TAC,6
	MOVEI TEM,"A"-'A'(TAC)
	PUSH P,TAC1
	PUSHJ P,DISTYO
	POP P,TAC1
	JRST DISSIX

; INITIALIZE ROUTINE FOR DISASTER MESSAGES . . .

↑DISINIT:
	MOVE TAC,[POINT 7,DISBUF]
	MOVEM TAC,DISPTR
	MOVEM TAC,DISOPT
	SETZM DISFLAG
	MOVEI TAC,5*DISLEN
	MOVEM TAC,DISCTR
	POPJ P,

; ROUTINE TO TYPE ON THE CTY WITH PIS OFF
; CALLING . . .
;	MOVE TEM,<CHARACTER>
;	PUSHJ P,CTYTYO
; CLOBBERS TAC AND SOME OTHERS

↑CTYTYO:
	CONSZ CTY,40		;HAS SOMEONE TYPED SOMETHING?
	JRST CTYTY2
CTYTY3:

	MOVEI TAC,777777
	CONSZ CTY,20
	SOJG TAC,.-1
	DATAO CTY,TEM
	CAIE TEM,11			;WAS THAT A TAB?
	POPJ P,
	MOVEI TEM,4		;YES, SEND 3 IDLE CHARS.
TABWAT:

	MOVEI TAC,777777
	CONSZ CTY,20
	SOJG TAC,.-1
	DATAO CTY,[1]
	SOJG TEM,TABWAT
	POPJ P,

CTYTY2:
	DATAI CTY,TAC	;YES, GET IT
	CAIE TAC,"O"-100	;IS IT ↑O?
	JRST CTYTY3		;NO, GO ON
	CONSO APR,MAOFF		;YES, ARE WE THE SIX?
	POPJ P,			;YES, IGNORE THIS CHAR.
	PUSH P,DAT		;SAVE THIS
	SKIPN DAT,TTYTAB+TCONLN	;IS THERE A CTY DDB
	JRST .+3
	ADDI DAT,TTOBUF
	PUSHJ P,SETBFO		;CLEAR OUTPUT BUFFER
	POP P,DAT
	JRST DISINI		;CLEAR DISASTER BUFFER AND POPJ

; ROUTINE TO SHOVE THE TIME AND DATE INTO THE BUFFER

↑DISDATE:
	MOVEI TEM,1
	PUSHJ P,DISTYO		;WARM UP THE CTY
	MOVE TAC,THSDAT
	IDIVI TAC,=31
	EXCH TAC,TAC1
	ADDI TAC,1
	PUSH P,TAC1
	PUSHJ P,DISDEC
	POP P,TAC1
	SETZ TAC,
	DIVI TAC,=12
	EXCH TAC,TAC1
	PUSH P,TAC1
	MOVE TAC,MONTAB(TAC)
	DPB TAC,[POINT 21,DISMON,27]		;WHEW!
	MOVE AC1,[POINT 7,DISMON]
	MOVEI AC2,5
DISDA1:
	ILDB TEM,AC1
	PUSH P,AC1
	PUSH P,AC2
	PUSHJ P,DISTYO
	POP P,AC2
	POP P,AC1
	SOJG AC2,DISDA1
	POP P,TAC1
	MOVEI TAC,=64(TAC1)
	PUSHJ P,DISDEC
	MOVEI TEM," "
	PUSHJ P,DISTYO
	MOVE TAC,TIME
	IDIVI TAC,JIFMIN
	IDIVI TAC,=60
	IMULI TAC,=100
	ADD TAC,TAC1
	PUSHJ P,DISDEC
	PUSHJ P,DISMES
	ASCIZ /
/
	POPJ P,

SUBTTL	IOCSS	4 AUG 67

;ROUTINE TO ADVANCE OUTPUT BUFFER AT INTERRUPT LEVEL

;CALL:	PUSHJ PDP,ADVBFE
;	EXIT1		RETURN IF NEXT BUFFER IS EMPTY
;	EXIT2		RETURN IF NEXT BUFFER IS FULL
;CLEARS THE USE BIT (IOUSE:=0) OF THE BUFFER POINTED TO BY THE
;OUTPUT BUFFER ADDRESS (DEVOAD) OF THE CURRENT DEVICE DATA BLOCK
;AND ADVANCES THE BUFFER ADDRESS TO THE NEXT BUFFER IN THE RING.
;UPON RETURN, SKIPS IF THE NEXT BUFFER IS FULL.
;SECOND WORD OF NEXT BUFFER IS ADDRESS CHECKED TO
;MAKE SURE IT IS NOT IN JOB DATA AREA OR ABOVE USER AREA
;THE SECOND WORD OF CURRENT BUFFER WAS CHECKED AT UUO LEVEL
;OR PREVIOUS CALL TO ADVBFE



↑ADVBFE:
	AOS	NABFE			;COUNT BUFFER ADVANCE
	PUSH	P,AC3
	JSP	AC3,PRSET		;SET UP PROT-RELOC REGISTERS
	SKIPN	TAC1,DEVOAD(DDB)	;PICK UP BUFFER ADDRESS
	JRST	ADVXIT			;NONE THERE, EXIT
	JSP	AC3,ADRCK		;MAKE SURE THIS IS A LEGAL ADDRESS
	XCTR	XW,[MOVEM IOS,-1(TAC1)]
	MOVSI	TAC,IOUSE
	XCTR	XRW,[ANDCAB TAC,(TAC1)]
	TRNE	IOS,740000		;ANY ERRORS?
	JRST	ADVXIT			;YES, DO NOT FILL NEXT BUFFER
	MOVE	TAC1,TAC
	JSP	AC3,ADRCK		;ADDRESS CHECK NEXT BUFFER IN RING
	HRRM	TAC1,DEVOAD(DDB)	;OK. PUT IN LATEST FREE BUFFER ADDRESS
	JRST	ADVBE2

;ENTER HERE FROM SCNSER TO CHECK IF NEXT BUFFER FULL OF DATA YET

↑ADVBE1:
	PUSH	P,AC3
	JSP	AC3,PRSET
ADVBE2:
	SKIPN	TAC1,DEVOAD(DDB)
	JRST	ADVXIT
	XCTR	XR,[SKIPL (TAC1)]
	JRST	ADVXIT
	JRST	ADVBF1

; ROUTINE TO PUSH CURRENT PR ON STACK AND SET UP NEW PR
; CALLING . . .
;	JSP AC3,PRSET
; RETURNS WITH PR ON STACK.

PRSET:

IFN FTXCTR,<PUSH P,160
	    PUSH P,@161>	; MAKE XCTR SIMULATION RECURSIVE
	PUSH P,AC2
	PUSH P,AC1
	PUSH P,J
	PUSH P,TEM
	PUSH P,LASTPR(PID)
	LDB J,PJOBN
	PUSHJ P,GETPR
	MOVEM TAC,LASTPR(PID)
	DATAO APR,TAC
	MOVEI TEM,JOBPFI	; SET UP ADDRESS OF JOB DATA AREA
	HLRZ AC1,PROG		; SET UP BOUNDS OF JOB FOR ADDRESS CHECKING
	LDB AC2,PSEGN
	JUMPE AC2,(AC3)		; NO UPPER SEGMENT, LEAVE
	HLRZ AC2,JBTADR(AC2)	; PICK UP ITS SIZE
	ADDI AC2,400000
	JRST (AC3)

; ROUTINE TO ADDRESS CHECK SOMETHING
; CALLING . . .
;	MOVE TAC1,<ADDRESS TO BE CHECKED>
;	MOVE AC1,<LOWER SEGMENT LENGTH>
;	MOVE AC2,<UPPER SEGMENT LENGTH>
;	JSP AC3,ADRCK
; GOES TO ADVXIT IF ERROR

ADRCK:
	CAILE TEM,(TAC1)	; ABOVE JOB DATA AREA?
	JRST ADVXIT		; NO, ERROR
	CAIL AC1,(TAC1)		; INSIDE LOWER?
	JRST (AC3)		; YES
	TRNE TAC1,400000	; IS IT UPPER SEGMENT ADDRESS?
	CAIGE AC1,(TAC1)	; YES, IS IT THEN IN THE UPPER SEGMENT?
	JRST ADVXIT		; NO, ERROR
	JRST (AC3)		; YES, WIN

ADVXIT:
	POP P,LASTPR(PID)	; POP PR OFF STACK
	DATAO APR,LASTPR(PID)	; RESTORE PR
	POP P,TEM
	POP P,J
	POP P,AC1
	POP P,AC2
IFN FTXCTR,<POP P,@161
	    POP P,160>		;XCTR SIMULATION
	POP P,AC3
	POPJ P,

;ROUTINE TO ADVANCE INPUT BUFFER AT INTERRUPT LEVEL

;CALL:	PUSHJ PDP,DEVBFF
;	EXIT1		RETURN IF NEXT BUFFER IS FULL
;	EXIT2		RETURN IF NEXT BUFFER IS EMPTY
;SETS THE USE BIT (IOUSE:=1) OF THE BUFFER POINTED TO BY THE
;INPUT BUFFER ADDRESS (DEVIAD) OF THE CURRENT DEVICE DATA BLOCK
;AND ADVANCES THE BUFFER ADDRESS TO THE NEXT BUFFER IN THE RING.
;UPON RETURN, SKIPS IF THE NEXT BUFFER IS EMPTY.
;SECOND WORD OF NEXT BUFFER IS ADDRESS CHECKED TO MAKE SURE
;IT IS NOT IN IO PROTECTED PART OF JOB DATA AREA OR ABOVE
;USER AREA
;ALSO END OF BUFFER IS CHECKED TO MAKE SURE NOT ABOVE JOB AREA



↑ADVBFF:
	AOS	NABFF
	PUSH	P,AC3
	JSP	AC3,PRSET
	SKIPN	TAC1,DEVIAD(DDB)	;IS THERE A BUFFER ADDRESS THERE?
	JRST	ADVXIT			;NO, ERROR EXIT
	JSP	AC3,ADRCK		;YES, IS IT LEGAL
	XCTR	XW,[MOVEM IOS,-1(TAC1)]
	MOVSI	TAC,IOUSE
	XCTR	XRW,[IORB TAC,(TAC1)]
	MOVE	TAC1,TAC
	JSP	AC3,ADRCK
	HRRM	TAC1,DEVIAD(DDB)
	XCTR	XR,[SKIPGE TAC1,(TAC1)]
	JRST	ADVXIT
	HLRZS	TAC1
	ADD	TAC1,TAC		;ADDRESS CHECK END OF BUFFER TOO
	JSP	AC3,ADRCK
ADVBF1:
	SKIPGE	TAC,JBTSTS(J)		;IF JOB IS NOT RUNNING . . .
	TLNE	TAC,SHF!SWP!CMWB	;OR SWUFFLING OR SCHWAPPING . . .
	JRST	ADVXIT			;DO NOT ALLOW THE DEVICE TO GO ON.
	TRNN	IOS,IOCON+740000
IFE FTXCTR,<	AOS	-6(P)>		;NO ERRORS, GIVE SUCCESS RETURN 
IFN FTXCTR,<	AOS	-10(P)>		;2 MORE FOR 160 AND @161
	JRST	ADVXIT			;LASTPR, TEM, J, AC1, AC2, AND AC3 ARE ON STACK

;ROUTINE TO ADDRESS CHECK AT UUO LEVEL ONLY
;CALL	HRRZ AC1,REL ADR.
;	PUSHJ PDP,UADCK1
;	NEVER RETURNS IF ERROR,STOPS JOB AND PRINTS ERROR
;BAD ADR. IF IN LOC 20-JOBPFI IN JOB DATA AREA
;OR IF ABOVE PROTECTION(USRREL) FOR CURRENT JOB


↑UUOACK:HRRZ  AC1,UUO	;CHECK UUO.

↑UADCK1:
	TRNN AC1,777760		; IN USER ACS?
	POPJ PDP,		;YES, ADDRESS IS OK

;ROUTINE TO ADDRESS CHECK AT UUO LEVEL ONLY
;USER ACS ARE ALSO ILLEGAL(ADR IS FOR IO USE LATER AT
;INTERRUPT LEVEL)
;CALL:	HRRZ AC1,REL.ADR.
;	PUSHJ PDP,UADRCK
;	NEVER RETURN IF ERROR


↑UADRCK: MOVE J,JOB(PID)
	CAILE AC1,JOBPFI 	;IS ADR. IN IO PROT. PART OF JOB DATA AREA?
	JRST UADCK2		;NO
	PUSH P,AC1	; SAVE OUR ACCUMULATOR
	MOVE AC1,UUOPC(ITEM)
	TLNE AC1,USRMOD
	JRST UADRER	; EXEC MODE IS GOD.
	POP P,AC1
	POPJ P,
UADCK2:
	CAMG AC1,USRREL(PID)	;NO, IS IT ABOVE PROTECT.?
	POPJ PDP,		;NO
	TRNN AC1,400000		; IS IT IN UPPER SEGMENT?
	JRST UADRER		; NO, MUST BE ERROR
	PUSH P,AC2		; GET US AN ACCUMULATOR
	LDB AC2,PSEGN		; PICK UP SEGMENT NUMBER
	JUMPE AC2,UADRER	; NONE IS ERROR
	HLRZ AC2,JBTADR(AC2)	; PICK UP REL. ADR.
	CAILE AC1,400000(AC2)
	JRST UADRER
	POP P,AC2
	POPJ P,

;ROUTINE TO ADDRESS CHECK AT ANY LEVEL
;CALL:	MOVE PROG,[XWD PROT.,RELOC,]
;	HRRZ TAC,REL. ADR.
;	PUSHJ PDP,IADRCK
;	ERROR RETURN(ERROR MESSAGE NOT PRINTED,JOB NOT STOPPED)
;	OK RETURN


↑IADRCK:
	MOVS TAC1,PROG		; GET PROTECTION TO RH
	CAILE TAC,JOBPFI	;ADR. ABOVE PROT. PART OF JOB DATA AREA?
	CAILE TAC,(TAC1)	;YES, BELOW OR EQUAL TO PROTECT.?
	POPJ PDP,		;NO
	JRST CPOPJ1		;YES, SKIP RETURN

;ROUTINE TO CHECK VALIDITY OF A DUMP MODE COMMAND LIST
;WHICH IS:
;A LIST OF 0 OR MORE IOWD FORMAT WORDS
;   TERMINATED BY A GOTO WORD(LH=0)
;  WHICH POINTS TO ANOTHER LIST OF 0 OR MORE IOWD FORMAT WORDS ETC.
;   UNTIL A GOTO WORD IS ENTIRELY ZERO
;
;SINCE MONITOR DOES NOT RESCHEDULE WHEN IN EXEC MODE
;A MAXIMUM LIST OF 100 IS IMPOSED

;CALL:	MOVE UUO,[XWD PROG,REL. ADR. OF FIRST COMMAND]
;	PUSHJ PDP,COMCHK
;	ADDRESS CHECK RETURN(ERROR ROUTINE IS NOT CALLED)
;	OK RETURN, SUM OF LH OF IOWDS IN DAT
;		ADDRESS OF FIRST IOWD (LH NOT 0) IN UUO


↑COMCHK:
	PUSH PDP,UUO		;SAVE POINTER TO LIST
	PUSH PDP,AC2
	PUSH PDP,AC3		;JS
	MOVEI AC1,JOBPFI	;HIGHEST IO PROTECTED LOC. IN JOB DATA AREA
	MOVE AC2,UUOPC(ITEM)
	TLNN AC2,USRMOD		; IS THIS A MONITOR CALL
	MOVEI AC1,JOBSAV	;YES, HIGHEST LOC. NOT WRITTEN BY SAVE
	SETZB DAT,AC2		;CLEAR WORD COUNT AND ADDRESS OF FIRST IOWD
	MOVEI ITEM,100		;ONLY 100 LISTS
	JRST COMCK1
COMCK0:
	HRR UUO,TAC1		;CHANGE COMMAND LIST POINTER ON GO TO WORD
	CAIE AC1,JOBPFI
	JRST COMCK1		;JS
	HRRZ TAC,UUO		;CHECK JUMP ADDRESS
	PUSHJ PDP,IADRCK
	JRST COMCKE		;ERROR.

COMCK1:
	SOJLE ITEM,COMCKE	;EXCEEDED 100 YET?
	SKIPN TAC1,@UUO		;NO. GET NEXT IOWD. END OF LIST?
	JRST COMCK2		;YES
	TLNN TAC1,777777	;IS IT A GO TO WORD?
	JRST COMCK0		;YES
	HLRO AC3,TAC1		;NO. SAVE NEGATIVE WORD COUNT ;JS
	HRRZS TAC1		;GET LOWEST ADDRESS-1
	CAMGE TAC1,AC1		;IS IT GREATER THAN LOC. PROTECTED
				;FROM IO IN JOB DATA AREA?
	JRST COMCKE		;NO. ERROR RETURN
	SUB TAC1,AC3		;YES. COMPUTE LAST LOC.	;JS
	CAMLE TAC1,USRREL(PID)	;IS LAST LOC. IN BOUNDS?
	JRST COMCKE		;NO. ERROR RETURN
	SUB DAT,AC3		;YES. ACCUMULATE NEG. WORD COUNT ;JS
	SKIPN AC2		;IS THIS THE FIRST IOWD?
	MOVE AC2,UUO		;YES. SAVE ADDRESS IN AC2
	AOJA UUO,COMCK1		;GO GET NEXT IOWD

COMCK2:
	SKIPE AC2		;ARE THERE ANY IOWDS WITH LH NOT 0?
	MOVE UUO,AC2		;YES, POINT UUO TO FIRST SUCH IOWD.
				;OTHERWISE, UUO POINTS TO A ZERO.
	POP PDP,AC3		;JS
	POP PDP,AC2
	JRST TPOPJ1		;REMOVE SAVED UUO AND SKIP RETURN
COMCKE:
	POP PDP,AC3		;JS
	POP PDP,AC2
	POP PDP,UUO		;RESTORE ORIGINAL UUO
	POPJ PDP,		;ERROR RETURN

;ASSASG	ASSIGN DEVICE IF UNASSIGNED
;CALL:	MOVE	J, JOB NUMBER
;	MOVE	DDB, ADDRESS OF DDB
;	MOVEI	TAC1, EITHER ASSPRG OR ASSCON
;	PUSHJ	P, ASSASG
;	CAN'T	ASSIGN RETURN
;	DEVICE ASSIGNED RETURN


↑ASSASG:
	MOVE	TAC,JBTPRV(J)
	TLNE	TAC,LUPPRV		;LOCAL USER?
	JRST	ASSAS3			;YES. BYPASS TEST
	MOVE	TAC,DEVCMR(DDB)
	TLNE	TAC,DEVLUP		;REQUIRES LOCAL USER STATUS?
	POPJ	P,			;YES.  FAIL.
ASSAS3:
	MOVE	TAC,DEVCMR(DDB)
	TLNN	TAC,DEVSHR		;SHARABLE DEV?
	JRST	ASSAS2			;NO
	HRRZ	TAC,DEVSER(DDB)
	PUSHJ	P,DGETDD(TAC)		;YES - MAKE A NEW DDB
	JRST	ASSAS0

ASSAS2:
	LDB	TAC,PJOBN
	CAIE	TAC,(J)			;IS THIS DDB OURS?
	JRST	ASSAS1
;	MOVE TAC,TAC1
;	ANDI TAC,ASSPRG
;	TDNN TAC,DEVMOD(DDB)		;ARE WE INITING AN ALREADY INITED DEVICE?
	JRST	ASSAS0			;NO
	POPJ	P,			;YES, LOSE

ASSAS1:
	MOVE	TAC,[TTYATC,,ASSCON!ASSPRG]
	CONO	PI,SCNOFF		;TURN SCANNER OFF
	TDNE	TAC,DEVMOD(DDB)		;ONE LAST CHECK
	JRST	SCNONJ			;OOPS - EATEN AWAY FROM UNDER US
ASSAS0:
	DPB	J,PJOBN			;NO, STORE JOB NUMBER
	IORM	TAC1,DEVMOD(DDB)	;SET ONE OF ASSIGN BITS
	MOVSI TAC,DVTTY
	TDNE TAC,DEVMOD(DDB)
	JRST ASSAST			;JUMP IF ASSIGNING A TTY
ASSASZ:
	CONO	PI,SCNON		;TURN SCANNER CHAN. BACK ON
	JRST	CPOPJ1

ASSAST:
	PUSH P,AC1
	LDB TAC,PUNIT
	SKIPGE TTYTAB(TAC)		;SKIP IF COMBIT IS NOT SET
	SOS COMCNT
	MOVSI AC1,COMBIT+DLYBIT
	ANDCAM AC1,TTYTAB(TAC)
	POP P,AC1
	JRST ASSASZ

;ROUTINE TO SEARCH FOR A DEVICE
;CALL:	HRR ITEM,JOB NUMBER
;	MOVE TAC,[SIXBIT .DEVICE NAME.]
;	PUSHJ PDP, DEVSRC
;	NOT FOUND
;	FOUND

	
↑FNDDDB:TLNE TAC,770000		;IS IT NAME OR #?
	JRST DEVSRC
	CAMG TAC,USRHCU(PID)	;LEGAL CHANNEL?
	SKIPN DDB,USRJDA(TAC)	;GET DDB POINTER
	POPJ P,			;LOSE
	JRST CPOPJ1

↑DEVSRC:
	MOVSI DEVDAT,JLOG	;IS JOB LOGGED IN?
	TDNE DEVDAT,JBTSTS(J)
				;DO NOT SEARCH LOGICAL NAMES IF
				;FETCHING "LOGOUT" FROM "SYS".
	PUSHJ PDP, DEVLG	;SEARCH LOGICAL NAMES FIRST
	JRST DEVPHY		;NOT FOUND, SEARCH PHYSICAL NAMES
	JRST CPOPJ1		;FOUND

;SEARCH LOGICAL NAMES

↑DEVLG:	HLRZ DEVDAT,DEVLST	;BEGINNING OF DDB CHAIN
DEVLP0:
	CAME TAC,DEVLOG(DEVDAT)	;COMAPRE WITH LOGICAL NAME
	JRST DEV0		;NO MATCH
	LDB TAC1,PJOBN		;DOES THE LOGICAL NAME BELONG TO THIS JOB?
	CAMN TAC1,ITEM
	JUMPN TAC,CPOPJ1	;YES, GIVE SUCCESSFUL RET. IF NAME NOT 0
DEV0:
	HLRZ DEVDAT,DEVSER(DEVDAT)
				;NO, KEEP LOOKING
	JUMPN DEVDAT,DEVLP0
	POPJ PDP,		;FINISHED AND NOT FOUND

;SEARCH PHYSICAL NAMES

↑DEVPHY:
	CAMN TAC,[SIXBIT /OPR/]	; IS IT "OPR"?
	MOVE TAC,DEVOPR		;YES, CHANGE TO OPERATOR'S TTY
	CAMN TAC,[SIXBIT /SYS/]	;IS IT "SYS"?
	SKIPA TAC,SYSTAP	;YES, CHANGE TO SYSTEM TAPE DEVICE NAME
	TDZA TAC1,TAC1		;NO, CLEAR SYSTEM TAPE FLAG
	MOVEI TAC1,SYSDEV	;YES, SET SYSTEM TAPE FLAG
	HLRZ DEVDAT,DEVLST	;SEARCH DEVICE DATA BLOCKS
DEVLP1:

	TLO DEVDAT,(TAC1)	;SET SYSTEM TAPE BIT IF SEARCHING FOR SYS
	CAMN TAC,DEVNAM(DEVDAT)	;MATCH OF PHYSICAL NAME?
	JUMPN TAC,CPOPJ1	;YES, GIVE OK RET. IF NAME IS NOT 0
DEVLP2:
	HLRZ DEVDAT,DEVSER(DEVDAT)
	JUMPN DEVDAT,DEVLP1
	CAME TAC,[SIXBIT /TTY/]	;IS THIS PUBLIC LOGICAL NAME TTY?
	JRST	DEVLP3		;SEE IF IT'S A TTY.
	PUSH PDP,DAT		;SAVE OUTPUT BYTE POINTER(TTY) OR INIT. ARG. ADR.
	PUSHJ PDP,TTYFND	;YES, FIND TTY JOB IS ATTACHED TO
	POP PDP,DAT		;RESTORE
	JRST CPOPJ1		;AND GIVE SUCCESSFUL RETURN
DEVLP3:
	PUSH P,TAC		;SAVE DEVICE NAME IN CASE NOT FOUND
	PUSH P,DAT		;AND THIS IN CASE IT IS
	PUSHJ P,GETDDB		;SEE IF TTY DDB
	CAIA
	AOS -2(P)		;SKIP ON SUCCESS
	POP P,DAT
	POP P,TAC
	POPJ P,

;ROUTINE TO SETUP N-RING IO BUFFER IN USER AREA

;CALL:	PUSHJ PDP,BUFCLC
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
; SETS UP AN N BUFFER RING FOLLOWING THE USER'S PROGRAM, WHERE N
; IS IN THE ADDRESS FIELD OF AC UUO.
; THE BUFFER RING FORMAT IS AS FOLLOWS:
;	LOCATION		LH   CONTENTS   RH
; C(JOBFF) + 1              BUFFER         C(JOBFF) +1
;    + 0(BUFFER SIZE+2)      SIZE               + 1(BUFFER SIZE+2)
; C(JOBFF) +1               BUFFER         C(JOBFF) +1
;     +1(BUFFER SIZE+2)      SIZE                + 2(BUFFER SIZE+2)
;         .		.		     .
;	.		.		     .
;	.		.		     .
; C(JOBFF) + 1	        BUFFER	   C(JOBFF) + 1
;    + (N-2)(BUFFER SIZE+2)  SIZE               +(N-1)(BUFFER SIZE+2)
; C(JOBFF) + 1	        BUFFER	   C(JOBFF) + 1
;    + (N-1)(BUFFER SIZE+2)  SIZE		   
;THEN SET 	BUFPNT:=IOUSE,C(JOBFF) + 1
; AND		JOBFF:=C(JOBFF) + N(BUFFER SIZE + 2)
; BUFWRD IS RESTORED.

BUFWRD←←AC3

↑BUFCLC:
	LDB TAC,PDVBLN
				; GET BUFFER SIZE IN TAC
BUFCLM:
	PUSH PDP,BUFWRD		; SAVE BUFWRD ON STACK
	HRRZ BUFPNT,JOBFF(PROG)	; BUFPNT:= FIRST FREE USER LOC+1
	ADDI BUFPNT,1
	HRRZ BUFWRD,BUFPNT
	HRL BUFWRD,TAC		; PUT XWD BUFSIZ,JOBFF IN BUFWRD
	ADDI TAC,2		; ADD 2 TO BUFFER SIZE
	HRRZ TAC1,UUO		; GET NUMBER OF BUFFERS
	JUMPG	TAC1,.+2	;SKIP UNLESS NONE WERE REQUESTED. (ME 12-11-72)
	MOVEI	TAC1,2		;GIVE HIM TWO.
	HRRZ AC1,TAC
	IMUL AC1,TAC1
	ADD AC1,BUFWRD
	HRRZ AC1,AC1
	CAMG AC1,USRREL(PID)	; WILL THIS SPACE FIT IN USER CORE?
	JRST BUFC1		; YES, DO INBUF CODE

; HERE, WE WANT TO EXPAND CORE TO FIT IN A RING OF BUFFERS

	PUSH PDP,TAC		; NO.
	PUSH PDP,UUO		;  SO
	PUSH PDP,TAC1		;   WE
	PUSH PDP,BUFPNT		;    SAVE
	PUSH PDP,BUFWRD		;     A
	PUSH PDP,DEVDAT		;      FEW
	PUSH PDP,DSER		;       AC'S
	MOVE ITEM,JOB(PID)	;       AND DO A CORE UUO TO MAKE ROOM
	MOVE TAC,AC1		;       HOW HIGH TO TRY FOR
	MOVEI UUO,UUO		;       ..
	PUSHJ PDP,UCORE		;       TRY FOR ANOTHER K OF USER CORE
	JFCL			;       LET ADR CHECK HAPPEN IF CAN'T DO SO
	POP PDP,DSER		;       AND
	POP PDP,DEVDAT		;      WE
	POP PDP,BUFWRD		;     RESTORE
	POP PDP,BUFPNT		;    THE
	POP PDP,TAC1		;   FEW
	POP PDP,UUO		;  AC'S
	POP PDP,TAC		; DUE TO IOWAIT
				; FALL INTO BUFC1

; END OF LOOP FOR SETTING UP AN N-RING BUFFER

BUFC1:
	ADD	BUFWRD,TAC	;ADD IN LENGTH OF BUFFER, ADDR OF NEXT BUFFER
	HRRZ	AC1,BUFPNT	;IS THIS ADDR IN BOUNDS?
	PUSHJ	P,UADRCK
	XCTR	XW,[MOVEM BUFWRD,(BUFPNT)]	;PUT THIS ADDRESS IN BUFFER HEADER
	HRR	BUFPNT,BUFWRD
	SOJG	TAC1,BUFC1		;LOOP AROUND AND MAKE N-1 MORE BUFFERS
	HRR	BUFWRD,JOBFF(PROG)	;UPDATE THE USER'S JOBFF
	ADDI	BUFWRD,1
	MOVEI	AC1,-2(BUFPNT)		;CHECK LAST ADDRESS OF HEADER
	PUSHJ	P,UADRCK
	SUB	BUFPNT,TAC
	XCTR	XW,[MOVEM BUFWRD,(BUFPNT)]	;LINK LAST BUFFER TO FIRST BUFFER
	ADDI	BUFPNT,-1(TAC)
	HRRM	BUFPNT,JOBFF(PROG)	;UPDATE USER'S JOBFF
	HRR	BUFPNT,BUFWRD		;LOAD IN USE BIT AND ADDRESS OF FIRST BUFFER
	HRLI	BUFPNT,IOUSE
	POP	P,BUFWRD		;RESTORE BUFWRD FROM STACK
	POPJ	P,			;EXIT

;ROUTINE TO CLEAR IO BUFFER IN USER AREA
;CALLED AT INTERRUPT AND UUO LEVEL

;CALL:	HRRZ TAC,REL. ADR. OF 2ND WORD OF USER BUFFER
;	PUSHJ PDP,BUFCLR
;	ERROR RETURN MEMORY EXCEEDED
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
; CLEARS THE WORD COUNT AND DATA AREA OF THE BUFFER WHOSE ADDRESS
; IS IN TAC 18-35.

	

↑BUFCLR:
	PUSHJ PDP,IADRCK	; ADDRESS IN BOUNDS?
	POPJ PDP,		;NO. ERROR RETURN
	HRLI TAC,PROG		; SET TO RELOCATE BY PROG
	PUSH PDP,TAC		;SAVE FIRST BUFFER ADR.
	HLRZ TAC1,@TAC		;TAC1 18-35=SIZE
	TRZ TAC1,400000
	ADD TAC,TAC1		;LAST ADR=2ND ADR+SIZE
	TLZ TAC,-1		;CLEAR LEFT HALF
	PUSHJ PDP,IADRCK	;LAST ADDRESS IN BOUNDS?
	JRST TPOPJ		;NO. ERROR RETURN
	HRLI TAC,PROG		; SET LAST ADR. FOR RELOCATION
	POP PDP,TAC1		;RESTORE FIRST ADR.
	NOSHUFF			;NO SHUFFLING
	MOVEI TAC1,@TAC1	; GET ABS. ADDR OF 2ND WD. OF BUFFER
	HRL TAC1,TAC1
	AOBJN TAC1,.+1		;THIRD WORD IN BUFFER
	SETZM (TAC1)		;CLEAR THIRD WORD
	AOS TAC1		;SET DEST. ADR. TO 4TH WORD
	BLT TAC1,@TAC		;CLEAR BUFFER
	SHUFFLE			;SHUFFLING
	JRST CPOPJ1		;SUCESSFUL RETURN

;ROUTINE TO COMPUTE 12 BIT FOLDED CHECKSUM

;CALL:	PUSHJ PDP,CKS12
;	EXIT		ALWAYS RETURNS HERE
;CALCULATES FOLDED 12 BIT CHECKSUMS OF THE DATA WORDS IN THE
;BUFFER WHOSE ADDRESS IS IN AC TAC1.  TWO ALGORITHMS ARE USED.
;ON RETURN, THE LEFT HALF OF AC TAC CONTAINS A CHECKSUM OBTAINED
;BY ACCUMULATING, IN ONE'S COMPLEMENT, THE DATA WORDS AND FOLDING IT.
;THE LEFT HALF OF AC DAT CONTAINS A CHECKSUM OBTAINED BY ACCUMULATING,
;IN TWO'S COMPLEMENT, THE DATA WORDS AND FOLDING IT.  AC TAC1
;CONTAINS A 1.


↑CKS12:	ADD TAC1,PROG		;TAC1:=-WORD COUNT,ADDRESS OF FIRST DATA WORD
	AOS TAC1
	HRRZ TAC,0(TAC1)
	MOVNS TAC
	AOS TAC1
	HRL TAC1,TAC
	SETZM TAC		;INITIALIZE TWO'S COMPLEMENT SUM
CKS12A:
	ADD TAC,0(TAC1)		;TWO'S COMPLEMENT ADD
	AOBJN TAC1,CKS12A	;DONE?
	LSHC TAC,-30
	LSH TAC1,-14
	ADD TAC,TAC1
	LSHC TAC,-14
	LSH TAC1,-30
	ADD TAC,TAC1
	TRZE TAC,770000
	AOS TAC
	HRLZS TAC
	MOVEI TAC1,1		;TAC1:=1
	POPJ PDP,

;ROUTINE TO CLEAR RESIDUE OF WORD POINTED TO BY A BYTE POINTER

;CALL:	PUSHJ PDP,CLRBYT
;	EXIT		ALWAYS RETURNS HERE
;CALLED WITH A BYTE POINTER IN AC TAC, IT CLEARS THE REST OF THE
;WORD POINTED TO BY THE BYTE POINTER.


↑CLRBYT:
	LDB TAC1,[POINT 6,TAC,5]	; SET UP POINTER
	DPB TAC1,[POINT 12,TAC,11]	;TAC 0-5:=0,TAC 6-12:=P
	SETZM TAC1
	DPB TAC1,TAC			;CLEAR BITS 36-P THROUGH 35
	POPJ PDP,			;RETURN

;IOALL, IOALLR, IORELS,IOWAIT

↑IOWAIT:	SKIPA TAC,[WAIT1]	;WAIT FOR ALL DEVICES TO BE INACTIVE
↑IORELS:	MOVEI TAC,RELEA3	;RELEASE ALL IO DEVICES. FALL INTO IOALL

;ROUTINE TO DO IO FOR ALL DEVICES ASSIGNED TO JOB
;CALL	MOVEI TAC,ADR. OF IO SUB.
;	PUSHJ PDP,IOALL

↑IOALL:	PUSH PDP,TAC			; SAVE SUBROUTINE CALL
	SETZB UCHN,UUO			;START WITH USER CHANNEL 0
	SKIPL DEVDAT,USRHCU(PID)	; IS THIS NEGATIVE?
	JRST IOALL1
	SETZM USRHCU(PID)		;SAVE-GET HAS BEEN HERE, RELEASE DEVICE ANYWAY!!!
	JRST IOALL2
IOALL1:
	CAMLE UCHN,USRHCU(PID)		;IS IT GREATER THAN HIGHEST CHAN. USED?
	JRST IOALLP			;YES, POP PDP,TAC; POPJ PDP,
	SKIPN DEVDAT,USRJDA(UCHN)	;GET NEXT DDB ADR., IS IT IN USE?
	AOJA UCHN,IOALL1		;NO, KEEP GOING
IOALL2:
	MOVE IOS,DEVIOS(DEVDAT)
	DPB UCHN,PUUOAC
	MOVE DSER,DEVSER(DEVDAT)	;SETUP ADR. OF DEV. DISP. TABLE
	LDB J,PJOBN			;DOES THIS DDB BELONG
	CAMN J,JOB(PID)			;TO THIS JOB?
	PUSHJ PDP,@(PDP)		;YES, CALL THE SUB.
	MOVE J,JOB(PID)			;KEEP THIS HONEST
	AOJA UCHN,IOALL1		;INCREMENT USER CHAN. NO.

IOALLP:
	SKIPL UCHN,JBTIOP(J)		;GET IO PDL POINTER
	JRST TPOPJ			;NONE THERE. RETURN
	PUSH P,[-1]
IOALP1:
	SKIPN DDB,(UCHN)		;SKIP FLUSHED CHANNELS
	JRST IOALP2
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)		;EVERYONE MUST LIVE SOMEWHERE
	MOVE DDB,USRJDA
	PUSH P,UCHN
	SETZ UCHN,
	MOVE IOS,DEVIOS(DDB)
	DPB UCHN,PUUOAC
	MOVE DSER,DEVSER(DDB)		;SETUP ADR. OF DEV. DISP. TABLE
	LDB J,PJOBN			;DOES THIS DDB BELONG
	CAMN J,JOB(PID)			;TO THIS JOB?
	PUSHJ P,@-2(P)			;YES, CALL THE SUB.
	MOVE J,JOB(PID)			;KEEP THIS HONEST
	POP P,UCHN
	MOVE DDB,(UCHN)
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)
	JUMPE DDB,IOALP2
	SETZM (P)			;FLAG TO NOT RETURN JBTIOP
IOALP2:
	ADD UCHN,[1,,1]
	AOBJN UCHN,IOALP1
	POP P,TAC
	JUMPE TAC,TPOPJ
	PUSH P,AC1
	HRRZ AC1,JBTIOP(J)		;FLUSH IO STACK
	SETZM JBTIOP(J)
	PUSHJ P,FSGIVE
	POP P,AC1
	JRST	TPOPJ


;HERE TO CHASE THROUGH THE DDB LIST AND CALL RELEA5 FOR ANY DDB OF OURS
;CALLED FROM IOKILL
;THIS IS A KLUDGE TO RECTIFY THE PROBLEM OF DDBS GETTING LOST FROM JOBJDA

IOALLR:
	PUSH	P,USRJDA
	MOVEI	DDB,DEVLST-DEVSER
IOALR1:
	HLRZ	DDB,DEVSER(DDB)
	JUMPE	DDB,IOALR3
IOALR2:
	LDB	J,PJOBN
	CAME	J,JOB(PID)
	JRST	IOALR1
	MOVE	UCHN,DEVMOD(DDB)
	TRNN	UCHN,ASSPRG		;ASSIGNED BY PROGRAM?
	JRST	IOALR1			;NO
	MOVEM	DDB,USRJDA
	MOVEI	UCHN,0
	DPB	UCHN,PUUOAC
	MOVE	IOS,DEVIOS(DDB)
	MOVE	DSER,DEVSER(DDB)	;SETUP ADR. OF DEV. DISP. TABLE
	PUSH	P,DSER			;SAVE DSER
	PUSHJ	P,RELEA5		;RELEASE THIS DDB
	POP	P,DDB
	HLRZ	DDB,DDB			;ADDRESS OF NEXT DDB
	JUMPN	DDB,IOALR2		;CONTINUE THROUGH THE DDB CHAIN.
IOALR3:
	POP	P,USRJDA
	MOVE	J,JOB(PID)		;KEEP THIS HONEST
	POPJ	P,

;IOKILL, CLRUSR

;KILL ALL DEVICES(RELEASE WITHOUT WAITING FOR DEVICE INACTIVE)

↑IOKILL:
	MOVEI	TAC,RELEA5
	PUSHJ	P,IOALL		;RELEASE ALL DEVICES WITHOUT WAITING
	PUSHJ	P,IOALLR	;CHASE THRU DDB LIST AND RELEASE ANY OTHERS

;ROUTINE TO CLEAR PROTECTED JOB DATA AREA IN MONITOR
;AND RECLAIM FREE AREA ABOVE USER PROGRAM FOR IO BUFFERS

	HLRZ	TAC,JOBSA(JDAT)	;RESET FIRST FREE LOC. FOR THIS JOB
	MOVEM	TAC,JOBFF(JDAT)
↑CLRUSR:
	SETZM	JOBENB(JDAT)	;INITIALIZE USER FOR NO TRAPS ENABLED
	MOVEI	TAC,USRLO1(PID)	;FIRST LOC+1 TO CLEAR
	HRLI	TAC,USRLO(PID)	;FIRST LOC.
	SETZM	USRLO(PID)
	BLT	TAC,USRHI(PID)
	SETZM	USRHCU(PID)	;CLEAR HIGHEST USER IO CHAN. IN USE
	POPJ	P,


;ROUTINE TO FLAG DEVICE ACTIVE  - ORACT, SETACT, CLRACT, STOIOS
;CALL	MOVE IOS,IO STATUS BITS
;	MOVE DEVDAT,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ PDP,SETACT
;CALLED BY ALL IO SERVICE ROUTINES AT UUO AND INTERRUPT LEVELS



↑ORACT:	SKIPE SPWUUF(PID)
	CONSZ PI,77000
	CAIA
	JRST SPWERR
	TRO IOS,IOACT
	IORB IOS,DEVIOS(DDB)
	JRST ORACT1
↑SETACT:
	SKIPE SPWUUF(PID)
	CONSZ PI,77000
	CAIA
	JRST SPWERR
	TROE IOS,IOACT
	JRST STOIOS
	TLZA	IOS,IOW
↑CLRACT:
	TRZ IOS,IOACT
↑STOIOS:
	MOVEM IOS,DEVIOS(DDB)
ORACT1:
	LDB TAC,PDVTIM		;GET NO. OF SECONDS
	DPB TAC,PDVCNT		;TO WAIT BEFORE
	POPJ P,		;DEVICE IS CONSIDERED HUNG

; THIS ROUTINE UPDATES EACH DEVICE'S HUNG COUNT AND DISPATCHES
; IF THE COUNT IS EXHAUSTED

↑DEVCHK:
	MOVEI TAC,JIFSEC	; RESET HUNG DEVICE CHECK TIME
	MOVEM TAC,HNGTIM	;TO CHECK ONCE A SECOND
;	HLRZ DEVDAT,DEVLST
	SOSN DSKHNG		;SEE IF DISK IS HUNG THIS WAY!
	PUSHJ P,DSKDSP+DHNG	;CALL DISK HUNG ROUTINE
	MOVEI DDB,PTRDDB	;SKIP DSK AND UDP
DEVCK0:
	MOVE IOS,DEVIOS(DEVDAT)	;IS DEVICE ACTIVE?
	TRNN IOS,IOACT
	JRST DEVCK2		;NO
DEVCK3:
	LDB TAC,PDVCNT		; YES, DECREMENT HUNG COUNT
	SOJL TAC,DEVCK1		;0 MEANS IGNORE DEVICE
	DPB TAC,PDVCNT		; NOW REPLACE IT IN THE DDB
	JUMPN TAC,DEVCK1	;HAS COUNT GONE TO 0?
	MOVE DSER,DEVSER(DEVDAT);YES, GET DISPATCH TABLE ENTRY
	PUSH PDP,DEVDAT
	PUSHJ PDP,DHNG(DSER)	;DISPATCH TO SERVICE ROUTINES TO 
				;UNHANG DEVICE
	PUSHJ PDP,DEVHNG	;PRINT ERROR MESSAGE AND STOP JOB
	POP PDP,DEVDAT		;DO NOT PRINT MESS. AND STOP JOB RETURN
DEVCK1:
	HLRZ DEVDAT,DEVSER(DEVDAT)
	CAIE DEVDAT,TTYLST	;DON'T DO TTY'S
	JUMPN DEVDAT,DEVCK0
	POPJ PDP,

DEVCK2:
	MOVE DAT,DEVCMR(DEVDAT)	; PULL IN EXTRA DEVCHR BITS
	TLNE DAT,DEVIBF		; DOES THIS DEVICE HAVE AN INTERNAL BUFFER?
	TLNN IOS,DEVSBB		; IF IT DOES, IS IT BUSY?
	JRST DEVCK1		; NOT BUSY, IGNORE DEVICE
	JRST DEVCK3		; BUSY, INCREMENT HUNG COUNT

; OTHER USEFUL ROUTINES FOR SETING UP USER BUFFER POINTERS
; CHECK RING USE BIT AND SEE IF USER HAS ANOTHER BUFFER TO FILL
; SET UP DEVDAT AND PROG
; DOES SCRATCH WORK IN TAC
; SKIPS IF HE HAS BUFFERS HE CAN BE FILLING

↑DEVCR:	HLR TAC,DEVBUF(DEVDAT)	; PICK UP RELATIVE ADDRESS OF HIS BUFFER HEADER
	HRLI TAC,PROG		; SET TO INDEX BY HIS RELOCATION CONSTANT
	HRR TAC,@TAC		; WE NOW HAVE THE ABSOLUTE ADDRESS OF THE FIRST BUFFER
	SKIPL @TAC		; CHECK THE RING USE BIT, AGAIN INDEXED BY PROG
	AOS (PDP)		; BUFFER IS FREE, LET HIM FILL IT
	POPJ PDP,

; SET UP WORD COUNT IN AC2
; SET UP 7-BIT BYTE POINTER TO ACTUAL DATA IN AC3
; DEVDAT AND PROG MUST BE SET UP
; ROUTINE SKIPS ON SUCCESS, DOESN'T SKIP IF BUFFER IS EMPTY

↑DEVSTU:
	SKIPL @DEVOAD(DEVDAT)	; FIRST, SEE IF THIS BUFFER HAS ALREADY BEEN EMPTIED
	POPJ PDP,		; YES IT HAS, EXIT NOW
	MOVEI AC3,@DEVOAD(DEVDAT)
	HRRZ AC2,1(AC3)		; WORD COUNT IS LOCATED 1 LOC AFTER HEADER ADDRESS
	ADD AC3,[POINT 7,2]	; MAKE ABSOLUTE ADDRESS INTO A BYTE POINTER TO THE WORD AFTER THE WORD COUNT
	AOS (PDP)		; SKIP UPON SUCCESS
	POPJ PDP,

;ROUTINE TO SETUP PROG AND ITEM FOR INTERRUPT SERVICE ROUTINE

;CALL	PUSHJ PDP,IOSET
;	EXIT	ALWAYS RETURNS HERE
;THIS PROGRAM IS CALLED FROM AN INTERRUPT SERVICE ROUTINE.
;IT PUTS THE ADDRESS OF THE DATA AREA OF THE JOB (C(JBTADR18-35))
;CONNECTED TO THE DEVICE SPECIFIED BY AC DEVDAT IN AC PROG AND
;PUTS THE ITEM POINTER (C(DEVCTR)) IN AC ITEM.

	

↑IOSET:	LDB PROG,PJOBN
	MOVE ITEM,DEVCTR(DEVDAT)	;ITEM:=ITEM POINTER=C(DEVCTR)
	MOVE PROG,JBTADR(PROG)		;PROG:=C(JBTADR 18-35)
	POPJ PDP,			;RETURN

;CALLING SEQUENCE
;	PUSHJ PDP,IOSETC
;	EXIT		ALWAYS RETURNS HERE

;SETS JBFPTR18-35:=C(TAC1 18-35)
;	JBFCTR:=C(ITEM)*[WORD LENGTH/BYTE SIZE]
;WHERE	WORD LENGTH:=36 DECIMAL
;	BYTE SIZE:=C(JBFPTR6-11)
;	[X]:= INTEGER PART OF X




↑IOSETC:
	ADDI	JBUF,1			;JBFPTR12-18 SET TO 0
	MOVSI	TAC,7777		;JBFPTR18-35:=C(TAC1 18-35)+1
	XCTR	XRW,[ANDM TAC,(JBUF)]
	XCTR	XRW,[HRRM TAC1,(JBUF)]
	XCTR	XRW,[AOS (JBUF)]
;NEXT 3 INST'S ADDED BY RPH TO AVOID INVALID WORD COUNTS 10-11-72
	XCTR	XLB,[LDB TAC1,[POINT 17,(TAC1),17]]	;GET BUFFER SIZE
	CAILE	ITEM,-1(TAC1)			;MORE DATA INDICATED THAN CAN BE IN BUFFER?
	MOVEI	ITEM,-1(TAC1)			; YES, SET TO MAX
	XCTR	XLB,[LDB TAC1,[POINT 6,(JBUF),11]]	;TAC1:=BYTE SIZE
	PUSHJ	P,ITMCT1			;JBFCTR:=C(ITEM)*[36/BYTE SIZE]
	ADDI	JBUF,1
	XCTR	XW,[MOVEM ITEM,(JBUF)]
	POPJ	P,				;EXIT

;ROUTINE TO RETURN NO. OF ITEMS IN BUFFER

;CALL:	PUSHJ PDP,ITMSET
;	EXIT		ALWAYS RETURNS HERE
;SETS AC ITEM:=(BUFFER SIZE-1)*[WORD LENGTH/BYTE SIZE]
;WHERE BUFFER SIZE:=BITS 1-17 OF THE BUFFER HEADER WORD POINTED TO
;		BY C(DEVADR)
;	WORD LENGTH:=36 DECIMAL
;	BYTE SIZE:=INTEGER PART OF X.

;CALLING SEQUENCE
;	PUSHJ PDP,ITMCNT
;	EXIT		ALWAYS RETURNS HERE
;SETS AC ITEM:=C(ITEM)*[WORD LENGHT/BYTE SIZE]

↑ITMSET:
	LDB ITEM,[POINT 17,@DEVADR(DEVDAT),17]
	SUBI ITEM,1
	LDB TAC1,[POINT 6,DEVPTR(DEVDAT),11]
↑ITMCT1:
	MOVEI TAC,44		; GET C(ITEM):=C(ITEM)*[WORD LENGTH/C(TAC1)]
	IDIV TAC,TAC1
	IMUL ITEM,TAC
	POPJ PDP,

;ROUTINE TO SET DEVICE STATUS WORD FROM UUO
;AND SETUP IOS


↑SETIOS:
	PUSHJ PDP,WAIT1
	PUSHJ	P,SETMOD
	JRST	ILLMOD
	POPJ	P,

↑SETMOD:
	LDB TAC1,[POINT 4,UUO,35]	;GET DEVICE DATA MODE
SETIO2:
	MOVEI TAC,1		;AND CHECK FOR LEGALITY
	LSH TAC,(TAC1)
	TDNN TAC,DEVMOD(DEVDAT)
	JRST SETIO1
	TRZ UUO,IOACT		;LET USER SET ALL BITS EXCEPT IOACT
	HRRM UUO,DEVIOS(DEVDAT)
	JRST	CPOPJ1

SETIO1:
	CAIE TAC1,2		;MODE 2?
	POPJ	P,		;NO. ILL MODE
	MOVEI TAC1,D		;YES. TRY MODE 17 INSTEND.
	ADDI UUO,D-2
	JRST SETIO2

;SETUP BYTE POINTER AND ITEM COUNT
;CALLED BY STODAT ONLY (AT INTERRUPT LEVEL)
;CALL	PUSHJ PDP,NEWBUF
;	ADDRESS CHECK WHEN SETTING UP BUFFER
;	OK RETURN





NEWBUF:
	HRRZ TAC,DEVADR(DEVDAT)	;TAC:=INPUT BUFFER HEADER ADDRESS
	PUSHJ PDP,BUFCLR	;CLEAR INPUT BUFFER.
	POPJ PDP,		;ADDRESS CHECK
	HRR TAC,DEVADR(DEVDAT)
	HRLZI TAC,7737
	AND TAC,DEVPTR(DEVDAT)	;DEVPTR 0-5:=0, DEVPTR 12:=0
	HRR TAC,DEVADR(DEVDAT)	;DEVPTR 18-35:=C(DEVADR 18-35) + 1
	AOS TAC
	MOVEM TAC,DEVPTR(DEVDAT)
	PUSHJ PDP,ITMSET	;ITEM:=(BUFFER SIZE-1)*[36/BYTE SIZE]
	MOVEM ITEM,DEVCTR(DEVDAT)	;DEVCTR:=ITEM COUNT
	JRST CPOPJ1		;RETURN

;ROUTINE TO SETUP BYTE POINTER ACCORDING TO DATA MODE

;CALL:	PUSHJ PDP,SETBYT
;	EXIT		ALWAYS RETURNS HERE
;SETS	TAC 0-5:=0
;	TAC 6-11:=S
;	TAC 12-13:=0
;	TAC 14-17:=PROG
;WHERE S=36 IF DATA MODE (IOS 32-25) IS BINARY (B)
;	IMAGE (I), IMAGE BINARY (IB), OR DUMP (SD,D,DR)
;      S=7  IF DATA MODE IS 	ASCII PACKED (A)
;			ASCII LINE (AL)
;			ASCII SEQUENCED (AS)
;			ASCII SEQUENCED LINE (ASL)
;		OR	ALTERNATE MODE BREAK (AM)


↑SETBYT:
	TRNN IOS,14		; IS MODE LESS THAN 10?
	HRLI TAC,700+PROG	;YES,ASCII OR ASCII LINE
	TRNE IOS,14		;10 OR GREATER?
	HRLI TAC,4400+PROG	;YES, IMAGE,IMAGE BIN. OR BIN.
	POPJ PDP,

; ROUTINE TO STORE DATA IN IOBUFFER FOR INPUT DEVICES THAT
; OPERATE CHARACTER AT A TIME.

; CALLING SEQUENCE . . .
;       PUSHJ PDP,STODAT
;       EXIT1        CHECKSUM ERROR
;       EXIT2        BLOCK FULL OR BLOCK BOMPLETE
;       EXIT3        DATA STORED CORRECTLY
; CALLED FROM AN INPUT SERVICE ROUTINE WITH A DATA ITEM IN AC DAT.
; STORES THE DATA ITEM IN THE BUFFER, CHECKING TO SEE IF IT WERE
; THE FIRST ITEM ON THE BUFFER AND SETTING UP THE POINTER AND
; WORD COUNT APPROPRIATELY CHECKING THE MODE TO SEE IF ANY SPECIAL
; PROCESSING NEED BE DONE. FOR EXAMPLE, THE TERMINATION
; OF A BUFFER ON CERTAIN CHARACTERS IN OTHER MODES, OR IF THE BUFFER
; IS FULL. THERE ARE THREE RETURNS FROM THIS ROUTINE: THE FIRST
;RETURN OCCURS ON AN ERROR CONDITION, THE SECOND RETURN OCCURS
;ON A BLOCK FULL CONDITION OR BLOCK COMPLETE CONDITION, THE THIRD
;RETURN OCCURS ON THE DATA STORED CORRECTLY CONDITION.  THIS
;ROUTINE ALSO DOES SOME CHECKING ON INPUT OF BINARY RECORD,
;PAPER TAPE OR CARDS.
;CALLING SEQUENCE
;	PUSHJ PDP,STOSQD
;	XXXX		ALWAYS SKIPS 
;	EXIT		ALWAYS RETURNS HERE
;STORES THE WORD COUNT:=C(DEVPTR 18-35) -C(DEVIAD 18-35) - 1
;IN THE BUFFER.

↑STODAT:
	TLNN IOS,IOFST		; IS THIS FIRST ITEM OF BUFFER?
	JRST STO0		;NO
	PUSHJ PDP,NEWBUF	;SET UP A NEW BUFFER. ITEM:=(BUFFER 
				;SIZE - 1)*[36/BYTE SIZE]
	POPJ PDP,
STO0:
	LDB TAC1,PIOMOD		;DATA MODE
	CAIN TAC1,B		;MODE=BINARY?
	JRST STOBIN
	TLZ IOS,IOFST
STO1:
	IDPB DAT,DEVPTR(DEVDAT)	;STORE DATA IN BUFFER.
	CAIE TAC1,A		;MODE=ASCII, IMAGE, OR BINARY?
	CAIN TAC1,I
	JRST STOAIB
	CAIE TAC1,IB		;IMAGE BINARY?
	CAIN TAC1,B		;CHECKSUM BINARY?
	JRST STOAIB		;YES
	ANDI	DAT,177		;NO, MUST BE ASCII LINE MODE.
	CAIG	 DAT,14		;LINE FEED,FORM FEED, OR VERTICAL TAB?
	CAIGE	DAT,12
	JRST .+2		;NO
	JRST STOSQF		;YES
	SOJGE ITEM,CPOPJ2	;ITEM:=C(ITEM)-1. IS C(ITEM)>OR=0?
STOE1:
	TRO IOS,IOBKTL	;IOBKTL:=1
	POPJ PDP,
STOAIB:
	SOJG ITEM,CPOPJ2;	ITEM:=C(ITEM)-1. IS C(ITEM)>0?
	CAIN TAC1,A		;MODE=ASCII?
	JRST STOSQF		;YES
	CAIN TAC1,B		;MODE=BINARY?
	JRST STOBND		;YES, COMPUTE CHECKSUM AND CHECK.
	PUSHJ PDP,ITMSET	;ITEM:=(BUFFER SIZE-1)*[36/BYTE SIZE]
				; - C(DEVCTR)
	SUB ITEM,DEVCTR(DEVDAT)
	MOVE TAC1,DEVIAD(DEVDAT);STORE ITEM COUNT
	ADDI ITEM,1		;IN FIRST WORD OF BUFFER
	AOJA TAC1,STOSQE

↑STOSQD:
	TLZN IOS,IOFST		; FIRST CALL?
	JRST STOSQF		;NO
	PUSHJ PDP,NEWBUF	;YES, CLEAR BUFFER,SET ITEM COUNT
	POPJ PDP,		;ADDRESS CHECK
STOSQF:
	MOVE TAC1,DEVIAD(DEVDAT)	;REL. ADR. OF BUFFER
	AOS TAC1
	HRRZ ITEM,DEVPTR(DEVDAT)	;ITEM:=C(DEVPTR 18-35) -
				;C(DEVIAD 18-35) -1
	SUBI ITEM,(TAC1)
STOSQE:
	HRRM ITEM,@TAC1		;WORD COUNT TO FIRST WORD IN BUFFER
	JRST CPOPJ1		;EXIT2. BLOCK COMPLETE


STOBIN:
	TLZN IOS,IOFST		;WILL THE NEXT ITEM BE THE FIRST ITEM
	JRST STO1		;OF A BUFFER?  IOFST:=0
	HRRZ TAC,DAT		;YES.
	CAMLE TAC,ITEM		;IS WORD COUNT <OR= (BUFFER SIZE-1)*
	JRST STOE1		;   [36/BYTE SIZE]?
	MOVE ITEM,TAC		;ITEM:=WORD COUNT
	MOVEM DAT,@DEVPTR(DEVDAT)	;STORE WORD COUNT IN BUFFER
	JRST CPOPJ2		;EXIT3.  DATA STORED CORRECTLY.

STOBND:
	HRRZ TAC1,DEVIAD(DEVDAT)
	PUSHJ PDP,CKS12		;COMPUTE CHECKSUM
	ADD TAC1, DEVIAD(DEVDAT)
	HLLZ TAC1,@TAC1		;DATA CHECKSUM=COMPUTED CHECKSUM?
	CAMN TAC,TAC1
	JRST CPOPJ1		;EXIT2. BLOCK COMPLETE
	TRO IOS,IODTER		;IODTER:=1
	JRST CPOPJ		;EXIT1.  CHECKSUM ERROR



SUBTTL	RUNCSS	4 AUG 67 - KSTOP

;RUN CONTROL IS A COLLECTION OF ROUTINES WHICH
;SET AND CLEAR BITS IN THE JOB STATUS WORDS OF
;ALL JOBS SO THAT THE SCHEDULER WILL START AND STOP
;THEM ACCORDINGLY

;COMMON ERROR STOPPING ROUTINES
;CALLED AT ANY LEVEL(UUO,CLK, OR INTERRUPT)
;CALL:	MOVE ITEM,JOB CAUSING ERROR OR BEING STOPPED
;	MOVE DEVDAT,ADRRESS OF THAT JOB TTY DEVICE DATA BLOCK
;	MOVE DAT,BYTE POINTER TO LAST CHAR. ALREADY MOVED
;			;TO TTY OUTPUT BUFFER
;	PUSHJ PDP,KSTOP,PHOLD,HOLD,OR ESTOP
;	NEVER RETURN IF CALLED AT UUO LEVEL

;ROUTINE TO STOP JOB AFTER KJOB COMMAND
;CALLED AT UUO LEVEL IF JOB HAD CORE,CLK LEVEL IF NOT


↑KSTOP:	MOVSI	TAC,JNA!JLOG!JACCT	;CLEAR BITS 
	ANDCAM	TAC,JBTSTS(J)
	SKIPN	JBTADR(J)
	JRST	KSTOP1
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/JBTADR NOT ZERO AT KSTOP.  CALL A DOCTOR DOUBLE QUICK.   /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISFLU
	PUSHJ	P,DDTCALL
	POPACS
KSTOP1:



	MOVNI	TAC,NULQ		;PUT HIM IN NULL QUEUE
	MOVEM	TAC,JOBQUE(J)		;SO SWAPPER WILL FORGET ABOUT HIM
	PUSHJ	P,REQUE
	PUSHJ P,FLUSIN			;FLUSH FROM SWAP IN LIST
IFN FTLOGIN,<
	SETZM	PRJPRG(J)		;KEEP TABLE ACCURATE
>
	SETZM	JOBNAM(J)
	SETZM	TTIME(J)		;CLEAR RUN TIME FOR R. GORIN
	SETZM	JBTBTM(J)		;CLEAR LOGIN TIME FOR ACCOUNTING
	SETZM	JBTGSL(J)		;CLEAR GUARANTEED SERVICE WORDS
	SETOM	JBTWKM(J)		;WAKE ON ALL INTERRUPTS
	JRST	ESTOP2

;ROUTINE TO STOP JOB, SET ERROR BIT AND PRINT MESSAGE - HOLD, PHOLD
;THEN ADD ↑C<CRLF><CRLF><PERIOD>
;CALL:	MOVEI TAC,ADR. OF MESSAGE


↑PHOLD:	PUSHJ	P,CONMES	;MOVE MESSAGE TO TTY OUTPUT BUFFER
				;FALL INTO HOLD
;ROUTINE TO STOP JOB, SET ERROR BIT,
;AND ADD "↑C<CRLF><CRLF><PERIOD>



↑HOLD:	PUSHJ	P,PRCRCC
	PUSHJ	P,TTYSTC	;MAKE SURE TTY STAYS IN MONITOR MODE
				;AND START TTY TYPING OUT MESSAGE
				;FALL INTO ESTOP

;ROUTINE TO STOP USER AND FLAG AS ERROR STOP - ESTOP, MSTOP

MSTOP:

↑ESTOP:
	JUMPE	J,CPOPJ
	SKIPE	SPWUUF(PID)		;SPACEWAR LEVEL?
	CONSZ	PI,77000		;YES. ABOVE CH 7?
	CAIA				;NOT SPACEWAR (OR ABOVE CH 7)
	JRST	SPWERR			;ERROR AT SPACEWAR LEVEL
	MOVSI	TAC,JACCT
	ANDCAM	TAC,JBTSTS(J)		;NO LONGER AN ACCOUNTING PROGRAM
	MOVSI	TAC,JLOG
	TDNE	TAC,JBTSTS(J)		;IS THIS JOB REALLY LOGGED IN?
	JRST	ESTOP4			;YES, PROCEED NORMALLY
	SKIPN	PROG,JBTADR(J)
	JRST	ESTOP4			;NOT LOGGED IN AND NO CORE.
	CONSZ	PI,77400		;NOT LOGGED IN.  ARE WE AT UUO LEVEL
	JRST	ESTP3B			;NO, MUST START MONITOR JOB TO KILL JOB
	SKIPN INTACT(PID)
	JRST ESTP3A			;AT UUO LEVEL BUT NOT USER INT LEVEL
ESTP3C:
	PUSHJ P,ESTOP3			;SET JLOG, SETUP MONJOB,
	SETOM ESTINT			;TELL CH7 WE'RE COMING FROM ESTOP
	JRST WSCHD2			;GET INTO CHANNEL 7

ESTP3B:
	CAMN	J,JOB(PID)		;PI IN PROGRESS.  JLOG OFF
	SKIPN	INTACT(PID)
	JRST	ESTOP3
	JRST	ESTP3C			;CURRENT JOB IS AT USER-INT LEVEL

ESTP3A:
	PUSHJ P,JOBKL1		;AT UUO LEVEL, CAN KILL JOB FROM HERE
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /RETURNED FROM JOBKL1 AT ESTOP
/
	POPACS
	JRST ESTOP4			;SET ERROR BIT

ESTOP3:
	IORM	TAC,JBTSTS(J)	; FINISH LOGGING IN JOB SO WE WON'T GET HERE AGAIN
	MOVE	TAC,['-DIE!-']
	MOVEM	TAC,JOBNAM(J)	; (EVEN IF WE FAIL TO KILL THIS, WE GET NEW PHANTOM)
	PUSHJ	P,INTKIL	; MAKE SURE THE LOSER CAN'T GET ANY MORE ERRORS - RPH
	JSP	TAC1,MONJOB	; SET MONITOR JOB TO RUN AND KILL JOB
	JRST	JOBKL		; HERE AT UUO LEVEL

;GET HERE FROM KSTOP
↑ESTOP2:
	JUMPE	J,CPOPJ			;IS THIS ERROR IN JOB 0?
	SKIPE	SPWUUF(PID)		;JOB IN SPACEWAR MODE ?
	CONSZ	PI,77000
	CAIA
	JRST	SPWERR			;YES. GO TO SPWSER.
	MOVSI	TAC,JACCT		; ZERO OUT ACCT BIT
	ANDCAM	TAC,JBTSTS(J)		; SO IF LOGIN BLOWS, WE CAN KILL IT!!
ESTOP4:
	MOVSI	TAC,JERR		; SET ERROR BIT
	IORB	TAC,JBTSTS(J)		;SO JOB CAN NOT CONTINUE(CONT COM.)
	TRNE	TAC,JLOCK
	JRST	[MOVSI TAC,UNLOKC
		HRR TAC,J
		CONO PI,PIOFF
		IDPB TAC,CLKQ		;USE DPYSLUR CLOCK QUEUE.
		CONO PI,PION
		JRST .+1]
	PUSHJ P,INTKILL			; CLEAR THE USER INTERRUPT SYSTEM
	CAME J,STUSER			;SYSTEM TAPE USER?
	JRST ESTOP6			;NO
	MOVSI TAC,'SYS'			;FIND SYS DDB
	PUSHJ P,DEVSRC			;SYSTEM ERROR IF NOT FOUND
	JRST ESTOP5			;BARF!
	PUSHJ P,RELEA9			;YES, RELEASE SYSTEM TAPE WITHOUT WAITING
	JRST ESTOP6

ESTOP5:
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ππNO DEVICE SYS AT ESTOP!
/
	POPACS
ESTOP6:
	CAMN J,JOB(PID)	;IF NOT CURRENT JOB
	CONSZ PI,77400	;OR AT INTERRUPT LEVEL
	JRST STOP1	;JUST GO TO STOP1 AS ALWAYS
	SKIPE INTACT(PID)
	JRST STOP1	;ALSO IF FROM USER INT
	PUSHJ P,SETSTP	;OTHERWISE PUT HIM IN STOPQ, ETC.
	MOVE TAC,UUOPC(J)
	TLNN TAC,USRMOD
	TDZA TAC,TAC	;GIVE HIM 0 IF PC WAS EXEC
	HRRI TAC,-1(TAC);ELSE BACK IT UP TO LOSING UUO
	MOVEM TAC,UUOPC(J)
	JRST USRX4A	;NOW CATCH HIM ON HIS WAY "BACK"

;ROUTINE TO STOP ANY JOB FROM BEING SCHEDULED - STOP1, SETSTP
;CALL:
;	MOVE	J, JOB NUMBER
;	PUSHJ	P, STOP1
;	EXIT	;RETURN HERE IMMEDIATELY, IF CALLED FROM HIGHER
;PRIORITY PI CHANNEL THAN CLK(LOWEST), OTHERWISE WHEN JOB IS RUNABLE
;CALLED FROM COMMAND DECODER WHEN <CONTROL>C TYPED IN BY USER

↑STOP1:	PUSHJ	P,SETSTP	;SET IT TO STOPQ, ETC
	CAME	J,JOB(PID)	;IS THIS JOB CURRENT USER
	JRST	REQUE		;NO, SET REQUE JOB FLAG
	SKIPE INTACT(PID)
	SETOM ESTINT		;TELL CH7 WE'RE COMING FROM ESTOP
	JRST	WSCHD2		;YES, CALL WSCHED TO WAKE CH7

;THIS ROUTINE DOES ALL THE WORK OF STOPPING THE GUY WITHOUT ACTIVATING CH7
SETSTP:
	MOVSI	TAC,RUN
	CONO	PI,PIOFF	;DONE AT INTERUPT LEVEL HIGHER THAN DT LEVEL
	CAME	J,STUSER	;IS THIS JOB CURRENTLY USING THE SYSTEM TAPE?
	TDNN	TAC,JBTSTS(J)	;NO, IS RUN BIT OFF IN JOB STATUS WORD
	JRST	STOP1A		;YES
	ANDCAM	TAC,JBTSTS(J)	;NO, SO CLEAR IT
	CONO	PI, PION
	MOVM	TAC,JOBQUE(J)	;GET JOB WAIT QUEUE CODE(IF ANY)
	CAIG	TAC,MAXQ	;DOES STATE HAVE Q ?
	SOSL	REQTAB(TAC)	;YES. REDUCE IT.
	JRST	STOP1A		;NO
	SOSGE	AVALTB(TAC)	;YES REDUCE  COUNT
	SETZM	AVALTB(TAC)	;CLEAR AVAL FLAG IF NO ONE WAITING
STOP1A:
	CONO	PI,PION		;MAKE SURE PI ON
	MOVNI	TAC,STOPQ	; REQUE JOB TO STOP QUEUE
	MOVM	TAC1,JOBQUE(J)
	CAIE	TAC1,NULQ	; UNLESS HE IS IN THE NULL QUEUE
	MOVEM	TAC,JOBQUE(J)
	CAMN	J,LOCKNO	;WERE WE WAITING TO BE LOCKED IN?
	SETZM	LOCKNO		;YES. WELL, THERE'S NO ONE THERE ANYMORE.
	POPJ	P,		;↑C, CONTINUE WILL NOT UNLOCK A JOB!

;DLYCOM     ROUTINE TO REQUE JOB WHICH HAS HAD A COMMAND TYPED
;WHICH NEEDS CORE AND THE CORE IMAGE IS ON THE DISK.
;OR IS IN CORE AND HAS ACTIVE DEVICES.
;CALLED FROM COMMAND DECODER
;CALL:	MOVE ITEM,JOB NO.
;	PUSHJ PDP,DLYCOM


↑DLYCOM:MOVSI TAC,CMWB			; SET COMMAND WAIT BIT
	IORB TAC,JBTSTS(J)		;IN JOB STATUS WORD
	TLNN TAC,SWP			;DO WE NEED HIM IN??
	POPJ P,				;IN ALREADY
	MOVSI TAC,COMSNB
	JRST SETSIN

;ROUTINE TO PUT JOB IN NO CORE QUEUE

↑NOCORQ:PUSHJ P,FLUSIN			; FLUSH FROM SWAP IN LIST
	MOVEI	TAC,NULQ		; NO JOB NUMBER OR NO CORE QUEUE
	MOVNM	TAC,JOBQUE(J)
	JRST	REQUE

;ROUTINE TO SETUP MONITOR JOB TO RUN LATER AT UUO LEVEL - MONJOB
;CALLED BY COMMANDS WHICH MAY OR MAY NOT NEED TO
;RUN MONITOR JOB DEPENDING ON WHETHER JOB HAS CORE(KJOB,IJOB)
;TTY WILL REMAIN IN MONITOR MODE
;JOB MUST HAVE CORE ASSIGNED
;CALL:	MOVE ITEM, JOB NUMBER
;	MOVEI TAC1,ADDR. OF MONITOR JOB TO BE RUN
;	PUSHJ PDP,MONJOB
;WHEN SCHEDULED TO RUN, MONITOR JOB MUST SET UP ITS OWN ACS


↑MONJOB:
	PUSHJ	P,MSTART	; START WITH PC IN MONITOR
	JRST	SETRUN		;MCF(JBS);SET TTY TO START JOB WHEN COMMAND RESPONSE
				;IS FINISHED AND KEEP TTY IN MONITOR MODE

;MONSTR ROUTINE TO SETUP ACS FOR MONITOR JOB STARTING AT UUO LEVEL
;SETS UP J, WITH JOB NO.; PROG WITH RELOCATION, AND P
;WITH PUSH DOWN LIST ADR. IN JOB DATA AREA
;USED BY KJOB,CORE 0,SAVE,GET,RUN,R AND FINISH COMMANDS
;CALL:	MOVEI TAC1,MONITOR JOB STOP ADDRESS
;	JSP TAC,MONSTR
;	RETURN WITH ACS P, PROG AND J SETUP


↑MONSTR:
	MOVEI	PID,P1PID
	CONSO	APR,MAOFF
	MOVEI	PID,P2PID
	MOVE	J,JOB(PID)	; GET CURRENT JOB NUMBER
	MOVE	JDAT,JBTDAT(J)	;ADR. OF JOB DATA AREA
IFN JDMPRG,<
	MOVE	PROG,JBTADR(J)	;JOB RELOCATION
>
	EXCH	AC1,TAC
	JSP	TAC,GETPDL	; GET A PUSHDOWN LIST FOR US
	EXCH	AC1,TAC		; GET OUR RETURN ADDRESS BACK
	PUSH	P,TAC1		;SAVE STOP ADRRESS
	JRST	(TAC)		;RETURN AND DO MONITOR JOB

;ROUTINE TO SET JOB STATE TO BE SCHEDULED TO RUN - USTART, MSTART
;WITH SPECIFIED STARTING ADDRESS INCLUDING PC FLAGS
;CALLED ONLY WHEN JOB IN CORE AND AFTER JOB HAS BEEN
;SAFELY STOPPED IN ONE OF 2 STATES:
;1) PC IN USER MODE
;2) JOB IN A WAIT FOR SHARABLE DEVICE, OR IO WAIT
;CALL:	MOVE TAC1,STARTING PC
;	MOVE ITEM, JOB NUMBER
;	MOVE JDAT,ADR. OF JOB DATA AREA WHICH MUST BE IN CORE
;	PUSHJ PDP,USTART(PC TO USER MODE),MSTART(PC TO MONITOR MODE)
;	RETURN HERE IMMEDIATELY


↑USTART:
	MOVE TAC,JOBPC(JDAT)	; GET OLD PC
	TLNE TAC,USRMOD		;IS IT IN USER MODE TOO?
	JRST USTRT1		;YES, DUMP ACS AND PC FLAGS ARE ALREADY HIS
	MOVEI TAC,JOBDAC(JDAT)	;NO, MOVE USERS(UUO) ACS TO DUMP ACS
	HRL TAC,JDAT		;SOURCE=REL. 0,DEST.=JOBDAC IN JOB DATA AREA
	BLT TAC,JOBD17(JDAT)	;MOVE ALL ACS
	MOVE TAC,UUOPC(J)	; UUO PC HAS LAST KNOWN PC
	TLNN TAC,USRMOD		;IF NOT USEER MODE
	MOVE TAC,UUOOPC(J)	;TRY THIS
	TLNN TAC,USRMOD		;IS IT?
	TLZ TAC,-1		;NO, CLEAR ALL PC FLAGS
	HRRI TAC,-1(TAC)	;SUBTRACT 1 FROM RIGHT HALF AND
				;PRESERVE LH PC FLAGS.
				;(RH=0 ON HALT 0 OR FIRST START)
USTRT1:
	HLL TAC1,TAC		;PRESERVE USER APR FLAGS
	TLO TAC1,USRMOD		;MAKE SURE NEW PC IN USER MODE
	TLZ TAC1,37		;MAKE SURE NO INDIRECT BITS OR INDEX FIELD
	JRST MSTAR1

↑MSTART:MOVE TAC,JOBPC(JDAT)	; PICK UP USER'S PC
	TLNE TAC,USRMOD		;IN USER MODE?
	JRST MSTAR1		;YES, THIS IS CORRECT JOBOPC
	MOVE TAC,UUOPC(J)	;HERE IS LAST USER PC (MAYBE)
	HRRI TAC,-1(TAC)	;JUST LIKE USTART
MSTAR1:
	TLNE TAC,USRMOD		;IF IT STILL ISN'T USER PC LEAVE HIS OLD ONE
	MOVEM TAC,JOBOPC(JDAT)	; STORE IT FOR LATER USE
	MOVEM TAC1,JOBPC(JDAT)	; STORE NEW PC
	CAMN J,JOB(PID)		;IS THIS CURRENT JOB?
	MOVEM TAC1,USRPC(PID)	;YES.  STORE IN SYSTEM CORE AS WELL.
	SKIPE INTACT(PID)
	CAME J,SJOB		;MAKE SURE THAT USRPC IN THE INTERRUPT STACK
	JRST MSTAR2		;GETS UPDATED
	MOVE TAC,INTSP
	MOVEM TAC1,USRPC-USRJDA-20(TAC)
MSTAR2:
	PUSHJ P,STXTM2		;UPDATE INTERACTION RUN TIME FOR THIS JOB
	MOVSI TAC,JERR+WTMASK
	ANDCAM TAC,JBTSTS(ITEM)	;CLEAR ERROR AND WAIT STATUS BITS
	MOVNI TAC,RUNQ		; REQUE JOB TO RUN QUEUE
	MOVEM TAC,JOBQUE(J)
IFN FTSWAP,<
	SETOM STIME(ITEM)	; TELL SWAPPER THIS CORE IMAGE HAS BEEN MODIFIED
>
	JRST TTYSET		;SET TTY STATE TO INITIAL COND.
				;TTYUSR OR TTYURC SHOULD BE CALLED
				;TO INDICATE WHETHER TTY TO USER OR EXEC MODE
				;AND THAT JOB IS TO RUN(RUN BIT =1) WHEN
				;MONITOR COMMAND RESPONSE FINISHES.
				;SET MONITOR MODE

;ROUTINE TO SET JOB STATUS RUN BIT(RUN)
;CALLED BY SCANNER SERVICE WHEN TTY MONITOR COMMAND
;RESPONSE FINISHES.  THIS ACTION IS ENABLED BY CALLING
;TTYUSR, OR TTYURC IN SCNSER
;CALL:	MOVE ITEM,JOB NUMBER
;	PUSHJ PDP,SETRUN



↑SETRUN:
	LDB TAC,[POINT JWSIZ,JBTSTS(J),JWPOS]	;GET OLD WAIT QUEUE CODE
	JUMPE TAC,SETR1		;NONE
	AOSE REQTAB(TAC)	;DEVICE AVAILABLE?
	MOVNM TAC,JOBQUE(J)	;NO - PUT US BACK INTO WAIT Q
SETR1:
	MOVSI TAC,RUN		;SET RUN BIT IN JOB STATUS WORD
	IORM TAC,JBTSTS(ITEM)


↑REQUE:	PUSH P,TAC
	MOVEI TAC,QJOB(ITEM)
	CONO PI,PIOFF
	SKIPE (TAC)
	JRST .+3
	EXCH TAC,QJOB
	HRROM TAC,@QJOB
	CONO PI,PION
	JRST TPOPJ

;ROUTINE TO PUT A JOB TO SLEEP AND WAKE UP AGAIN LATER
;CALLED AFTER CLOCK QUEUE REQUEST PUT IN BY UUO ROUTINE



↑SETSLP:
	MOVSI TAC,CLKR		; FLAG THAT A CLOCK REQUEST
				;HAS BEEN PUT IN.
	IORM TAC,JBTSTS(ITEM)	;SO ONLY ONE PER JOB
	MOVEI AC1,IOWQ		;SLEEP STATE CODE
	JRST SETSTT		;SET STATUS AND RESCHEDULE

;HERE AT CLOCK LEVEL WHEN CLOCK REQUEST TIMES OUT FOR SLEEP
;JOB NO. IN AC TAC


↑WAKE:	MOVNI TAC1,RUNQ		;RUN QUEUE CODE
	MOVE ITEM,TAC		;JOB NO.
	MOVSI TAC,CLKR		;CLEAR CLOCK REQUEST BIT FOR THIS JOB
	ANDCAM TAC,JBTSTS(ITEM)	;SO IT CAN PUT ANOTHER ONE IN
	MOVM TAC,JOBQUE(J)	;GET QUEUE CODE
	CAIE TAC,IOWQ		;IS JOB STILL SLEEPING?
	POPJ P,			;NO
	MOVEM TAC1,JOBQUE(J)	;YES, STORE RUN QUEUE CODE
				;(CONTROL C, START CAN GET JOB OUT OF SLEEP)
	JRST REQUE

;ROUTINE TO GET DATA CONTROL AND ANOTHER SHARABLE DEVICE
;JOB NEVER GETS ONE DEVICE AND WAITS FOR SECOND, SINCE TYPING
;CONTROL C WOULD NEVER FINISH WITH FIRST DEVICE
;CALL	PUSHJ PDP,GETDCXX
;	AOSE XXREQ	;REQUEST COUNT FOR OTHER DEVICE
;	RETURN WHEN BOTH AVAILABLE


↑GETDCDT:↑GETDCMT:
	XCT @(PDP)		;INCREASE SHARABLE DEVICE REQ. COUNT
GETWT:
	PUSHJ PDP,DVWAT1	;NOT AVAIL., GO WAIT FOR IT
	AOSN DCREQ		;IS DATA CONTROL AVAILABLE?
	JRST CPOPJ1		;YES, RETURN BOTH AVAILABLE
	MOVE AC1,@(PDP)		;DATA CONTROL NOT AVAILABLE
	SUBI AC1,REQTAB
	SOSL REQTAB(AC1)	;REDUCE REQ. COUNT FOR OTHER
				;SHARABLE DEVICE.
	SETOM AVALTB(AC1)	;SET AVAILABLE IF OTHER JOBS WAITING
	JFCL DCREQ		;ARGUMENT FOR DCWAIT
	PUSHJ PDP,DCWAIT	;WAIT FOR DATA CONTROL FREE
	MOVE AC1,@(PDP)		;INCREMENT REQ. COUNT
	AOSN @AC1		;NOW IS SHARABLE DEVICE FREE?
	JRST CPOPJ1		;YES
	SOSL DCREQ		;NO, REDUCE DATA CONTROL REQUEST
	SETOM DCAVAL		;SET AVAIL., SOME OTHER JOB WAITING FOR IT
	JRST GETWT		;TRY AGAIN

;ROUTINE TO WAIT FOR A SHARABLE DEVICE
;CALLED AT UUO LEVEL ONLY BY DEVICE SERVICE ROUTINES
;CALL:	AOSLE XXREQ		;ADD 1 TO SHARABLE DEVICE REQUEST COUNT
;				;IS DEVICE AVAILABLE?
;	PUSHJ PDP,XXWAIT	;NO, PUT JOB IN WAIT QUEUE
;	RETURN WHEN DEVICE AVAILABLE

;INITIALLY THE REQUEST COUNT IS -N, WHERE N IS THE
;NUMBER OF JOBS WHICH CAN USE THE SHARABLE DEVICE AT THE SAME TIME
;A REQUEST COUNT OF 0 MEANS THE MAXIMUM NO. OF JOBS ARE
;USING THE DEVICE, A POSITIVE NUMBER IS THE
;NUMBER OF JOBS WAITING IN THE SHARABLE DEVICE WAIT QUEUE



↑MTWAIT:↑DTWAIT:↑DCWAIT:↑STWAIT:
↑DVWAIT:
	MOVE AC1,(PDP)		; GET ADDRESS OF CALLER
	SKIPA AC1,-2(AC1)	;GET AOSLE XXREQ INSTRUCTION
DVWAT1:
	MOVE AC1,@-1(PDP)	;GET ADR. OF CALLER OF THIS ROUTINE
	SUBI AC1,REQTAB		;COMPUTE WAIT-STATE QUEUE CODE
SETSTT:
	MOVE AC3,JOB(PID)	;CURRENT JOB NO.
	HRRZS AC1		; CLEAN UP JOB QUEUE CODE
	MOVNM AC1,JOBQUE(AC3)	;STORE IN JOB STATUS WORD
	JRST WSCHED		;GO SCHEDULE ANOTHER AND RETURN TO CALLER
				;WHEN SHARABLE DEVICE BECOMES AVAILABLE
				;SEE CLOCK AND CLKCSS
				;WORD WAIT QUEUE CODE

;SETIOD - ROUTINE TO SET JOB TO RUN AFTER IT HAS BEEN STOPPED
;BECAUSE IT HAD TO WAIT FOR IO TO COMPLETE FOR SOME DEVICE
;EACH SERVICE ROUTINE AT INTERRUPT LEVEL
;CHECK EACH TIME IT FINISHED A TASK(BUFFERFUL)
;TO SEE IF THE JOB USING THE DEVICE HAS
;PREVIOUSLY CAUGHT UP WITH DEVICE AND HAS BEEN STOPPED
;CALL:	MOVE DEVDAT,ADR. OF DEVICE DATA BLOCK
;	MOVE IOS,DEVIOS(DEVDAT)	;GET DEVICE IO STATUS WORD FROM DDB
;	TLZE IOS,IOW	;IS JOB IN AN IO WAIT FOR THIS DEVICE?
;	PUSHJ PDP,SETIOD	;YES, GO FLAG JOB TO START UP AGAIN
;	RETURN
; REQUEUES JOB TO A RUN QUEUE
;THE SCHEDULER THEN SEES THAT THIS JOB HAS ITS
;IO WAIT SATISFIED AND IS WAITING TO BE RUN AGAIN


;!! No longer clobbers ac's !  	DWP.

↑STTIOD:PUSH P,[-TQ]	;HE'S A TTY.  PUT HIM IN SPECIAL HIGH-PRIORITY QUEUE
	CAIA
↑SETIOD:PUSH P,[-RUNQ]		; REQUE TO WAIT SATISFIED QUEUE
	EXCH J,(P)
	PUSH P,J
	LDB J,PJOBN		;Get job no.
	SKIPL JBTSTS(J)		; IS JOB STILL RUNNING?
	JRST [	POP P,J		;No.
		POP P,J
		POPJ P,]
	POP P,JOBQUE(J)
	PUSHJ	PDP,REQUE	;ARRANGE TO REQUE THIS JOB.
	POP P,J
NULTST:
	SKIPE JOB(PID)		;IS NULL JOB RUNNING?
	POPJ PDP,		;NO LET OTHER JOB RUN
	CONO PI,PIOFF
	JRST STOP2

;ROUTINE TO CAUSE CLK ROUTINE TO RESCHEDULE - WSCHED
;CALLED AT ANY LEVEL
;CALL:	PUSHJ PDP,STOP2	
;	RETURN IMMEDIATELY EXCEPT IF AT UUO LEVEL
;	IF AT UUO LEVEL, RETURN WHEN JOB IS RUNABLE AGAIN


↑WSCHED: JUMPE PID,WSCHD1
	PUSHACS
	CONSZ APR,MAOFF
	JRST WSCHDA
	PUSHJ P,DISMES
	ASCIZ/ππPDP-6 AT WSCHED
/
	POPACS
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD
WSCHDA:
	PUSHJ P,DISMES
	ASCIZ/ππPID CLOBBERED AT WSCHED
/
	POPACS
WSCHD1:
	SKIPE SPWUUF(PID)	;MAKE SURE WE'RE NOT IN A SPACEWAR JOB
	JRST SPWERR
WSCHD2:
	AOS NWSCHEDS		; MARK ANOTHER ONE GONE
	CONO PI,PIOFF		;AVOID PREMATURE CLK INT
	SETOM SCHEDF(PID)	;THIS IS A SCHEDULING INTERRUPT
STOP2:
	HLLOS CLKFLG(PID)	;SET FLAG TO INDICATE CLK INTERRUPT
				;EVEN THOUGH CLK INTERRUPT IS NOT A TIME INTERRUPT
	CONO PI,PION+1B24!1⊗(7-CLKCHN)
				;TURN PI BACK ON AND REQUEST INTERRUPT TO
				;CLK PI CHANNEL(LOWEST PRIORITY CHANNEL)
	POPJ P,			;INTERRUPT IMMEDIATELY IF AT UUO LEVEL

;ROUTINE TO WAIT TILL DEVICE CATCHES UP WITH USER AND BECOMES INACTIVE
;CALLING SEQUENCE
;     PUSHJ PDP, WAIT1
;     EXIT	  ALWAYS RETURNS HERE
 
;IF THE DEVICE IS INACTIVE (IOACT=0), RETURNS TO EXIT. OTHERWISE, SETS
;IOW:=1 AND ENTERS WAIT UNLESS IOACT BECOMES ZERO BEFORE THE
;JUMP IS MADE, IN WHICH CASE IT SETS IOW:=0 AND RETURNS TO EXIT.
;ON LEAVING THE WAIT STATE, RETURNS TO EXIT.
;THIS ROUTINE PREVENTS THE STATE IOACT=0 AND IOW=1 FROM OCCURING
;CALLING SEQUENCE
;     PUSHJ PDP, WSYNC
;     EXIT             ALWAYS RETURNS HERE
;SETS IOW:=1 AND ENTERS WAIT ROUTINE. RETURNS TO EXIT WHEN IOACT=0.


↑WAIT1:	MOVE IOS,DEVIOS(DEVDAT)
	MOVE AC1,DEVMOD(DDB)
	TLNE AC1,DVTTY		;TTY MAY ALWAYS PROCEED FROM HERE!!!!! RPH
	POPJ P,
	TRNN IOS, IOACT		;IS DEVICE ACTIVE? (IOACT=1?)
	JRST WAIT2
	PUSHJ PDP,WSYNC		;WAIT
	JRST WAIT1

WAIT2:
	MOVSI AC1,DEVIBF	; SET TO CHECK IF THIS DEVICE IS INTERNALLY BUFFERD
	TDNE AC1,DEVCMR(DEVDAT)	; TEST THE BIT
	TLNN IOS,DEVSBB		; IT HAS A BUFFER, IS IT BUSY?
	POPJ PDP,		; NO, LEAVE
	PUSHJ PDP,WSYNC		; YES, WAIT FOR IT
	JRST WAIT1		; THEN MAKE SURE

;WSYNC IS CALLED TO WAIT UNTIL 
;SETIOD IS CALLED BY INTERRUPT SERVICE ROUTINE
;IE  UNTIL CURRENT BUFFER ACTIVITY IS COMPLETED
;CALLED ONLY FROM UUO LEVEL
;CALL:	MOVE DEVDAT,ADR. OF DEVICE DATA BLOCK
;	PUSHJ PDP,WSYNC
;	RETURN IMMEDIATELY IF DEVICE IS INACTIVE
;	RETURN WHEN DEVICE FINISHES NEXT BUFFER IF IT IS ACTIVE



↑WSYNC:	MOVSI IOS,IOW		;SETUP DEVICE IO WAIT BIT
	MOVEI AC1,DIOWQ		; DISK IO WAIT QUEUE
	MOVE AC3,DEVIOS(DEVDAT)	; SEE IF JOB IS LOCKED IN CORE
	MOVE AC2,DEVMOD(DEVDAT)	; WHICH FOR DEVICES OTHER THAN THE TTY MEANS IOACT IS ON
	TLNN AC2,DVTTY
	TRNN AC3,IOACT		; LOCKED IN?
	MOVEI AC1,IOWQ		; NO, STRAIGHT IO WAIT QUEUE CODE
	MOVE AC3,JOB(PID)	;CURRENT JOB NO.
	HRRZ AC2,DEVCMR(DEVDAT)	; FIRST, DOES HE HAVE CONTROL CELLS?
	SKIPE P2NUM		; IF P2 IS ACTIVE . . .
	JUMPN AC2,WSYNC1	; WE CHECK. IF YES, THIS IS A SPECIAL CASE
	MOVSI AC2,DEVIBF	; ALSO, IS THIS A SCREWEY DEVICE?
	TDNE AC2,DEVCMR(DEVDAT)	; LIKE LPT WITH THE INTERNAL BUFFER
	SKIPA AC2,[XWD DEVSBB,0]
	MOVEI AC2,IOACT
	CONO PI,PIOFF
	TDNN AC2,DEVIOS(DEVDAT)
	JRST WSYNC3
	IORM IOS,DEVIOS(DEVDAT)
	MOVNM AC1,JOBQUE(AC3)
	CONO PI,PION
	PUSHJ PDP,WSCHED
	ANDCAB IOS,DEVIOS(DEVDAT)
	POPJ PDP,

WSYNC3:
	CONO PI,PION
	MOVE IOS,DEVIOS(DEVDAT)
	POPJ PDP,

; WE GET HERE IF THIS DEVICE HAS CONTROL CELLS
; WE MUST BOTH GET CONTROL OF THE CELLS AND SHUT OFF THE PI
; BECAUSE EVEN IF P2 IS ACTIVE, THE DEVICE MIGHT NOT BE RUNNING ON P2

WSYNC1:
	MOVSI AC2,DEVIBF	; NOW SEE IF THIS IS A SCREWEY DEVICE
	TDNE AC2,DEVCMR(DEVDAT)
	SKIPA AC2,[XWD DEVSBB,0]
	MOVEI AC2,IOACT
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>	; GET CONTROL OF IOS
	TDNN AC2,DEVIOS(DEVDAT)	; IS THE DEVICE ACTIVE?
	JRST WSYNC2		; NO, FORGET IT
	CONO PI,PIOFF		; INTERLOCK OUR FOOLING AROUND
	IORM IOS,DEVIOS(DEVDAT)
	MOVNM AC1,JOBQUE(AC3)
	CONO PI,PION
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	PUSHJ PDP,WSCHED	; DO THE IO WAITING
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	ANDCAB IOS,DEVIOS(DEVDAT)
WSYNC4:
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	POPJ P,

WSYNC2:
	MOVE IOS,DEVIOS(DEVDAT)	; RESTORE IOS
	JRST WSYNC4		; RELEASE CELLS, RESTORE ACS

REPEAT 0,<
; ROUTINE TO SWITCH YOUR JOB TO THE OTHER PROCESSOR TEMPORARILY
; CALLING . . .
;	PUSHJ P,PSWITCH
; CLOBBERS ACCUMULATOR AC1

PSWITCH:

	LDB AC1,PRUNB		; PICK UP THIS JOB'S PROCESSOR BITS
	PUSH P,AC1		; SAVE THEM
	MOVEI AC1,RUN1
	SKIPN PID
	MOVEI AC1,RUN2
	PSYNC JBTCSC
	DPB AC1,PRUNB
	XSYNC JBTCSC
	PUSHJ P,WSCHED
	MOVE PID,OTHERID(PID)	; PICK UP THE PROPER ID
	POP P,AC1
	PSYNC JBTCSC
	DPB AC1,PRUNB
	XSYNC JBTCSC		; RESTORE RUN BITS
	POPJ P,

GOTOP1:
	JUMPE PID,CPOPJ
	JRST PSWITCH
>
;: COMCSS[J17,SYS] EOF.
;: CLKSER[J17,SYS]
COMMENT ⊗   VALID 00091 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00010 00002	APRINT	8 SEPT 67
C00013 00003	HERE, WE GENERATE ANY USER CLOCK-INTERRUPTS NEEDED.
C00017 00004	 HERE WE REQUEST CH7 INTERRUPT AND DISMISS
C00020 00005	ADDRESS BREAK SYSTEM.
C00023 00006	APRER	OTHER APR INTERRUPTS BESIDES CLOCK
C00026 00007	 THIS ROUTINE REQUESTS USER INTERRUPT FOR VARIOUS APR-TYPE TRAP CONDITIONS
C00030 00008	HERE WE'VE DECIDED THAT THIS LOSER DOESN'T HAVE A VALID TRAP ADDRESS.
C00032 00009	 HERE WE HAVE A NON-TRIVIAL ERROR
C00034 00010	 WE GET HERE ON AN ERROR IN THE EXEC
C00036 00011	SYSTEM CLOBBERED     DETECTED BY SYS WR REF KLUDGE
C00038 00012	CLOCK	24 JULY 67
C00040 00013	HERE AT CLK INTERRUPT LEVEL  -  CLKINT
C00042 00014	P2 CLK INTS COME HERE
C00043 00015	 HERE IT IS NOT TIME TO TAKE A REAL CLOCK INTERRUPT
C00046 00016	SET TIME FLAGS, UPDATE SYSTEM TIME, COUNT DOWN PROCESSOR ALIVE FLAGS
C00052 00017	 KEEP INFORMATION FLOWING BETWEEN THE PROCESSORS
C00055 00018	 HERE IS THE GUY THAT CALLS UP PHANTOM PROCESSES LIKE BATCH MONITORS
C00059 00019	 MAINTAIN P1'S 2-PROCESSOR COMMUNICATION
C00062 00020	 HERE IS SUBROUTINE FOR PHANTOM ROUTINES
C00065 00021	 MORE PHANTOM CLOCK LEVEL ROUTINES, WAITING FOR RESOURCES
C00067 00022	 HERE WE FLUSH THE DISASTER TYPEOUT BUFFER THEN PROCESS CLOCK REQUESTS
C00069 00023	 IF WE ARE SHUFFLING 1K AT A TIME, DO ANOTHER K HERE, THEN CALL SCHEDULER
C00072 00024	DIFFERENT JOB, SAVE SOFTWARE STATE(HARDWARE ALREADY SAVED)
C00075 00025	S2U AND U2S
C00078 00026	RESTORE HARDWARE STATE OF CURRENT JOB
C00080 00027	THE NULL JOB
C00082 00028	 CHECKSUM ROUTINE. CALL WITH IOWD IN TAC, RETURNS CHECKSUM IN TAC1.
C00083 00029	BEGIN	SYSFIX	VERIFY SYSTEM CHECKSUM AND FIX IT IF WRONG.
C00090 00030	 THIS IS WHERE THE USER INTERRUPT HANDLER RESIDES . . .
C00096 00031	 ROUTINE TO GET FIRST SERVICABLE INTERRUPT BIT FROM WORD OF BITS
C00098 00032	 HERE WE CLEAR THE INTERRUPT BIT IN JBTIRQ AND ACTUALLY
C00103 00033	 HERE WE INITIALIZE ALL THE SYSTEM VARIABLES IN PREPARATION FOR RUNNING THE USER INTERRUPT PROCESS
C00107 00034	 HERE, HE IS NOT CONTINUING AFTER A UWAIT, BUT IS BEING RUN REGULARLY
C00110 00035	 ROUTINE TO TYPE OUT ERROR MESSAGE FOR ILL. STARTING ADDRESS
C00112 00036	 ROUTINE TO SWAP A GUY IN SO HE MAY BE INTERRUPTED
C00115 00037	 WE COME BACK TO HERE AFTER AN INTERRUPT - INTCH7,INTDSM,INTOUT,INTERR
C00119 00038	 WE GET HERE FROM A DEBREAK UUO - INTDEB, INTERP, INTAPR
C00122 00039	INTKILL  ROUTINE TO CLEAR A JOB'S INTERRUPT ENABLINGS AND RESET HIS MASKS
C00124 00040	INIJOB		ROUTINE TO INITIALIZE A JOB SLOT
C00129 00041	COMCON	4 AUG 67	 THE COMMAND DECODER
C00132 00042	COMMAND
C00135 00043	COMFND: MOVE	UUO,COMTAB(AC1)	SAVE FULL COMMAND NAME
C00138 00044	CHKACT:
C00141 00045	RETURN FROM COMMAND SETUP ROUTINE
C00144 00046	PCRLF:	TLNE AC2,ERRFLG		DID AN ERROR OCCUR?
C00147 00047	TABLE OF CONSOLE COMMANDS
C00150 00048	DEFINE NAMES
C00155 00049	 MORE COMMANDS . . .
C00159 00050	BEGIN COMTBL			GENERATE TABLE OF SIXBIT COMMAND NAMES
C00161 00051	CALLED FROM COMMAND DECODER WHICH IS CALLED FROM CLOCK ROUTINE
C00164 00052	COR0:		CALLED FROM CORE COMMAND TO ZERO CORE
C00166 00053	PTTY PJOB KJOB
C00172 00054	IFN FTLOGIN,<			 PRINT OUT A JOB'S PROJECT PROGRAMMER NUMBER
C00176 00055	 SERVICE LEVEL COMMAND
C00187 00056	KILL N ---- KILL JOB N IMMEDIATELY! -- OR MAYBE LATER
C00191 00057	PRIVILEGED KILL ROUTINE, FLUSHES THINGS WITHOUT WAITING
C00192 00058	KJOB2:	JUMPE	PROG,JOBKA	DOES JOB HAVE CORE?
C00195 00059	 "START L" OR "START" - START AT LOC. L OR STARTING ADDRESS
C00200 00060	CCONTINUE, CONTINUE, DDT
C00203 00061	SETUWP, CLRUWP, ENABLE, DISABLE
C00208 00062	 "CORE  #" - ASSIGNS #*1024 WORDS OF CORE TO JOB
C00211 00063	COR4:	MOVSI	TAC,NOINCK	DON'T INITIALIZE A JOB
C00214 00064	PRJOB:	PUSHJ P,INLMES
C00217 00065	"HELP" -HELP COMMAND
C00219 00066	ALOGIN, SETTPV, CLRTPV
C00221 00067	"LOGIN" - LOGIN COMMAND
C00225 00068	R, RUN, SAVE, SSAVE, GET COMMANDS
C00230 00069	 "ASSIGN DEV:NAME" - ASSIGN DEVICE TO JOB AND GIVE IT LOGICAL NAME
C00242 00070	ALREADY ASSIGNED TO ANOTHER JOB
C00245 00071	"DEASSIGN DEV" - DEASSIGNS DEVICE FROM CONSOLE
C00248 00072	REASSIGN UUO
C00250 00073	ROUTINE COMMON TO REASSIGN UUO AND COMMAND
C00252 00074	REASS4:	HRRZ DSER,DEVSER(DEVDAT)
C00254 00075	REASE1:	POP PDP,TAC
C00255 00076	"ATTACH DEVNAM" -ATTACHES A PREVIOUSLY PARTITIONED DEVICE
C00258 00077	IFN FTLOGIN,<
C00261 00078	ATT2:	EXCH	DDB,TAC1		PUT LINE NO. OF OUR TTY IN DDB
C00262 00079	FLUSH THIS TTY'S BUFFERS IF NOT IN USE BY A JOB
C00264 00080	"FORK", "CFORK", "DETACH" AND "CDETACH" COMMANDS
C00271 00081	"DAYTIME" - PRINT TIME OF DAY
C00277 00082	"TIME (JOB NO.)" - PRINT TOTAL AND INCREMENTAL RUNNING TIME FOR A JOB
C00285 00083	ROUTINE TO LET TTY TALK TO ANY OTHER RING OF TTYS
C00286 00084	"EXAMINE LOC" - LOOKS A CONTENTS OF LOC AND PRINTS IN OCTAL
C00290 00085	"DEPOSIT LH RH LOC" - DEPOSITS XWD LH,RH IN LOCATION LOC
C00293 00086	"BLANK" OR NO ALPHA NUMERIC BEFORE BREAK CHAR COMMAND
C00294 00087	 "FINISH DEVICE" - CLOSES,RELEASE AND DEASSIGNS DEVICE
C00300 00088	"RESOURCES" - PRINT OUT AVAILABLE DEVICES AND FREE BLOCKS ON THE DISK
C00304 00089	RUNCHK, DLYCOR, DLYCR1
C00307 00090	SEARCH DEVICE CHAIN FOR DSK WITH COUNTS ON
C00309 00091	"FILES <filename or job number>" -- print status of open files.
C00321 ENDMK
C⊗;

SUBTTL	APRINT	8 SEPT 67

;THIS SERVICE ROUTINE RUNS ON A HIGH PRIORITY CHANNEL
;AND REQUESTS INTERRUPTS ON LOWER CLK CHANNEL
;FOR SCHEDULING JOBS AND ERROR HANDLING THAT THE USER
;IS NOT ENABLED TO HANDLE HIMSELF

AP2CHL←CAT(P2CH,\APRCHN)
CL2CHL←CAT(P2CH,\CLKCHN)


↑AP2INT:
	EXCH	PID,APRID+P2PID
	JRST	BREAKX

↑APRINT:
	EXCH	PID,APRID+P1PID
;APR IS ALWAYS ENABLED FOR CLOCK,ILM,NXM,PDLOV, AND CONS.
;ALSO AROV AND PC CHNG IF THE USER REQUESTS.

	CONSZ	APR,ADRBRK	;ADDRESS BREAK?
	JRST	BREAK		;YES, GO PROCESS
BREAKX:
	CONSO	APR,1B26	;YES, IS IT CLOCK?
	JRST	APRER		;NO, GO CHECK ERROR FLAGS

;CLOCK HAS TICKED.  DO TIME ACCOUNTING
	AOS	TIME(PID)	;YES, INCREMENT TIME OF DAY
	AOS	UPTIME(PID)	;DEC 3.16 INCREMENT UP TIME.
	SETOM	TIMEFF(PID)	;FLAG THAT APR CLOCK HAS TICKED
	HLLOS	CLKFLG(PID)	;SET FLAG FOR CLK FORCED INTERRUPT
	MOVEM	TAC,APRTAC(PID)	;GET AN ACCUMULATOR
	CONSO	PI,7400		;ARE WE AT INTERRUPT LEVEL (CH4-7)?
	JRST	BREAK3		;NO
	AOS	INTIME(PID)	;BUMP INTERRUPT TIME
	JRST	APRI1		;YES, SKIP TIME ACCOUNTING

BREAK3:
	SKIPN	TAC,JOB(PID)	;INCREMENT RUNNING TIME
	JUMPN	PID,APRI1	;IF P2, DON'T BUMP NULL TIME
	AOS	TTIME(TAC)	;TIME ACCOUNTING (RTIME IS NO LONGER COUNTED)
	AOS	JBTRNB(TAC)	;INCREMENT HIS JOB LOADING TOO.
	JUMPE	TAC,APRI1	;ESCHEW OBFUSCATION
	MOVEM	AC1,APRAC1(PID)	;GET AN AC
	HLRZ	AC1,JBTADR(TAC)	;GET CURRENT JOB'S PROTECTION
	LSH	AC1,-12
	ADDI	AC1,1
	ADDM	AC1,JBTKCJ(TAC)	;KILO-CORE*JIFFIES
	MOVE	AC1,APRAC1(PID)	;GET BACK OUR AC
APRI1:
	JUMPN	PID,APRADD
	SOSGE	DDCNT		;HAS DATA DISK TIMED OUT??
	JRST	DDCLK		;YES, GO FLUSH IT
	SKIPE	DDSTART		;DO WE NEED TO START IT UP?
	JRST	DDSTRT		;YES, DO SO.


;HERE, WE GENERATE ANY USER CLOCK-INTERRUPTS NEEDED.
; APRLST POINTS TO A LIST, 2-WORDS PER ENTRY
; LH OF FIRST WORD IS TIME BETWEEN INTERRUPTS
; RH OF FIRST WORD IS JOB NUMBER
; SECOND WORD IS NEGATIVE COUNT OF TIME BETWEEN INTERRUPTS

↑APRADD:
	JUMPN	PID,APRI2	;NO CLOCK INTERRUPTS ON P2
	SKIPN	TAC,APRLST	;ANY INTERRUPTS TO GIVE?
	JRST	APRI2		;NO, EXIT NOW
	MOVEM	AC1,APRAC1(PID)	;SAVE SOME AC'S AND PICK UP A PDL
	MOVEM	J,APRJ(PID)
	MOVEM	AC2,APRAC2(PID)
	EXCH	P,APRPDL(PID)
APRCI2:
	SKIPN	J,(TAC)		;END OF LIST?
	JRST	APRCI9		;YES, RESTORE ACS AND LEAVE
	AOSGE	1(TAC)		;TIME EXPIRED YET?
	JRST	APRCI4		;NO, LOOP AROUND
	MOVSI	AC2,INTCLK	;MAKE SURE HE IS STILL ENABLED
	TDNN	AC2,JBTIEN(J)
	JRST	APRCI5		;NOT ENABLED, ALLOWABLE TIMING ERROR, JUST DELETE
	HLRZ	AC1,J		;RESET TIME
	MOVNM	AC1,1(TAC)
	IORM	AC2,JBTIRQ(J)
	SETOM	INTREQ(PID)
APRCI4:
	ADDI	TAC,2		;LOOP AROUND FOR NEXT ENTRY
	JRST	APRCI2



;APRDEL DELETE CLOCK INT ENTRY POINTED TO BY TAC
;DELETES FS BLOCK AND SKIP RETURNS IF LAST ENTRY IS DELETED
;CALL ONLY AFTER DOING CONO PI,APROFF
↑APRDEL:
	JUMPN	PID,CPOPJ
	MOVEI	AC1,2(TAC)
APRCI6:
	SKIPN	(AC1)
	JRST	APRCI7
	ADDI	AC1,2		;FIND END OF LIST AND MOVE LAST ENTRY INTO ENTRY
	JRST	APRCI6		;BEING DELETED

APRCI7:
	MOVE	AC2,-2(AC1)	;PICK UP LAST ENTRY
	MOVEM	AC2,(TAC)
	MOVE	AC2,-1(AC1)
	MOVEM	AC2,1(TAC)
	SETZM	-2(AC1)
	MOVEI	AC1,-2(AC1)
	CAME	AC1,APRLST
	POPJ	P,
APRCI8:
	AOS	(P)
APRDRL:
	MOVEI	AC1,0
	EXCH	AC1,APRLST
	JRST	FSGIVE

APRCI5:
	PUSHJ	P,APRDEL	;DELETE THE ENTRY, SKIP IF THAT WAS THE LAST ONE
	JRST	APRCI2
	JRST	APRCI3			;LIST EXHAUSTED
APRCI9:
	CAMN	TAC,APRLST		;IS LIST EMPTY?
	PUSHJ	P,APRDRL
APRCI3:
	EXCH	P,APRPDL(PID)		;RESTORE THE ACS WE SAVED
	MOVE	AC1,APRAC1(PID)
	MOVE	AC2,APRAC2(PID)
	MOVE	J,APRJ(PID)		;FALL INTO APRI2

; HERE WE REQUEST CH7 INTERRUPT AND DISMISS

APRI2:
	SKIPE	SPWUUF(PID)	;SPACEWAR ACTIVE?
	SOSE	SPWTMO(PID)	;YES. DECREMENT SPACEWAR TIMEOUT
	JRST	APRI2Z		;ALL IS OK.

;THIS IS HOW WE BLOW UP THE SPACEWARRIOR.
	MOVEI	TAC,46		;ASSUME PI CHANNEL 3 INTERRUPTED CH 7
	CONSZ	PI,1000		;CH6 IN PROGRESS?
	JRST	APRI2A		;YES
	CONSZ	PI,2000		;CH5 IN PROGRESS?
	JRST	APRI2B		;YES
	CONSO	PI,4000		;CH4 IN PROGRESS?
	JRST	APRI2D		;NO. IT WAS CH3
	JRST	APRI2C
APRI2A:
	ADDI	TAC,2		;CHANNEL 6
APRI2B:
	ADDI	TAC,2		;CHANNEL 5
APRI2C:
	ADDI	TAC,2		;CHANNEL 4
APRI2D:
	JUMPN	PID,.+2
	IORI	TAC,100			;MAOFF
	MOVEM	TAC1,SPWBLO(PID)	;SAVE TAC1 A WHILE
	MOVE	TAC1,[JRST SPTMOE]
	MOVEM	TAC1,SPWXCT(PID)	;MAKE SURE WE CATCH UUOCON EXITING
	EXCH	TAC1,@(TAC)		;WHEE!
	TLNE	TAC1,USRMOD		;USER MODE?
	JRST	APRI2Y			;YES. THIS IS EASY
	EXCH	TAC1,@(TAC)		;PUT BACK THE INTERRUPTED PC
	MOVE	TAC1,UUO0(PID)		;GET UUO0
APRI2Y:
	EXCH	TAC1,SPWBLO(PID)	;STORE INTERRUPTED ADDRESS.

APRI2Z:
	MOVE	TAC,APRTAC(PID)		;RESTORE TAC
	CONO	PI,1B24+1⊗(7-CLKCHN)	;REQUEST INTERRUPT ON CLOCK CHANNEL.
	SETOM	DSFLAG(PID)		;TELL DPYSER CLOCK HAS TICKED.
	CONSZ	APR,@APRIN1(PID)	;IS THE USER ENABLED FOR ANY FLAGS?
					;(APRIN1 SET EACH TIME A USER RUNS)
	JRST	APRER			;YES, GO PROCESS TRAP.
	CONO	APR,1B26+APRCHN		;NO, CLEAR THE CLOCK FLAG
PBRET:
	JUMPN	PID,P2RET
P1RET:
	EXCH	PID,APRID+P1PID
	JEN	@APRCHL			;DISMISS INTERRUPT

P2RET:
	EXCH	PID,APRID+P2PID
	JEN	@AP2CHL


;ADDRESS BREAK SYSTEM.
;PUT THE EXCEPTED PCS (THE ONES YOU WANT TO IGNORE BREAKS FROM) IN BRKTAB,
; AND THE NUMBER OF EXCEPTED PCS IN BRKNUM.
;WHEN A BREAK OCCURS FROM SOME UNEXCEPTED PC, IT EXECUTES THE CODE AT
;BRKHIT, WHICH MAY BE PATCHED TO WHATEVER YOU WANT.
;NOTE THAT IF BRKNUM≤0 ALL BREAKS ARE EXCEPTED AND AN ERROR MESSAGE RESULTS

BREAK:
	MOVEM	TAC,BRKTAC	;SAVE A COUPLE OF ACCUMULATORS
	MOVEM	AC1,BRKAC1
	HRRZ	TAC,APRCHL	;PICK UP BREAK PC+1
	SUBI	TAC,1		;MAKE IT HONEST
	SKIPLE	AC1,BRKNUM	;ARE WE READY FOR A BREAK?
	CAILE	AC1,BRKMAX	;YES.  REASONABLE NUMBER OF EXCEPTED PCS?
	JRST	BRKERR		;NO. NOT READY
	CAME	TAC,BRKTAB-1(AC1)	;IS THIS PC EXCEPTED?
	SOJG	AC1,.-1			;NO. TRY NEXT ONE
	JUMPGE	AC1,BRKXIT		;JUMP IF WE MATCHED SOME EXCEPTED PC.
BRKHIT:

REPEAT 10,<JFCL>
↑BRKXIT:
	MOVE	TAC,BRKTAC		;RESTORE ACCUMULATORS
	MOVE	AC1,BRKAC1
	CONO	APR,ADRBRK		;CLEAR BREAK BIT
	JRST	BREAKX			;RETURN TO CH3 CODE

BRKERR:
	EXCH	P,APRPDL(PID)
	PUSHACS
	CAIG	AC1,BRKMAX		;SKIP IF ILLEGAL VALUE OF BRKNUM
	JUMPGE	AC1,BRKER1		;JUMPE IF LEGAL VALUE OF BRKNUM
	PUSHJ	P,DISMES
	ASCIZ	/ILLEGAL VALUE OF BRKNUM = /
	HRRZ	TAC,BRKNUM
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	SETZM	BRKNUM
BRKER1:
	PUSHJ	P,DISMES
	ASCIZ	/ADDRESS BREAK, PC=/
	MOVE	TAC,APRCHL
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	POPACS
	EXCH	P,APRPDL(PID)
	JRST	BRKXIT

;APRER	OTHER APR INTERRUPTS BESIDES CLOCK

APRER:
				;HERE TOO IF USER MIGHT BE ENABLED FOR CLKINTS
	EXCH	TAC,@APRCH(PID)		;SAVE TAC, GET PC WORD
	CONSZ	APR,ILM
	JRST	APRMPV			;CLEAN UP AFTER CPU ON MPV
	TLNN	TAC,USRMOD		;IS IT IN USER MODE?
	JRST	APRER2			;NO, PRINT MESSAGE AND STOP JOB
APRER1:
	CONSO	PI,7000			;SPACEWAR LOSSAGE?
	SKIPN	SPWUUF(PID)		;IN CH7. SPACEWAR ACTIVE?
	JRST	APRER6			;NOT SPACEWAR
	EXCH	TAC,@APRCH(PID)
	JUMPE	PID,APRSWP
	EXCH	PID,APRID+P2PID
	JRST	SP2INT

APRSWP:
	EXCH	PID,APRID+P1PID
	JRST	SPWINT

APRER6:
	SKIPN	INTACT(PID)		;KILL IF ALREADY AT INT. LEVEL
	CONSO	APR,@APRIN1(PID)	;IS USER ENABLED FOR THIS INTERRUPT?
	JRST	APRER2			;NO, STOP JOB AND PRINT MESSAGE
	EXCH	JDAT,JOBDAT(PID)	;SAVE JDAT, GET CURRENT JOB DATA AREA ADR.

;WHEN THE KA-10 IS FIXED, DELETE ALL OF THIS DOWN TO APRE6A (BUT NOT CONSO)
;ALSO PUT HRRI INTO APRMPV
	CONSZ	APR,ILM			;ILL MEM REF?
	TLNE	TAC,20000		;YES. SKIP IF NOT ILDB/IDPB
	JRST	APRE6A			;NOT ILM OR ILM AND BIS FLAG IS SET
	HRRI	TAC,-1(TAC)		;ASSUME HE WAS DOING A WRITE OF SOME KIND

APRE6A:
	CONSO	APR,@APRIN2(PID)	;ENABLED VIA NEW USER INTERRUPT SYSTEM?
	JRST	APRER7			;NO. OLD STYLE.


; THIS ROUTINE REQUESTS USER INTERRUPT FOR VARIOUS APR-TYPE TRAP CONDITIONS

	MOVEM TAC,APRIN3(PID)	; SAVE PC FOR CLKINT
	EXCH J,JOB(PID)
	CONI APR,TAC
	AND TAC,APRIN2(PID)
	EXCH P,APRPDL(PID)
	IORM TAC,JBTIRQ(J)
	EXCH P,APRPDL(PID)
	SETOM INTREQ(PID)	; NOW REQUEST AN INTERRUPT
	EXCH J,JOB(PID)
;	CONSZ APR,ILM
;	AOS APRIN3(PID)		;LET'S LEAVE IT ALONE - FW
	MOVE TAC,[JRST JOBTM5]
	MOVEM TAC,JOBTM5(JDAT)
	MOVE TAC,[XWD USRMOD,JOBTM5]
	EXCH JDAT,JOBDAT(PID)
	HLLOS CLKFLG(PID)
	CONO PI,1B24+1⊗(7-CLKCHN)
	JRST APRER3

;ENABLED VIA OLD-STYLE INTERRUPTS.
APRER7:
	MOVEM	TAC,JOBTPC(JDAT)	;STORE LOSER PC IN JOB DATA AREA
	HRRZ	TAC,JOBAPR(JDAT)	;GET TRAP ROUTINE ADDRESS
	CAIGE	TAC,JOBPFI		;LEGAL TRAP ADDRESS? (NO TRAPS TO ACS)
	JRST	APRER5			;NO.
	MOVEM	TAC,APRTAC(PID)		;
	HRRZ	TAC,JOBTPC(JDAT)	;DID FIRST INSTRUCTION OF TRAP ROUTINE
	CAMN	TAC,APRTAC(PID)		;GENERATE A BAD ADDRESS?
	JRST	APRER5			;YES IT WAS, TRAP IT
	ADDI	TAC,1
	CAMN	TAC,APRTAC(PID)		;REMEMBER THAT WE BUGGERED ADDRESS
	JRST	APRER5
	CONI	APR,JOBCNI(JDAT)	;STORE APR IN JOB DATA AREA
	HLL	TAC,JOBTPC(JDAT)	;NOW PUT THE ENTIRE PC TOGETHER AGAIN
	TLO	TAC,USRMOD		;MPV COMES FROM EXEC MODE TOO,
					;MAKE SURE WE GET TO USER MODE
	HRR	TAC,JOBAPR(JDAT)
	EXCH	JDAT,JOBDAT(PID)	;RESTORE JDAT,JOBDAT
APRER3:
	TLZ	TAC,440000		;CLEAR PC CHANGE AND AR OVF FLAGS
					;SO INTERRUPT MAY BE DISMISSED
	EXCH	TAC,@APRCH(PID)		;RESTORE TAC & @APRCH(PID)
	CONO	APR,530110+APRCHN	;CLEAR ERROR FLAGS WHICH CAN CAUSE
					;INTERRUPT (EXCEPT CLOCK).
	JUMPN	PID,P2RET
	JRST	P1RET

APRMPV:
					;CLEANUP AFTER CPU ON ILM
;	HRRI	TAC,-1(TAC)		;BACK UP PC TO POINT AT LOSER
	CONO	APR,400000!APRCHN	;DON'T MENTION PDLOV YET IF BOMBED ON MPV
	TLNE	TAC,USRMOD		;MAY HAVE TO WORRY IF EXEC LOST
	JRST	APRER1			;NO, JUST LOSER
	CONSO	PI,67400		;PI IN PROGRESS?
	JRST	APRMP1			;NO. MPV FROM UUO LEVEL: GO TO UADERR
	CONSZ	PI,00400		;IN PROGRESS ON CH7?
	SKIPN	SPWUUF(PID)		;IN CH7. AT SPACEWAR LEVEL?
	JRST	APRER6			;NOT SPACEWAR.  MPV FROM EXEC. (HOW??)
APRMP1:
	HRRI	TAC,UADERR		;SEND HIM TO ADDRESS CHECK
	JRST	APRER3

;HERE WE'VE DECIDED THAT THIS LOSER DOESN'T HAVE A VALID TRAP ADDRESS.
;SO WE CLEAR APRIN1(PID) TO PREVENT FURTHER DISTRACTION.
APRER5:
	MOVE	TAC,JOBTPC(JDAT)	;RESTORE PC AND FLAGS
	EXCH	JDAT,JOBDAT(PID)	;RESTORE JOB DATA AREA ADDRESS
	SETZM	APRIN1(PID)
APRER2:
	CONSO	APR,MAOFF
	CONSO	APR,200		;DID 6 GET ENABLED FOR PC CHANGE INTERUPT?
	JRST	APRERA		;NO
	CONO	APR,500!APRCHN		;CLEAR IT.
	EXCH	P,APRPDL+P2PID
	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISMES
	ASCIZ/UNEXPECTED PC CHANGE TRAP. PC=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	POPACS
	HLLZS	APRIN1+P2PID	;MAKE SURE IT DOESN'T HAPPEN AGAIN
	EXCH	P,APRPDL+P2PID
APRERA:
	CONSZ	APR,630000	;DOES EXEC CARE?	;JS  CONS,PDLOV,NXM,MPV
	JRST	APRERB		;YES!
	CONSO	APR,1B26
	JRST	APRER9
	MOVEM	TAC,APRTAC(PID)
	MOVE	TAC,APRIN1(PID)
	TRNE	TAC,1B26
	CONO	APR,1B26+APRCHN
	MOVE	TAC,APRTAC(PID)
APRER9:
	CONSO	APR,110			;ARITHMETIC OVERFLOW?
	JRST	APRER3
	MOVEM	TAC,APRTAC(PID)
	MOVE	TAC,APRIN1(PID)
	TRNN	TAC,10			;USER ENABLED FOR AROV?
	CONO	APR,40!APRCHN
	TRNN	TAC,100			;OR FOV (PC CHANGE ON 6)
	CONO	APR,400!APRCHN
	MOVE	TAC,APRTAC(PID)
	JRST	APRER3

; HERE WE HAVE A NON-TRIVIAL ERROR

APRERB:
	MOVEM	TAC,APRPC(PID)	;STORE ERROR PC FOR CLK CHANNEL
	CONI	APR,APRERR(PID)	;STORE ERROR FLAGS
				;(ALSO USED AS ERROR FLAG)
	HLLOS	CLKFLG(PID)	;SET FLAG FOR CLK INTERRUPT
	SETOM	SCHEDF(PID)	;FLAG THAT RESCHEDULING IS NEEDED
				;(EVEN THOUGH PC MAY BE IN EXEC MODE)
	CONO	PI,1B24+1⊗(7-CLKCHN)	;REQUEST INTERRUPT ON CLOCK CHANNEL.
	CONSO	APR,ILM		;ILL MEM REF?
	JRST	APRERC
	MOVEM	TAC,USAVPC(PID)	;SAVE ERROR PC FOR CLKINT
	HRRI	TAC,0		;YES. FORCE LEGAL ADDRESS SO
	JRST	APRER4		;PDP-10 WILL NOT HANG (CROCK!) ON WILD PC.
APRERC:
	TLNN	TAC,USRMOD	;PC IN USER MODE?
CONSO PI,67400;;replaced;;	CONSO	PI,177B27≠(1B27⊗(7-APRCHN))	;ARE WE SOME OTHER PI CHANEL?
	CAIA			;NO.
	JRST	APRMES		;SYSTEM SCREW-UP!!
↑APRER4:CONSO	APR,NXM		;NON-EXISTANT MEMORY?
	JRST	APRER3		;NO. RESTORE ACS AND DISMISS
	MOVEI	TAC,(TAC)	;YES. IS IT PC?
	CAML	TAC,RMEMSIZ	
	MOVEI	TAC,[CONO PI,1B24!1⊗(7-CLKCHN)]
				;YES. DISMISS TO CLKINT
	HLL	TAC,APRPC(PID)
	JRST	APRER3		;RESTORE ACS AND DISMISS

; WE GET HERE ON AN ERROR IN THE EXEC

APRMES:
	EXCH	P,APRPDL(PID)
	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/CH3 ERROR IN EXEC.  PC = /
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/
APR CONI = /
	MOVE	TAC,APRERR(PID)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	PUSHJ	P,SYSFIX
	JFCL			;NOT IN MONITOR
	CAIA			;ERROR, BUT COULDN'T FIX
	JRST	MONOK		;FOUND ERROR AND FIXED(I HOPE!)
	PUSHJ	P,ALTNOW
	JFCL
	PUSHJ	P,DISFLU	;FLUSH MESSAGES TO CTY
	PUSHJ	P,DDTCALL	;THIS DOES REQUIRE INTERVENTION
	JRST	MONOK1
MONOK:
	DEBCHECK
MONOK1:
	SKIPE	DISFLAG
	JRST	APREM1
	POPACS
	EXCH	P,APRPDL(PID)
	JRST	APRER4

APREM1:
	PUSHJ	P,DISMES
	ASCIZ	/RELOAD OR FIND A WIZARD.
/
	PUSHJ	P,DISFLUSH
	POPACS
	HALT	AUTOLOAD

;SYSTEM CLOBBERED     DETECTED BY SYS WR REF KLUDGE
REPEAT 0,<
CLBFIX:
	CONO	APR,CLRCLB+APRCHN	;CLEAR IT SO WE DON'T GET BACK HERE AGAIN
	EXCH	P,APRPDL(PID)
	PUSHACS			;GET SOME ACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/π⊗⊗ππSYSTEM CLOBBERED
PC+1 = /]
	DISARG OCT,<@APRCH(PID)>
	[ASCIZ/    /]
	-1
	MOVE TAC,@APRCH(PID)
	TLNE TAC,USRMOD		;WAS IT A LOSER?
	JRST USRCLB		;YES
	PUSHJ P,DISMES
	ASCIZ/PI = /
	CONI PI,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISERR
	[ASCIZ/
C(P) = /]
	DISARG OCT,<APRPDL(PID)>
	[ASCIZ/
/]
	-1
CLBFX1:
	PUSHJ	P,SYSFIX
	JFCL
	JFCL
	SKIPN	DEBMODE		;DO WE WANT TO STOP
	JRST	CLBRET
	SETOM	DISFLAG
	PUSHJ	P,DISFLUSH
	POPACS			;LET DDT LOOK AT THE REAL ACS
	PUSHJ	P,DDTCAL
	JRST	CLBRT1
CLBRET:
	POPACS
CLBRT1:
	EXCH	P,APRPDL(PID)
	JRST	PBRET

USRCLB:
	MOVE	J,JOB(PID)
	PUSHJ	P,DISJOB
	CONI	PI,TAC
	TRNN	TAC,400		;SPACEWAR?
	JRST	USRCL1
	PUSHJ	P,DISMES
	ASCIZ	/  SPCWAR/
USRCL1:
	PUSHJ	P,DISCRLF
	JRST	CLBFX1		;NOW TRY TO FIX IT!
>

SUBTTL	CLOCK	24 JULY 67

;THIS ROUTINE RUNS ON THE LOWEST PRIORITY PI CHANNEL AND AT UUO LEVEL
;TO CAUSE AN INTERRUPT ON CLK CHANNEL:
;	SETOM CLKFLG	;FLAG THAT INTERRUPT HAS BEEN REQUESTED
;	CONO PI,CLKREQ	;REQUEST PI INTERUPT ON LOWEST PI CHANNEL
;THE FOLLOWING OTHER FLAGS MUST ALSO BE SET
;APRERR-APR DETECTED ERROR IN CURRENT JOB
;SCHEDF-RESCHEDULING MUST TAKE PLACE(EVEN THOUGH PC IN EXEC MODE)
;TIMEF-APR CLOCK HAS TICKED ON HIGH PRIORITY CHANNEL
;SEE APRSER AND RUNCSS TO SEE HOW THIS ROUTINE IS CALLED

;CLK SERVICE PERFORMS THE FOLLOWING ON A REGULAR BASIS:
;PROCESSES CLOCK QUEUE REQUESTS
;CALLS CONSOLE MONITOR COMMAND DECODER
;CALLS CORE SHUFFLER
;THEN CALLS SCHEDULER
;IF THE CURRENT JOB IS IN EXEC MODE THE ABOVE 4 TASKS ARE
;DELAYED UNTIL THE CURRENT JOB ENTERS A STOPPABLE STATE: I.E., UNTIL
;	1. JOB STARTS TO WAIT FOR A BUSY SHARABLE DEVICE
;	2. JOB STARTS TO WAIT FOR IO TO COMPLETE
;	3. CONTROL ABOUT TO RETURN TO USER MODE
;THEN CLK SERVICE IS ENTERED AT THE UUO LEVEL


;HERE AT CLK INTERRUPT LEVEL  -  CLKINT

↑CLKIN0:EXCH 17,UUO0+P1PID	;GET HERE WHEN CLKFLG < 0
	MOVEM 17,CLKCHL		;SIMULATE INT FROM LOSER
	EXCH 17,UUO0+P1PID
↑CLKINT:SETZM CLKFLG+P1PID
	MOVEM 17,CLKS17+P1PID	;SAVE AC 17
	IFN FTHG, <	MOVEI 17,7
			MOVEM 17,HGCODE	>
	MOVEI 17,P1PID
	SKIPLE INTDISP(17)	; DO WE HAVE SOMEONE TRYING TO SNEAK INTO CH7
	JRST @INTDISP(17)	; YES, GO SERVICE HIM
IFN FTHG,<	SETZM HGCODE	>
	SKIPN 17,USAVPC
	MOVE 17,CLKCHL		;IS CURRENT JOB IN USER MODE?
	TLNN 17,USRMOD
	SKIPE SCHEDF+P1PID	;NO, IS THIS A FORCED RESCHEDULING INTERRUPT?
	JRST CLKIN1
	MOVEI 17,P1PID
	SKIPE INTREQ(17)
	JRST INTNOW
CLKINX:
	MOVE 17,[CONO PI,PIOFF]
	MOVEM 17,UUOXIT+P1PID	;DIVERT TO CLKIN0 ON WAY BACK TO LOSER
	MOVE 17,CLKS17+P1PID	;LEAVE TIMEF SET AND DISMISS INT.
	JEN @CLKCHL

CLKIN1:
	DATAO PI,[0]		;WE ARE NOW OFFICIALLY IN CHANNEL 7
	MOVEM 17,USRPC+P1PID
	SETZM USAVPC+P1PID
	MOVEI 17,P1PID
	JRST CLKERR

;P2 CLK INTS COME HERE

↑CL2IN0:EXCH 17,UUO0+P2PID
	MOVEM 17,CL2CHL
	EXCH 17,UUO0+P2PID
↑CL2INT:SETZM CLKFLG+P2PID
	MOVEM 17,CLKS17+P2PID
	MOVE 17,[P2PID]
	SKIPLE INTDISP(17)
	JRST @INTDISP(17)
	SKIPN 17,USAVPC+P2PID
	MOVE 17,CL2CHL
	TLNN 17,USRMOD
	SKIPE SCHEDF+P2PID
	JRST CL2IN1
	MOVE 17,[P2PID]
	SKIPE INTREQ(17)
	JRST INTNOW
CL2INX:
	MOVE 17,[CONO PI,PIOFF]
	MOVEM 17,UUOXIT+P2PID
	MOVE 17,CLKS17+P2PID
	JEN @CL2CHL

CL2IN1:
	MOVEM 17,USRPC+P2PID
	SETZM USAVPC+P2PID
	MOVE 17,[P2PID]
	JRST CLKERR

; HERE IT IS NOT TIME TO TAKE A REAL CLOCK INTERRUPT
; HOWEVER WE WILL GIVE A USER INTERRUPT NOW

INTNOW:
	REPEAT 0,<	;LET'S SEE IF ANYBODY REALLY NEEDS THIS SHIT

INTNOW:
	MOVEM 16,INTSAC+16(17)	; SAVE ACS IN SPECIAL PLACE,
				;   BECAUSE JOB MIGHT BE IN TRANSIT
	HRRZ 16,@CLKCH(17)
	CAIL 16,USRXT0
	CAIL 16,USRXT5
	SKIPE INTHLD(17)
	JRST INTNW2		;IN USRXIT CODE - COME BACK LATER
	MOVEI 16,INTSAC(17)
	BLT 16,INTSAC+15(17)
	MOVE PID,17
	MOVE TAC,CLKS17(PID)
	MOVEM TAC,INTSAC+17(PID)
	SKIPN TAC,USAVPC(PID)
	MOVE TAC,@CLKCH(PID)	; SAVE PC
	SETZM USAVPC(PID)
	MOVEM TAC,USRPC(PID)
	HRLI P,-CLKPLN		;LENGTH OF PDL
	HRRI P,CLKPDL-1(PID)
	SETOM INTNF(PID)
	PUSHJ P,INTRUN
	SETZM INTNF(PID)
	HRLZI 17,INTSAC(PID)
	JUMPE PID,CLKBLT
	BLT 17,17
	JEN @USRPC+P2PID
CLKBLT:
	BLT 17,17
	JEN @USRPC+P1PID

INTNW2:
	MOVE 16,INTSAC+16(17)
>
	JUMPE 17,CLKINX		;CLOBBER UUOXIT & DISMISS
	JRST CL2INX
				;STORAGE FOR CURRENT JOB
CLKERR:
	JSR @CLKSV(17)		; SAVE ACCUMULATORS
	HRLI P,-CLKPLN
	HRRI P,CLKPDL-1(PID)
	MOVE TAC,UUOXI(PID)
	MOVEM TAC,UUOXIT(PID)	;RESTORE EXIT, NOW THAT WE MADE IT
CIP9:

	SKIPE TAC,APRERR(PID)	;IT THIS AN ERROR INTERRUPT?
	PUSHJ PDP,APRILM	;YES, GO PROCESS ERROR 
	SKIPE INTREQ(PID)		; ANY INTERRUPTS PENDING?
	PUSHJ P,INTRUN
	JUMPN PID,RSCHED
	SKIPE SPWGO
	PUSHJ P,SPWCHK
	SKIPE SP2GO
	PUSHJ P,SP2CHK
	JRST RSCHED

SPWCHK:
	SKIPA	TAC1,[,SPWGO(J)]
SP2CHK:
	MOVE	TAC1,[,SP2GO(J)]
	SETZ	J,
	MOVSI	TAC,SPWERB	;LOOK FOR ANY SPACEWAR MODE ERRORS
	LDB	J,[POINT 6,@TAC1,5]
	TDNN	TAC,JBTST2(J)
	JUMPN	J,.-2
	JUMPE	J,CPOPJ
	JRST	SPWMES

;SET TIME FLAGS, UPDATE SYSTEM TIME, COUNT DOWN PROCESSOR ALIVE FLAGS

RSCHED:
	CONO	PI,APROFF		;SHUT OFF THE REAL-TIME CLOCK
	SKIPN	TIMEFF(PID)		;ARE WE BEHIND IN TIME ACCOUNTING?
	JRST	CIP6			;NO, JUST RESCHEDULE
	SETZM	TIMEFF(PID)		;DECREMENT "BEHIND" COUNT
	CONO	PI,APRON		;ENABLE CHANNEL 3 AGAIN
	SETOM	TIMEF(PID)		;SET "TIME" FLAG
	MOVE	TAC,OTHERID(PID)
	SOS	PALIVE(TAC)
	MOVEI	TAC,30
	MOVEM	TAC,PALIVE(PID)

	JUMPN	PID,MIDCHK		;FLUSH PDP6
	SOSLE	T15CNT		;TIME TO CHECK FOR AUDIO SWITCH?
	JRST	SECCHK
;HERE EVERY 1/4 TH SECOND
	MOVEI	TAC1,=15
	MOVEM	TAC1,T15CNT
	PUSHJ	P,ASSCN		;SEE IF ANY AUDIO SWITCH WORK TO BE DONE(TTYSER)
SECCHK:
	SOSLE	DKBCNT		;TIME TO RUN THE 1 SECOND CLOCK?
	JRST	MIDCHK		;NO
;HERE ONCE PER SECOND. 
	MOVEI	TAC1,=60	;CHECK EVERY SECOND
	MOVEM	TAC1,DKBCNT	;RESTORE COUNT WORD (IN APRDAT)
	MOVE	TAC,TIME	;GET CURRENT TIME
	IDIVI	TAC,=60		; AND CONVERT IT TO SECONDS
	HRL	TAC,THSDAT	; PUT DATE IN LEFT HALF
	MOVEM	TAC,TIMDAT	;SAVE <DATE>,,<TIME IN SECS>
;HERE WE MAKE SURE THAT KEY NXM STOP IS ON.  PROCESSOR REALLY LOSES
;WHEN IT GETS A NXM, SO ... REG 8-14-73
	CONSZ	PTP,200		;SKIP IF KEY NXM STOP IS OFF.
	JRST	DDSTAT		;IS OK.
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/πππTURN NXM STOP ON!
/
	CONO	PI,PIOFF	;NOW SO WE REALLY MAKE OURSELVES NASTY
	PUSHJ	P,DISFLUSH
	CONSO	PTP,200
	JRST	.-1		;WAIT UNTIL SOMEONE NOTICES.
	CONO	PI,PION
	POPACS
DDSTAT:

IFN FTDDSTAT,<
	SOSLE	NDSTAT		;TIME FOR DD STATISTICS?
	JRST	SCNPIC		;NO. CHECK THE SCANNER NEXT
	MOVEI	TAC,5		;HERE EVERY 5 SECONDS
	MOVEM	TAC,NDSTAT

	MOVE	TAC,NDDXCT	;GET NEW COUNT
	EXCH	TAC,NDDXOL	;STORE AS OLD COUNT
	SUB	TAC,NDDXOL	;OLD COUNT - NEW COUNT. RESULT NEGATIVE
	MOVN	TAC,TAC
	CAMLE	TAC,NDDXMX	;BIGGER THAN OLD MAX?
	MOVEM	TAC,NDDXMX	;YES. STORE NEW MAX.

	MOVE	TAC,NDDLCT	;GET NEW COUNT
	EXCH	TAC,NDDLOL	;STORE AS OLD COUNT
	SUB	TAC,NDDLOL	;OLD-NEW. RESULT IS POSITIVE.
	CAMLE	TAC,NDDLMX	;BIGGER THAN OLD MAXIMUM?
	MOVEM	TAC,NDDLMX	;YES. STORE NEW MAX.
>				;END FTDDSTAT
;SCANNER PI CHN CHECK - TEMP. FIX TO HARDWARE PROBLEM - 12 JUNE 72 - JHS
SCNPIC:
	CONI	DKB,TAC1
	ANDI	TAC1,7
	CAIN	TAC1,SCNCHN	;DOES DKB STILL THINK IT'S ON CHANNEL 5?
	JRST	MIDCHK		;  YES
	CONO	DKB,10!SCNCHN	;  SET PI'S AND RESET FOR GOOD MEASURE
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/SCANNER LOST PI CHANNEL AGAIN!
/
	POPACS
MIDCHK:


;MIDNITE CHECK

	CONO	PI,APROFF		;HOLD UP CHANNEL 3
	MOVE	TAC1,TIME(PID)
	CAMGE	TAC1,MIDNIT		;GONE PAST MIDNITE?
	JRST	CIP2			;NO
	SUB	TAC1,MIDNIT		;KEEP COUNT ACCURATE
	MOVEM	TAC1,TIME(PID)		;REPLACE COUNT
	CONO	PI,APRON		;ENABLE CHANNEL 3 AGAIN
CIP3:
	MOVEI	IOS,0			;RESET IOS ALSO.
	AOS	TAC,THSDAT(PID)		;UPDATE DAY.
	IDIVI	TAC,=31
	DIVI	IOS,=12			;NO.
	LDB	IOS,PMONTB
	CAMGE	IOS,TAC1		;END OF MONTH?
	JRST	CIP3			;YES.

;	SETZM	AFOOL			;THESE 4 INSTR. FOR APRIL 1 HACK.
;	JUMPN	TAC1,CIP2		
;	CAIN	TAC,3
;	SETOM	AFOOL

CIP2:
	CONO	PI,APRON		;ENABLE CLOCK TRAPS AGAIN
	JUMPN	PID,CIPZZ1		;SKIP THIS STUFF ON THE PDP-6
	HGMAC	(21)
	SOSLE	FSCKCT
	SKIPE	FSNCLK
	PUSHJ	P,FSCLK			;THINK ABOUT FREE STORAGE.
	SKIPLE	SPFSNT
	PUSHJ	P,SFSCLK		;REPLENISH SPARE LISTS IF NECESSARY
IFG DPYNUM,<				;MAINTAIN DISPLAYS
	PUSHJ	PDP,DPYCLK
IFN IMPSW,<	HGMAC	(23)
		PUSHJ	P,IMPCLK>
	HGMAC	(14)
	JUMPE	PID,CIPZZ1
	PUSHJ	P,DISMES
	ASCIZ	/πPID CLOBBERED BY DPYCLK OR TTYCLK
/
	MOVEI	PID,P1PID		;WHICH IS KNOWN TO BE ZERO
>
CIPZZ1:
	HGMAC	(0)

; KEEP INFORMATION FLOWING BETWEEN THE PROCESSORS
; MODIFIED CLOCK ROUTINES FOR 2-PROCESSOR SYSTEM

	JUMPE	PID,JLCALC
	PUSHJ	P,JLCAL		;CALCULATE JOB LOADING
	PUSHJ	P,SPWP2		;DO SPACEWAR
	PUSHJ	P,WHOSER	;CALCULATE WHO LINES
	PUSHJ	P,PTRP2		;KEEP PAPERTAPE READER ALIVE
	PUSHJ	P,PTPP2		;KEEP TAPE PUNCH/PLOTTER GOING
	PUSHJ	P,ADP2		;AND THE AD
	SOSG	XGPP2F		;COUNT DOWN TO RUN XGP CLOCK LEVEL.
	PUSHJ	P,XGPP2		;AND THE XGP
	SKIPE	ADCP2L		; ADC?
	PUSHJ	P,ADCP2
	SKIPE	DACP2L
	PUSHJ	P,DACP2

IFN 0,<	;THIS PROBLEM HAS BEEN FIXED?
	SKIPL	AC2,NULDAT+P2PID+JOBDAC+10	;THE ONE THAT GETS IT
	TDNN	AC2,[140000,,140000]	;MAY HAVE COUNTED DOWN TO NEXT BIT
	JRST	NULOK
	PUSHJ	P,DISMES
	ASCIZ	/100000 BIT PICKED: /	;SO GJG WILL KNOW
	TLNN	AC2,140000
	JRST	NULLOK
	PUSHJ	P,DISMES
	ASCIZ	/LEFT /
	JRST	NULROK
NULLOK:
	PUSHJ	P,DISMES
	ASCIZ	/RIGHT /
NULROK:
	SETZM	NULDAT+P2PID+JOBDAC+10	;RESTART IT
	PUSHJ	P,DISMES
	ASCIZ /HALF.
/
>	;END IFN 0,

NULOK:
	SOSL	CRKYET		; TIME TO READ THE CROK AGAIN?
	JRST	CRKT4		; NO, SKIP IT
	MOVEI	TAC,=3600*5	; SET FOR 5 MINS
	MOVEM	TAC,CRKYET
	MOVEI	TAC1,5		; WE WILL TRY FIVE TIMES
	PUSHJ	PDP,DAT2	; READ PETIT CROCK
	JRST	CRKT4		; NO, CRK SICK
	MOVEM	ITEM,CRKTIM	; UPDATE TIME OF DAY
	MOVEM	DAT,CRKDAT	; UPDATE DATE
	JRST	CRKT4

JLCALC:
	HGMAC	(16)
	MOVE	TAC,OTHERID(PID)
	SKIPE	P2NUM
	SKIPGE	PALIVE(TAC)
	PUSHJ	P,JLCAL		; RECOMPUTE PRIORITIES
JORD:
	SKIPE	ORDYET
	PUSHJ	P,ORDER		; SORT THE JOBS IN THE RUN QUEUE INTO PRIORITY ORDER

; HERE IS THE GUY THAT CALLS UP PHANTOM PROCESSES LIKE BATCH MONITORS

IFN FTBAT,<
	SOSLE	BATYET		;RUN OUR BATCH JOB YET?
	JRST	BAT3A		;NO. NOT YET
	HGMAC	(0)
	MOVEI	TAC,=60*JIFSEC	;RESET TO LOOK AGAIN IN 1 MINUTE
	MOVEM	TAC,BATYET	;SET RETRY TIME
	SKIPE	MAINTM		;MAINTMODE?
	JRST	BAT3A		;FLUSH THIS CODE WHILE MAINTM SET
	MOVSI	TAC,-BATLEN	;LENGTH OF BATMAN
BATLOP:
	MOVEM	TAC,BATPNT	;SAVE IT
	SKIPE	AC1,BATMAN(TAC)	;JOBNAM
	SKIPN	AC3,ROBIN(TAC)	;PPN
	JRST	BAT3		;AVOID EMBARASSING CONFUSION!
	SKIPGE	J,ALFRED(TAC)	;GET CIRCUMSTANTIAL CODE
	JRST	BAT3		;NEGATIVE MEANS DON'T START ME
	JUMPE	J,BAT0		;IF ZERO THEN START ME!
	MOVE	TAC,TIME	;GET JIFFIE TIME
	IDIVI	TAC,=60*JIFSEC	;MAKE IT MINUTES
	HRL	TAC,THSDAT	;GET THE DATE
	CAMGE	TAC,ITEM	;COMPARE WITH HIS REQUEST
	JRST	BAT3		;NOT YET.
	HRRZ	TAC,BATPNT	;GET CURRENT POINTER BACK
	SETZM	ALFRED(TAC)	;SO WE DON'T GET HERE AGAIN
BAT0:
	MOVEI	J,JOBN-1	;SCAN JOBS LOOKING FOR ONE LIKE THIS.
	MOVSI	TAC,JNA
BAT1:
	TDNN	TAC,JBTSTS(J)	;IS THERE A JOB HERE?
	JRST	BAT2		;NO.
	CAMN	AC1,JOBNAM(J)	;WITH A NAME LIKE MINE?
	CAME	AC3,PRJPRG(J)	;AND A PPN LIKE MINE TOO?
	JRST	BAT2		;NO MATCH.
	SKIPL	AC2,JBTSTS(J)	;IS THIS JOB RUNNABLE?
	TLNE	AC2,JLOG	;NOT RUNNABLE. IS IT LOGGED IN?
	JRST	BAT3		;RUNNABLE OR LOGGED IN.
;HERE WE HAVE A DEAD PHANTOM.  KILL IT AND START A NEW ONE.
;TO BE CONTINUED....
	JRST	BAT3		;TO BE CONTINUED. IN THE MEANTIME, DO NOTHING.

BAT2:
	SOJG	J,BAT1		;LOOP LOOKING THRU ALL JOBS.
	PUSHJ	P,INIJOB	;ATTEMPT TO MAKE A NEW JOB
	JRST	BAT3A		;NONE AVAILABLE. MAYBE SOON...
	JRST	BAT3B		;AVAILABLE LATER...

BAT4:
	PUSHJ	P,GETBAT	;START A PHANTOM JOB.
BAT3:
	MOVE	TAC,BATPNT	;GET BACK BAT POINTER
	AOBJN	TAC,BATLOP
	JRST	BAT3A		;DONE
BAT3B:
	MOVEI	TAC,=60		;WAIT FOR ONE SECOND
	MOVEM	TAC,BATYET
BAT3A:
				;DONE WITH PHANTOM CHECKS FOR THIS MINUTE.
>;END OF FTBAT

; MAINTAIN P1'S 2-PROCESSOR COMMUNICATION

	HGMAC(0)
	CONI	TV,SPWBUT	;READ THE SPACEWAR BUTTONS
	SKIPE	SPWGO		;ONLY RUN SPACEWAR IF SOMEONE WANTS IT
	PUSHJ	P,SPWP1		;RUN SPACEWAR OFF THE CLOCK
	MOVE TAC,OTHERID(PID)	; PICK UP ADDRESS OF PDP-6'S DATA AREA
	SKIPGE PALIVE(TAC)	; IS SIX RUNNING?
	PUSHJ P,WHOSER		; APPARANTLY NOT. REFRESH WHO LINE.
	SKIPN P2NUM		; DOES P2 EXIST?
	JRST CRKT2		; NO, FORGET IT

	SKIPE	PARFLG		; PARITY ERROR ON P2?
	PUSHJ	P,PARCLK	;YES. CALL PARITY ERROR SERVICE

CRKT3:
	MOVE ITEM,CRKTIM	; PICK UP TIME OF DAY
	SKIPN DAT,CRKDAT	; IS THE CRK RUNNING? DATES AREN'T = 0
	JRST CRKT1		; CRK DEAD, FORGET IT.
	MOVEM ITEM,TIME(PID)	; UPDATE TIME OF DAY
	MOVEM DAT,THSDAT(PID)	; UPDATE DATE
	SETZM CRKDAT		; CLEAR DATE FLAG

CRKT1:
	SKIPE	PTRADV		;RUN CLOCKS FOR PTR,PTP,AD AND XGP
	PUSHJ	P,PTRP1

	SKIPE	PTPSID
	PUSHJ	P,PTPP1

	SKIPLE	ADADV
	PUSHJ	P,ADP1

	SKIPE	XGPP1F		;DO WE HAVE TO LOOK AT XGP STATUS?
	PUSHJ	P,XGPP1		;YES.

	SKIPE	ADCP1L		; ADC CALLING?
	PUSHJ	P,ADCP1		; YES

	SKIPE	DACP1L		; DAC MAYBE?
	PUSHJ	P,DACP1

REPEAT 0,<			;ABOUT TIME THIS CROCK WAS FLUSHED
	HGMAC(20)		;HGCODE FOR SCHCLK, REPLACED BY THE FOLLOWING:
	SKIPGE	J,JBTQ-DIOWQ	;ANYONE IN QUEUE?
	JRST	CRKT2		;NOPE.
	AOS	JBTRNB(J)	;COUNT TIME (WHAT A CROCK!)
	HRRE	J,JBTQ(J)	;GET NEXT GUY IN Q.
	JUMPGE	J,.-2		;JUMP IF REAL JOB THERE.
>
	JRST	CRKT2

; HERE IS SUBROUTINE FOR PHANTOM ROUTINES

IFN FTBAT,<
↑GETBT0:			;ENTER HERE FROM CLKREQ BY XGPSER
	MOVE	J,TAC		;JNA FOR THIS JOB IS TURNED ON ALREADY.
	JRST	GETBTX

GETBAT:

	SKIPE MAINTMODE
	POPJ P,
	MOVE TAC,BATPNT		;GET THE POINTER TO BAT TABLES
	MOVE TAC,GORDON(TAC)	;GET THIS PHANTOM'S PRIVILEGE BITS
	MOVEM TAC,JBTPRV(J)	;SAVE
	MOVEM TAC,JB2PRV(J)	;ALSO IN PASSIVE BITS
	MOVEM AC3,PRJPRG(J)
	MOVEM AC3,JOBPPN(J)
	MOVEM AC1,JOBNAM(J)	;SETUP THIS GUY'S NAME
IFN FTSTAT,<PUSHJ P,NAMSTT>
	MOVSI TAC,JNA		;MAKE SURE NO ONE GETS THIS NUMBER
	ORM TAC,JBTSTS(J)
GETBTX:
	MOVSI TAC,'DSK'		;DEVICE DISK. 
	MOVEM TAC,JOBDEV(J)
	MOVSI TAC,'DMP'		;AND DUMP
	MOVEM TAC,JOBLOG(J)
	SETZM JOBCRD(J)		;NO CORE SIZE OR STARTING INCREMENT
	SETZM JBTUFD(J)
IFN FTDSKPPN,<SETZM DSKPPN(J)	;INITIALIZE DISK ALIAS PPN>
	SETZM JBTKCJ(J)
	MOVSI TAC,JLOG
	ANDCAM TAC,JBTSTS(J)
	HLLZS SAVSAI(J)		;JUST IN CASE
GETBT1:
	SETOM TAC1
	PUSHJ P,DDBSRC
	JRST DELBTT		; NO DDB, DELAY
GETBT2:
	SETZ PROG,
	MOVEI TAC,JOBDA
	PUSHJ P,CORE0		; GET IT SOME CORE
	JRST DELBAT		; NOT AVAILABLE, WAIT FOR IT
GETBT3:
	MOVSI TAC,SWP!SHF
	SKIPN XJOB(J)		; IF STILL GETTING CORE, DELAY A WHILE
	TDNE TAC,JBTSTS(J)	; DID JOB GO AWAY DURING ALL THIS?
	JRST BATSWP		; YES, GET IT BACK IN
↑BATSW:		;ENTER HERE FROM SWAPPER WHEN JOB COMES IN
	PUSHJ P,SETLOG		; SET-UP LOGIN STUFF
	MOVE TAC,JOBNAM(J)
	MOVEM TAC,FILNAM(PROG)
	MOVE TAC,JOBDEV(J)	; DEVICE
	MOVEM TAC,DEVWRD(PROG)
	HLLZ TAC,JOBLOG(J)	; EXTENSION
	MOVEM TAC,FILEXT(PROG)
	SKIPN TAC,JOBCRD(J)		; CORE SIZE
	JRST .+3			; DON'T FUTZ WITH ZERO
	LSH TAC,12			; TO WORDS
	SUBI TAC,1			;TO PROT
	MOVEM TAC,JOBCOR(PROG)
	HRRZ TAC,JOBLOG(J)
	MOVEM TAC,INCWRD(JDAT)	;SAVE IN PLACE WE CAN FIND IT LATER
	MOVEI TAC1,PRUNJB	; THIS GUY KNOWS ABOUT INCREMENTAL START-UP
	JRST MONJOB

; MORE PHANTOM CLOCK LEVEL ROUTINES, WAITING FOR RESOURCES

DELBAT:
	LSH J,=12		; HERE WE WAIT FOR CORE TO BECOME AVAILABLE
	ADD J,[XWD BATRS,1]
DELB1:
	CONO PI,PIOFF
	IDPB J,CLOCK(PID)
	CONO PI,PION
	POPJ P,

BATRS:
	MOVE J,TAC
	JRST GETBT2

DELBTT:
	LSH J,=12
	ADD J,[XWD BATTT,1]
	JRST DELB1

BATTT:
	MOVE J,TAC
	JRST GETBT1

BATSWP:
	MOVSI TAC,BATSNB	; SET THIS FLAG AND PUT IN SWAPIN LIST
	JRST SETSIN		; WILL CALL BATSW WHEN SWAPPED IN

;THERE ARE 3 TABLES IN APRDAT OF EQUAL LENGTH WHICH CONTAIN THE NAMES OF
;ALL THE PHANTOM JOBS AND A FLAG TO TELL IF THIS JOB SHOULD BE
;STARTED AT ALL THE JOBS ARE STARTED WHEN THE SYSTEM STARTS UP AND
;CHECKED FOR RESTART EVERY MINUTE.
>;END OF FTBAT

; HERE WE FLUSH THE DISASTER TYPEOUT BUFFER THEN PROCESS CLOCK REQUESTS

CRKT2:
	HGMAC(0)
	MOVE TAC,DISPTR
	CAME TAC,DISOPT		; ANYTHING IN THE DISASTER BUFFER?
	PUSHJ P,DISOUT		; YES, GO EMPTY IT

;PROCESS TIMING REQUESTS STORED IN QUEUE

CRKT4:
	HGMAC	(17)		;TIMING REQUEST.
	HRRZ DAT,CLOCK(PID)	;GET END OF LIST
CIP4:
	CAIG DAT,CIPWT-1(PID)	;END YET?
	JRST CIP5		;YES
	SOS TAC1, (DAT)		;DECREMENT TIMING REQUEST
	TRNE TAC1, 7777		;TIME EXPIRED YET
	SOJA DAT, CIP4		;NO, CONTINUE SCAN
	CONO PI, PIOFF		;YES, MOVE LAST ITEM IN LIST TO THIS
	MOVE TAC, @CLOCK(PID)
	SOS CLOCK(PID)
	MOVEM TAC, (DAT)
	CONO PI,PION
	LDB TAC, [POINT 6, TAC1, 23]
				;GET 6 BIT DATA ITEM
	HLRZS TAC1		; SETUP DISPATCH ADDRESS
	CAMG TAC1,SYSTOP	; IS THIS A REASONABLE ADDRESS?
	JRST CIP5AA
	PUSH P,DAT
	PUSHJ P,ALTNOW
	JFCL
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ /ππCLOCK REQUEST WITH ILLEGAL ADDRESS
/
	POP P,DAT
	SKIPN DISFLAG
	JRST CIP5A
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

CIP5AA:
	PUSH PDP, DAT		;SAVE ONLY VALUABLE AC
IFN FTHG, <PUSH	P,HGCODE 
	   HGMAC(22)	>
	PUSHJ PDP, (TAC1)	;AND DISPATCH TO TIMING REQUEST ROUTINE
IFN FTHG, <POP	P,HGCODE >
	POP PDP, DAT
CIP5A:
	SOJA DAT, CIP4		;GO BACK FOR MORE REQUESTS

; IF WE ARE SHUFFLING 1K AT A TIME, DO ANOTHER K HERE, THEN CALL SCHEDULER

CIP5:
	JUMPN PID,CIP6A		;P2 JUMPS TO CIP6A -AVOID RUNNING COMMAND
IFN FTSHF1K,<
	HGMAC	(13)
	SKIPN TAC,SHFTAC	;ANY SHUFFLING TO DO?
	JRST CIP11		;NO.
	MOVE ITEM,SHFJOB	;LOAD NUMBER OF JOB TO BE MOVED
	HRRZ TAC1,TAC		;YES. DO 1K OF IT.
	CAML TAC1,SHFEND	;ARE WE DONE?
	JRST CIP12		;YES.
	BLT TAC,1777(TAC1)	;MOVE THAT CORE.
	MOVE TAC,[XWD 2000,2000]
	ADDM TAC,SHFTAC		;UPDATE SHFTAC
	HRRZ TAC,SHFTAC		;WAS THAT THE LAST?
	CAMGE TAC,SHFEND
	JRST CIP11
CIP12:
	PUSHJ P,NOTSH1		; FINISHED. MARK IT DONE.
	PUSHJ P,SHFDONE
>	;END OF IFN FTSHF1K

CIP11:
	HGMAC(11)
	SOSG HNGTIM		;DECREMENT HUNG IO DEVICE 
	PUSHJ PDP,DEVCHK	;GO CHECK FOR HUNG IO DEVICES
CIP6:
	CONO PI,APRON		; ENABLE CLOCK TRAPS IF THEY WERE OFF
	HGMAC(1)
	SKIPE COMCNT		;ANY COMMANDS TO PROCESS?
	PUSHJ PDP,COMMAND	;YES, CALL COMMAND DECODER.
	HGMAC(6)
CIP6A:
	PUSHJ PDP,NXTJOB	;CALL SCHEDULER
	HGMAC(15)
	SETZM SCHEDF(PID)	;CLEAR FORCED SCHEDULING FLAG
	SETZM TIMEF(PID)	;CLEAR "CLOCK FIRED" FLAG
	JUMPN J,CLKSRJ		; IF NULL JOB RUNNING, DO FOLLOWING TEST
	JUMPN PID,CLKSRJ
	MOVE AC1,[XWD -RUNQ,-RUNQ]
	MOVE AC2,[XWD -TQ,-TQ]
	CAMN AC1,JBTQ-RUNQ
	CAME AC2,JBTQ-TQ	; IF ANYBODY RUNNABLE, BUMP COUNT
	AOS NJRNULLS
CLKSRJ:
	MOVEI	TAC1,1		;THIS BIT WILL REPRESENT THE NEW JOB
	SETZ	TAC,		; SOMEWHERE IN TAC OR TAC1
	LSHC	TAC,(J)		;MOVE BIT TO APPROPRIATE POSITION
	ORM	TAC,JBSRUN	; AND NOTE THIS JOB HAS BEEN RUN LATELY
	ORM	TAC1,JBSRUN+1

	CAMN ITEM,JOB(PID)	;IS NEXT JOB SAME AS LAST ONE?
	JRST CIP8		;YES, JUST RESTORE ACS AND DISMISS
	SKIPE ITEM		; ARE WE SWITCHING TO THE NULL JOB?
	AOS NJSWITCHES		; NO, MARK ANOTHER SWITCHING

;DIFFERENT JOB, SAVE SOFTWARE STATE(HARDWARE ALREADY SAVED)

	MOVE	JDAT,JOB(PID)	;GET OLD JOB NUMBER
	MOVE	TAC,TIMDAT	;GET <DATE>,,<TIME IN SECS>
	MOVEM	TAC,FTIME(JDAT)	;AND SAVE FOR JOB THAT JUST RAN

	SKIPE JDAT,JOBDAT(PID)	;NULL JOB OR CORE 0 ON OLD JOB?
	PUSHJ P,S2U		; MOVE CHANNEL ASSIGNMENTS INTO USER CORE
↑NULJOB:			;TRANSFER HERE FROM SYSINI WITH ITEM=0
CIP7:
	MOVEM ITEM,JOB(PID)	;STORE NEW CURRENT JOB NUMBER
	MOVE PROG,JBTADR(ITEM)	;RELOCATION FOR CURRETN JOB
	MOVEM PROG,JOBADR(PID)	;XWD PROTEC,RELOC
IFN JDMPRG,<
	MOVE JDAT,JBTDAT(ITEM)	;LOC. OF JOB DATA AREA
	MOVEM JDAT,JOBDAT(PID)	;FOR CURRENT JOB
>
	CONO APR,550+APRCHN	; CLEAR APR ENABLED FLAGS
	HLLZS APRIN1(PID)	;DISABLE USER APR INTERRUPTS
	SETZM APRIN3(PID)
	JUMPE ITEM,NULJB	;IS NEW JOB NULL JOB?
	HLRZM PROG,USRREL(PID)	;PROTECTION FOR CURRENT JOB
	HLRZM PROG,JOBREL(JDAT)	;SET PROT. IN JOB DATA AREA FOR USER TO LOOK AT
	PUSHJ P,U2S		; MOVE USER TABLE INTO SYSTEM
	MOVE TAC,JBTIEN(J)	; PICK UP USER INTERRUPT ENABLINGS
	ANDI TAC,CPUMSK
	MOVEM TAC,APRIN2(PID)	; SET SO CH3 CAN TEST FOR THEM
	IOR TAC,JOBENB(JDAT)	;NOW INCLUDE OLD-STYLE INTS
	ANDI TAC,CPUMSK!1000	; SYSTEM ENABLED FOR PDL OV, ILM, NXM, CLK
	HRRM TAC,APRIN1(PID)	; PUT IN USER ENABLED LOC
	XORI TAC,110		; COMPLEMENT FOV, AROV, SO 0 MEANS ENABLE
				; AND 1 MEANS DISABLE
	ADDI TAC,330		; SET BITS 27 AND 30 IF DISABLE
				; SET BITS 28 AND 31 IF ENABLE
	ANDI TAC,660		;MASK OUT ALL BUT PC CHNG+AROVF ENABLE-DISABLE
	CONO APR,APRCHN(TAC)	;ENABLE OR DISABLE PC CHNG AND AR OVF
	JRST CIP8		; JUMP TO PAGE AFTER NEXT

;S2U AND U2S
S2U:
	MOVEI TAC,JOBPRT(JDAT)	;DEST.=FIRST LOC PROTECTED FROM USER
	HRLI TAC,USRPRT(PID)	;SOUR.=SYSTEM DATA STORAGE FOR CURRETN JOB
	SKIPL TAC1,USRHCU(PID)
	JRST CIP14
	SUBI JDAT,2
	JRST CIP13
CIP14:
	CAILE TAC1,17		;MUST BE 17 OR LESS(IO MIGHT
				;CLOBBER IF ADDRESS CHECKING MISSES)
	MOVEI TAC1,17		;MOVE ALL 20 CHANNELS IF NEG.
				;OR LESS THAN 0.
	ADD JDAT,TAC1		;RELOCATE TO USER AREA
CIP13:
	BLT TAC,JOBJDA(JDAT)	;MOVE TO USER JOB DATA AREA
				;STOP WITH USER CHANNEL 0-1+C(USRHCU)
	POPJ P,

U2S:
	MOVEI TAC,USRPRT(PID)	;DEST.=PROTECTED AREA IN MONITOR
	HRLI TAC,JOBPRT(JDAT)	;SOURCE=FIRST PROTECTED LOC. IN JB  DATA AREA
	SKIPL TAC1,JOBHCU(JDAT)	;MOVE NO. OF USER IO CHAN. IN USE
	CAILE TAC1,17		;MUST BE 17 OR LESS(IO MIGHT CLOBBER
				;IF ADRRESS CHECKING MISSES
	MOVEI TAC1,17		;MOVE ALL 20 CHAN. IF NEG. OR GREATER THAN 17
	BLT TAC,USRJDA(TAC1)	;AND MOVE INTO MONITOR
	POPJ P,

;RESTORE HARDWARE STATE OF CURRENT JOB

CIP8:
	JUMPE PID,CIP8A
	JUMPE ITEM,CIP8A
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /ππPDP-6 ATTEMPTING TO RUN JOB!
/
	POPACS
	SETZB ITEM,JOB(PID)	;MAKE SURE IT IS THE NULL JOB!!!!!!!!
	JRST NULJB
CIP8A:
	PUSHJ P,GETPR
	DATAO APR,TAC
IFN FTSWAP,<
	SETOM STIME(ITEM)	; MARK THAT THIS JOB HAS BEEN RUN
	LDB TAC,PSEGN		; AND MARK HIGH SEGMENT TOO
	MOVE TAC1,JBTSTS(TAC)	; IF IT IS NOT WRITE-PROTECTED
	TLNN TAC1,JWP
	SETOM STIME(TAC)	; IF WRITE-ENABLED, MARK USED.
>
	SKIPE JDAT,JBTDAT(ITEM)	;JOB DATA AREA(IS THERE ONE?)
	JRST CIP8B
	SKIPE NULBAD(PID)	; IS THE NULL JOB SICK?
	JRST NULJB		; YES, GO FIX IT
	MOVEI JDAT,NULDAT(PID)	;NO, MUST BE NULL JOB
CIP8B:
	MOVE TAC,JOBD17(JDAT)
	MOVEM TAC,CLKS17(PID)
	MOVSI 17,JOBDAC(JDAT)	;RESTORE DUMP ACS
	JUMPE PID,CIP8C
	BLT 17,16
	MOVE 17,[P2PID]
	SKIPE APRERR(17)
	JRST CLKERR
	MOVE 17,CLKS17(17)
	JEN @USRPC+P2PID
CIP8C:
	MOVN J,J
	MOVSI TAC,400000
	LSH TAC,(J)
	DATAO PI,TAC
	BLT 17,16
	MOVE 17,[P1PID]
	SKIPE APRERR(17)		;ERROR IN THE EXEC?
	JRST CLKERR			;YES. GO PROCESS.
	MOVE 17,CLKS17(17)
	JEN @USRPC+P1PID	; RETURN TO USER.

PMONTB:
	POINT 6,MONTAB(TAC),5	;POINTER TO NO. DAYS IN MONTH

;THE NULL JOB
;RUNS IN USER MODE WITH PC=1 AND COUNTS IN AC 0

NULJB:
	SOSL CHKYET(PID)
	JRST NULJB1
	MOVEI TAC1,=1000	; ONLY CHECKSUM EVERY THOUSAND TIMES
	MOVEM TAC1,CHKYET(PID)
	PUSHJ P,SYSFIX		;CHECK FOR ERROR AND FIX
	JRST NULJB1		;NO ERRORS
	JFCL			;ERROR, BUT CAN'T FIX, FIX CHECKSUM
	MOVE TAC,MONPTR		;RECOMPUTE CHECKSUM, ERROR FIXED!
	PUSHJ P,CHECK
	MOVEM TAC1,MONSUM
NULJB1:
	SETZM NULBAD(PID)
	JUMPN PID,NULSIX
	MOVSI 17,NULJ10		; SET UP BLT TO ACCUMULATORS
	BLT 17,NULL10		; BLT IN ZINGHEIM'S NULL JOB
	JRST 11,1		;DISMISS IF INTERRUPT IN PROGRESS
NULSIX:
	MOVSI 17,NULJ6
	BLT 17,NULL6
	JRST 11,1

NULJ10:
	0
	ROT 0,-1	; RING AROUND THE ACCUMULATOR
	TLNN 0,200000
	TLC 0,400000
	MOVEI 10,70000
	SOJGE 10,5
	JRST 1
NULL10←←.-NULJ10

NULJ6:
	0
	ROT 0,1		; RING AROUND THE ACCUMULATOR
	TRNN 0,2
	TRC 0,1
	MOVEI 10,34000
	SOJGE 10,5
	XCT SIXRUN	;TRAP IF CORE GETS CLEARED
	JRST 1
NULL6←←.-NULJ6

; CHECKSUM ROUTINE. CALL WITH IOWD IN TAC, RETURNS CHECKSUM IN TAC1.

↑CHECK:	MOVEI TAC1,0
	JCRY0 .+1
	ADD TAC1,(TAC)
	JCRY0 [AOJA TAC1,.+1]
	AOBJN TAC,.-2
	HLRZ TAC,TAC1
	HRRZS TAC1
	ADD TAC1,TAC
	TLZE TAC1,1
	ADDI TAC1,1
	POPJ PDP,

BEGIN	SYSFIX	;VERIFY SYSTEM CHECKSUM AND FIX IT IF WRONG.
; ROUTINE TO RE-READ THE PROTECTED PART OF THE MONITOR FROM LIBRASCOPE
; CALLED BY:
;	PUSHJ P,SYSFIX
;	<NO ERRORS>
;	<ERROR, BUT COULDN'T FIX>
;	<ERRORS FIXED>


↑↑SYSFIX:
	PUSH	P,TAC
	PUSH	P,TAC1
	MOVE	TAC,MONPTR
	PUSHJ	P,CHECK		;CHECKSUM MONITOR
	CAME	TAC1,MONSUM	;IS IT OK?
	JRST	NOTOK
	POP	P,TAC1
	POP	P,TAC
	POPJ	P,		;ALL IS WELL

NOTOK:
	POP	P,TAC1
	POP	P,TAC
↑↑SYSCHK:
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/⊗π⊗π⊗π⊗MONITOR CHECKSUM FAILURE.
/
	JUMPN	PID,SIXFIX	;THE PDP-6 CANT FIX ANYTHING
	CONSO	DSK,1B27	;IS THERE ANY DISK TODAY?
	SKIPN	SYSTHERE	;IS THIS SYSTEM OUT THERE?
	JRST	NOFIX
	JRST	GOFIX		;ATTEMPT TO FIX ERRORS

SIXFIX:
	SETZM	CHKYET+P1PID	;TELL THE PDP-10 TO LOOK SOON
NOFIX:
	POPACS			;IF DISK IS OFF-LINE, NOTHING WE CAN DO.
	JRST	CPOPJ1		;TELL THEM NOTHING FIXED!

GOFIX:
	SETOM	ERRYET		
REPEAT 0,<			;12/1/73
	CONI	APR,TAC		;THE REMEMBER STATE OF SYS REF KLUGE
	PUSH	P,TAC		;THE ONLY WAY OUT GOES THRU FIXXIT
	DATAO	PTR,[0]		;SHUT OFF THE SYS REF KLUGE.
>
	CONSO	IOP,777770	;IF NO BITS ON, IS IDLE.
	JRST	IOPOK
	MOVSI	UUO,1
	CONSO	IOP,IOPJDN!IOPANY;IF JOB DONE, OR ANY ERROR IS UP, IS OK
	SOJG	UUO,.-1		;IF OTHER BITS ON BUT NOT JOB DONE, OR ERROR WAIT FOR IT
IOPOK:
	CONI	IOP,IOPSAV#	;SAVE THE STATUS OF THE IOP
	SKIPN	UUO,MONPTR	;IOWD FOR THE PROTECTED PART OF THE MONITOR
	JRST	FIXXIT		;IF NOT SET UP YET, FORGET IT! (WHEREDAFUCKAREWE)
	
	HRRZ	AC1,UUO
	LSH	AC1,-5		;THIS SHOULD BE THE STARTING SECTOR COUNT
	MOVEI	AC2,37
	AND	AC2,UUO		;GET OFFSET FOR FIRST 40 WORDS
	SUBI	AC2,FIXLEN	;AND THAT LEAVES....
				;READ FIXLEN WORDS AT A TIME AND COMPARE WITH MEMORY

DONXT:
	MOVEI	AC3,40		;WE WILL TRY THIS MENY TIMES
DOAGIN:
	CONO	IOP,0
	CONO	DSK,14000
	DATAO	IOP,[XWD -FIXLEN,FIXBUF]
	PUSH	P,AC1		;SAVE SECTOR #
	CAIL	AC1,2300	;WRAP TO NEXT TRACK?
	ADDI	AC1,1B24-2300	;YES, ADJUST
	ADD	AC1,SYSBAND
	DATAO	DSK,AC1
	POP	P,AC1		;RESTORE SECTOR #
	CONSO	IOP,IOPANY!IOPJDN;WAIT FOR IOP TO FINISH
	JRST	.-1
	CONSO	IOP,IOPANY	;ANY ERRORS?
	CONSZ	DSK,3370
	SOJG	AC3,DOAGIN
	JUMPLE	AC3,FIXXIT
CHKWRD:
	AOJG	AC2,NXTCHK
	MOVE	AC3,FIXBUF+FIXLEN-1(AC2)
	CAME	AC3,(UUO)
	JRST	PRNDIF		;TELL THE WORLD!
STRDON:
	AOBJN	UUO,CHKWRD
	AOSLE	TAC,ERRYET	;DONE WITH CHECK.
	JRST	FIXXTB		;THERE WERE ERRORS.
	PUSHJ	P,DISMES
	ASCIZ	/NO ERRORS FOUND.
/
	JRST	FIXXIT
FIXXTB:
	PUSHJ	P,DISDCP
	PUSHJ	P,DISMES
	ASCIZ	/  ERRORS DETECTED.
/
FIXXIT:
	MOVE	UUO,IOPSAV	;SUCCESS. NOW TRY TO PUT THE WORLD BACK.
	TRNE	UUO,IOPJDN	;IF JOB DONE IS ON, PUT UP DATA MISSED ALSO
	TRO	UUO,IOPMIS	;TO DO PREVIOUS TRANSFER OVER FOR GOOD MEASURE
	CONO	IOP,(UUO)	;SINCE WE FORGET THAT THERE WAS AN ERROR
REPEAT 0,<
	POP	P,TAC		;RESTORE STATE OF SYS WR REF KLUGE
	TRNE	TAC,SWRENB	;WAS KLUGE ENABLED?
	DATAO	PTR,[1]		;YES. IT WAS. TURN IT BACK ON.
>
	POPACS
	JRST	CPOPJ2

PRNDIF:
	PUSHACS
	AOSLE	TAC,ERRYET
	JRST	PRNDF1
	PUSHJ	P,DISMES
	ASCIZ	/LOC     CORE            DISK
/
	MOVEI	TAC,0
PRNDF1:
	CAIL	TAC,10		;ONLY PRINT THE FIRST 8 ERRORS
	JRST	PRNDF2
	MOVEI	TAC,(UUO)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/   /
	MOVE	TAC,(UUO)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/    /
	MOVE	TAC,AC3
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
PRNDF2:
	POPACS
	MOVEM	AC3,(UUO)	;FIX THE SYSTEM!
	JRST	STRDON		;AND CONTINUE LOOKING.

NXTCHK:
	ADDI	AC1,FIXNUM
	MOVNI	AC2,FIXLEN		;THIS MANY WORDS FROM NOW ON!
	JRST	DONXT


BEND SYSFIX
↑SYSFIX←SYSFIX

; THIS IS WHERE THE USER INTERRUPT HANDLER RESIDES . . .

↑INTRUN:
	SETZM INTREQ(PID)
	SETZM AC1
	EXCH AC1,APRIN3(PID)
	JUMPE AC1,INTR6
	MOVEM AC1,USRPC(PID)	; GET RIGHT USRPC (INSTEAD OF JOBTM5)
INTR6:
	PUSH P,LASTPR(PID)	; WE WILL RESET PR FROM THIS
	PUSH P,USRSAV(PID)	; WE MIGHT HAVE INTERRUPTED UUOCON BEFORE IT IS REENTRANT, SO SAVE ALL THIS STUFF . . .
	PUSH P,UUO0(PID)	; THE UUO LOCATION
	PUSH P,@UUOLOC(PID)	; THE UUO ITSELF
IFN FTXCTR,<PUSH P,160
	    PUSH P,@161>	; FOR XCTR SIMULATOR
	MOVE AC1,JOB(PID)
	MOVEM AC1,SJOB(PID)	; NOW SAVE AWAY THE JOB NUMBER WHERE WE CAN FIND IT AGAIN REDILY
	PUSH P,@CLKCH(PID)	; WE MUST ALSO SAVE AWAY CLKINT'S DATA BECAUSE IT IS NOT REENTRANT
	PUSH P,CLKS17(PID)	; IT DEPENDS ON THIS STAYING CONSTANT TOO!
	PUSH P,JOBDAT(PID)	; THESE ARE FOR THE REENTRANT PART OF UUOCON. FIRST THE JOB ADDRESS
	PUSH P,USRREL(PID)	; NEXT THE HIGHEST LOCATION IN THE LOSER'S CORE
	PUSH P,SCHEDF(PID)	; WE MUST SAVE THIS BECAUSE WE MIGHT HAVE INTERRUPTED WSCHED
	PUSH P,APRPC(PID)	; SAVE ANY APR ERRORS THAT MAY BE, BECAUSE THE I-LEVEL PROCESS MAY MAKE ITS OWN
	PUSH P,APRERR(PID)
	PUSH P,APRIN1(PID)
	MOVEI AC1,1(P)		; SAVE USER CHANNEL TABLE TOO
	HRLI AC1,USRPRT(PID)
	MOVEI AC2,(AC1)
	ADDI AC2,USRJDA+17-USRPRT
	BLT AC1,(AC2)
	ADD P,[XWD USRJDA+20-USRPRT,USRJDA+20-USRPRT]
	SETOM INTACT(PID)	; WE ARE NOW AT INTERRUPT LEVEL
	MOVEI J,JOBN-1
INTR2:
	SKIPN AC1,JBTIRQ(J)	; INTERRUPT WAITING HERE?
INTR1:
	SOJG J,.-1		; NO
	JUMPE J,INTXIT		; IF NONE AT ALL, GO AWAY
	PUSHJ P,GETINT		; GET THE BIT CORRESPONDING TO THE INTERRUPT
	JRST INTR1		; ALL MASKED OUT, LOOP BACK FOR NEXT GUY
	MOVE AC2,JBTSTS(J)
	TLNN AC1,INTSWW!INTSHW	; IF THIS IS A SHUFFLE OR A SWAP INTERRUPT, THE JOB IS REALLY THERE!
	TLNN AC2,SWP!SHF
	SKIPN PROG,JBTADR(J)	; IS THIS JOB REALLY HERE?
	JRST INTSWAPIN		; I GUESS NOT. HAVE HIM SWAPPED IN IF HE IS SWAPPED OUT.
	LDB AC3,PSEGN		; DOES HE HAVE AN UPPER?
	JUMPE AC3,INTR11
	MOVE AC2,JBTSTS(AC3)	; SEE IF IT IS IN CORE
	TLNN AC1,INTSWW!INTSHW
	TLNN AC2,SWP!SHF
	SKIPN JBTADR(AC3)
	JRST INTSWS		; SWAP SEGMENT IN
INTR11:
	SKIPE JBTIIP(J)		; IS THIS JOB ALREADY AT I-LEVEL?
	JRST [	SETOM INTREQ(PID)
		JRST INTR1]
INTR9:
	MOVE AC1,JBTIRQ(J)	; PICK UP INTERRUPT BITS AGAIN
	PUSHJ P,GETINT		; GET BIT CORRESPONDING TO INTERRUPT
	JRST INTR1		; ALL MASKED OUT
	JRST INTR7		; GOT IT. GO SERVICE INTERRUPT

; ROUTINE TO GET FIRST SERVICABLE INTERRUPT BIT FROM WORD OF BITS
; ENTER WITH COPY OF JBTIRQ IN AC1
; WILL RETURN SINGLE SERVICABLE BIT IN AC1

GETINT:
	MOVSI AC2,INTWAIT
	TDNE AC2,JBTIEN(J)
	JRST GTINT1		; HERE IF TRYING TO FINISH UUO (VIA UWAIT)
	MOVEI AC3,
INTR8:
	JFFO AC1,.+1		; PICK OFF FIRST BIT. SERVE INTERRUPTS ONLY ONE AT A TIME.
	MOVNS AC2
	MOVSI AC1,(1B0)
	LSH AC1,(AC2)		; AC1 NOW CONTAINS ONLY ONE BIT AND IT IS IN THE POSITION OF THE FIRST BIT IN JBTIRQ(J)
	TDNE AC1,JBTMSK(J)	; SEE IF THIS PROCESSOR IS ENABLED FOR THIS INTERRUPT
	JRST CPOPJ1
	IORB AC1,AC3
	ANDCA AC1,JBTIRQ(J)	; ARE THERE ANY MORE INTERRUPTS PENDING?
	JUMPE AC1,CPOPJ		; NO, GO ON TO NEXT GUY
	JRST INTR8		; YES

GTINT1:
	TDNN AC2,AC1		; SKIP IF INTWAIT ENABLED AND REQUESTED
	POPJ P,			; ENABLED BUT NOT REQUESTED YET
	MOVE AC1,AC2
	JRST CPOPJ1		; DO INTWAIT INT FIRST

; HERE WE CLEAR THE INTERRUPT BIT IN JBTIRQ AND ACTUALLY
; START UP THE INTERRUPT PROCESS

INTR7:
	TDNN AC1,JBTIRQ(J)
	JRST INTR9		; SOMEONE ATE THE INTERRUPT FROM UNDER US
	ANDCAM AC1,JBTIRQ(J)	; WE HAVE SERVICED THIS INTERRUPT SO FORGET IT.
	TDNN AC1,JBTIEN(J)	; IS THIS GUY ENABLED FOR THIS INTERRUPT?
	JRST INTR2		; NO, FORGET IT.
	SKIPN JBTIIP(J)
	JRST INTR14
	IORM AC1,JBTIRQ(J)
	SETOM INTREQ(PID)
	JRST INTR2		; TRY TO GET BACK NEXT TICK
INTR14:
	IORM AC1,JBTIIP(J)	; YES, HE NOW HAS THIS INTERRUPT IN PROGRESS
	HLRZ TAC,PROG
	SKIPN AC3,JOBINT(PROG)	;DOES HE WANT INTS SOMEWHERE ELSE?
	JRST INT14A		;NO
	ADDI AC3,2		;THIS MUST BE LEGAL, TOO
	CAIL AC3,JOBPFI+2
	CAILE AC3,(TAC)
	JRST INTADC		;SHIT ON HIM (MUST BE IN LOWER)
	ADDI AC3,(PROG)
	SKIPA AC2,AC3		;THE BITS GO HERE-2
INT14A:
	MOVEI AC2,JOBCNI+2(PROG);OR HERE
	MOVEM AC1,-2(AC2)	; PUT HIS INTERRUPT BITS WHERE HE CAN FIND THEM
	SKIPN AC2,AC3
	MOVEI AC2,JOBAPR(PROG)
	HRRZ AC2,(AC2)		; PICK UP HIS TRAP ROUTINE ADDRESS
	CAIL AC2,JOBPFI
	CAILE AC2,(TAC)
	CAIA
	JRST INTR10
	LDB AC1,PSEGN		; SEE IF PC IS IN UPPER
	JUMPE AC1,INTADC	; NO UPPER, ERROR
	HLRZ AC1,JBTADR(AC1)
	ADDI AC1,400000
	CAIL AC2,400000
	CAMLE AC2,AC1
	JRST INTADC		; OUT OF UPPER, ADDRESS CHECK

; HERE WE INITIALIZE ALL THE SYSTEM VARIABLES IN PREPARATION FOR RUNNING THE USER INTERRUPT PROCESS

INTR10:
	PUSH P,UUOPC(J)		; SAVE HIS UUO LEVEL PC TOO
	MOVEM PROG,JOBDAT(PID)	; SET UP ADDRESS OF USER AREA FOR UUOCON.
	HLRZM PROG,USRREL(PID)	; UUOCON NEEDS JOBDAT, USRREL, AND JOB, AND THAT'S ALL
	MOVEM J,JOB(PID)	; THIS IS OUR TEMPORARY JOB NUMBER
	CAME J,SJOB(PID)	;MIGHT ALREADY BE THERE
	PUSHJ P,U2S		; PICK UP JOBJDA
	SETZM APRERR(PID)	; CLEAR OUT THIS BECAUSE PREVIOUS JOB MAY HAVE HAD AN ERROR
	SETZM APRPC(PID)
	SETZM APRIN1(PID)
	SETZM SCHEDF(PID)
	SETOM STIME(J)		; MARK CORE IMAGE AS ALTERED NOW.
	LDB AC1,PSEGN		; SEE IF WE MUST MARK UPPER
	JUMPE AC1,INTR5		; NONE THERE.
	MOVE AC2,JBTSTS(AC1)	; DON'T MARK CORE IMAGE DIRTY IF WRITE PROTECTED
	TLNN AC2,JWP
	SETOM STIME(AC1)
INTR5:
	MOVNI AC1,10
	MOVEM AC1,INTQUANT(PID)	; HE GETS 8 TICKS BEFORE DOOM STRIKES
	MOVEI AC1,INTCH7
	MOVEM AC1,INTDISP(PID)	; COUNT DOWN HIS QUANTUM TIME EVERY CLOCK BREAK
	MOVM AC1,JOBQUE(J)	; SEE IF HE IS WAITING FOR AN INTERRUPT
	CAIE AC1,INTWQ
	JRST INTWRJ
	MOVE AC1,JBTIIP(J)	; DO WE WAKE HIM UP?
	TDNN AC1,JBTWKM(J)
	JRST INTWRJ		; NO
	MOVNI AC1,TQ		; YES, WAKE HIM UP WITH HIGH PRIORITY
	MOVEM AC1,JOBQUE(J)
	PUSHJ P,REQUE
INTWRJ:
	PUSHJ P,GETPR		; SET UP PROTECTION-RELOCATION
	DATAO APR,TAC
	MOVEM P,INTSP(PID)	; ALL WE NEED TO SAVE IS THE STACK POINTERS.
				; CLKINT DOESN'T DEPEND ON ACCUMULATORS.
	MOVE AC2,JBTIIP(J)
	TLNN AC2,INTWAIT	; IF WE ARE TRYING TO DEBREAK,
				; MUST GIVE HIM HIS UUO-LEVEL ACCUMULATORS
	JRST INTR4
	ANDCAM AC2,JBTIEN(J)	; HE IS NO LONGER ENABLED FOR INTERRUPT-WAIT
	SKIPN AC2,AC3
	MOVEI AC2,JOBTPC+1(PROG)
	MOVE AC1,USRPC(PID)	; GIVE HIM HIS MOST ACCURATE PC
	MOVEM AC1,-1(AC2)
	MOVSI 17,JOBDAC(PROG)	; GIVE HIM HIS UUO-LEVEL ACCUMULATORS TO SAVE AWAY
	MOVE AC1,JBTUPC(J)	; AND RESTART HIM JUST AFTER THE UWAIT UUO
	MOVEM AC1,UUO0(PID)
	JUMPE PID,INTR15
	BLT 17,17
	JRST 13,@UUO0+P2PID
INTR15:
	BLT 17,17
	JRST 13,@UUO0+P1PID

; HERE, HE IS NOT CONTINUING AFTER A UWAIT, BUT IS BEING RUN REGULARLY

INTR4:
	MOVSI AC1,JOBAC(PROG)
	HRRI AC1,INTACS(PID)	; SAVE HIS UUO-LEVEL ACCUMULATORS, FOR HE WILL DO UUO'S
	BLT AC1,INTACS+17(PID)
	MOVE AC1,USRPC(PID)	;SHOULD BE HERE BY NOW
	TLNE AC1,USRMOD
	JRST INTR4A
	MOVE AC1,UUOPC(J)	; IF IN EXEC, GIVE HIM HIS LAST UUO-LEVEL PC.
	CAIN AC1,USRXT5
	MOVE AC1,UUO0(PID)	;WHICH MAY BE HERE IF WE INTERRUPTED UUOCON EARLY
	TLZN AC1,USRMOD		;FLAG IT AS COMING FROM EXEC
	TDZA AC1,AC1		;OR RET ZERO IF WE DON'T KNOW IT (RECURSION CONFUSION)
	SUBI AC1,1		;ADJUST IT TO POINT AT HIS UUO
INTR4A:
	SKIPE AC2,AC3
	JRST .+3
	MOVEI AC2,JOBTPC+1(PROG)
	MOVEI AC3,JOBAPR(PROG)
	MOVE AC3,(AC3)
	MOVEM AC1,-1(AC2)
	MOVE AC2,JBTPRV(J)
	TLNN AC2,LUPPRV
	TLZ AC3,4000		;DON'T SET IOT USER UNLESS LOCAL
	MOVE 16,J		; NOW SET UP HIS ACCUMULATORS
	MOVE 2,PROG
	MOVE 1,SPWBUT
	SETZM 3
	MOVE 15,JBTIIP(16)
	TLNE 15,INTSHW!INTSWW
	SETOM 3			; IF HE IS ABOUT TO GET SHUFFLED OR SWAPPED, TELL HIM
	MOVEI 4,1
	SKIPE PID
	MOVEI 4,2		; PROCESSOR NUMBER IN 4
	SETZM 5			; 5 TELLS WHETHER THE OTHER PROCESSOR IS ALIVE
	MOVE 6,JBTSTS(16)	; HE WANTS HIS STATUS WORD IN 6 TOO
	LDB 7,[POINT 6,JBTSTS(16),35]
	HLRZ 7,JBTADR(7)
	MOVE 10,INTDTM(16)
	MOVM 14,JOBQUE(16)	;TELL HIM HIS CURRENT Q
	SKIPN P2NUM
	JRST SIXDED
	CAIE 4,1
	JRST SIXTST
	SKIPGE PALIVE+P2PID
	SETOM 5
	JRST 13,(AC3)		;AC3 HAD BETTER THE HELL NOT BE CLOBBERED BY SHIT ABOVE
SIXTST:
	SKIPGE PALIVE+P1PID
SIXDED:
	SETOM 5
	TLZ AC3,37	;AVOID @ LOOPS
	JRST 13,@AC3	;SINCE JRST 2,() DOESN'T WORK ON 6

; ROUTINE TO TYPE OUT ERROR MESSAGE FOR ILL. STARTING ADDRESS

INTADC:
	SETZM JBTIIP(J)		; IF ADDRESS CHECK, GET HIM OUT OF INTERRUPT LEVEL
	PUSHJ P,TTYERP		; NOW GIVE HIM A NASTY MESSAGE
	PUSHJ P,INLMES
ASCIZ /INTERRUPT ADDRESS OUT OF BOUNDS
/
	PUSHJ P,HOLD		;PRINT ↑C CRLF . CRLF.  CALL TTYSTC AND ESTOP
	JRST INTR1

INTXIT:
	JRST 2,@[.+1]
	SETZM INTACT(PID)	; ALL DONE. RESTORE ALL THE STUFF WE SAVED UP FRONT.
	SETZM INTDISP(PID)
	HRLI AC1,-USRJDA-20+USRPRT+1(P)
	HRRI AC1,USRPRT(PID)
	BLT AC1,USRJDA+17(PID)
	SUB P,[XWD USRJDA+20-USRPRT,USRJDA+20-USRPRT]
	POP P,APRIN1(PID)
	POP P,APRERR(PID)
	POP P,APRPC(PID)
	POP P,SCHEDF(PID)
	POP P,USRREL(PID)
	POP P,JOBDAT(PID)
	POP P,CLKS17(PID)
	POP P,@CLKCH(PID)
IFN FTXCTR,<POP P,@161
	    POP P,160>		; FOR XCTR SIMULATION
	POP P,@UUOLOC(PID)
	POP P,UUO0(PID)
	POP P,USRSAV(PID)
	POP P,LASTPR(PID)	; RESTORE PR
	MOVE J,SJOB(PID)
	MOVEM J,JOB(PID)
	DATAO APR,LASTPR(PID)	; RESTORE JOB'S PROTECTION-RELOCATION
	POPJ P,

; ROUTINE TO SWAP A GUY IN SO HE MAY BE INTERRUPTED

INTSWAPIN:

	MOVE AC3,J		; AC3 IS JOB TO TEST FOR BEING IN
	PUSHJ P,INTSWT		; SWAPIN TEST SUBR
	JRST INTR1		; NO CAN DO
	LDB AC3,PSEGN		; GET SEGMENT #
	JUMPE AC3,INTR1
	MOVE TAC,JBTSTS(AC3)
	TLNE TAC,SWP		; IF SWAPPED OUT,
	JRST INTR1		; NORMAL THING WILL HAPPEN
	MOVSI TAC,JHLDIN	; ELSE HOLD IT IN
	IORM TAC,JBTSTS(AC3)	; FOR LOWER
	JRST INTR1

INTSWS:
	PUSHJ P,INTSWT		; AC3 JOB TO BRING IN, J LOWER
	JRST INTR1
	MOVE TAC,JBTSTS(J)
	TLNE TAC,SWP		; IF LOWER IS SWAPPED OUT,
	JRST INTR1		; LET NORMAL THING HAPPEN
	MOVSI TAC,JHLDIN
	IORM TAC,JBTSTS(J)	; ELSE HOLD HIM IN FOR UPPER
	JRST INTR1

INTSWT:
				; SEE IF HE IS MASKED OUT
	TDNN AC1,JBTMSK(J)	; ARE ANY OF THOSE BITS ON?
	POPJ P,			; APPARANTLY NOT, DON'T BOTHER TO CALL HIM IN
	SETOM INTREQ(PID)	; COME BACK NEXT TIME AROUND TOO
	MOVE AC2,JBTSTS(AC3)
	TLNN AC2,SWP		; NEED TO GET HIM IN CORE?
	POPJ P,			; NO, MUST BE SHUFFLE, JUST WAIT
	EXCH AC3,J		; GET US IN J
	MOVSI TAC,INTSNB
	PUSHJ P,SETSIN		; PUT INTO SWAP IN LIST
	EXCH AC3,J
	JRST CPOPJ1

; WE COME BACK TO HERE AFTER AN INTERRUPT - INTCH7,INTDSM,INTOUT,INTERR
; NOW WE HAVE TO FIGURE OUT HOW WE GOT HERE AND WHAT TO DO ABOUT IT

INTCH7:
	SKIPE APRERR(17)	; THIS IS THE PLACE WE COME UPON CH7 BREAKS WHILE AN I-LEVEL PROCESS IS RUNNING. FIRST CHECK FOR APR ERRORS
	JRST INTAPR
	SKIPE SCHEDF(17)	; SEE IF THE BOOB HAS GOT HIMSELF IN IO WAIT
	JRST INTERP		;MAY HAVE BEEN FROM ESTOP, SO CHECK JERR
	AOSL INTQUANT(17)	; OR MAYBE HIS TIME HAS EXPIRED
	JRST INTOUT		; YES
	JUMPE 17,INTOK
	MOVE 17,CLKS17+P2PID
	JEN @CL2CHL
INTOK:
	MOVE 17,CLKS17+P1PID
	JEN @CLKCHL
INTOUT:
	JSR @CLKESV(17)		;SETS UP J, PROG, P, DOES S2U SOMETIMES, ETC.
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
ASCIZ /?
I-LEVEL TIME-OUT/
	MOVE TAC1,@CLKCH(PID)
INTERR:
	PUSHJ P,PCP
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC
	PUSHJ P,ESTOP
INTDSM:
	SETZM ESTINT
	MOVE P,INTSP(PID)	; HERE WE ARE AT THE DISMIS UUO
	MOVE J,JOB(PID)		; PICK UP ALL THE ACCUMULATORS
	MOVE PROG,JOBDAT(PID)
	POP P,UUOPC(J)
	MOVEI AC1,JOBAC(PROG)
	HRLI AC1,INTACS(PID)	; PUT BACK EVERYTHING
	BLT AC1,JOBAC+17(PROG)
	CAME J,SJOB(PID)	;DON'T BOTHER IF ALREADY OK
	PUSHJ P,S2U		; MOVE JOBJDA BACK
	SETZM JBTIIP(J)		; GET HIM OUT OF INTERRUPT LEVEL
	JRST INTR2

; WE GET HERE FROM A DEBREAK UUO - INTDEB, INTERP, INTAPR

INTDEB:
	MOVE P,INTSP(PID)
	MOVE J,JOB(PID)
	MOVE PROG,JOBDAT(PID)
	MOVE AC1,UUOPC(J)	;ADDRESS OF WHERE WE WANT TO BE AT MAIN LEVEL
	MOVEM AC1,USRPC(PID)
	CAMN J,SJOB(PID)
	MOVEM AC1,-USRJDA-20+USRPC(P)	;THIS IS WHAT WILL BE PUT INTO USRPC!!
	HRLI AC1,JOBAC(PROG)
	HRRI AC1,JOBDAC(PROG)
	HRRI AC2,17(AC1)
	BLT AC1,(AC2)		;REAL ACS WILL BE UUO ACS AT TIME OF DEBREAK UUO
	MOVM AC1,JOBQUE(J)
	CAIE AC1,IOWQ
	JRST INTDB1
	MOVNI AC2,RUNQ		;IN CASE WE ARE FAILING TO GO BACK TO A UUO IN IOWQ
	MOVEM AC2,JOBQUE(J)
	PUSHJ P,REQUE		;(THIS USED TO BE INLINE CODE - REG)
INTDB1:
	CAME J,SJOB(PID)	;NOT NECESSARY IF CURRENT JOB
	PUSHJ P,S2U
	POP P,UUOPC(J)
	SETZM JBTIIP(J)
	JRST INTR2

INTERP:
	JSR @CLKESV(17)
	SKIPE ESTINT
	JRST INTDSM		;GOT HERE FROM ESTOP
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
ASCIZ /?
ATTEMPT TO SCHEDULE I-LEVEL PROCESS, UUO/
	MOVE TAC1,UUOPC(J)
	SOJA TAC1,INTERR

INTAPR:
	JSR @CLKESV(17)
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
ASCIZ /?
USER I-LEVEL /
	MOVEI TAC,[ASCIZ /CH3 ERROR/]
	MOVE AC1,APRERR(PID)
	TRNE AC1,ILM
	MOVEI TAC,[ASCIZ /ILL. MEM. REF./]
	TRNE AC1,NXM
	MOVEI TAC,[ASCIZ /NON-EX. MEM./]
	TRNE AC1,POV
	MOVEI TAC,[ASCIZ /PDL OV/]
	PUSHJ P,CONMES
	MOVE TAC1,APRPC(PID)
	JRST INTERR

;INTKILL  ROUTINE TO CLEAR A JOB'S INTERRUPT ENABLINGS AND RESET HIS MASKS

↑INTKILL:
	PUSH P,AC1
	PUSH P,AC2
	SETZM JBTIEN(J)		; CLEAR THE ENABLE BITS FIRST
	SETZM JBTIRQ(J)		; NOW CLEAR ANY PENDING INTERRUPTS
	SETZM JBTIIP(J)
	SETOM JBTWKM(J)		; INITIALIZE THE WAKE UP MASK
	SETOM JBTMSK(J)		; NOW CLEAR THE PROCESSOR MASK
	PUSHJ P,APRDKL		;FLUSH CLOCK REQUESTS
	POP P,AC2
	POP P,AC1
	SETZM UUOPTR(J)		;ALSO DISABLE UUO INTERPRETER
	POPJ P,

;INIJOB		ROUTINE TO INITIALIZE A JOB SLOT
;CALL AT CLOCK LEVEL OR UUO LEVEL
;	PUSHJ	P,INIJOB
;	<JOB CAPACITY EXCEEDED>
;	<CANNOT GET FREE STORAGE - TRY AGAIN LATER>
;	<SUCCESS. J IS SET UP; PROG IS ZERO, JDAT IS ZERO>
;	IF YOU WANT TO MAKE THIS A REAL JOB, YOU MUST CLAIM JOB
;	SLOT BY MARKING JNA OR CMWB IN JBTSTS.

;CLOBBERS TAC
;SETS UP: JBTADR,JBTPRV,JBTBTM,JBTSTS,TTIME,RTIME,JBTUFD,DSKPPN,JBTRNB,JBTPR2,
;	  JBTKCJ,J

INIJB0:
	MOVSI	TAC,JNA!CMWB
INIJB1:
	MOVEI	J,1			;SEEK JOB SLOT
INIJB2:
	TDNN	TAC,JBTSTS(J)
	JRST	CPOPJ1			;THIS ONE IS FREE.
	CAMGE	J,JOBNM1		;HAVE WE REACHED MAXIMUM SLOT NUMBER?
	AOJA	J,INIJB2		;NOT YET.
	MOVEI	J,0			;RETURN A ZERO
	POPJ	P,			;AND LOSE.

↑INIJOB:
	JUMPN	PID,CPOPJ		;GOD FORBID THE PDP-6 SHOULD TRY THIS
	PUSHJ	P,INIJB0		;SEEK A JOB SLOT
	POPJ	P,			;NONE AVAILABLE
	SKIPE	JBTADR(J)		;MAKE SURE THERE'S NO CORE  FOR THIS JOB
	PUSHJ	P,INIJXX		;COMPLAIN
	SKIPE	JBTPDL(J)		;DO WE HAVE A PDL YET?
	JRST	INIJB4
	PUSH	P,AC3
	PUSH	P,AC1
	PUSHJ	P,MAKPDL
	JRST	INIJB5			;HERE IF NO FREE STORAGE.
	MOVSI	TAC,JNA!CMWB		;IS THIS JOB SLOT STILL THERE?
	TDNN	TAC,JBTSTS(J)
	JRST	INIJB3			;YES. THIS SLOT IS STILL THERE.
	PUSHJ	P,INIJB1		;SEEK A NEW SLOT.
	JRST	INIJB6			;NO SLOTS
INIJB3:
	MOVEM	AC1,JBTPDL(J)		;SET JOB PDL.
	POP	P,AC1
	POP	P,AC3
INIJB4:
	SETZB	PROG,TTIME(J)		;NO CORE ANYWHERE.
	SETZB	JDAT,RTIME(J)
	SETZM	DSKOPS(J)		;NO DISK USAGE YET
	SETZM	JBTWAT(J)		;HAVEN'T WAITED FOR SYSTEM YET
	SETZM	JB2WAT(J)		;DITTO
	SETZM	XTIME(J)		;MAKE SURE NO-UPDATE BIT IS CLEAR IN XTIME
	MOVSI	TAC,JERR
	MOVEM	TAC,JBTSTS(J)		;AN NICE WAY TO START: JERR.
	SETZM	JBTADR(J)		;NO CORE.
	SETZM	JBTPRV(J)		;NO ACTIVE PRIVILEGES
	SETZM	JB2PRV(J)		;OR PASSIVE ONES
	SETZM	JBTRNB(J)
	SETZM	JBTPR2(J)		;NO PEEK-POKE
IFN FTDISK,<
	SETZM	JBTUFD(J)		;NO UFD ADDRESS
IFN FTDSKPPN,<
	SETZM	DSKPPN(J)		;NO DSKPPN
>>
	SETZM	JBTKCJ(J)		;NO KILO-CORE JIFFIES
	MOVE	TAC,TIMDAT		;GET <DATE>,,<TIME IN SECS>
	MOVEM	TAC,JBTBTM(J)		;SAVE JOB BEGINING TIME.
	MOVEM	TAC,FTIME(J)		;SET TIME LAST RUN.
	JRST	CPOPJ2			;GIVES THE (DOUBLE) SKIP RETURN.

INIJB6:
	MOVEI	AC1,1(AC1)		;SET UP RIGHT ADDRESS FOR FSGIVE.
	PUSHJ	P,FSGIVE
	SOS	(P)			;NO JOBS RETURN # 0
INIJB5:
	POP	P,AC1			;NO FREE STORAGE
	POP	P,AC3
	JRST	CPOPJ1			;NO F.S.  RETURN # 1

;HERE TO RELEASE AN ILL-GOTTEN JOB.
RELJOB:
	JUMPN	PID,CPOPJ		;GOD FORBID THE PDP-6 SHOULD EVER TRY
	MOVEI	AC1,0
	EXCH	AC1,JBTPDL(J)
	MOVSI	TAC,JNA	
	ANDCAM	TAC,JBTSTS(J)
	JUMPE	AC1,CPOPJ
	MOVEI	AC1,1(AC1)
	JRST	FSGIVE

↑MAKPDL:				;ALSO CALLED BY SYSINI
	MOVEI	AC3,JBTPLN		;GET A PDL FOR THIS JOB.
	PUSHJ	P,FSGET			;FROM FREE STORAGE.
	POPJ	P,			;NO FREE STORAGE.
	HRLI	AC1,1-<JBTPLN+JOBPRT-JOBPFI>	;SET LEFT SIDE TO COUNT.
	SETZM	(AC1)			;ZERO FIRST LOCATION OF PDL
	MOVSI	AC3,(AC1)		;SOURCE OF BLT
	HRRI	AC3,1(AC1)		;DESTINATION
	BLT	AC3,JBTPLN-1(AC1)	;ZERO THE ENTIRE PDL.
	SOJA	AC1,CPOPJ1		;AC1 SET AS PDL POINTER. SKIP RETURN.

INIJXX:
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/JBTADR NOT ZERO AT INIJOB (OR ESTSG2) /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISTAB
	MOVE	TAC,JBTADR(J)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	POPACS
	DEBCHECK
	POPJ	P,

SUBTTL	COMCON	4 AUG 67	 THE COMMAND DECODER

;CALLED FROM CLOCK ROUTINE WHEN 'COMCNT' IS GREATER THAN 0
;AS SET BY TTY SERVICE ROUTINE
;ALL AC'S HAVE BEEN SAVED BY CLOCK CHANNEL
;THE COMMAND DECODER CALLS TTYCOM WHICH SCANS FOR TTY WHICH TYPED
;THE COMMAND AND THEN DISPATCHES(PUSHJ) TO APPROPRIATE
;COMMAND SETUP ROUTINE OF THE SAME NAME WITH AC'S SET AS:
;ITEM = JOB NUMBER
;TAC = BYTE POINTER TO COMMAND STRING(SPACE OR CR AFTER COMMAND NAME)
;DAT = BYTE POINTER TO LAST OUTPUT CHARACTER
;DEVDAT = ADDRESS OF DEVICE DATA BLOCK TYPING COMMAND
;JDAT = ADDRESS OF JOB AREA, = 0 IF NO JOB AREA
;PROG = ADDRESS OF PROGRAM AREA, 0 MEANS NOT IN CORE OR NO CORE
;IOS IS SET TO 0, USED FOR ADDRESS OF SUBSEQUENT CALLS
;DEVDAT IS ALSO PUSHED ON END OF PD LIST SO IT MAY BE DESTROYED.
;UPON RETURN FROM COMMAND SETUP ROUTINE, A CR-LF IS ADDED TO
;MESSAGE AND TTY IS STARTED ON TTY SPECIFIED BY -1(PDP)
;SEVERAL COMMAND FLAGS ARE CHECKED BEFORE DISPATCHING TO
;COMMAND SETUP ROUTINES TO SEE IF COMMAND IS LEGAL AT THIS TIME
;SEVERAL MORE FLAGS ARE CHECKED UPON RETURN FROM COMMAND SETUP
;ROUTINES(UNLESS AN ERROR HAS OCCURRED) FOR STANDARD
;COMMAND RESPONSE
;IF AN ERROR OCCURS, THE JOB NO.(ITEM) SHOULD BE 0 ON RETURN
;SO THAT JOB WILL NOT BE INITIALIZED IF FIRST COMMAND.
;ERRMES ROUTINE WILL SET ITEM TO 0

;SINCE THE COMMAND DECODER IS CALLED FROM THE CLOCK ROUTINE
;COMMAND SETUP ROUTINE MUST RUN TO COMPLETION QUICKLY
;IF A COMMAND FUNCTION CANNOT DO THIS, IT MUST JUST SET
;THE JOB TO RUNABLE STATUS AND RETURN IMMEDIATELY
;OR DELAY THE COMMAND FOR LATER EXECUTION

;COMMAND

;	HERE IF TTYCOM DIDN'T FIND ANYONE
NOCOMS:

IFN FTTTYBUG,<
	AOSG	LINSV1		;SKIP IF WE FAILED TO FIND A COMMAND TWICE
	POPJ	P,		;NO THIS IS OUR FIRST LOST COMMAND
	JRST	CNTCOM
;>;;else;;	POPJ	P,		;THIS IS A NO-OP IF THERE ARE NO COMMANDS

↑COMMAND:
	PUSHJ	P,TTYCOM	;SETUP DEVDAT,DAT,TAC,AND ITEM
				;FOR ANY TTY WHICH HAS TYPED A COMMAND
	JRST	NOCOMS		;THERE WERE NO TTY'S WITH COMMANDS
	SETOM	LINSV1		;MARK THAT WE SAW A COMMAND
COM0:
	PUSH	P,DDB		;SAVE TTY DEVICE DATA BLOCK ADDRESS
	PUSHJ	P,CTEXT		;SCAN COMMAND NAME, RETURN IT IN TAC1
	CAMN	TAC1,['HAL   ']	;LET ↑C THROUGH
	JRST	NOSCRU
	JUMPE	J,NOSCRU
	MOVE	AC1,JBTSTS(J)
	TLNN	AC1,JLOG
	TLNN	AC1,JNA
	JRST	NOSCRU
	MOVSI	TAC1,'K  '	;ANY COMMAND BUT ↑C FORCES LOGOUT IF NOT LOGGED IN
NOSCRU:
	MOVE	AC1,TAC1	;COPY COMMAND.
	MOVNI	AC2,1		;SET MASK ALL ONES
	LSH	AC2,-6		;CLEAR OUT ONE MORE CHAR.
	LSH	AC1,6		;SHIFT 1 COMMAND CHAR OFF
	JUMPN	AC1,.-2		;IF NOT END OF COMMAND, GO AROUND
	MOVEI	DSER,0		;CLEAR FLAG REGISTER
	MOVSI	AC1,-DISPL	;SEARCH COMMAND TABLE FOR MATCH
COMLP:
	CAMN	TAC1,COMTAB(AC1);EXACT MATCH?
	JRST	COMFND		;YES, THIS IS IT. (AC1 SET WITH INDEX)
	MOVE	UUO,COMTAB(AC1)	;GET FULL ENTRY NAME FROM COMMAND TABLE
	TDZ	UUO,AC2		;MASK OFF UNSPECIFIED CHARACTERS
	CAME	TAC1,UUO	;MATCH UNDER MASK?
	JRST	COMNEQ		;NO. NOT EVEN GOOD MATCH
	JUMPE	DSER,.+2
	TLOA	DSER,400000	;SET SIGN BIT TO DENOTE AMBIGUOUS MATCH
	MOVEI	DSER,1(AC1)	;COPY INDEX TO DSER - FIRST MATCH UNDER MASK
COMNEQ:
	AOBJN	AC1,COMLP	;NO, KEEP LOOKING
	JUMPLE	DSER,.+2	;DID ONE AND ONLY ONE COMMAND MATCH?
	MOVEI	AC1,-1(DSER)	;YES. GET COMMAND INDEX THAT WE SAVED.
				;FALL INTO COMFND.
				;IF NOTHING MATCHES, WE HAVE ILLEGAL COMMAND

COMFND:
 MOVE	UUO,COMTAB(AC1)	;SAVE FULL COMMAND NAME
	MOVE	TAC1,DISP(AC1)	;GET DISPATCH TABLE ENTRY.
	PUSH	P,TAC1		;SAVE RH(DISPATCH ADR.+BITS)
	MOVE	AC1,JBTSTS(J)	;JOB STATUS WORD FOR THIS JOB
IFN FTLOGIN,<
	TLNN	AC1,JLOG	;IS JOB LOGGED IN?
	TLNE	TAC1,NOLOGIN	;NO, CAN COMMAND PROCEED WITH NO LOGIN?
	JRST	CHKNO		;YES
	TLNE	TAC1,DOLOG	;THE REG KLUGE?
	JRST	CHKNOX		;YES.  ALLOW THIS USER TO LOGIN NOW.
	JSP	TAC,COMER	;NO, TYPE "LOGIN PLEASE"
	ASCIZ	/LOGIN PLEASE
/
CHKNOX:
	MOVE	TAC1,DISP-1	;INDEX FOR THE REG KLUDGE
	MOVEM	TAC1,(P)	;STORE THE BITS ON THE STACK AGAIN
>
CHKNO:

	JUMPN	J,CHKRUN 	;JUMP IF JOB NUMBER ALREADY ASSIGNED.
	TLNE	TAC1,NOJOBN	;NO, DOES THIS COMMAND NEED A JOB NUMBER?
	JRST	COMGO		;NO
	PUSHJ	P,INIJOB	;INITIALIZE A JOB
	JRST	JBCPEX		;NO JOBS AVAILABLE.
	JRST	[MOVEI	TAC1,DLYCM1	;WE NEED TO WAIT FOR FREE STORAGE.
		JRST	COMDIS]	;SO WE DELAY THIS COMMAND FOR A TICK.
	MOVE	TAC1,(P)	;RESTORE TAC1 - CLOBBERED BY INIJOB
	SETZM	DEVLOG(DDB)	;CLEAR LOGICAL NAME OF TTY
	JRST	CHKCO1

CHKRUN:

	TLNE AC1,RUN		;DEC 3.16
	TLNN TAC1,NORUN		;DEC 3.16
	JRST CHKACT		;DEC 3.16
	MOVM AC3,JOBQUE(J)
	CAIE AC3,STOPQ
	JRST CNCMES
	MOVSI AC3,RUN
	ANDCAM AC3,JBTSTS(J)	;NOTE!!!! THIS IS A FIX TO A BUG!!!!!!
	JRST CHKACT

CNCMES:
	JSP TAC,COMER		;DEC 3.16
	ASCIZ /PLEASE TYPE ↑C FIRST
/

JBCPEX:
	JSP TAC,COMER
	ASCIZ /JOB CAPACITY EXCEEDED
/

CHKACT:

IFN JDMPRG,<
	MOVE JDAT,JBTDAT(ITEM)	;ADDRESS OF JOB DATA AREA
>
	MOVE PROG,JBTADR(ITEM)	;XWD PROTECTION,RELOCATION
IFN FTSWAP,<
	TLNE AC1,SWP		;ARE WE SWAPPED OUT?
	SETZB PROG,JDAT		;YES. PRETEND NO CORE.
	TLNE AC1,SWP		;IS JOB ON DISK OR ON ITS WAY?
	TLNN TAC1,INCORE	;MUST JOB BE IN CORE?
	JRST CHKCO2		;NO
	TLNN TAC1,SHRINK	;SHALL WE SHRINK HIM BEFORE BRINGING HIM IN
	JRST CHKCO3		;NO.
	PUSHJ P,INTKILL		;REG 11-11-72 KILL INTERRUPTS BEFORE SHRINK
	PUSHJ P,CORX		;SHRINK BEFORE SWAP IN. RPH 8-15-71
CHKCO3:
	MOVEI TAC1,DLYCOR	;YES, DELAY COMMAND.
	JRST COMDIS
>
CHKCO2:
	TLNE TAC1,NOACT		;CAN COMMAND BE PERFORMED WITH ACTIVE DEVICES?
	PUSHJ PDP,RUNCHK	;NO, RETURN IF JOB STOPPED AND NO ACTIVE DEVICES
CHKCO1:
	TLNE TAC1,NOCORE	;DOES THIS COMMAND NEED CORE?
	JRST COMGO		;NO. GO DISPATCH
	JUMPN PROG,COMGO	;NO, IS CORE IN MEMORY?
	JSP TAC,COMER		;NO, PRINT "NO CORE ASSIGNED"
	ASCIZ /NO CORE ASSIGNED
/
COMER:
	MOVSI TAC1,NOINCK
	MOVEM TAC1,(PDP)
	MOVEI TAC1,CERR		;CALL ERROR MESSAGE ROUTINE
COMGO:
	MOVSI IOS,NOSKPB
	ANDCAM IOS,(PDP)	;NO. CLEAR REQUE FLAG ON STAT	;DEC 3.16
	TLZ AC1,CMWB		;WAS JOB IN CMW?	;DEC 3.16
	MOVEM AC1,JBTSTS(ITEM)	;DEC 3.16
COMDIS:
	TLNE TAC1,NOPRIV	;NEED TO CLEAR TEMPORARY PRIVILEGES?
	PUSHJ P,CLRTPV		;YES, DO IT
	MOVEI IOS,0		;CLEAR IOS FOR SETTING DISPATCH ADDRESSES
	AOS NCOMS
	PUSHJ PDP,(TAC1)	;DISPATCH TO COMMAND SETUP ROUTINE.

;RETURN FROM COMMAND SETUP ROUTINE

COMRET:
	POP	P,AC2		;RESTORE COMMAND FLAGS
	POP	P,DDB		;RESTORE TTY DDB ADDRESS.
	TLNN AC2,NOSKPB
	PUSHJ P,COMR2A		;SKIP TO BREAK CHAR UNLESS REQUESTED NOT TO
	PUSHJ	P,COMR2B	;DECREMENT COMCNT
	TLNN	AC2,NOACT		;DID WE STOP SPACEWAR?
	JRST	COMRE1			;NO.
	MOVSI	AC1,SPWSUS!SPWST1!SPWST2	;PREPARE TO RESTART IT
	PSYNC	SPWCSC			;GET CONTROL OF SPW TABLES
	ANDCAM	AC1,JBTST2(J)		;ZERO OUT THE SUSPENSION BIT
	XSYNC	SPWCSC			;RELEASE CONTROL
COMRE1:
	JUMPN	J,COMRT1		;DID AN ERROR OCCUR?
	TLNN	AC2,NOJOBN		;I.E., J=0 AND NOJOBN=0?
ERRFLG←1;;here to override TAG;;
	MOVSI	AC2,NOINCK!ERRFLG	;YES, PRINT ERROR MESSAGE ONLY.
COMRT1:
	MOVE	AC1,JBTSTS(J)		;JOB STATUS WORD
	TLNN	AC2,NOINCK		;SUPPRESS JOB INIT. CHECK?
	TLOE	AC1,JNA			;NO, IS JOB INIT BIT ALREADY SET?
	JRST	PCRLF			;YES.
	MOVSI	AC1,JNA			;NO, SET IT THIS COMMAND
	IORM	AC1,JBTSTS(J)
	PUSHJ	P,TTYATI		;ATTACH TTY TO JOB
	JFCL				;IGNORE IF CAN NOT(SHOULD NEVER HAPPEN)
	PUSHJ	P,PRJOB			;TYPE JOB # & CONFIG LINE
IFE FTLOGIN,<
	PUSHJ	P,PRSPC			;DEC 3.16
	PUSHJ	P,DAYTIM		;DEC 3.16	;JS
>
					;FALL INTO PCRLF

PCRLF:
	TLNE AC2,ERRFLG		;DID AN ERROR OCCUR?
	PUSHJ PDP,PRQM		;YES. APPEND ?
	TLNN AC2,NOCRLF		;SUPRESS CRLF?
	PUSHJ PDP,CRLF		;NO
	TLNN AC2,NOPER		;SUPRESS PRINTING PERIOD?
	PUSHJ PDP,PRPER		;NO
	JUMPE ITEM,PCRLF1	;JOB DOES NOT RUN IF ERROR 
				;OR NO JOB NUMBER ASSIGNED.
	TLNE AC2,TTYRNU		;JOB TO RUN WHEN TTY FINISHED TYPING?
				;COMMAND RESPONSE (TTY TO USER MODE)?
	PUSHJ PDP,TTYUSR	;YES, CALL SCANNER ROUTINE
	TLNE AC2,TTYRNC		;NO, JOB TO RUN AND REMAIN IN MONITOR MODE?
	PUSHJ PDP,SETRUN	;YES, CALL SCANNER ROUTINE	;MCF(JS)
PCRLF1:
	TLNN AC2,NOMESS		;IS THERE A MESSAGE?
	JRST TTYSTR		;YES, START TTY TYPING IT OUT
	POPJ PDP,

COMR2A:
	LDB	TEM,TITAKR(DDB)	;GET BREAK CHARACTER
	ANDI	TEM,177
	MOVEI	DAT,TTIBUF(DDB)	;IN CASE SOMEONE CLOBBERED IT.
SKPBRK:
	PUSH PDP,TAC
SKPBR2:
	PUSHJ PDP,SPCHEK
	JRST SKPBR1
	TLNE TAC,BREAKB		; IS THIS CHAR THE BREAK?
	JRST TPOPJ		; YES, RESTORE TAC AND RETURN
SKPBR1:
	PUSHJ PDP,GETLCCHR	; GET A CHARACTER FROM COMMAND LINE
	JUMPN TEM,SKPBR2	; LOOK FURTHER FOR BREAK CHAR
	JRST TPOPJ		; UNLESS NO MORE CHARS

;CALLED FROM COMMAND RETURN AND FROM DETACH (CDET,FORK,CFORK) COMMAND
COMRT2:
	PUSHJ	PDP,COMR2A	;SKIP TO BREAK CHAR
COMR2B:
	MOVSI	AC1,COMBIT
	LDB	TAC,PUNIT
	CONO	PI,SCNOFF
	SKIPGE	TTYTAB(TAC)
	SOS	COMCNT
	ANDCAM	AC1,TTYTAB(TAC)
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM
>
	CONO	PI,SCNON
	POPJ	P,

;TABLE OF CONSOLE COMMANDS


;BITS CHECKED BEFORE DISPATCHING TO COMMAND SETUP ROUTINE

NOCORE←←400000	;NO CORE NEEDED FOR COMMAND
NOJOBN←←200000	;NO JOB NUMBER NEEDED FOR COMMAND
NOLOGIN←←100000	;JOB DOES NOT NEED TO BE ALREADY LOGGED IN.
NOACT←←40000	;COMMAND MUST BE DELAYED IF JOB HAS ACTIVE DEVICES.
INCORE←←20000	;COMMAND MUST BE DELAYED IF JOB HAS CORE ASSIGNED
		;AND IS NOT IN CORE.
NORUN←←10000		;↑C MUST BE TYPED BEFORE COMMAND CAN BE
		;EXECUTED.
SHRINK←←4000	;IF JOB ON DISK, SHRINK BEFORE BRINGING HIM IN!!!
		;THIS SHOULD SAVE A LOT OF TIME
NOPRIV←←2000	;CLEAR TEMPORARY PRIVILEGE BITS BEFORE DISPATCHING


;BITS CHECKED AFTER RETURN FROM COMMAND SETUP ROUTINE
NOSKPB←←4000	;DON'T CALL SKPBRK (SEE US RECYCLE THOSE BITS!)
;NODATE←←1000	;DONT PRINT DATE AFTER JOB INITIALIZATION
NOINCK←←400	;NO CHECK FOR JOB INITIALIZATION (JNA=0)
NOCRLF←←200	;NO PRINTING OF CRLF
NOPER←←100	;NO PRINTING OF PERIOD
TTYRNU←←40	;SET TTY TO USER MODE AND START JOB
		;WHEN COMMAND RESPONSE STOPS TYPING
TTYRNC←←20	;KEEP TTY IN COMMAND MODE AND START JOB
		;WHEN COMMAND RESPONSE STOPS TYPING
NOMESS←←10	;NO COMMAND RESPONSE EVER, DO NOT CALL TTYSTR
DOLOG←←4	;ALLOW LOGIN FIRST


ERRFLG←←1	;COMMAND ERROR

RPGBIT←←NOCORE!NOPER!NOCRLF!INCORE!NORUN!NOACT!TTYRNU!SHRINK!DOLOG!NOPRIV
			;BITS FOR THE RPG COMMANDS

DEFINE NAMES
<
	C KJOB,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C LOGOUT,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C K,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C KATTACH,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C KLOG,KJOB,NOCORE!NOJOBN!NOINCK!NOLOGIN!NOACT!NORUN!NOCRLF!NOPER!NOMESS!INCORE!SHRINK
	C START,START,NOPER!TTYRNU!INCORE!NOACT!NORUN
	C S,START,NOPER!TTYRNU!INCORE!NOACT!NORUN	;JS
	C HALT,STOP,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C KILL,KILCOM,NOCORE
	C FLUSH,FLUSH,NOINCK!NOLOGIN!NOJOBN!NOCORE
	C <>,CBLANK,NOCORE!NOJOBN!NOLOGIN!NOINCK!NOCRLF
	C R,RCOM,NOCORE!NOPER!TTYRNU!NOCRLF!INCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
	C RUN,RUNCOM,NOCORE!NOPER!TTYRNU!NOCRLF!INCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
IFN FTLOGIN,<
	C CORE,CORE,NOCORE!NOACT!NOLOGIN!NORUN!NOINCK!NOJOBN
	C C,CORE,NOCORE!NOACT!NOLOGIN!NORUN!NOJOBN!NOINCK
>
IFE FTLOGIN,<	;IN NON-LOGIN SYSTEM, CORE COMMAND MAY MAKE A JOB.
	C CORE,CORE,NOCORE!NOACT!NOLOGIN!NORUN
	C C,CORE,NOCORE!NOACT!NOLOGIN!NORUN
>
	C SETUWP,SETWPS,NOACT!NOCORE!NOPRIV		;RPH SET SEGMENT WRITE PROT
	C CLRUWP,CLRWPS,NOACT!NOCORE!NOPRIV		;RPH CLEAR SEGMENT WRITE PROT
	C ENABLE,ENABLE,NOCORE
	C DISABLE,DISABLE,NOCORE
	C GET,GET,NOCRLF!NOPER!TTYRNU!INCORE!NOCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
	C G,GET,NOCRLF!NOPER!TTYRNU!INCORE!NOCORE!NOACT!NORUN!SHRINK!DOLOG!NOPRIV
	C SAVE,SAVE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NOPRIV
	C SSAVE,SSAVE,NOCRLF!NOPER!TTYRNU!INCORE!NOACT!NORUN!NOPRIV
	C CONTINUE,CONT,NOPER!TTYRNU!INCORE!NORUN
	C DE,DCOM,INCORE!NOPRIV
	C E,ECOM,NOCRLF!INCORE
	C PJOB,PJOBDV,NOCORE!NOLOGIN!NOJOBN!NOINCK
	C PTTY,PTTY,NOCORE!NOJOBN!NOINCK!NOLOGIN
IFN FTDSKPPN,<
	C ALIAS,SDSKPPN,NOCORE!NOPRIV			;RPH
>
	C SLEVEL,SLEVEL,NOCORE
	C ASSIGN,ASSIGN,NOCORE!DOLOG!NOPRIV
	C A,ASSIGN,NOCORE!DOLOG!NOPRIV			;JS
	C DEASSI,DEASSIGN,NOCORE
	C D,DEASSIGN,NOCORE
	C DDT,DDTGO,NOPER!TTYRNU!INCORE!NORUN!NOPRIV
	C TTY,TTYSUB,NOLOGIN!NOCORE!NOJOBN!NOINCK	;RPH
	C FINISH,FINIS,NOPER!NOACT!INCORE!NORUN!NOPRIV
	C F,FINIS,NOPER!NOACT!INCORE!NORUN!NOPRIV
	C REENTER,REENTER,TTYRNU!NOPER!INCORE!NORUN
	C CSTART,STARTC,TTYRNC!INCORE!NORUN
	C CCONTINUE,CONTC,TTYRNC!INCORE!NORUN
	C DETACH,DETACH,NOCORE!NOINCK!NOPER!NOCRLF!NOMESS
	C CDETACH,CDETACH,NOCORE!NOINCK
	C ATTACH,ATTACH,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C DAYTIME,DAYTIM,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C EDDT,CEDDT,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C TIME,RUNTIM,NOCORE!NOLOGIN!NOINCK!NOJOBN
	C RESOURCES,FREDEV,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C FILES,FILCOM,NOCORE!NOJOBN!NOLOGIN!NOINCK
	C REASSI,REASS,NOCORE!NOACT!INCORE!NORUN
	C TALK,TALK,NOCORE!NOJOBN!NOLOGIN!NOMESS!NOINCK!NOCRLF!NOPER
	C HELLO,HELLO,NOCORE!NOLOGIN!NOJOBN!NOINCK	;JS
IFN FTLOGIN,<
	C LOGIN,CLOGIN,NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN
	C L,CLOGIN,NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN
	C PPPN,PPPN,NOLOGIN!NOCORE!NOJOBN!NOINCK
	C FORK,FORK,NOINCK!NOMESS!NOPER!NOCRLF!NOCORE!NOPRIV
	C CFORK,CFORK,NOINCK!NOMESS!NOPER!NOCRLF!NOCORE!NOPRIV
>

; MORE COMMANDS . . .
IFN FTDISK,<
	C HELP,HELP,RPGBIT!NOLOGIN
	C WHERE,WHECOM,RPGBIT!NOLOGIN
	C SYSTAT,WHOCOM,RPGBIT!NOLOGIN
	C WHO,WHOCOM,RPGBIT!NOLOGIN
	C W,WHOCOM,RPGBIT!NOLOGIN
	C FINGER,FINGER,RPGBIT!NOLOGIN
	C FIND,FNDCOM,RPGBIT!NOLOGIN
	C FIXIML,FIXIML,RPGBIT!NOLOGIN

	C LISP,LSPCOM,RPGBIT
	C RSL,RSLCOM,RPGBIT

	C COMPILE,RPGCOM,RPGBIT			;RPG COMMANDS
	C DEBUG,RPGCOM,RPGBIT
	C PREPARE,RPGCOM,RPGBIT
	C LOAD,RPGCOM,RPGBIT
	C EXECUTE,RPGCOM,RPGBIT
	C CREF,RPGCOM,RPGBIT
	C TV,RPGCOM,RPGBIT
	C CTV,RPGCOM,RPGBIT
	C EDIT,RPGCOM,RPGBIT
	C ED,RPGCOM,RPGBIT
	C CREATE,RPGCOM,RPGBIT
	C TECO,RPGCOM,RPGBIT
	C MAKE,RPGCOM,RPGBIT
	C TRY,RPGCOM,RPGBIT
	C PUB,RPGCOM,RPGBIT

	C READ,ETCOM,RPGBIT
	C ETV,ETCOM,RPGBIT
	C CETV,ETCOM,RPGBIT

	C LIST,CPYCOM,RPGBIT			;COPY COMMANDS
	C DIRECTORY,CPYCOM,RPGBIT
	C DI,CPYCOM,RPGBIT
	C DELETE,CPYCOM,RPGBIT
	C RENAME,CPYCOM,RPGBIT
	C TYPE,CPYCOM,RPGBIT
	C COPY,CPYCOM,RPGBIT
	C PRINT,CPYCOM,RPGBIT
	C TRANSFER,CPYCOM,RPGBIT
	C XGPLIST,CPYCOM,RPGBIT

	C SEND,MAICOM,RPGBIT			;MAIL AND REMINDERS
	C MAIL,MAICOM,RPGBIT
	C GRIPE,MAICOM,RPGBIT
	C REMIND,MAICOM,RPGBIT
	C CANCEL,OBLCOM,RPGBIT			;DELETE REMINDERS
	C LATER,MAICOM,RPGBIT
	C RCV,RCVCOM,RPGBIT!NOLOGIN
	C PLAN,MAICOM,RPGBIT

	C SPOOL,SPLCOM,RPGBIT			;SPOOLER
	C QSPOOL,SPLCOM,RPGBIT!NOLOGIN
	C UNSPOOL,SPLCOM,RPGBIT
	C XSPOOL,SPLCOM,RPGBIT

	C ZERO,ZERCOM,RPGBIT
	C XEROX,XERCOM,RPGBIT
	C DO,DOCOM,RPGBIT
	C TEST,TSTCOM,RPGBIT

	C REWIND,DSCCOM,RPGBIT		;DUMP COMMAND RUN DART NOW.
	C DUMP,DSCCOM,RPGBIT		;IDUMP COMMAND IS FLUSHED.
	C RESTOR,DSCCOM,RPGBIT
	C ADVANC,DSCCOM,RPGBIT
	C BACKSP,DSCCOM,RPGBIT
	C TLIST,DSCCOM,RPGBIT
	C EOT,DSCCOM,RPGBIT
	C LOCATE,DSCCOM,RPGBIT

	C TN,TNCOM,RPGBIT
	C TELNET,TNCOM,RPGBIT
	C FTP,FTPCOM,RPGBIT

	C DIAL,DILCOM,RPGBIT

	C NS,NSCOM,RPGBIT		;NEWS SERVICE--USES TEMPORARY PRIVILEGES
	C HOT,HOTCOM,RPGBIT		;NEWS SERVICE HOT LINE WITH TEMP PRIV

	C UDPUFD,UDPCOM,RPGBIT		;UDP UFD MUNGER LOTSA PRIVS
>>

BEGIN COMTBL			;GENERATE TABLE OF SIXBIT COMMAND NAMES

DEFINE C(A,B,C),<
	<SIXBIT /A/>
>

↑↑COMTAB:
	XLIST
	NAMES
	LIST
↑↑DISPL←.-COMTAB	;LENGTH OF TABLE

;GENERATE THE DISPATCH TABLE AND SPECIAL BITS

DEFINE C!(A,B,D)<
       <XWD D,B>
>
;SPECIAL HACK TO FORCE LOGIN FROM "ANY" COMMAND.
	XWD NOCORE!NOLOGIN!NOPER!TTYRNU!INCORE!NOACT!NORUN,CXLOGI
↑DISP:
	XLIST
	NAMES
	LIST

	XWD NOCORE+NOJOBN+NOLOGIN+NOINCK,NOCOM	;CATCH ANYTHING THAT'S NOT A COMMAND

BEND COMTBL

;CALLED FROM COMMAND DECODER WHICH IS CALLED FROM CLOCK ROUTINE
;WITH FOLLOWING AC'S SET:
;TAC= BYTE POINTER TO COMMAND STRING(SPACE OR CR AFTER COMMAND NAME)
;ITEM = JOB NUMBER
;DAT = BYTE POINTER TO LAST OUTPUT CHARACTER
;DEVDAT= ADDRESS OF DEVICE DATA BLOCK INITIATING COMMAND
;JDAT = ADDRESS OF JOB DATA AREA, = 0 IF NO JOB AREA
;PROG=XWD PROTECTION,RELOCATION; 0 IF NO CORE
;IOS=0

;UPON RETURN FROM COMMAND SETUP ROUTINE, A CR-LF IS ADDED IF
;NEEDED AND TTY IS STARTED

;SINCE THE COMMAND DECODER IS CALLED FROM THE CLOCK ROUTINE
;COMMAND SETUP ROUTINES MUST RUN TO COMPLETION QUICKLY
;IF A COMMAND FUNCTION CANNOT DO THIS, IT MUST JUST SET
;THE JOB TO A RUNABLE STATUS AND RETURN IMMEDIATELY



CEDDT:
	PUSHJ P,STLNAC		;SET UP LINE(TAC1)
	TLNN TAC1,CTYLIN	;IS HE ON THE CTY?
	JRST COMERR		;NO, FLUSH HIM
	JRST DDTCAL		;YES, GET EXEC DDT

COR0:
		;CALLED FROM CORE COMMAND TO ZERO CORE
	JUMPE PROG,CPOPJ	;RETURN IF JOB DOES NOT HAVE CORE
	MOVSI TAC,TTYRNU!NOPER!NOCRLF
	IORM TAC,-1(P)		;TELL COMRET TO PUT TTY IN USER MODE
	JSP TAC1,MONJOB		;SET TO RUN MONITOR JOB(PC IN EXEC MODE)
				;RETURN HERE AT UUO LEVEL(NO ACS SET UP)
	MOVEI TAC1,HOLD		;PUT ERROR STOP ON END OF PDL
	JSP TAC,MONSTR		;START MONITOR JOB BY SETTING UP ACS AND
JOB1:
	PUSHJ	P,RESET		;RELEASE ALL IO DEVICES ASSIGNED TO THIS JOB
	PUSHJ	P,TTYFNU	;FIND TTY FOR THIS JOB(SETUP ITEM WITH JOB NO.)
	PUSHJ	P,NOCORQ	;PUT JOB IN NO CORE Q
	MOVEI	TAC,0		;FLUSH ALL CORE
	SOS	(P)		;CORE1 WILL SKIP RETURN
IFN FTSWAP,<
	SETZM	JBTSWP(J)	;CLEAR IMGIN AND IMGOUT
	SETOM	STIME(J)	;MARK CORE IMAGE ALTERED
	LDB	DAT,PSEGN
	MOVE	TEM,JBTSTS(DAT)
	TLNN	TEM,JWP
	SETOM	STIME(DAT)
>
	JRST	CORE1

;PTTY PJOB KJOB
; "PTTY" GIVES THE LOGICAL NAME OF THE TTY THE LOSER IS ON.
; "PTTY N" GIVES THE LOGICAL NAME OF THE TTY FOR JOB N.

PTTY:
	PUSHJ P,DECIN	;JOB NUMBER MAYBE?
	JRST PTTY1
	JRST COMERA
	JUMPE TAC1,NOTLOG
	CAIL TAC1,JOBN		;LEGAL?
	JRST NOTLOG		;NONE SUCH JOB
	MOVE TAC,JBTSTS(TAC1)
	TLNN TAC,JNA		;DOES HE HAVE A JOB NUMBER?
	JRST NOTLOG		;NO, LOSE
	MOVE AC1,JBTLIN(TAC1)	;LINE NUMBER
	CAMN AC1,[-1]		;DETACHED?
	JRST PTTYDT		;YES
	TLNN AC1,CTYLIN		;CTY?
	JRST NOTCTY
	JSP TAC,CONMES
	ASCIZ/CTY
/
NOTCTY:
	PUSH P,AC1
	PUSHJ P,INLMES
	ASCIZ/TTY/
	POP P,TAC
	HRRZS TAC
	PUSHJ P,OCTPNT
	JRST PTTY2

PTTY1:
	MOVE TAC1,DEVNAM(DDB)
	PUSHJ P,PRNAME
	LDB AC1,PUNIT
	HLL AC1,LINTAB(AC1)
PTTY2:
	TLNN AC1,DDDLIN
	JRST CRLF
	PUSHJ P,INLMES
	ASCIZ /, DD/
	MOVE AC1,LETAB-DPYL0(AC1);NONZERO IT SAYS HERE
	HLRZ TAC,PRGNUM(AC1)
	PUSHJ P,OCTPNT
	JRST CRLF

PTTYDT:

	JSP TAC,CONMES
	ASCIZ/DETACHED.
/

; "PJOB" PRINT JOB NUMBER OF JOB TTY IS ATTACHED TO
; "PJOB TTYN" PRINT JOB NUMBER OF JOB USING TTYN.

PJOBDV:
	PUSHJ P,CTEXT1		;ARG
	JUMPN TAC1,PJOBX
	JUMPE ITEM,LOGPLS
↑PJOB:	MOVE TAC,ITEM		;JOB NO.
↑DECLF:	PUSHJ PDP,RADX10	;PRINT TAC AS DEC. THEN CRLF
	JRST CRLF

PJOBX:
	MOVE TAC,TAC1
	PUSH P,TAC
	PUSHJ P,DEVPHY
	SKIPA DDB,-3(P)			;(SO I DON'T CARE IF DEVPHY MUNGS IT)
	JRST FNDDEV
	PUSHJ P,DADD00			;NOT DEVICE, PERHAPS DD CHAN
	JRST PJDVLZ			;NOPE, NO SUCH FROBULE
	LDB TAC1,[DDUSR(TAC)];;replace;;LDB TAC1,[DDUSR+<(TAC)>]	;YES, GET USE CODE
	JUMPE TAC1,DEVFRE		;0, NOT IN USE
	CAIGE TAC1,100			;IF LESS THAN 100,
	JRST FNDDV1			;  IT'S ASSIGNED TO THAT JOB
	CAIL TAC1,200			;ABOVE 200,
	JRST DEVFR2			;  DETACHED FROM SYS (OR AVLCHN)
	SUBI TAC1,100-DDL0		;ELSE MAKE IT A TTY LINE NUMBER
	PUSH P,TAC1
	MOVEI AC1,(TAC1)
	PUSHJ P,NOTCTY			;THIS WILL TYPE THE TTY NUMBER
	POP P,TAC1
FNDDV0:
	SKIPN DDB,TTYTAB(TAC1)	;DOES IT HAVE A DDB
	JRST DEVFRE		;NO ONE HAS IT
FNDDEV:
	MOVE TAC1,DEVMOD(DDB)		;SPECIAL HAIR FOR UDP AS USUAL
	TLNE TAC1,DVUDP
	JRST PJBUDP
	LDB TAC1,PJOBN
FNDDV1:
	JUMPE TAC1,DEVFR1
	PUSH P,TAC		;SORRY ABOUT THIS
	PUSHJ P,PJPRNM
	POP P,TAC
	PUSHJ P,INLMES
	ASCIZ/ ASSIGNED TO JOB /
	POP P,TAC
	JRST DECLF

PJBUDP:
	LDB TAC,PUNIT			;UDP: GET INDEX TO TABLES
	SKIPL TAC1,UDPOWN-1(TAC)
	JRST FNDDV1			;PRIVATELY OWNED, DO THE USUAL THING
	SKIPN UDPCNT-1(TAC)
	JRST DEVFRE			;NO DDBS, NOT IN USE
	PUSH P,TAC
	PUSHJ P,PJPRNM
	POP P,TAC
	SKIPE TAC,SATADR(TAC)
	PUSHJ P,SATTAC			;PRINT SATID IF ANY
	POP P,(P)
	JSP TAC,CONMES
	ASCIZ / PUBLIC
/

PJDVLZ:
	POP P,(P)
	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JRST NOTDEV

DEVFR1:
	MOVE TAC1,DEVMOD(DDB)
	TRNN TAC1,ASSCON		;DETACHED MAYBE?
	JRST DEVFRE
DEVFR2:
	JSP TAC,PJBMSG
	ASCIZ/DETACHED FROM SYSTEM.
/

DEVFRE:
	JSP TAC,PJBMSG
	ASCIZ/NOT IN USE.
/

PJBMSG:
	POP P,(P)
	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JRST CONMES

PJPRNM:
	MOVE DDB,-5(P)
	MOVEI DAT,TTOBUF(DDB)
	EXCH TAC1,-2(P)
	JRST PRNAME

;  "KJOB" KILL ATTACHED JOB



KJOB:
	JUMPE ITEM,JOBKB	;WAS JOB INITIALIZED?	;DEC 3.16
IFN FTSWAP,<
	TLNN AC1,SWP		;DEC 3.16
	JRST KJOB1		;DEC 3.16
	JUMPN PROG,DLYCR1	;DEC 3.16
CORX:
	MOVEI TAC,1		;DEC 3.16
	PUSH PDP,CORX1		;DEC 3.16
	JRST CORE0K		;DEC 3.16
KJOB1:

>	
IFN FTLOGIN,<
	PUSHJ P,STLNAC		;GET TTY BITS
	TLNN TAC1,IMPBIT	;IMP'S GET LOGGED OUT ANYWAY
	TLNN TAC1,PTYLIN	;FLUSH PTY JOBS INSTANTLY!
	TLZN AC1,JLOG!JACCT	;SHALL WE RUN LOGOUT?
	JRST KJOB2		;NO.
	TLO AC1,JACCT		;SET "ACCOUNTING PGM RUNNING"
	HLLM AC1,JBTSTS(ITEM)
IFN FTSWAP,<
	PUSHJ PDP,ALOGN1
>
	MOVSI TAC,TTYRNU+NOMESS
	XORM TAC,-1(PDP)
	PUSH PDP,['LOGOUT']
	JRST ARCOM		;RUN LOGOUT
>

IFN FTLOGIN,<			; PRINT OUT A JOB'S PROJECT PROGRAMMER NUMBER

PPPN:
	PUSHJ	P,DECIN		;GET ARGUMENT, IF ANY
	JRST	PPPN6		;NO ARGUMENT. PPN FOR CURRENT JOB.
	JRST	COMERA		;ILL. ARGUEMENT
	MOVSI	TAC,NOINCK	;DON'T INITIALIZE A JOB JUST FOR ME!
	IORM	TAC,-1(P)
	CAIGE	TAC1,JOBN	; OUT OF BOUNDS?
	CAIG	TAC1,0
	JRST	ECOMA		; PRINT "OUT OF BOUNDS"
	MOVE	AC1,TAC1	; USE THAT JOB NUMBER
PPPN5:
	MOVE	TAC,JBTSTS(AC1)
	SKIPE	PRJPRG(AC1)
	TLNN	TAC,JNA
	JRST	NOTLOG
	MOVE	TAC,[POINT 6,PRJPRG(AC1)]
	PUSHJ	P,PPPN7		;WRITE 3 SIXBIT CHARACTERS
	MOVEI	TEM,","
	XCT	TYO
	PUSHJ	P,PPPN7		;TYPE THE REST
IFN FTDSKPPN,<
	SKIPN	DSKPPN(AC1)	;ANY ALIAS PPN?
	JRST	NOALIAS
	PUSHJ	P,INLMES
	ASCIZ/  ALIAS  /
	MOVE	TAC,[POINT 6,DSKPPN(AC1)]
	PUSHJ	P,PPPN7
	MOVEI	TEM,","
	XCT	TYO
	PUSHJ	P,PPPN7
NOALIAS:

>;FTDSKPPN
	PUSHJ	PDP,INLMES
	ASCIZ /
/
	POPJ	PDP,

PPPN6:
	MOVEI	AC1,(J)		; NO ARGUMENT USE PPN OF CURRENT JOB
	MOVE	AC2,JBTSTS(J)
	TLNN	AC2,JLOG
	JRST	LOGPLS
	JRST	PPPN5

PPPN7:
	MOVEI	TAC1,3		;3 CHARACTERS
PPPN8:
	ILDB	TEM,TAC		;LOAD THE NEXT BYTE
	JUMPE	TEM,PPPN9	;FLUSH NULL BYTES
	ADDI	TEM," "		;MAKE SIXBIT INTO ASCII
	XCT	TYO		;TYPE ONE CHARACTER
PPPN9:
	SOJG	TAC1,PPPN8	;LOOP
	POPJ	P,
>

;COMMAND	"ALIAS P,PN"  OR  "ALIAS P"  OR  "ALIAS"
;THE FIRST SETS DSKPPN(J) AND THE SECOND RESETS IT
IFN FTDSKPPN,<
SDSKPPN:

CAIE TEM,073;;replaced;;	CAIE	TEM,";"
	CAIN	TEM,12		;TERMINATOR SEEN ALREADY?
	JRST	CDSKPPN		;YES. RESET ALIAS.
	PUSHJ	P,GETWRB	;LOOK FOR ARG
	JUMPE	TAC1,[	CAIE TEM,12	;NO ARG AT ALL?
CAIN TEM,073;;replaced;;			CAIN TEM,";"
			JRST CDSKPPN	;NO ARG IS OK
			JRST COMERA]	;BAD ARG, ERROR
	HLLZ	AC2,TAC1	;SAVE P
	TRNE	TAC1,-1		;CHECK SYNTAX, RPH YOU LAZY ...
	JRST	COMERA
CAIE TEM,073;;replaced;;	CAIE	TEM,";"
	CAIN	TEM,12		;ONE ARG?
	JRST	[HRR AC2,PRJPRG(J)	;COPY PRG
		JRST CNGPRJ]
;	CAIE	TEM,","		;COMMA FOR SEPERATOR?
;	CAIN	TEM,"/"		;OR SLASH?
;	CAIA			;YES
;	JRST	COMERA		;NO
	PUSHJ	P,GETWRB	;TRY TO GET PN
	JUMPE	TAC1,COMERA	;MUST BE ONE
	HLR	AC2,TAC1	;DON'T CARE ABOUT TERMINATOR HERE
	TRNE	TAC1,-1
	JRST	COMERA
CNGPRJ:
	CAMN	AC2,MFDENT	;SAME AS 1,1?
	JRST	COMERA		;SOME THINGS NOT ALLOWED.
	CAMN	AC2,PRJPRG(J)	;RESETING EXPLICITLY
CDSKPPN:
SETZ	AC2,
	CAME	AC2,DSKPPN(J)	;CHANGING?
	SETZM	JBTUFD(J)	;YES, CLEAR JBTUFD
	MOVEM	AC2,DSKPPN(J)
	POPJ	P,

GETWRB:
	PUSHJ P,CTEXT
	JUMPE TAC1,NOJUST
	TLNN TAC1,7777
	LSH TAC1,-14
	TLNN TAC1,77
	LSH TAC1,-6
NOJUST:
	PUSHJ P,SKIPSB		;CAREFUL, THIS GUY CAN CALL TPOPJ
	POPJ P,
>;FTDSKPPN

↑NOTLOG:JSP TAC,ERRMES
	ASCIZ /NO SUCH JOB
/

; SERVICE LEVEL COMMAND
; SLEVEL
; YOUR CURRENT SERVICE LEVEL IS PRINTED.

MAXLEV ←← =80		;NOBODY CAN HAVE MORE THAN 80% OF THE MACHINE

SLEVEL:

TYPSL:
	PUSHJ	P,SPRSSL		;MAKE SURE CURRENT SERVICE LEVEL IS SPREAD
					;SPRSSL IS IN UUOCON
	HRRZ	TAC,JBTGSL(J)
	IMULI	TAC,=100
	ADDI	TAC,400000		; TRY TO CORRECT FOR ROUNDOFF ERROR
	HLRZS	TAC
	PUSHJ	P,RADX10
	JSP	TAC,CONMES
	ASCIZ	/% SERVICE LEVEL
/

;KILL N ---- KILL JOB N IMMEDIATELY! -- OR MAYBE LATER
KILCOM:
	PUSHJ	P,DECIN			;GET ARGUMENT
	JRST	NOTENF			;NONE
	JRST	COMERA			;ILLEGAL
	CAMN	J,TAC1			;NO SUICIDE!
	JRST	ILLKIL
	CAIL	TAC1,JOBN		;LEGAL?
	JRST	NOTLOG			;TOO BIG
	JUMPLE	TAC1,NOTLOG		;TOO SMALL
	MOVE	TAC,JBTSTS(TAC1)
	TLNN	TAC,JNA			;LEAVE US NOT FLUSH NON-EX JOBS
	JRST	NOTLOG
	TLNE	TAC,JSEG		;IS IT SEG2.
	JRST	KILCM5			;JUST CHANGE NAME OF UPPER SEGMENT.
	MOVSI	AC1,KILPRV		;LOOK FOR KILL PRIVILEGE
	TDNE	AC1,JBTPRV(J)		;...
	JRST	KILOK			;HE HAS THE POWER
	HRRZ	AC1,PRJPRG(ITEM)	;GET PROGRAMMER NAME
	HRRZ	TAC,PRJPRG(TAC1)	;GET PRG OF GUY WE'RE KILLING
	CAME	TAC,AC1			;SAME
	JRST	NOTYRS			;LOSE!
KILOK:
	MOVE	TAC,JBTSTS(TAC1)
	TLNE	TAC,SHF
	JRST	DLYCM			;WAIT A WHILE
	PUSH	P,J			;SAVE ME
	PUSH	P,PROG			;AND MY JOB
	MOVE	J,TAC1			;MAKE BELIEVE I'M HIM
	MOVE	PROG,JBTADR(J)		;AND HIS JOB
	TLNE	TAC,SWP			;SWAPPED OUT?
    ;NEXT INSTRUCTION MAY BE HAZZARDOUS TO YOUR HEALTH IF TWIDDLED.
	JRST	KILCM3			;GET HIM IN
	JUMPE PROG,KILCM7		;ANY CORE?
	MOVE TAC,(P)
	MOVE TAC,JBTPRV(TAC)		;GET PRIVILEGES OF GUY WHO TYPED COMMAND
	TLNE TAC,KILPRV			;IF HE HAS THE PRIV
	JRST KILCM6			;HE CAN KILL WITH ACTIVE IO
	PUSHJ PDP,ANYACT		;YES, ARE DEVICES ACTIVE?
	JRST KILCM3			;YES, DELAY
	JRST KILCM6			;WE HAVE CORE AND NO ACTIVE DEVICES

KILCM7:
	MOVEI	TAC,JOBDA		;NO, JUST GET A JOB DATA AREA
	PUSHJ	P,CORE0			;MAKE SURE HE HAS CORE
	JFCL
	JUMPE	PROG,KILCM4		;IF WE DON'T HAVE CORE HERE WE LOSE.
KILCM6:
	MOVSI TAC1,CMWB			;CLEAR COMMAND WAIT BIT
	ANDCAM TAC1,JBTSTS(J)		;SO HE WILL RUN
	MOVEI TAC1,KILCM1		;THIS IS THE PLACE TO START HIM
	MOVE TAC,JBTPRV(J)		;GET PRIV AGAIN
	TLNN TAC,KILPRV			;SKIP IF HE HAS IT
	MOVEI TAC1,JOBKL		;ELSE NORMAL KJOB ROUTINE
	PUSHJ P,MONJOB			;MAKE HIM A MONITOR JOB
KILCM2:
	POP P,PROG			;SUPRISE
	POP P,J				;IT'S ME AGAIN
	POPJ P,				;DIDN'T SEE A THING

KILCM3:
	PUSHJ P,DLYCOM			;SET CMWB AND GET IN CORE IF NECESSARY
KILCM4:
	POP P,PROG			;NOW LETS BE OURSELVES AGAIN
	POP P,J
	JRST DLYCM			;NOW DELAY US.

KILCM5:
	MOVE TAC,PRJPRG(TAC1)
	MOVEM TAC,JOBNAM(TAC1)		;NO ONE WILL BELIEVE THIS NAME.
IFN FTSTAT,<PUSH P,J
	MOVE J,TAC1
	PUSHJ P,NAMSTT
	POP P,J
>
	POPJ P,

NOTYRS:
	JSP TAC,ERRMES
	ASCIZ /NOT ONE OF YOUR JOBS.
/

ILLKIL:
	JSP TAC,CONMES
	ASCIZ /USE "KJOB" TO LOG YOURSELF OFF.
/

;PRIVILEGED KILL ROUTINE, FLUSHES THINGS WITHOUT WAITING
KILCM1:
	MOVEI	TAC1,ESTOP
	JSP	TAC,MONSTR		;MAKE ME SOME PDL
	PUSHJ	P,RESETSEG		;FLUSH HIS SEGMENT
	PUSHJ	P,IOKILL		;KILL ALL IO WITHOUT WAITING
	PUSHJ	P,TTYFND		;FIND TTY
	PUSHJ	P,TSETBF		;CLEAR IO
	MOVSI IOS,TOIP
	ANDCAB IOS,DEVIOS(DDB)		;CLEAR TOIP SO ESTOP WON'T HANG
	PUSHJ	P,KILSPW		;KILL SPACEWAR
	JRST	JOBKL1			;LET KJOB ROUTINE DO THE REST

KJOB2:
	JUMPE	PROG,JOBKA	;DOES JOB HAVE CORE?
	JSP	TAC1,MONJOB	;YES, SCHEDULE MONITOR JOB.
↑JOBKL:	MOVEI	TAC1,ESTOP2	;ESTOP AT END OF PDL
	JSP	TAC,MONSTR	;SET UP ACS AND PDL LIST
JOBKL1:
	PUSHJ	P,DSFLUSH	;SET UP TO FLUSH SPECIAL DETACHED SEGMENTS

IFN FTDRD,<
	CAMN	PROG,JBTADR(J)	;THE FOLLOWING IS BROUGHT TO YOU BY THE DRD.
	JRST	JOBKL2
	PUSHAC
	PUSHJ	P,DISMES
	ASCIZ	/PROG CLOBBERED AT JOBKL1 /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	POPACS
JOBKL2:

>
	PUSHJ	P,RESET		;FINISH IO BEFORE DEASSIGNING
	PUSHJ	P,DEASTY	;WHILE WE STILL HAVE CORE, DEASSIGN DEVICES XCPT TTY
	PUSHJ	P,JOB1		;CALL RESET(AGAIN!), RELEASE CORE.

IFN FTDRD,<
	SKIPN	JBTADR(J)	;THE FOLLOWING IS MORE DRD CODE
	JRST	JOBKA
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/JBTADR NOT ZERO AT JOBKA-1 /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	POPACS
>

JOBKA:

IFE FTLOGIN,<
	MOVE	TAC,TTIME(J)	;TOTAL TIME
	SUB	TAC,RTIME(J)	;MINUS INCREMENTAL TIME
	JUMPE	TAC,.+2		;SKIP IF ZERO
	PUSHJ	P,PRTIME	;TYPE INCREMENTAL TIME
	MOVE	TAC,TTIME(J)
	PUSHJ	P,PRTIME	;TYPE TOTAL TIME.
>
JOBKK:
	PUSHJ	P,DEASTY	;DEASSIGN ALL BUT TTY
	PUSHJ	P,TTYERR	;GET TTY FOR OUTPUT
	PUSHJ	P,INLMES
	ASCIZ	/KJOB
/
	PUSHJ P,PRPER
	PUSHJ	P,TTYSTR
	PUSHJ	P,TTYKIL	;RETURN TTY TO VIRGIN STATE
	SKIPE	AC1,JBTJL(J)	;AND JOB PRIORITY HISTORY
	PUSHJ	P,FSGIVE
	SETZM	JBTJL(J)
	SKIPE	AC1,JBTFS(J)	; ANY SPARE FREE STORAGE?
	PUSHJ	P,FSGIVE
	SETZM	JBTFS(J)
	PUSHJ P,TMPKIL		;FLUSH ALL HIS TMPCOR FILES (IGNORING ALIAS)
	PUSHJ	P,RELPDL	;RELEASE THE PDL, IF ANY.
				;RETAIN USE OF PDL AS LONG AS WE'RE AT
				;UUO LEVEL OR CHANNEL 7
	HLRZ	AC1,SAVSAI(J)
	JUMPE	AC1,.+2
	PUSHJ	P,FSGIVE	;RETURN SWAP UUO AC SAVE BLK
	SETZM	SAVSAI(J)
	JRST	KSTOP		;CLEAR JOB STATUS WORD AND STOP JOB


;ERROR IN COMMAND


CERR:
	JRST ERRMES

JOBKB:
	SETZM -1(PDP)		;CLEAR NOJOBN SO COMRET WILL PRINT MESSAGE
	JRST LOGPLS		;"LOGIN PLEASE"

; "START L" OR "START" - START AT LOC. L OR STARTING ADDRESS
; "CSTART L" OR  "CSTART" - START AT LOC. L(TTY IN COMMAND MODE)

START:
					;SAME AS STARTC
STARTC:
	PUSHJ P,SKIPSJ
	CAIE TEM,"+"
	CAIN TEM,"-"			;REQUESTING INCREMENT?
	JRST STARTA			;YES, SCAN
	PUSHJ P,OCTIN			;CONVERT POSSIBLE OCTAL NO ARG.
	SKIPA TAC1,JOBSA(JDAT)		;NO START ADR. SPECIFIED RETURN
	JRST COMERA			;ILLEGAL CHARACTER
	CAME TAC1,JOBSA(JDAT)		;STARTUP ADDRESS TYPED?
	PUSHJ P,CLRTPV			;YES, CLEAR TEMP PRIVILEGES
	HRRZ TAC,TAC1			;GET STARTUP ADDR
	TDZA TAC1,TAC1
STARTB:
	HRRZ TAC,JOBSA(JDAT)
	JUMPN TAC,STRTCK		;ADD INCREMENT AND START
	JSP TAC,ERRMES
	ASCIZ /NO STARTUP ADDRESS!
/

STARTA:
	CAIE TEM,"+"			;+?
	JRST STARTE			;NO, MUST BE -
	PUSHJ P,OCTINS			;YES, READ INC
	SKIPA TAC1,[1]			;INVENT 1 FOR NO ARG
	JRST COMERA
	JRST STARTB

STARTE:
	PUSHJ P,OCTINS			;GET - INC
	SKIPA TAC1,[1]			;INVENT 1 FOR NO ARG
	JRST COMERA
	MOVN TAC1,TAC1			;NOW NEGATE
	JRST STARTB

;"REENTER" - REENTER USER PROGRAM
REENTE:
	PUSHJ P,SKIPSJ
	CAIN TEM,"-"
	JRST REENTM			;GET - INC
	PUSHJ P,OCTIN
	TDZA TAC1,TAC1			;0 FOR NO ARG
	JRST COMERA			;ILL CHAR
REENTN:
	HRRZ TAC,JOBREN(JDAT)
	JUMPN TAC,STRTCK		;ADD INCREMENT AND START
	JSP TAC,ERRMES
	ASCIZ /NO REENTER ADDRESS
/

REENTM:
	PUSHJ P,OCTINS
	SKIPA TAC1,[1]
	JRST COMERA
	MOVN TAC1,TAC1
	JRST REENTN

STRTCK:
	JUMPE TAC1,.+2			;ANY INCREMENT?
	PUSHJ P,CLRTPV			;YES, CLEAR TEMP PRIVILEGES
	ADD TAC1,TAC			;ADD INCREMENT
	JRST USTART			;NOW START IT UP

; "HALT" OR "<CONTROL>C"
;SCANNER ROUTINES DUMMY UP STOP WHEN CONTROL C TYPED IN
;STOP MUST BE DELAYED IF THIS JOB IS SYSTEM TAPE USER
;AND SYSTEM TAPE IS ACTIVE. OTHERWISE, THE JOB WILL NOT BE
;STOPPED WHEN DONE USING THE SYSTEM TAPE.


↑STOP:	JUMPE	ITEM,STOPB1
	CAMN	ITEM,STUSER	;IS THIS SYSTEM TAPE USER?
	JRST	STOPA		;YES
IFN FTDISK,<

	PUSHJ	P,STOPCK	;CAN THE JOB STOP?
	JRST	MAKCNC		;PUT BACK CONTROL C.
>
	PUSHJ	P,STOP1		;STOP JOB
STOPB:

REPEAT 0,<
	MOVSI	TAC,INTHAL	;↑C USER INTERRUPT BIT
	TDNN	TAC,JBTIEN(J)
	JRST	STOPB1
	IORM	TAC,JBTIRQ(J)	;ENABLED, GIVE HIM THE INTERRUPT
	SETOM	INTREQ(PID)	;AS IF THE 6 WOULD EVER DO THIS
>;END REPEAT 0.
STOPB1:
	MOVSI	TAC,JACCT
	ANDCAM	TAC,JBTSTS(J)	;GOODBYE LOSER!
	JSP	TAC,CONMES	;PRINT "↑C CRLF CRLF PERIOD"
	ASCIZ	/↑C
/
	POPJ	P,

STOPA:
	POP	P,TAC1		;DOES THE JOB HAVE ACTIVE DEVICES?
	PUSHJ	P,ACTCHK
	PUSHJ	P,ESTOP		;NO, STOP THE JOB AND LET GO OF SYSTEM TAPE
	MOVEI	TAC1,COMRET
	PUSH	P,TAC1
	JRST	STOPB

MAKCNC:
	MOVE	TAC1,LINSAV
	MOVE	TAC1,TTYTAB(TAC1)
	MOVEI	TAC,600
	DPB	TAC,TITAKR(TAC1)
	JRST	DLYCR1		;DON'T REQUE, OR HE WON'T GET OUT OF THIS STATE!!!

;CCONTINUE, CONTINUE, DDT

; "CCONT" - CONTINUE EXECUTION(TTY REMAINS IN COMMAND MODE)
; "CONT" - CONTINUE EXECUTION FROM WHERE LEFT OFF

CONTC:
				;SAME AS CONT
CONT:
	MOVSI	TAC1,JERR
	TDNE	TAC1,JBTSTS(J)	;IS JOB ERROR BIT SET?
	JRST	NOCONT		;YES, LOSE
	MOVNI	TAC1,RUNQ	;NO, REQUE TO RUN QUEUE
	MOVEM	TAC1,JOBQUE(J)
	JRST	REQUE

NOCONT:
	JSP TAC,ERRMES		;YES, PRINT CANT CONTINUE
	ASCIZ /CAN'T CONTINUE
/


; "DDT" - START EXECUTION AT DDT IN USER AREA

DDTGO:
	HRRZ	TAC1,JOBDDT(JDAT)	;DDT STARTING ADR. IN JOB DATA AREA
	JUMPN	TAC1,DDTG1		;IS IT NON-ZERO? IF YES, STORE
					;OLD PC IN JOBOPC IN JOB DATA AREA
					;THEN START WITH PC IN USER MODE
	JSP TAC,ERRMES			;ZERO PRINT "NO DDT"
	ASCIZ /NO DDT
/

;KLUDGE TO MAKE SURE DDT MEMORY IS WRITEABLE
DDTG1:
	HLRZ	TAC,PROG
	CAIG	TAC1,(TAC)
	JRST	USTART			;ADR IN LOWER - GO AHEAD
	MOVE	TAC1,JOBPC(PROG)
	TLNN	TAC1,USRMOD
	JRST	DDTG2
	MOVSI	TAC,JOBDAC(PROG)	;MAKE SURE ACS ARE IN RIGHT PLACE
	HRRI	TAC,(PROG)
	BLT	TAC,17(PROG)
DDTG2:
	JSP	TAC1,MONJOB		;GET TO UUO LEVEL
	JSP	TAC,MONSTR
	PUSHJ	P,UNPURE		;TRY TO UNPURIFY UPPER
	JRST	DDTPUR
DDTG3:
	HRRZ	TAC,JOBDDT(PROG)	;WHERE TO GO
	HLL	TAC,JOBOPC(PROG)	;WITH HIS OLD FLAGS
	TLO	TAC,USRMOD		;DEFINITELY IN USER MODE
	TLZ	TAC,4037		;CLEAR IOT-USER AND @() BITS
	MOVEM	TAC,UUOPC(J)
	JRST	USRXIT			;"RETURN" FROM THIS "UUO"

DDTPUR:
	MOVE	J,JOB(PID)		;J WAS CLOBBERED BY UNPURE.
	PUSHJ	P,TTYERP
	PUSHJ	P,INLMES
	ASCIZ	/COULDN'T UNPURIFY UPPER. CONTINUE TO TRY ANYWAY./
	PUSHJ	P,PRCRCC
	PUSHJ	P,TTYSTC		;NOW, FORCE TTY TO TYPE STUFF.
	PUSHJ	P,SETSTP		;MAKE US STOP SOON
	JRST	DDTG3

;SETUWP, CLRUWP, ENABLE, DISABLE
SETWPS:
	PUSH P,[-1,,0]			;NO PRO BITS YET
	CAIA
CLRWPS:
	PUSH P,[0]			;NO PRO BITS YET
	PUSHJ P,OCTIN
	JRST NOSPRO			;NO SET PRO
	JRST [	POP P,(P)
		JRST COMERA]
	CAILE TAC1,777			;LEGAL?
	JRST ILLPRO
	TRO TAC1,400000
	HRRM TAC1,(P)
NOSPRO:
	PUSH P,J
	LDB J,PSEGN
	JUMPE J,NXSEG
	PUSHJ P,ACCESS
	JRST WPSEG
	JRST WPSEG
	HRRZ TAC1,-1(P)			;GET PRO BITS
	TRNN TAC1,400000		;IS HE REQUESTING BIT SETTINGS?
	JRST NOSPR1			;NO
	MOVE TAC1,(P)			;JOB #
	MOVE TAC1,JBTPRV(TAC1)
	TLNN TAC1,SEGPRV		;DOES HE HAVE PRIV?
	TRNN TAC,400			;NO, CHECK PROTECTION PROTECTION
	CAIA				;OKAY TO DIDDLE
	JRST WPSEG			;LOSE
	HRRZ TAC1,-1(P)			;GET BITS AGAIN
	ANDI TAC1,377			;DON'T LET HIM SET UNPURIFIED BIT
	DPB TAC1,[POINT 9,JOBCRD(J),8]
NOSPR1:
	MOVSI TAC,JWP
	SKIPGE -1(P)
	IORB TAC,JBTSTS(J)
	SKIPL -1(P)
	ANDCAB TAC,JBTSTS(J)
	POP P,-1(P)			;MOVE J BACK ONTO FLAG
	HLRZ TAC1,JBTADR(J)		;GET SEGMENT PROT
	TLNE TAC,JWP
	TLO TAC1,400000			;SET WP BIT IF JWP SET
	MOVE TAC,J			;SAVE J HERE
	MOVEI J,JOBN-1			;PREPARE TO SCAN ALL JOBS
SETRLC:
	LDB AC1,PSEGN
	CAMN AC1,TAC			;USING THIS SEGMENT?
	SKIPN PROG,JBTADR(J)		;YES, IS JOBRL2 AVAILABLE?
	CAIA				;NO
	MOVEM TAC1,JOBRL2(PROG)		;STORE NEW JOBRL2
	SOJG J,SETRLC
	POP P,J
	POPJ P,

NXSEG:
	POP P,J
	POP P,(P)
	JSP TAC,ERRMES
	ASCIZ /NO UPPER SEGMENT!
/

WPSEG:
	POP P,J
	POP P,(P)
	JSP TAC,ERRMES
	ASCIZ /SORRY, PROTECTION FAILURE!
/

ILLPRO:
	POP P,(P)
	JSP TAC,ERRMES
	ASCIZ /ILLEGAL PROTECTION CODE!
/

DISABL:
	PUSHJ P,PRVSET			;GET BIT INTO TAC
	JRST NXPRV			;NO SUCH PRIVILEGE
	HRLOI TAC,-1-LUPPRV		;CR TYPED, CLEAR ALL BITS (EXCEPT TNTPRV)
	JFCL				;NOT LEGAL PRIV FOR THIS USER (OK TO CLEAR)
	ANDCAM TAC,JBTPRV(J)
	POPJ P,

ENABLE:
	PUSHJ P,PRVSET
	JRST NXPRV
	SKIPA TAC,JB2PRV(J)		;CR, COPY PRIVILEGES FROM PASSIVE
	JRST ILLPRV			;NOT LEGAL FOR THIS USER
	IORM TAC,JBTPRV(J)
	POPJ P,

NXPRV:
	JSP TAC,ERRMES
	ASCIZ /NO SUCH PRIVILEGE!
/

ILLPRV:
	JSP TAC,ERRMES
	ASCIZ /SORRY, YOU CAN'T HAVE THAT PRIVILEGE!
/


DEFINE XLPRIV(NAM,VAL)<	'NAM',,VAL>
DEFINE XRPRIV(NAM,VAL)<>

↑LFTTAB:PRIVS
↑LFTLEN←←.-LFTTAB


DEFINE XLPRIV(NAM,VAL)<>
DEFINE XRPRIV(NAM,VAL)<'NAM',,VAL>

↑RHTTAB:PRIVS
↑RHTLEN←←.-RHTTAB


PRVSET:
	PUSHJ P,CTEXT1
	JUMPE TAC1,CPOPJ1		;CR OR DELIM TYPED
IFG LFTLEN,<
	MOVSI TAC,-LFTLEN		;LENGTH OF LEFT TABLE
FNDLFT:
	HLLZ AC1,LFTTAB(TAC)
	CAMN AC1,TAC1
	JRST ISLFT
	AOBJN TAC,FNDLFT
>;LFTLEN
IFG RHTLEN,<
	MOVSI TAC,-RHTLEN
FNDRHT:
	HLLZ AC1,RHTTAB(TAC)
	CAMN AC1,TAC1
	JRST ISRHT
	AOBJN TAC,FNDRHT
>;FNDRHT
	POPJ P,				;NO SUCH PRIVILEGE

ISLFT:
	HRLZ TAC,LFTTAB(TAC)		;LEFT HALF BIT
	CAIA
ISRHT:
	HRRZ TAC,RHTTAB(TAC)		;RIGHT HALF BIT
	AOS (P)
	AOS (P)				;AT LEAST 2 SKIPS
	TDNE TAC,[RSPRVS]		;IS HE REQUESTING A RESTRICTED PRIVILEGE?
	POPJ P,				;YES, FLUSH
	MOVE AC1,JB2PRV(J)		;GET PASSIVE PRIVILEGES
	TLNN AC1,PRIPRV			;IF HE HAS PRIV PRIV, ALL IS OK
	TDNE TAC,AC1			;OR IF THE PRIV HE WANTS IS IN PASSIVE TABLE
	AOS (P)				;SKIP IF PRIV OK
	POPJ P,

; "CORE  #" - ASSIGNS #*1024 WORDS OF CORE TO JOB
;   "CORE" WITH NO ARG. WILL PRINT NO OF FREE BLOCKS LEFT
;	WITHOUT AFFECTING CURRENT ASSIGNMENT OF CORE



CORE:
	PUSHJ	P,DECIN		;GET NO. OF 1K BLOCKS
	JRST	COR4		;NO ARG. SPECIFIED, JUST TYPE FREE BLOCK LEFT
	JRST	COMERA		;ILLEGAL DECIMAL CHARACTER RETURN
IFN FTLOGIN,<
	MOVE	TAC,JBTSTS(J)	;GET JOB STATUS WORD
	TLNN	TAC,JLOG	;IS JOB LOGGED IN?
	JRST	LOGPLS		;NO, TYPE OUT MESSAGE
>
	PUSHJ	P,CLRTPV	;CLEAR TEMPORARY PRIVILEGES
IFN FTSWAP,<
	MOVE	AC1,SWAPLIMIT	;GET THE SWAPLIMIT
	LSH	AC1,-12		;CONVERT SWAPLIMIT TO K
	CAMLE	TAC1,AC1	;TOO BIG?
	JRST	CORFX1		;YES. TELL HIM SO.
	TLNN	TAC,SWP		;IS HE SWAPPED OUT?
	JRST	COR3		;NO. CONTINUE
	JUMPN	PROG,DLYCR1	;DELAY UNTIL HE IS IN CORE
	SKIPN	TAC,TAC1	;DEC 3.16
	JRST	CORX		;DEC 3.16
	SOS	(PDP)		;DEC 3.16
	JRST	CORE0K		;DEC 3.16


COR3:
>
	JUMPE	TAC1,COR0	;RELEASE DEVICES IF ASKING FOR 0 CORE
	MOVE	TAC,TAC1	
	LSH	TAC,12		;CONVERT 1K BLOCKS TO WORDS
	SUBI	TAC,1		;HIGHEST REL. LOC.
	PUSH	P,JBTADR(J)	;SAVE OLD CORE ASSIGNMENT
	LDB	TAC1,PSEGN	;SEE IF HE HAS AN UPPER
	SKIPE	TAC1
	PUSHJ	P,CORSGT	;YES, GET ITS SIZE INTO TAC1
	ADD	TAC1,TAC	;ADD LOWER SIZE + UPPER SIZE
	CAMLE	TAC1,CORMAX	;WILL IT FIT?
	JRST	CORFX		;NO
	PUSHJ	P,CORE0		;TRY TO ASSIGN CORE
	JRST	CORFX		;CAN'T DO IT
	POP	P,AC1		;GET BACK OLD CORE ASSIGNMENT
	SKIPE	AC1		;IF NO CORE ASSIGNED PREVIOUSLY
CORX1:
	POPJ	P,DLYCOR-1	;DEC 3.16 
	PUSHJ	P,CLRJOB
	SETZM	JOBSA(PROG)
	JRST	CORX1

CORFX:
	POP	P,(P)		;POP OFF OLD CORE ASSIGNMENT
CORFX1:
	MOVE	DDB,-2(P)	;GET TTY DDB BACK
	JSP	TAC,ERRMES
	ASCIZ	/NOT ENOUGH CORE!
/

COR4:
	MOVSI	TAC,NOINCK	;DON'T INITIALIZE A JOB
	IORM	TAC,-1(PDP)
	MOVE	DEVDAT,-2(P)	;RESTORE TTY DDB
IFE FTSWAP,<
	MOVE	TAC,CORTAL	;NO. OF FREE 1K BLOCKS
	PUSHJ	P,RADX10	;PRINT NO. OF FREE 1K BLOCKS LEFT
	PUSHJ	P,INLMES
CORMES:
	ASCIZ	/K CORE LEFT
/
	POPJ	P,
>
IFN FTSWAP,<
IFN FTLOGIN,<
	MOVE	TAC,JBTSTS(J)	;GET JOB STATUS WORD
	TLNN	TAC,JLOG	;IS JOB LOGGED IN?
	JRST	COR2.1		;NOT LOGGED IN. HE HAS NO CORE.
>
	MOVEI	TAC1,(J)	;GET JOB NUMBER
	PUSHJ	P,CORSGT	;GET CORE SIZE IN WORDS
	LSH	TAC1,-12	;DIVIDE TO GET K
	MOVEI	TAC,(TAC1)
	PUSHJ	P,RADX10
	PUSHJ	P,INLMES
	ASCIZ	/K IS YOUR JOB SIZE.
/
	LDB	TAC1,PSEGN
	JUMPE	TAC1,COR2.1
	PUSHJ	P,CORSGT	;GET SIZE OF UPPER IN WORDS IN TAC1
	LSH	TAC1,-12	;CONVERT TO K
	MOVEI	TAC,(TAC1)
	PUSHJ	P,RADX10
	PUSHJ	P,INLMES
	ASCIZ	/K IS YOUR UPPER.
/
COR2.1:
	MOVE	TAC,CORMAX		;LOAD AVAIL CORE ;REG
	CAMLE	TAC,SWAPLIMIT		;BIGGER THAN SWAPLIMIT?
	MOVE	TAC,SWAPLIMIT		;YES, PRINT IT INSTEAD
	LSH	TAC,-12			;CONVERT TO K
	PUSHJ	P,RADX10		;WRITE
	PUSHJ	P,INLMES
	ASCIZ	/K MAX.
/
	MOVE	TAC,CORMAX		;GET MAX AGAIN
	CAMG	TAC,SWAPLIMIT		;BIGGER THAN MAX?
	POPJ	P,
	LSH	TAC,-12
	PUSHJ	P,RADX10		;YES, PRINT IT ALSO
	PUSHJ	P,INLMES
	ASCIZ	/K USER CORE.
/
	POPJ	P,
>
↑LOGPLS:JSP TAC,ERRMES
	ASCIZ /LOGIN PLEASE
/

PRJOB:
	PUSHJ P,INLMES
	ASCIZ /JOB /
	MOVE TAC,J
	PUSHJ P,RADX10
	PUSHJ P,PRSPC
PRCONF:
	MOVEI TAC,CONFIG
	JRST CONMES

;HELLO 				;JS, REST OF PAGE
HELLO:
	PUSHJ	P,PRCONF	;TELL HIM WHAT FLAVOR SYSTEM WE ARE!
	JRST	CRLF		;TYPE CRLF

IFN FTLOGIN,<
;AUTOMATIC LOGIN AFTER DISK REFRESH OR WHEN REFLAG SET	;DEC 3.16, REST OF PAGE

LOGREF:
	MOVEM	TAC,PRJPRG(J)		;PJ,PG NOS IN REFLAG
	MOVSI	TAC,JLOG
	IORM	TAC,JBTSTS(J)		;LOG HIM IN.
	MOVSI	TAC,LUPPRV!PRIPRV	;SET JOB PRIVILEGES
	MOVEM	TAC,JBTPRV(J)
	MOVEM	TAC,JB2PRV(J)
	SETZM	-1(P)			;CLEAR ALL FLAGS FOR COMRET.
	SETZM	REFLAG			;ONLY ONCE.
	POPJ	P,
>

;"HELP" -HELP COMMAND


IFN FTLOGIN,<	;DEC 3.16
HELP1:
	MOVE	TAC,HELPPP
	TLNE	AC1,JLOG
	POPJ	P,
	PUSHJ	P,ALOGIN
	MOVSI	TAC1,LUPPRV		;GIVE 100,100 THE LOCAL USER PRIV
	IORM	TAC1,JBTPRV(J)		;BECAUSE HE CAN'T HARM US
	JRST	SETLOG			;AND SET-UP LOGIN STUFF
>

HELP:

IFN FTLOGIN,<
	PUSHJ PDP,HELP1
>
	PUSH P,['HELP  ']
	JRST ARCOM

WHECOM:

IFN FTLOGIN,<
	PUSHJ P,HELP1
>
	PUSH P,['WHERE ']
	JRST ARCOM

WHOCOM:

IFN FTLOGIN,<
	PUSHJ P,HELP1
>
	PUSH P,['WHO   ']
	JRST ARCOM

FIXIML:

IFN FTLOGIN,<
	PUSHJ P,HELP1
>
	PUSH P,['FIXIML']
	JRST ARCOM

FNDCOM:

IFN FTLOGIN,<
	PUSHJ	P,HELP1
>
	PUSH	P,['FIND  ']
	JRST	ARCOM

;ALOGIN, SETTPV, CLRTPV

ALOGIN:

IFN FTLOGIN,<	
		MOVEM	TAC,PRJPRG(J)
IFN FTDISK,<
		SETZM	JBTUFD(J)
IFN FTDSKPPN,<	SETZM	DSKPPN(J)	;INTIALIZE DISK ALIAS PPN>
	>
		SETZM	JBTKCJ(J)
		MOVSI	TAC,JLOG
		ANDCAM	TAC,JBTSTS(J)
>
IFN FTSWAP,<
ALOGN1:
	PUSHJ	P,TTYATI	;MAKE SURE TTY IS ATTACHED IN CASE
				;THIS COMMAND MUST BE DELAYED
				;BECAUSE NO CORE YET.
	JFCL
>
	POPJ	P,

SETTPV:
	ANDCM	TAC,JBTPRV(J)	;DON'T NEED ANY TEMPORARY PRIVS HE REALLY HAS
	IORM	TAC,JBTPRV(J)	;GIVE HIM THE TEMP PRIVS
	IORM	TAC,JBTTPV(J)	;REMEMBER TEMP PRIVILEGES WE ARE GIVING HIM
	POPJ	P,

CLRTPV:
	EXCH	TAC,JBTTPV(J)	;SAVE TAC, PICK UP TEMP PRIVILEGES
	ANDCAM	TAC,JBTPRV(J)	;TURN OFF TEMP PRIVS
	MOVEI	TAC,0
	EXCH	TAC,JBTTPV(J)	;RESTORE TAC, NO TEMP PRIVILEGES NOW
	POPJ	P,

;"LOGIN" - LOGIN COMMAND

IFN FTLOGIN,<

LOGDET:
	JSP	TAC,ERRMES
	ASCIZ	/PLEASE KJOB OR DETACH
/

CLOGIN:
	TLNE	AC1,JLOG	;IS HE LOGGED IN?
	JRST	LOGDET		;YES. FORCE LOGOUT FIRST
	SKIPE	TAC,REFLAG	;DEC 3.16
	JRST	LOGREF		;DEC 3.16
	JRST	.+2		;(TAC HAS A ZERO)
CXLOGI:
	MOVEI	TAC,1
	HRRM	TAC,SAVSAI(J)	;SET STARTING OFFSET.
	MOVE	TAC,DUMPPN	;SET PRJPRG TO DMPPPN
	PUSHJ	P,ALOGIN	;AUTOMATIC LOGIN
	MOVSI	TAC,JACCT	;FLAG ACCOUNTING PROGRAM RUNNING
	IORM	TAC,JBTSTS(J)
	PUSHJ	P,SKPBRK
	MOVE	TAC,[SIXBIT /LOGIN/]	;LOGIN FILE NAME.
	MOVEM	TAC,JOBNAM(J)	;STORE FILE NAME
IFN FTSTAT,<PUSHJ P,NAMSTT>
	MOVSI	TAC1,'DSK'	;READ FROM DSK, DMPPPN AREA.
	JRST	RUNCO2
>

;ONE OF THE RPG COMMANDS -- COMPILE, DEBUG, ECT

RPGCOM:
	PUSH PDP,[SIXBIT /RPG/]
	JRST ARCOM

ETCOM:
	PUSH P,['E     ']
	JRST ARCOM

DSCCOM:
	PUSH PDP,[SIXBIT /DART  /]
	JRST ARCOM

CPYCOM:
	PUSH PDP,[SIXBIT /COPY/]
	JRST ARCOM

MAICOM:
	PUSH P,[SIXBIT/MAIL/]
	JRST ARCOM

OBLCOM:
	PUSH	P,['FORGET']
	JRST	ARCOM

RCVCOM:
	PUSH	P,[SIXBIT /RCV/]
IFN FTLOGIN,<
	PUSHJ	P,HELP1
>
	JRST	ARCOM

NSCOM:
	PUSH	P,[SIXBIT /NS/]
NSCOM1:
	MOVE	TAC,JBTPRV(J)	;GET USER'S REAL PRIVS
	TLNN	TAC,LUPPRV	;IS HE LOCAL?
	JRST	NSCOM2		;NOPE, FLUSH HIM
	MOVSI	TAC,REAPRV
	PUSHJ	P,SETTPV	;SET TEMPORARY PRIVILEGES
	PUSH	P,[SIXBIT /  1  2/]
	JRST	ARPCOM

NSCOM2:
	POP	P,TAC
	JRST	COMERR		;PRETEND IGNORANCE

UDPCOM:
	PUSH	P,[SIXBIT /UDPUFD/]
	MOVE	TAC,JBTPRV(J)	;GET USER'S REAL PRIVS
	TLNN	TAC,LUPPRV	;IS HE LOCAL?
	JRST	NSCOM2		;NOPE, FLUSH HIM
	MOVSI	TAC,INFPRV!DAWPRV!WRTPRV!PROPRV	;BOY IS THIS A HAIRY PROGRAM
	PUSHJ	P,SETTPV	;SET TEMPORARY PRIVILEGES
	PUSH	P,[SIXBIT /  1  2/]
	JRST	ARPCOM

HOTCOM:
	PUSH	P,[SIXBIT /HOT/]
	JRST	NSCOM1

SPLCOM:

IFN FTLOGIN,<
	PUSHJ	P,HELP1
>
	PUSH	P,[SIXBIT /SPOOL/]
	JRST	ARCOM

FINGER:

IFN FTLOGIN,<
	PUSHJ	P,HELP1
>
	PUSH	P,[SIXBIT /FINGER/]
	JRST	ARCOM

LSPCOM:
	PUSH	P,[SIXBIT /LISP/]
	JRST	ARCOM

DOCOM:
	PUSH	P,[SIXBIT /DO/]
	JRST	ARCOM

ZERCOM:
	PUSH	P,[SIXBIT /ZERO/]
	JRST	ARCOM

XERCOM:
	PUSH	P,[SIXBIT /XEROX/]
	JRST	ARCOM

TSTCOM:
	PUSH	P,[SIXBIT /TEST/]
	JRST	ARCOM

RSLCOM:
	PUSH	P,[SIXBIT /RSL/]
	JRST	ARCOM

TNCOM:
	PUSH	P,[SIXBIT /T/]
	JRST	ARCOM

FTPCOM:
	PUSH	P,[SIXBIT /FTP/]
	JRST	ARCOM

DILCOM:
	PUSH	P,[SIXBIT /DIAL/]
	JRST	ARCOM

;R, RUN, SAVE, SSAVE, GET COMMANDS

;ARCOM:  CALL WITH JOBNAM STACKED.  RUN IT FROM SYS:
;AXCOM:	 SAME AS ARCOM, EXCEPT JOB STARTS AT C(JOBSA)+1

ARCOM:
	TDZA	TAC,TAC		;AUTOMATIC RUN COMMAND
AXCOM:
	MOVEI	TAC,1		;START WITH OFFSET=1
	PUSHJ	P,SKPBRK
ARCOM1:
	HRRM	TAC,SAVSAI(J)	;SET STARTUP OFFSET
	POP	P,JOBNAM(J)	;STORE FILE NAME
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	MOVSI	TAC1,'SYS'	;READ FROM SYSTEM DEVICE
	JRST	RUNCO2

;START UP WITH DOUBLE-SKIP C(JOBSA)+2, TTY POINTS TO THE REST OF LINE
AXXCOM:
	MOVSI	TAC,NOSKPB	;DOUBLE-SKIP ENTRY
	IORM	TAC,-2(P)	;TELL COMRET NOT TO CALL SKPBRK (JOBNAME STILL ON STACK)
	MOVEI	TAC,2		;SET FOR DOUBLE-SKIP ENTRY
	JRST	ARCOM1

;ARPCOM: CALL WITH JOBNAM STACKED, AND PPN STACKED TOO!

ARPCOM:
	HLLZS	SAVSAI(J)	;ZERO STARTING OFFSET
	POP	P,JOBPPN(J)	;SETUP SGSET KLUDGE
	PUSHJ	P,SKPBRK	;SKIP TO END OF LINE
	POP	P,JOBNAM(J)
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	MOVSI	TAC1,'DSK'	;READ FROM DSK
	JRST	RUNCO4

;"R CUSPNAME CORE" - DOES "RUN SYS:CUSPNAME"
RCOM:
	PUSH	P,[0]		;ZERO OUT PROGRAM NAME
	MOVEI	TAC,0
	JRST	ARCOM1

;"RUN DEVICE:FILE[PROJ.,PROG.] (CORE)"
;DOES A CORE,GET,START ALL IN ONE
;IF CORE ARG IS MISSING, SIZE IN DIRECTORY IS USED


RUNCOM:
	PUSHJ	P,CTEXT1	;GET DEVICE NAME FROM COMMAND STRING
	SETZM	JOBNAM(J)	;CLEAR OUT OLD JOB NAME
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	HLLZS	SAVSAI(J)	;CLEAR STARTUP INCREMENT
RUNCO2:
	SETZM	JOBPPN(J)	;DISABLE JOBPPN KLUGE FOR SGSET
RUNCO4:
	MOVEI	IOS,RUNJOB
RUNCM:
	PUSH	P,IOS		;SAVE DISPATCH
	JUMPN	PROG,RUNCO1	;NO. DOES JOB HAVE CORE?
	PUSH	P,TAC1		;SAVE DEVICE NAME
	MOVEI	TAC,ASSPRG	;CLEAR TTY "ASSIGNED BY PROGRAM" BIT
	ANDCAM	TAC,DEVMOD(DDB)
	MOVEI	TAC,JOBDA	;REQUEST JUST ENOUGH CORE FOR A JOB DATA AREA
	PUSHJ	P,CORE0		;IF OLD CORE(DEVICE ASSIGNMENTS RETAINED
	JFCL			;NO ROOM(PROG=0) OR ACTIVE IO (PROG NON ZERO)
	POP	P,TAC1		;RESTORE DEVICE NAME
RUNCO1:
	POP	P,IOS		;ADR. OF MONITOR JOB
IFE FTSWAP,<	JUMPN	PROG,RUNCO3	;AND SCAN REST OF ARG. IF CORE ASSIGNED
		JSP	TAC,ERRMES
		ASCIZ	/CORE IS FULL
/
RUNCO3:
>
IFN FTSWAP,<	JUMPE	PROG,DLYCOR	;DELAY IF ON DISK >
	MOVEM	UUO,COMWRD(PROG)	;PUT COMMAND IN AC FOR PROG TO SEE
	MOVEM	TEM,CHRWRD(PROG)	;ALSO DELIMITER CHAR
	SKIPN	AC2,JOBPPN(J)		;SPECIAL PPN HACK?
	JRST	SGSET			;NO
	JRST	SGSET0			;YES. SPECIAL ENTRY

;"GET DEVICE:FILE-NAME[PROJ.,PROG.] CORE" - SETS UP JOB AREA FROM RETREIVABLE
;DEVICE AND ASSIGNS CORE.


GET:
	MOVEI	IOS,GETJOB	;SETUP TO RUN GETJOB
	PUSHJ	P,CTEXT1	;GET DEVICE NAME
	SETZM	JOBNAM(J)	;CLEAR JOB NAME
	SETZM	JOBPPN(J)	;DISABLE JOBPPN KLUGE FOR SGSET
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	JRST	RUNCM


;"SAVE FILE-NAME[PROJ.,PROG.] CORE" - SAVES JOB AREA ON RETRIEVABLE DEVICE
;ONLY A SAVE OR A GET IN PROGRESS FOR EACH JOB
;NO ATTEMPT IS MADE TO SAVE DEVICE ASSIGNMENTS, AC'S, OR PC


SSAVE:
	TROA	IOS,SSAVJB	;SAVE UPPER ALSO (IOS CLEARED BEFORE DISPATCH)
SAVE:
	MOVEI	IOS,SAVJOB	;SETUP TO RUN SAVJOB 
	PUSHJ	P,CTEXT1	;GET THE FIRST COMMAND ARGUMENT (DEV OR FILENAME)
	SETZM	JOBNAM(J)	;CLEAR JOB NAME.
IFN FTSTAT,<	PUSHJ	P,NAMSTT>
	JRST	SGSET		;SCAN THE REST OF THE ARGUMENTS

; "ASSIGN DEV:NAME" - ASSIGN DEVICE TO JOB AND GIVE IT LOGICAL NAME

ASSIGN:
	MOVEI AC1,0			;START WITH NO ATTRIBUTES
ASSPP9:
	PUSHJ P,CTEXT1			;GET FIRST ARGUMENT
	JUMPE TAC1,NOTENF		;NO ARGUMENT TYPED IF 0
	MOVEI AC2,0
	MOVSI TAC,770000
ASSPP1:
	TDNN TAC,TAC1
	JRST ASSPP2
	IORM TAC,AC2			;MAKE MASK FOR NUMBER OF CHARACTERS TYPED
	LSH TAC,-6
	JUMPN TAC,ASSPP1
ASSPP2:
	MOVSI TAC,-NASATT
ASSPP3:
	CAMN TAC1,ASATTT(TAC)
	JRST ASSPP0			;EXACT MATCH.  GET BITS AND LOOP
	MOVE AC3,ASATTT(TAC)		;GET NAME OF ATTRIBUTE
	AND AC3,AC2			;AND WITH MASK
	CAMN TAC1,AC3
	TLON AC1,400000(TAC)
	AOBJN TAC,ASSPP3
	JUMPL TAC,ASSPPX		;AOBJN DIDN'T FALL THROUGH (TOO MANY MATCHES)
	JUMPGE AC1,ASSPPX		;IF SIGN BIT OFF THERE WERE NO MATCHES
	LDB TAC,[POINT 17,AC1,17]	;GET INDEX OF MATCHING ENTRY
ASSPP0:
	TDNE AC1,ASATBB(TAC)		;CHECK FOR EXCLUDED BITS
	JRST COMERR			;NAUGHTY NAUGHTY
	IOR AC1,ASATTB(TAC)		;OK, TURN ON NEW BIT
	MOVEI AC1,(AC1)			;FLUSH CRUFT IN LH
	JRST ASSPP9

PUBBIT←←1
PRIBIT←←2
OLDBIT←←4

ASATTT:
	'PUBLIC'
	'PRIVAT'
	'OLD   '
NASATT←←.-ASATTT

ASATTB:
	PUBBIT
	PRIBIT
	OLDBIT
IFN .-ASATTB-NASATT,<PRINTS /SOMEONE CAN'T COUNT AT ASATTB
/>

ASATBB:
	PRIBIT!OLDBIT			;TABLE OF BITS NOT ALLOWED WITH NEW ONE
	PUBBIT!OLDBIT
	PUBBIT!PRIBIT
IFN .-ASATBB-NASATT,<PRINTS /ASATBB WRONG SIZE
/>

ASSPPX:
	MOVE	AC2,TAC1		;SAVE DEVICE NAME
	PUSHJ	P,CTEXT1		;GET LOGICAL NAME, IF ANY
	MOVEM TAC1,ASSLGN		;SAVE FOR LATER
	MOVE TAC1,AC2			;RESTORE TAC1 TO PHYS NAME
	HRRZS	(P)			;CLEAR PARTIAL MATCH FOUND FLAG
	PUSH	P,DDB			;SAVE TTY DDB ADDRESS
	MOVE	TAC,TAC1
	PUSH P,AC1			;SAVE ATTRIBUTE BITS
	PUSHJ	P,DEVPHY
	JRST	ASSG3
	POP P,AC1
	MOVEI	TAC1,ASSCON
	JRST	ASSG4

ASSG3:
	POP P,AC1
	MOVEI TAC1,ASSCON		;SETUP ASSIGNED BY CONSOLE BIT
	HLRZ DDB,DEVLST
ASSG0:
	MOVE TAC,DEVNAM(DDB)
	CAME AC2,DEVNAM(DDB)		;DOES PHYSICAL NAME MATCH?
	JRST ASSG1			;NO
ASSG4:
	CAMN AC2,[SIXBIT /DSK/]		;IS THIS A DISK?
	JRST ASSG5			;YES.  BYPASS CHECK FOR SYSTEM TAPE
	CAMN TAC,SYSTAP			;IS NEXT DEVICE IN LIST THE SYSTEM TAPE?
	JRST ASSFIN			;YES, DO NOT ASSIGN. CLEAR DIRECTORY IN CORE BIT
ASSG5:
	PUSHJ P,ASSUDP			;TEST VARIOUS UDP CASES
	JRST ASSR1A			;CAN'T GET UDPN SINCE PRIVATE AND NOT OURS
	PUSHJ P,ASSCKS			;NOW CHECK FOR RECYCLABLE DDB
	JRST ASLNOK			;I.E., SHARABLE DEVICE AND OUR ASSCON DDB
	PUSHJ P,ASSASG			;TRY TO ASSIGN DEVICE
	JRST ASSER1			;ALREADY ASSIGNED TO ANOTHER JOB
	JRST ASSFIN			;ASSIGNED

ASSUDP:
	HLRZ AC3,TAC
	CAIE AC3,'UDP'
	JRST CPOPJ1			;NOT UDP.
	LDB AC3,PUNIT
	CAME AC2,[SIXBIT /UDP/]
	JRST ASSUD1			;ASKED FOR UDPN.  SEE IF PUBLIC OR OURS
	SKIPE UDPCNT-1(AC3)		;ANY DDBS IN USE FOR THIS UDP?
	POPJ P,				;YES.
ASSUD2:
	TRNE AC1,PUBBIT			;WANTS TO MAKE IT PUBLIC?
	JRST AUDPPB			;YES.
	TRNE AC1,OLDBIT			;WANTS TO MAKE IT OLD STYLE?
	JRST AUDPOL			;YES.
	TRNN AC1,PRIBIT			;MAKE IT PRIVATE?
	JRST CPOPJ1			;NO.
	PUSHJ P,AUDPNU			;YES, FIRST MAKE IT NEW STYLE
	PUSHJ P,AUDPPV			;THEN MAKE IT PRIVATE
	JFCL				;IGNORE FAILURE RETURN
	JRST CPOPJ1

AUDPPV:
	SKIPN UDPCNT-1(AC3)
	JRST ASSUD3			;OK TO PRIVATIFY UNUSED UDP
	PUSH P,DDB
ASSUD4:
	HLRZ DDB,DEVSER(DDB)
	JUMPE DDB,ASSUD5
	CAME AC2,DEVNAM(DDB)
	JRST ASSUD5			;NO MORE DDBS FOR THIS UDP
	LDB TAC,PJOBN
	CAIN TAC,(J)
	JRST ASSUD4			;SAME JOB SAME UDP IS OK
	MOVE DDB,-3(P)			;TTY DDB
	PUSHJ P,INLMES
	ASCIZ /ALREADY IN USE, CAN'T MAKE PRIVATE.
/
	POP P,DDB
	MOVE TAC,DEVNAM(DDB)
	POPJ P,				;FAILURE RETURN

ASSUD5:
	POP P,DDB
ASSUD3:
	MOVE TAC,DEVNAM(DDB)
	MOVEM J,UDPOWN-1(AC3)		;MAKE UDP PRIVATE
	JRST CPOPJ1			;SUCCESS RETURN

ASSUD1:
	SKIPL UDPOWN-1(AC3)		;WANTS UDPN
	CAMN J,UDPOWN-1(AC3)
	JRST ASSUD2			;OK SINCE PUBLIC OR OURS
	POPJ P,				;CAN'T GET UDPN SINCE PRIVATE NOT OURS

AUDPPB:
	PUSHJ P,AUDPNU			;WANTS PUBLIC: FIRST MAKE NEW-STYLE
	LDB AC3,PUNIT
	MOVE TAC,DEVMOD(DDB)		;DDB POINTS TO MODEL DDB IT SAYS HERE
	TLNE TAC,DVDSK			;IF WE MANAGED NEW-STYLE,
	SETOM UDPOWN-1(AC3)		;PUBLICIFY IT
	JRST CPOPJ1

AUDPNU:
	LDB AC3,PUNIT			;TRY TO MAKE IT NEW-STYLE UDP
	MOVE TAC,DEVMOD(DDB)
	TLON TAC,DVDSK			;OK IF ALREADY NEW-STYLE
	SKIPN UDPCNT-1(AC3)		;OR IF NO DDBS YET
	JRST AUDNOK
	EXCH DDB,-2(P)			;TTY DDB
	PUSHJ P,INLMES
	ASCIZ /ALREADY IN USE, CAN'T CHANGE FORMAT.
/
	EXCH DDB,-2(P)
	MOVE TAC,DEVNAM(DDB)
	POPJ P,

AUDNOK:
	MOVEM TAC,DEVMOD(DDB)		;SET FORMAT BIT
	MOVEI TAC,DSKDSP
	HRRM TAC,DEVSER(DDB)		;SIGH, SET THE NEW DISPATCH TABLE TOO
	MOVE TAC,DEVNAM(DDB)
	POPJ P,

AUDPOL:
	PUSHJ P,AUDPPV			;WANTS OLD-STYLE.  FIRST PRIVATIFY
	JRST CPOPJ1			;FAILED TO PRIVATIFY, SO NO OLD-STYLE
	AOS (P)				;WIN OR LOSE, WE'VE ESTABLISHED ACCESS
	LDB AC3,PUNIT			;TRY TO MAKE IT OLD-STYLE UDP
	MOVE TAC,DEVMOD(DDB)
	TLZE TAC,DVDSK			;OK IF ALREADY OLD-STYLE
	SKIPN UDPCNT-1(AC3)		;OR IF NO DDBS YET
	JRST AUDOOK
	EXCH DDB,-2(P)			;TTY DDB
	PUSHJ P,INLMES
	ASCIZ /ALREADY IN USE, CAN'T CHANGE FORMAT.
/
	EXCH DDB,-2(P)
	MOVE TAC,DEVNAM(DDB)
	POPJ P,

AUDOOK:
	MOVEM TAC,DEVMOD(DDB)		;SET FORMAT BIT
	MOVEI TAC,UDPDSP
	HRRM TAC,DEVSER(DDB)		;SIGH, SET THE OLD DISPATCH TABLE TOO
	MOVE TAC,DEVNAM(DDB)
	POPJ P,

;ROUTINE TO TRY TO RECYCLE ASSCON-TYPE DDB FOR SHAREABLE DEVICE
ASSCKS:
	MOVE AC3,DEVCMR(DDB)		;FIRST OF ALL, GOTTA BE SHARABLE DEV
	TLNN AC3,DEVSHR			;OR ASSASG WON'T COPY IT ANYWAY
	JRST CPOPJ1
	MOVE AC3,DDB			;NOW SEARCH ALL DDBS FOR THIS DEV
ASCKS1:
	LDB TAC,[POINT 6,DEVCHR(AC3),5]	;PJOBN
	CAIE TAC,(J)			;MUST MATCH OUR JOB TO BE A CANDIDATE
	JRST ASCKS9			;ELSE CONTINUE THROUGH DDBS
	MOVE TAC,DEVMOD(AC3)		;MUST HAVE ASSCON
	TRNN TAC,ASSCON			;PERHAPS NEEDLESSLY CONSERVATIVE, BUT
	JRST ASCKS9			;PERHAPS SOMEONE NEEDS NOT CON+PRG SAME DDB
	SKIPE TAC,DEVLOG(AC3)		;OK IF NO LOGICAL NAME IN THE DDB
	CAMN TAC,ASSLGN			;OR IF IT'S THE SAME AS LOG NAME ARG NOW
	JRST ASCKS2
	SKIPE ASSLGN			;ALSO OK IF NO LOG NAME ARG IN COMMAND
	JRST ASCKS9			;BUT LOSE IF 2 DIFFERENT LOG NAMES
ASCKS2:
	MOVE DDB,AC3			;GOT ONE!  SAVE POINTER
	POPJ P,

ASCKS9:
	HLRZ AC3,DEVSER(AC3)		;CONTINUE THROUGH DDB CHAIN
	JUMPE AC3,CPOPJ1		;CAN'T HAPPEN MAYBE
	MOVE TAC,DEVNAM(AC3)		;MAKE SURE THIS IS SAME DEVICE
	CAMN TAC,DEVNAM(DDB)
	JRST ASCKS1			;OK, CONTINUE TESTING
	JRST CPOPJ1			;NO, POP AC3, SKIP RET

;SYSTEM TAPE OR NOT MATCH OF ARG AND PHYSICAL NAME.

ASSG1:
	CAMN	TAC,SYSTAP		;IS THIS SYSTEM TAPE?
	JRST	ASSG2			;YES
	LDB	AC3,PJOBN		;SAVE OLD JOB NUMBER FOR THIS DEVICE
	MOVEM	AC3,ASSJBN
	TRZ	TAC,-1			;COMPARE LEFT HALF ONLY
	CAME	TAC,AC2
	JRST	ASSG2
	HRROS	-1(P)			;FLAG PARTIAL NAME MATCH FOUND
	PUSHJ P,ASSUDP			;DO UDP CHECKS
	JRST ASSG2			;THIS UDP NOT FREE TRY NEXT
	PUSHJ P,ASSCKS			;NOW CHECK FOR RECYCLABLE DDB
	JRST ASLNOK			;NONSKIP RETURN MEANS SUCCESS, GOT A DDB
	PUSHJ	P,ASSASG		;MATCH, TRY TO ASSIGN IT
	JRST	ASSG2			;KEEP LOOKING
	SKIPN ASSJBN
	JRST ASSFIN		;IF OLD JOB NUMBER 0,
					; DEVICE PREVIOUSLY UNASSIGNED

ASSG2:
	HLRZ	DDB,DEVSER(DDB)
	JUMPN	DDB,ASSG0
	POP	P,DDB
	SKIPL	(P)			;DID WE HAVE ANY PARTIAL MATCHES?
	JRST	NOTDEV			;PRINT NO SUCH DEVICE
	MOVE	DDB,-2(P)		;RESTORE TTY DDB
	PUSHJ	P,INLMES
	ASCIZ	/SORRY, NO /
	MOVE	TAC1,AC2
	PUSHJ	P,PRNAME
	JSP	TAC,CONMES		;PRINT 'NO SUCH DEVICE'
	ASCIZ	/'S AVAILABLE.
/

;ALREADY ASSIGNED TO ANOTHER JOB

ASSR1A:
	LDB TAC,PUNIT
	SKIPA TAC,UDPOWN-1(TAC)		;GET JOB NUMBER OF PRIVATE OWNER OF UDPN
ASSER1:
	LDB	TAC,PJOBN		;GET JOB NUMBER FOR DEVICE
	POP	P,DDB			;GET DDB FOR TTY
	PUSH	P,TAC			;SAVE JOB NUMBER
	MOVEI	TAC,ASSMS2		;TYPE ERROR MESSAGE
	PUSHJ	P,ERRMES
	POP	P,TAC			;GET JOB NUMBER BACK
	JRST	DECLF

ASSMS2:
	ASCIZ /ALREADY ASSIGNED TO JOB /

;DEVICE ASSIGNED, GIVE IT A LOGICAL NAME

ASSFIN:
	SETZM	DEVLOG(DDB)		;CLEAR LOGICAL NAME
ASLNOK:
	EXCH	DDB,(P)			;GET TTY DDB, SAVE DEVICE DDB
	MOVE	TAC1,ASSLGN		;RETRIEVE SAVED LOGICAL NAME ARG
	SKIPN	TAC,TAC1		;IS THERE A LOGICAL NAME SPECIFIED?
	JRST	DEFASS			;NO.  CHECK FOR DEFAULTING ASSIGNMENT
	PUSHJ	P,DEVLG			;SEE IF IT IS ALREADY IN USE BY THIS USER
	JRST	ASSF1			;NO
	MOVEI	TAC,LOGERR		;YES, PRINT ERROR
	MOVE	DDB,-3(P)		;RESTORE TTY DDB
	PUSHJ	P,ERRMES
DEFLOS:
	MOVEI	TAC,0			;CLEAR LOGICAL NAME FOR THIS DEVICE
ASSF1:
	POP	P,DDB
	SKIPN DEVLOG(DDB)		;WILL BE NONZERO ONLY FOR RECYCLED DDB
	MOVEM	TAC,DEVLOG(DDB)		;STORE IN DEVICE DATA BLOCK
	MOVSI	TAC1,DVDIRIN		;CLEAR DIRECTORY IN CORE BIT
	ANDCAM	TAC1,DEVMOD(DDB)
	MOVE	TAC1,DEVNAM(DDB)	;PHYSICAL NAME
	MOVE	AC2,DDB
	MOVE	DDB,-2(P)		;RESTORE TTY DDB
	PUSHJ	P,PRNAME		;PRINT IT
	PUSHJ	P,INLMES
	ASCIZ	/ ASSIGNED/
	SKIPN	DEVLOG(AC2)
	JRST	NOLOGP
	PUSHJ	P,INLMES
	ASCIZ	/ AS /
	MOVE	TAC1,DEVLOG(AC2)
	PUSHJ	P,PRNAME
NOLOGP:
	JSP	TAC,CONMES
	ASCIZ/
/

LOGERR:
	ASCIZ 	/LOGICAL NAME ALREADY IN USE, /

DEFASS:
	MOVE	DDB,(P)
	CAME	AC2,DEVNAM(DDB)
	CAMN	AC2,['TTY   ']		;DON'T DO IT FOR TTY
	JRST	ASSF1
	MOVE	TAC,AC2
	PUSHJ	P,DEVLG			;INUSE?
	JRST	ASSF1
	JRST	DEFLOS

;"DEASSIGN DEV" - DEASSIGNS DEVICE FROM CONSOLE


DEASSI:
	JUMPE ITEM,CPOPJ	;NO-OP IF NO JOB NUMBER
	PUSHJ PDP,CTEXT1	;GET DEVICE NAME
	JUMPE TAC1,DEALL 	;NO ARG. IF 0, DEASSIGN ALL BUT TTY
	MOVE TAC, TAC1		;DEVICE NAME
DEAER4:
	PUSHJ PDP,DEVLG		; SEARCH LOGICAL NAMES FIRST
	JRST DEAER3
	PUSHJ PDP,DEASG
	CAIA
	JRST DEADON
	PUSH PDP,[DEAER4+1]
	JRST DEV0
DEAER3:
	PUSHJ PDP,DEVPHY	; NOT FOUND, TRY PHYSICAL NAMES
	JRST DEAER2		; NOT FOUND AT ALL, LOSE!
	PUSHJ PDP,DEASG		; FOUND, DEASSIGN IT
	CAIA
	JRST DEADON
	MOVE AC1,DEVMOD(DDB)
	TLNE AC1,DVTTY		; STOP IF FOUND A TTY
	POPJ P,			; QUIT HERE OR WILL LOOP INDEFINITELY!!!!
				; ALSO FLUSH UNUSED TTY'S
	PUSH PDP,[DEAER3+1]
	JRST DEVLP2

DEADON:
	MOVE AC1,DEVMOD(DDB)
	TLNE AC1,TTYATC		; NOT FOR CONSOLE OF LOSER
	POPJ P,
	TRNN AC1,ASSPRG		; STILL ASSIGNED BY PROGRAM?
	JRST DEADN1
	MOVE TAC1,DEVNAM(DDB)
	MOVE DDB,-2(P)
	PUSHJ P,PRNAME
	JSP TAC,ERRMES
	ASCIZ/ DEASSIGNED, BUT STILL INITED!
/

DEADN1:
	TLNN AC1,DVTTY		; IF TTY
	POPJ P,
	JRST TTYREL		; RELEASE IT SO DDB WILL BE LET GO

↑NOTDEV:
DEAER1:
	MOVE DEVDAT,-2(PDP)	; RESTORE TTY DDB
	JSP TAC,ERRMES		; PRINT 'NO SUCH DEVICE'

	ASCIZ /NO SUCH DEVICE
/

DEAER2:
	MOVE TAC1,TAC			;PRINT PHYSICAL DEVICE NAME
	MOVE DEVDAT,-2(PDP)		; RESTORE TTY DDB FIRST
	PUSHJ PDP,PRNAME
	JSP TAC,ERRMES

	ASCIZ / WASN'T ASSIGNED
/

DEALL:
	PUSH P,DDB
	SETZ DDB,
	PUSHJ P,DEASTY
	POP P,DDB
	POPJ P,

;REASSIGN UUO
;CALL	MOVE AC,JOB NUMBER
;	MOVE AC+1,SIXBIT /DEVICE/
;	CALL AC,[SIXBIT /REASSIGN/]
;IF C(AC)=0, JOB HAS NOT BEEN INITIALIZED
;IF C(AC+1)=0, DEVICE NOT ASSIGNED TO THIS JOB OR DEVICE IS A TTY



↑REASSI:
	LDB UUO,PUUOAC
	HRLI UUO,PROG
	PUSH PDP,@UUO		;STACK JOB NUMBER TO BE REASSIGNED TO
	AOS UUO
	MOVE TAC1,@UUO		;DEVICE NAME
	MOVE ITEM,JOB(PID)	;THIS JOB NUMBER
	SOJA UUO,REASS1

;"REASSIGN DEV:JOB" - REASSIGN DEVICE "DEV" TO JOB "JOB"


REASS:

	PUSHJ PDP,CTEXT1	;GET DEVICE NAME
	JUMPE TAC1,NOTENF	;NULL NAME?
	MOVE UUO,TAC1		;SAVE IT IN UUO
	PUSHJ PDP,DECIN1	;GET NEW JOB NUMBER
	JRST NOTENF		;NONE SPECIFIED. DOESN'T RETURN IF ERROR
	JRST COMERA		;ILLEGAL CHARACTER
	PUSH PDP,TAC1		;PUT JOB NUMBER ON STACK, DEVICE
	MOVE TAC1,UUO		;NAME IN TAC1
	SETZM UUO		;SET COMMAND SWITCH


;ROUTINE COMMON TO REASSIGN UUO AND COMMAND


REASS1:
	EXCH ITEM,(PDP)		;NEW JOB NO. IN ITEM
	MOVE TAC,JBTSTS(ITEM)	;NEW JOB STATUS
	EXCH ITEM,(PDP)		;RESTORE ITEM AND STACK
	TLNN TAC,JNA		;DOES NEW JOB EXIST?
	JRST REASE1		;NO.
	MOVE TAC,TAC1
	PUSHJ PDP,FNDDDB	;SEARCH FOR DEV (USE CHANNEL # IF UUO)
	JRST REASE2		;NOT FOUND
	LDB TAC,PJOBN
	CAME TAC,ITEM		;ASSIGNED TO THIS JOB
	JRST REASE3		;NO
	MOVE TAC,DEVMOD(DEVDAT)
	TLNE TAC,TTYATC		;IS IT HIS CONSOLE?
	JRST REASE6		;YES. CAN'T BE REASSIGNED.
	TRNN TAC,ASSPRG		;IS DEVICE INITED?
	JRST REASS3		;NO.
	JUMPN UUO,REASS4	;YES. COMMAND LEVEL?
	HRL DEVDAT,(PDP)	;YES. SCHEDULE RELEASE
	MOVEM DEVDAT,JOBFDV(JDAT)
	POP PDP,TAC1
	MOVE DEVDAT,-2(PDP)
	MOVSI TAC1,TTYRNC	;SET TTYRNC SO JOB WILL RUN
	IORM TAC1,-1(PDP)
	JSP TAC1,MSTART
	JSP TAC,MONSTR
	HLRZ TAC,JOBFDV(JDAT)
	PUSH PDP,TAC
	HRRZ DEVDAT,JOBFDV(JDAT)
	MOVE ITEM,JOB(PID)
	SETOM UUO		;SET FLAG TO STOP JOB

REASS4:
	HRRZ DSER,DEVSER(DEVDAT)
	HRRZM DEVDAT,JOBFDV(JDAT)
	SKIPGE UCHN,USRHCU(PID)	; HAS MONDMP BEEN HERE?
	JRST REASS3		;YES, WE CAN'T BE IN USRJDA LIST
REASS2:
	HRRZ DEVDAT,USRJDA(UCHN)
	PUSH PDP,UCHN
	CAME DEVDAT,JOBFDV(JDAT)
	JRST REASS8
	HLL DEVDAT,USRJDA(UCHN)	; PICK UP UUO FLAGS FIRST
	PUSHJ PDP,RELEA5	; NOW RELEASE DEVICE
REASS8:
	POP PDP,UCHN
	SOJGE UCHN,REASS2
	SKIPL UCHN,JBTIOP(J)
	JRST REAST1
REAST2:
	HRRZ DDB,(UCHN)
	CAME DDB,JOBFDV(JDAT)
	JRST REAST3
	MOVE DDB,USRJDA
	EXCH DDB,(UCHN)
	MOVEM DDB,USRJDA
	PUSH P,UCHN
	SETZ UCHN,
	PUSHJ P,RELEA5
	POP P,UCHN
	MOVE DDB,(UCHN)
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)
REAST3:
	ADD UCHN,[1,,1]
	AOBJN UCHN,REAST2
REAST1:
	MOVE DEVDAT,JOBFDV(JDAT)
REASS3:
	MOVEI TAC,ASSCON	;ASSIGN IT BY CONSOLE
	IORM TAC,DEVMOD(DEVDAT)
	POP P,J
	DPB J,PJOBN		;PUT IN NEW JOB NUMBER
	SETZM DEVLOG(DDB)	;FLUSH LOGICAL DEVICE NAME!
	MOVE J,JOB(PID)
	JUMPL UUO,ESTOP
	POPJ PDP,

REASE1:
	POP PDP,TAC
	JUMPE UUO,NOTLOG	;PRINT NO SUCH JOB
REASE4:
	SETZM @UUO		;CLEAR C(AC)
	POPJ PDP,

REASE2:
	MOVEI TAC,NOTDEV	;NO SUCH DEVICE
REASE5:
	POP PDP,TAC1
	JUMPE UUO,(TAC)
	AOJA UUO,REASE4

REASE3:
	MOVEI TAC,REASSX	;WASN'T ASSIGNED
	JRST REASE5

REASE6:
	MOVEI TAC,REASE7
	JRST REASE5
REASE7:
	MOVE TAC1,DEVNAM(DEVDAT)
	MOVE DEVDAT,-2(PDP)	; RESTORE TTY DDB
	PUSHJ PDP,PRNAME
	JSP TAC,ERRMES
	ASCIZ / CAN'T BE REASSIGNED
/

REASSX:
	MOVE TAC1,DEVNAM(DEVDAT)
	JRST DEAER2+1

;"ATTACH DEVNAM" -ATTACHES A PREVIOUSLY PARTITIONED DEVICE
;	NOTE-MUST BE LOGGED IN UNDER [1,1] TO DO THIS
; "ATTACH N [PROJ.,PROG.]" - ATTACH CONSOLE TO JOB N
;CHANGES ADDRESS OF TTY DEVICE DATA BLOCK STORED IN -2(PDP)
;BY THE COMMAND DECODER



↑ATTACH:
	PUSHJ	P,DECIN		;GET JOB NO.
	JRST	NOTENF		;NOT A NUMBER OR NONE SPECIFIEED
IFN FTLOGIN,<
	JRST	DEVATT		;WANTS TO ATTACH A DEVICE
>
IFE FTLOGIN,<
	JRST	NOTLOG		;NO SUCH JOB
>
	JUMPE	TAC1,NOTLOG	;0 IS ILLEGAL
	CAIL	TAC1,JOBN	;IS JOB NUMBER TOO BIG?
	JRST	NOTLOG		;ILLEGAL JOB NUMBER.  PRINT NO SUCH JOB
	MOVSI	AC2,JNA		;HAS THIS JOB NO BEEN ASSIGNED?
	TDNN	AC2,JBTSTS(TAC1)
	JRST	NOTLOG		;NO, PRINT NO SUCH JOB
IFN FTLOGIN,<
	PUSH	P,TAC1		;SAVE JOB NO.
	PUSHJ	P,PJPGNO	;GET PROJ.-PROG. NOS. ARG
	MOVE	AC2,PRJPRG(J)	;NO PP NO. USE CURRENT ONE
	POP	P,TAC1		;RESTORE
	CAME	AC2,PRJPRG(TAC1);MATCHES THE DETACHED JOB'S PPN?
	JRST	ATT3		;NO-ERROR
				;YES
>
	LDB	TAC,PUNIT	;GET LINE NUMBER OF TTY THAT'S TYPING.
	JRST	.+2
ATTILA:
	HRRE	TAC,JBTLIN(J)	;GET LINE NUMBER OF CONTROLING JOB.
	CAIGE	TAC,PTYL0	;IS THIS ON A PTY?
	JRST	THEHUN		;NO. ATTACH IS LEGAL.
	MOVE	J,PTYJOB-PTYL0(TAC)	;GET JOB NUMBER OF CONTROLING JOB.
	CAIE	J,(TAC1)	;CONTROLLER=JOB TO ATTACH TO?
	JRST	ATTILA		;NO.  KEEP LOOPING
	MOVEI	J,0
	JSP	TAC,ERRMES
	ASCIZ	/ILLEGAL ATTACH LOOP
/

THEHUN:
	MOVE	J,TAC1		;JOB NUMBER TO J
	PUSHJ	P,COMRT2	;FIX COMCNT
	PUSHJ	P,TTYATT	;NO, ATTACH TTY
	JRST	ATT2		;ERROR CAN'T ATTACH
	MOVEM	DDB,-2(P)	;CHANGE DEV DATA BLOCK ADDRESS
	JRST	TTYFND		;ATTACHED. GO SET UP OUTPUT BYTE PTR.

IFN FTLOGIN,<
DEVATT:

	ADDI	TEM,20		; MAKE FIRST CHAR OF DEVICE NAME INTO SIXBIT
	PUSH	P,TEM		; NOW SAVE IT
	PUSHJ	P,CTEXT		;GET DEVICE ARGUMENT
	JFCL			;SHOULD NEVER RETURN
	POP	P,TEM		; GET CHARACTER BACK
	MOVE	AC1,JBTPRV(J)	;GET JOB PRIVILEGES.
	TLNN	AC1,DEVPRV	;HAS HE THIS PRIV?
	JRST	ATT5		;NO - ERROR
	MOVE	TAC,TAC1	;YES-SET UP DEVICE NAME
	LSH	TAC,-6
	DPB	TEM,[POINT 6,TAC,5]
	PUSH	P,DDB		;SAVE DDB FOR THIS TTY
	PUSHJ	P,DEVSRC	;SEARCH FOR DEVICE
	JRST	DADD01		;NOT FOUND
	LDB	AC1,PJOBN	;GET JOB NUMBER
	JUMPN	AC1,ATT6	;IS IT = 0?
	MOVE	TAC,DEVMOD(DDB) ;CHECK TO SEE IF THIS IS A TTY
	TLNE	TAC,DVUDP
	JRST	ATTUDP		;UDP IS SPECIAL
	TRNE	TAC,ASSPRG	;IN USE BY JOB 0?
	JRST	ATT5A		;YES, CAN'T ATTACH IT
	DPB	J,PJOBN		;SET JOB NUMBER
	LDB	TAC1,PUNIT	;
	TLNE	TAC,DVTTY	;IS IT A TTY?
	HRRM	DDB,TTYTAB(TAC1);DEC 3.16
DADD02:
	POP	P,DDB		;
	POPJ	P,		;RETURN

ATTUDP:
	LDB TAC,PUNIT		;TRYING TO ATTACH UDP
	SKIPN UDPCNT-1(TAC)	;MUST BE NO DDBS
	SKIPE UDPOWN-1(TAC)	;AND OWNER 0
	JRST ATT6		;ELSE IN USE, PUBLIC, OR SWAPPING DEVICE!
	SETOM UDPOWN-1(TAC)	;OK, MAKE IT PUBLIC
	JRST DADD02		;NOTE THAT YOU DON'T HAVE IT ASSIGNED NOW!

;NOTE: THIS ROUTINE IS ALSO CALLED FROM PJOB COMMAND
DADD00:
	MOVEI TAC1,0		;SUBROUTINE TO CHECK "DEV" NAME FOR DD
	ROTC TAC,14
	CAIN TAC1,'DD'		;NOT A DEVICE, IS IT A DD CHANNEL?
	PUSHJ P,SIX2LN		;YES, GOBBLE NUMBER
	POPJ P,			;NOT DD OR NO NUMBER
	CAIL TAC1,=32
	POPJ P,
	MOVSI TAC,DDDETU!DDANYW	;DETACHED USE CODE
	HRRI TAC,(TAC1)
	JRST CPOPJ1

DADD01:
	PUSHJ P,DADD00		;NOT A REAL DEVICE, TRY DD CHAN
	JRST TEMP1		;NOPE
	LDB TAC1,[DDUSR(TAC)];;replace;;LDB TAC1,[DDUSR+<(TAC)>]	;YES, GET USE CODE
	CAIE TAC1,DDDETU
	JRST ATT6		;WASN'T DET
	PUSHJ P,DDREL		;LET GO!!
	JRST DADD02
>

ATT2:
	EXCH	DDB,TAC1		;PUT LINE NO. OF OUR TTY IN DDB
	MOVE	TAC1,DEVNAM(TAC1)	;PRINT PHYSICAL NAME
	MOVE	DDB,TTYTAB(DDB)		;PRINT MESSAGE ON RIGHT TTY !!
	PUSHJ	P,PRNAME
	JSP	TAC,ERRMES
	ASCIZ	/ ALREADY ATTACHED
/

ATT3:
	JSP	TAC,ERRMES
	ASCIZ	/PROJECT-PROGRAMMER NUMBER MISMATCH
/

ATT5A:
	POP	P,DDB
ATT5:
	JSP	TAC,ERRMES
	ASCIZ	/CAN'T ATT DEV
/

ATT6:
	POP	P,DEVDAT
	JSP	TAC,ERRMES
	ASCIZ	/WASN'T DET
/

;FLUSH THIS TTY'S BUFFERS IF NOT IN USE BY A JOB

FLUSH:
	PUSHJ P,CTEXT1
	JUMPE TAC1,NOTENF	;NO ARG?
	MOVE TAC,TAC1
	PUSHJ P,LOG2LN		;CONVERT TO LINE NUMBER
	JRST NOTTTY
	SKIPN DDB,TTYTAB(TAC1)
	JRST FLUSH1
	LDB TAC,PJOBN
	CAME TAC,J		;LET HIM DO IT TO HIMSELF
	JUMPN TAC,INUSE		;JOB ON IT
	PUSHJ P,TSETBF		;CLEAR BUFFERS
	MOVSI TAC,TPMON!IOFST
	MOVEM TAC,DEVIOS(DDB)	;MAKE HIM A VIRGIN
FLUSH1:
	MOVE DDB,-2(P)		;GET BACK OUR DDB
	MOVEI DAT,TTOBUF(DDB)
	JSP TAC,CONMES
	ASCIZ/FLUSHED./

NOTTTY:
	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JSP TAC,ERRMES
	ASCIZ/NOT A TTY.
/

INUSE:
	MOVE DDB,-2(P)
	MOVEI DAT,TTOBUF(DDB)
	JSP TAC,ERRMES
	ASCIZ/IN USE.
/

;"FORK", "CFORK", "DETACH" AND "CDETACH" COMMANDS
;"DETACH" - DETACH CONSOLE FROM JOB 
;"DETACH DEVNAM" - DETACHES DEVICE FROM THE SYSTEM SOFTWAREWISE

MFORK:
	PUSH	P,J		;SAVE J
	PUSHJ	P,INIJOB	;INITIALIZE A JOB
	JRST	[POP	P,J	;NO JOBS AVAILABLE.
		POP	P,(P)	;FLUSH CALL TO MFORK
		MOVSI	TAC,NOMESS	;LET ERROR MESSAGE THROUGH
		ANDCAM	TAC,-1(P)
		JRST	LOSEJB]	;
	JRST	[POP	P,J
		POP	P,(P)
		JRST	DLYCM1]	;DELAY THIS COMMAND UNTIL FREE STORAGE AVAILABLE
	MOVE	TAC,J
	POP	P,J
	POPJ	P,

CFORK:
	MOVSI	TAC,JERR
	TDNE	TAC,JBTSTS(J)
	JRST	NOCONT
	MOVM	TAC,JOBQUE(J)
	CAIE	TAC,STOPQ	;START HIM ONLY IF STOPPED.
	JRST	FORK		;ALREADY RUNNING(MIGHT NOT BE IN RUNQ)
	PUSHJ	P,MFORK		;GET A NEW JOB NUMBER IN TAC
	PUSH	P,TAC
	MOVNI	TAC,RUNQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
	PUSHJ	P,SETRUN
	JRST	FORK1		;WE HAVE NEW JOB NUMBER ON STACK.

FORK:
	PUSHJ	P,MFORK		;GET US A NEW JOB NUMBER IN TAC
	PUSH	P,TAC		;ALL SET.
FORK1:
	PUSH	P,JBTLIN(J)
	PUSHJ	P,DETCH1
	POP	P,TAC1		;GET BACK OLD LINE NUMBER
	HRLM	J,-1(P)		;SAVE THE OLD JOB NUMBER ON TOP OF PC FLAGS
	PUSHJ	P,DDBSRC	;GET A NEW DDB
	JRST	[POP	P,J	;LOSE.
		PUSHJ	P,RELJOB	;RELEASE THE JOB WE GOT
		MOVEI	J,0	;SIGNAL ERROR TO COMRET
		POPJ	P,]
	MOVSI	TAC,NOMESS
	ANDCAM	TAC,-2(P)	;OK TO TALK NOW
	MOVEM	DDB,-3(P)	;AND WHERE TO SAY IT
	MOVEI	DAT,TTOBUF(DDB)
	POP	P,J		;GET THE JOB NUMBER OF NEW JOB.
	PUSHJ P,FORKC		;COPY OLD JOB'S POOP
	PUSHJ P,PRJOB
	PUSHJ P,INLMES
	ASCIZ/
FORK YOU VERY MUCH!/
	JRST PRCRCC

↑FORKC:	MOVSI	TAC,JLOG!JNA
	IORM	TAC,JBTSTS(J)	;MAKE THIS JOB HIS
	SETZM	DEVLOG(DDB)	;ZERO LOGICAL NAME OF TTY
	PUSHJ	P,TTYATI
	HLRZ	TAC,-1(P)	;GET THE OLD JOB NUMBER BACK
	MOVE	TAC,PRJPRG(TAC)
	MOVEM	TAC,PRJPRG(J)	;GIVE HIM SAME PPN
	HLRZ	TAC,-1(P)
	MOVE	TAC,JBTPRV(TAC)
	MOVEM	TAC,JBTPRV(J)	;COPY PRIVILEGES
	HLRZ TAC,-1(P)
	MOVE TAC,JB2PRV(TAC)
	MOVEM TAC,JB2PRV(J)	;ALSO PASSIVE ONES
	PUSHJ	P,SETLOG	;GET GOOD STUFF
	HLRZ	TAC,-1(P)	;GET THE OLD JOB NUMBER BACK
	MOVE	TAC,DSKPPN(TAC)
	MOVEM	TAC,DSKPPN(J)	;GIVE HIM THE SAME ALIAS
	POPJ P,

LOSEJB:
	JSP	TAC,ERRMES
	ASCIZ/JOB CAPACITY EXCEEDED!
/

CDETACH:
MOVSI	TAC,JERR
	TDNE	TAC,JBTSTS(J)
	JRST	NOCONT
	MOVM	TAC,JOBQUE(J)
	CAIE	TAC,STOPQ
	JRST	DETCH1
	MOVNI	TAC,RUNQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
	PUSHJ	P,SETRUN
IFE FTLOGIN,<DETACH:>
DETCH1:
	PUSHJ	P,COMRT2	;FIX COMMAND BIT, COMCNT BEFORE DETACHING.
	JRST	TTYDET		;GO DETACH TTY.

IFN FTLOGIN,<

DETACH:
	PUSHJ	P,CTEXT		;GET ARGUMENT
	JUMPE	TAC1,DETCH1	;ONLY "DET" TYPED
	MOVE	AC1,JBTPRV(J)	;GET PRIV BITS
	TLNN	AC1,DEVPRV	;DEVICE DETACH-ATTACH PRIV?
	JRST	LOGER1		;NO-PRINT ERROR MSG.
	MOVE	TAC,TAC1	;YES-SET UP DEVICE NAME
	PUSH	P,DDB		;SAVE TTY DDB
	PUSHJ	P,DEVSRC	;SEARCH FOR DEVICE
	JRST	DDDD01		;DEVICE NOT FOUND
	MOVE	TAC,DEVMOD(DDB)	;CHECK TO SEE IF THIS IS DSK
	TLNE	TAC,DVUDP	;IS IT A UDP?
	JRST	DDDUDP		;YES, BIG MESS
	TLNE	TAC,DVDSK	;IS IT THE DSK?
	JRST	TEMP1		;YES-PRINT ERROR MSG.
	MOVEI	TAC1,ASSCON	;FOUND-SET UP ASSIGNED BY CONSOLE
	PUSHJ	P,ASSASG	;TRY TO ASSIGN
	JRST	ASSER1		;CAN'T ASSIGN
	TLNE	DDB,SYSDEV	;IS THIS SYSTEM DEVICE?
	JRST	TEMP1		;YES-PRINT ERROR MSG.
	XOR	AC1,AC1		;NO-SET TO ZERO
	DPB	AC1,PJOBN	;SET JOB NO. TO NULL JOB
	MOVE	TAC,DEVMOD(DDB)	;CHECK TO SEE IF THIS IS A TTY
	TLNN	TAC,DVTTY	;IS IT A TTY?
	JRST	DDDD03		;NO-GO AHEAD
	LDB	TAC,PUNIT	;YES-SET UP FOR SCNSER
	MOVEI	TAC1,-1		;SET LEFT HALVE OF TTYTAB TO -1
	HRRM	TAC1,TTYTAB(TAC);SO THAT SCNSER CHECKS FOR THIS
DDDD03:
	POP	P,DEVDAT	;RESTORE OUR TTY DDB
	MOVSI	TAC,NOPER!NOCRLF!NOMESS	; ASK TO TYPE OUT A CRLF AND A PERIOD
	ANDCAM	TAC,-1(P)	; BY ZEROING THESE IN THE COMMAND FLAGS
	POPJ	P,		;SUCCESSFUL RETURN

DDDUDP:
	LDB TAC,PUNIT		;TRYING TO DETACH UDP, GET UNIT NUMBER
	SKIPE UDPCNT-1(TAC)	;MUST HAVE NO OUTSTANDING DDBS
	JRST ASSER1		;ELSE LOSE
	SETZM UDPOWN-1(TAC)	;OK, SET JOB 0 AS OWNER
	JRST DDDD03		;ANNOUNCE WIN

TEMP1:
	POP	P,DDB		;RESTORE TTY DDB
	JRST	DEAER1		;PRINT ERROR MSG. AND RETURN

LOGER1:
	JSP	TAC,ERRMES
	ASCIZ	/CAN'T DET DEV
/

DDDD01:
	PUSHJ P,DADD00		;NOT A DEV, TRY DD CHAN
	JRST TEMP1		;N
	PUSHJ P,DDCGET
	JRST DDDD02		;IN USE
	JRST DDDD03		;WIN
DDDD02:
	POP P,DDB
	JSP TAC,ERRMES
	ASCIZ /CHANNEL IN USE
/
>	;CLOSE FTLOGIN

;"DAYTIME" - PRINT TIME OF DAY
↑DAYTIM:
	PUSHJ	P,DECIN		;PICK UP JOB NUMBER ARGUMENT
	JRST	DAYT2		;NO ARGUMENT.  GIVE HIM DAY, DATE & TIME
	JRST	COMERA		;ILLEGAL DECIMAL ARGUMENT
	JUMPN	TAC1,.+2	;ZERO ARGUMENT?
	MOVE	TAC1,J		;YES.  "DAYTIME 0" GETS TIMES FOR OWN JOB
	MOVE	TAC,JBTSTS(TAC1)
	TLNE	TAC,JNA
	TLNE	TAC,JSEG
	JRST	NOTLOG		;NO JOB OR A SEGMENT.  PRINT NO SUCH JOB.

	PUSH	P,[0]		;INITIALIZE A FLAG: DONT PRINT DATES
	HLRZ	TAC,JBTBTM(TAC1);GET LOGIN DATE
	CAME	TAC,THSDAT	;DID HE LOGIN TODAY?
	SETOM	(P)		;NO.  FLAG TO PRINT DATES
	MOVEI	TAC,[ASCIZ /LOGIN   RUN    NOW
/]
	SKIPE	(P)		;PRINTING DATES?
	MOVEI	TAC,[ASCIZ /  LOGIN      RUN       NOW
/]				;YES, LEAVE ROOM FOR DATES
	PUSHJ	P,CONMES	;PRINT TITLES
	MOVE	TAC,JBTBTM(TAC1);GET LOGIN DATE/TIME
	PUSHJ	P,PRDATM	; AND PRINT IT
	MOVE	TAC,FTIME(TAC1)	;GET DATE/TIME LAST RUN
	PUSHJ	P,PRDATM	; AND PRINT IT
	MOVE	TAC,TIMDAT	;GET CURRENT DATE/TIME
	PUSHJ	P,PRDATM	; AND PRINT IT
	SUB	P,[1,,1]	;POP FLAG
	JRST	CRLF		;PRINT CRLF, AND RETURN

PRDATM:
	SKIPN	-1(P)		;ARE WE PRINTING DATES?
	JRST	PDTIM0		;NO.  JUST PRINT TIME
	PUSH	P,TAC1		;YES.
	PUSH	P,TAC
	HLRZ	TAC,TAC		;GET DATE
	IDIVI	TAC,=31		;CONVERT TO DAY OF MONTH
	MOVEI	TAC,1(TAC1)	; WHICH IS THE REMAINDER+1
	MOVEI	TEM," "
	PUSHJ	P,PRTIM3	;PRINT DATE IN 2 COLS PADDING WITH LEADING BLANK
	MOVEI	TEM,"-"
	XCT	TYO
	POP	P,TAC
	ANDI	TAC,-1		;CLEAR THE DATE HALF OF TAC
	JRST	PDTIM1		;PRINT TIME (no use POPing TAC1 and then PUSHing it)

↑DAYT2:	PUSH	P,DAT		; SAVE DAT OVER CALL ON DATIME
	PUSH	P,ITEM		;AND ITEM		;JS
	MOVE	TAC,THSDAT	;PICKUP DATE	;REG
	PUSHJ	P,DAYCNT	;CALCULATE
	IDIVI	TAC,7
	LSH	TAC1,1
	MOVEI	TAC,DAYTAB(TAC1)	;LOAD ADDRESS OF ASCIZ STRING
	PUSHJ	P,CONMES
	PUSHJ	P,PRSPC
	POP	P,ITEM		;RESTORE STACK 
	POP	P,DAT
	MOVE	TAC,THSDAT	;END REG STUFF
	IDIVI	TAC,=31
	EXCH	TAC,TAC1	;YEAR AND MONTH IN TAC1
	AOS	TAC		;DAY IN TAC
	PUSHJ	P,RADX10	;PRINT DAY
	MOVEI	TAC,0
	DIVI	TAC,=12
	EXCH	TAC,TAC1
	MOVE	TAC,MONTAB(TAC)	;MONTH
	DPB	TAC,[POINT 21,DAMESS,27]
	MOVEI	TAC,DAMESS
	PUSHJ	P,CONMES	;PRINT DAY
	MOVEI	TAC,=64(TAC1)
	PUSHJ	P,RADX10	;PRINT YEAR
	PUSHJ	P,PRSPC		;ADD SPACES
	HRRZ	TAC,TIMDAT	;PRINT TIME OF DAY
	PUSHJ	P,PDTIME
	JRST	CRLF

↑DAYTAB:
	ASCIZ/WEDNESDAY/
	ASCIZ/THURSDAY/
	ASCIZ/FRIDAY/
	ASCIZ/SATURDAY/
	ASCIZ/SUNDAY/
	ASCIZ/MONDAY/
	ASCIZ/TUESDAY/

MONTHB:
	0			;JAN
	=31			;FEB
	=59			;MAR
	=90			;APR
	=120			;MAY
	=151			;JUN
	=181			;JUL
	=212			;AUG
	=243			;SEP
	=273			;OCT
	=304			;NOV
	=334			;DEC

;CALL WITH TAC SET UP W/ SYSTEM FORMAT DATE.
;RETURN W/ TAC= NUMBER OF DAYS SINCE JAN 1, 1964
;TAC1 AND AC2 CLOBBERED
↑DAYCNT:
	IDIVI	TAC,=31		;DAY OF THE MONTH IN TAC1
	MOVEI	DAT,1(TAC1)	;DAY INTO DAT
	IDIVI	TAC,=12		;MONTHS IN TAC1, YEARS IN TAC
	ADD	DAT,MONTHB(TAC1)	;ADD NUMBER OF DAYS BEFORE THE 1st OF MONTH
	TRNN	TAC,3		;SKIP UNLESS LEAP YEAR
	CAIGE	TAC1,2		;LY. SKIP IF AFTER FEBRUARY
	SUBI	DAT,1		;NOT LEAP YEAR. OR BEFORE MARCH
	MOVEI	TAC1,3(TAC)
	LSH	TAC1,-2		;NUMBER OF LY SINCE '64 NOT INCLUDING THIS YEAR
	IMULI	TAC,=365	;NUMBER OF YEARS TIMES 365
	ADDI	TAC,(TAC1)	;PLUS NUMBER OF PRIOR LEAP YEARS
	ADDI	TAC,(DAT)	;PLUS NUMBER OF DAYS SO FAR THIS YEAR.
	POPJ	P,

;"TIME (JOB NO.)" - PRINT TOTAL AND INCREMENTAL RUNNING TIME FOR A JOB
;"TIME 0" IMPLIES RUNTIME FOR NULL JOB AND THE TOTAL TIME SPENT SHUFFLING USERS
;	IF NO JOB NO. GIVEN-TIME WILL BE FOR CURRENTLY LOGGEN IN JOB NO.

RUNTIM:
	PUSHJ	P,DECIN		;GET JOB NO. ARG.
	JRST	CRUN1		;NO ARG. GIVEN
	JRST	COMERA		;ILLEGAL DECIMAL CHARACTER RETURN
	JUMPE	TAC1,CRUN2	;RUNTIME 0 GIVEN?
	CAIL	TAC1,JOBN	;JOB NO. TOO BIG?
	JRST	NOTLOG		;YES, ILLEGAL JOB NUMBER
CRUN3:
	MOVE	TAC,JBTSTS(TAC1);IS THIS A REAL JOB WE HAVE HERE?
	TLNE	TAC,JNA		;SKIP IF NO NUMBER ASSIGNED.
	TLNE	TAC,JSEG	;THERE IS A JOB HERE. SKIP IF NOT A SEGMENT
	JRST	NOTLOG		;NO JOB OR A SEGMENT. PRINT NO SUCH JOB.
	PUSHJ	P,INLMES	;PRINT TITLES
	ASCIZ	/     TOTAL   INCREMENT        WAIT  KCS
/
	MOVE	TAC,TTIME(TAC1)	;CPU TIME SINCE LAST LOGIN
	PUSHJ	P,PRTIME	;PRINT COMPUTE TIME USED
	MOVE	TAC,TTIME(TAC1)	;CALCULATE INCREMENTAL RUN TIME
	SUB	TAC,RTIME(TAC1)
	PUSHJ	P,PRTIME	; AND PRINT IT
	MOVE	TAC,TTIME(TAC1)
	CAMN	J,TAC1		;PRINTING TIME OUT FOR OWN JOB?
	MOVEM	TAC,RTIME(TAC1)	;YES.  RESET INCREMENTAL TIME.

	SKIPGE	TAC,JBTWAT(TAC1);GET TIME WAITING FOR SYSTEM
	ADD	TAC,UPTIME	;MAKE THIS TIME REAL
	PUSHJ	P,PRTIME	; AND PRINT IT
	MOVE	TAC,JBTKCJ(TAC1);GET KILO-CORE-JIFFIES USED
	IDIVI	TAC,=60		; AND CONVERT TO KILO-CORE-SECONDS
	JRST	DECLF		; AND PRINT IT WITH A CRLF AND RETURN

CRUN1:
	SKIPE	TAC1,J		;LOGGED IN?
	JRST	CRUN3		;YES.  GIVE HIM HIS OWN TIME.
CRUN2:
	PUSHJ	P,INLMES	;"TIME 0" OR UNLOGGED IN "TI"
	ASCIZ	/UP /
	MOVE	TAC,UPTIME
	IDIVI	TAC,=60*=60	;CONVERT TO MINUTES
	IDIVI	TAC,=60		;CALCULATE HOURS
	PUSH	P,TAC1		;SAVE MINUTES
	PUSHJ	P,RADX10	;PRINT HOURS
	PUSHJ	P,INLMES
	ASCIZ	/ hr /
	POP	P,TAC		;RETRIEVE MINUTES
	PUSHJ	P,RADX10	;PRINT MINUTES
	PUSHJ	P,INLMES
	ASCIZ	/ min;  SHFL /
	MOVE	TAC,SHFWRD	;NO. WORDS SHUFFLED
 	IDIVI	TAC,=1000000/<=60*3>	;ABOUT THIS MANY WORDS PER TICK.
	PUSHJ	P,PERCNT	;PRINT AS A PERCENTAGE OF UPTIME
	PUSHJ	P,INLMES
	ASCIZ	/;  NULL /
	MOVE	TAC,TTIME	;GET NULL TIME
	PUSHJ	P,PERCNT	;AND PRINT AS A PERCENTAGE OF UPTIME
	PUSHJ	P,INLMES
	ASCIZ	/;  ILEV /
	MOVE	TAC,INTIME
	PUSHJ	P,PERCNT
	PUSHJ	P,INLMES
	ASCIZ	/;  RIT /
	MOVE	TAC,JLRIT
	PUSHJ	P,PERCN1
	JRST	CRLF

;ROUTINE TO PRINT A PERCENTAGE OF UPTIME IN FORM "DD.D%"
;CALL WITH TIME (IN TICKS) IN TAC: PUSHJ P,PERCNT

PERCNT:
	IMULI	TAC,=1000
	IDIV	TAC,UPTIME
PERCN1:
	IDIVI	TAC,=10		;CALCULATE PERCENTAGE
	PUSH	P,TAC1		;SAVE FRACTION
	PUSHJ	P,RADX10	;PRINT INTEGRAL PART OF PERCENTAGE
	PUSHJ	P,PRPER		;PRINT A PERIOD
	POP	P,TEM
	ADDI	TEM,"0"
	XCT	TYO		;PRINT TENTHS OF A PERCENT
	MOVEI	TEM,"%"
	XCT	TYO		;PRINT PERCENT SIGN
	POPJ	P,

PR2SP:
	MOVEI	TEM," "
	XCT	TYO
TYOPOP:
	XCT	TYO		;PRINT TWO SPACES AFTER TIME
	POPJ	P,

PRCOLN:
	MOVEI	TEM,":"		;PRINT COLON
	JRST	TYOPOP

;ROUTINE TO PRINT A TIME IN FORMAT "H:MM:SS'TT  " (HOURS, MINS, SECS, TICKS)
;CALL WITH TIME IN TICKS IN TAC.  PRESERVES TAC1!
PRTIME:
	PUSH	P,TAC1
	IDIVI	TAC,=60*=60*=60	;HOURS INTO TAC
	JUMPE	TAC,PRTIM1	;PRINT 2 SPACES INSTEAD OF 0: FOR HOURS
	PUSHJ	P,RADX10
	PUSHJ	P,PRCOLN	;PRINT COLON
	TRCA	TEM,"0"≠":"	;MAKE SURE MINUTES GET PADDED WITH 0 IF NECESSARY
PRTIM1:
	PUSHJ	P,PR2SP		;PRINT 2 SPACES
	MOVE	TAC,TAC1
	IDIVI	TAC,=60*=60	;MINUTES INTO TAC
	PUSHJ	P,PRTIM3
	PUSHJ	P,PRCOLN
	MOVE	TAC,TAC1
	IDIVI	TAC,=60		;SECONDS INTO TAC
	PUSHJ	P,PRTIM2	;PRINT WITH LEADING 0 IF NECESSARY
	MOVEI	TEM,"'"		;USE RIGHT QUOTE TO PUNCTUATE TICKS
	XCT	TYO
	MOVE	TAC,TAC1	;TICKS INTO TAC
	PUSHJ	P,PRTIM2
	PUSHJ	P,PR2SP
	POP	P,TAC1		;RESTORE TAC1 FROM STACK
	POPJ	P,		;AND RETURN

PRTIM2:
	MOVEI	TEM,"0"		;PAD WITH LEADING 0 IF NECESSARY
PRTIM3:
	CAIGE	TAC,=10		;ANY PADDING NEEDED?
	XCT	TYO		;YES.  ONE CHARACTER OF PADDING PLEASE
	JRST	RADX10		;NOW PRINT TAC AS DECIMAL NUMBER AND RETURN

;ROUTINE TO PRINT TIME OF DAY IN FORMAT "HH:MM  "
;CALL WITH TIME IN SECONDS IN TAC.  PRESERVES TAC1
PDTIM0:
	ANDI	TAC,-1		;CLEAR DATE IN LEFT HALF OF TAC
PDTIME:
	PUSH	P,TAC1		;SAVE TAC1
PDTIM1:
	IDIVI	TAC,=60*=60	;HOURS INTO TAC
	PUSHJ	P,PRTIM2	;PRINT HOURS WITH LEADING 0 IF NECESSARY
	PUSHJ	P,PRCOLN
	MOVE	TAC,TAC1
	IDIVI	TAC,=60		;MINUTES INTO TAC
	PUSHJ	P,PRTIM2	;PRINT MINUTES WITH LEADING 0 IF NECESSARY
	PUSHJ	P,PR2SP		;PRINT 2 SPACES
	POP	P,TAC1		;RESTORE TAC1
	POPJ	P,

;ROUTINE TO LET TTY TALK TO ANY OTHER RING OF TTYS
;	"TALK TTYN"
;	TTYN NEED NEVER HAVE BEEN TYPED ON BEFORE

TALK:
	PUSHJ PDP,CTEXT		;GET ARGUMENT
	JUMPE TAC1,TALK2	;NONE SPECIFIED
	MOVE TAC,TAC1
	PUSHJ PDP,DEVSRC	;SEARCH FOR DEVICE
	JRST TALK1		;NONE AVAIL
	PUSHJ PDP,TTYTLK
	JRST TALK1
	POPJ PDP,

TALK2:

	MOVEM ITEM,-1(PDP)
	JRST NOTENF

TALK1:
	MOVE DEVDAT,-2(PDP)	; RESTORE TTY DDB
	MOVSI ITEM,NOINCK	; SET FLAGS TO PRINT RESPONSE
	MOVEM ITEM,-1(PDP)
	JSP TAC,ERRMES
	ASCIZ /BUSY
/

;"EXAMINE LOC" - LOOKS A CONTENTS OF LOC AND PRINTS IN OCTAL
;IF LOC IS MISSING, NEXT LOC IS PRINTED
;TAB. IS PRINTED INSTEAD OF CRLF(LIKE DDT)


ECOM:
	PUSHJ PDP,OCTIN		;GET OCTAL LOCATION
	JRST ECOM2		;NO ARG - GET CURRENT LOC
	JRST COMERA		;ILLEGAL CHARACTER
ECOM1:
	PUSHJ P,TESTIN		;GET SET UP
	 JFCL			;OK IF WRITE-PROT
	HLRZS TAC		;GET RELOCATION IN RIGHT HALF OF TAC
	PUSH PDP,TAC		;PUSH IT
	PUSHJ PDP,DEAT		;CHECK FOR AC REFERENCE
	SUBI TAC1,(AC3)		;MAKE REL TO APPROP SEG
	ADDM TAC1,(PDP)		;RELOCATE ADDR
	HRRZ TAC,JOBEXM(JDAT)	;PRINT LOC BEING EXAMINED
	PUSHJ PDP,OCTPNT
	PUSHJ PDP,INLMES	;PRINT SLASH TAB
	ASCIZ %/	%
	HLRZ TAC,@(PDP)		;PRINT LEFT HALF
	PUSHJ PDP,OCTPNT
	PUSHJ PDP,INLMES	;PRINT SPACE
	ASCIZ / /
	HRRZ TAC,@(PDP)		;PRINT RIGHT HALF
	PUSHJ PDP,OCTPNT
	PUSHJ PDP,INLMES	;PRINT FINAL TAB
	ASCIZ /	/
	JRST TPOPJ

;HERE WE GET THE LAST LOC+1. NOTE WE DO NOT CHANGE JOBEXM YET SINCE WE MAY
;GO TO DLYCOM FROM TESTIN AND DON'T WANT TO AOS IT SEVERAL TIMES.
ECOM2:
	MOVE TAC1,JOBEXM(PROG)
	AOJA TAC1,ECOM1

;SETUP ROUTINE FOR EXAMINE/DEPOSIT COMMANDS
;ADDRESS CHECKS, AND WAITS FOR SWAP (VIA DLYCOM) IF NEEDED FOR UPPER
;EXECUTES INSTRUCTION FOLLOWING CALL IF WRITE-PROTECTED UPPER
TESTIN:
	ANDI TAC1,-1		;FLUSH EXTRANEOUS GARBAGE
	MOVEI AC3,		;INITIALLY ASSUME LOWER
	MOVS TAC,JBTADR(ITEM)	;PROT. RELOC.
	CAIG TAC1,(TAC)		;LEGAL LOC
	JRST CPOPJ1		;YES, GO ON.
	MOVEI AC3,1(TAC)	;COMPUTE POSSIBLE UPPER ORIGIN
	LDB AC1,PSEGN		;# OF UPPER
	JUMPE AC1,ECOMP		;NONE
	MOVE AC2,JBTSTS(AC1)
	TLNE AC2,JWP		;IF WRITE-PROTECTED,
	XCT @(P)		;CHECK LEGALITY BEFORE TRYING TO SWAP
	SKIPE TAC,JBTADR(AC1)	;PROT. RELOC OF UPPER
	JRST TESTU1
	LDB TAC,IMGIN	;SWAPPED OUT, GET SIZE
	ASH TAC,12	;MAKE IT WORDS
	SOJA TAC,.+2	;MAKE IT HONEST
TESTU1:
	MOVS TAC,TAC
	CAIGE AC3,400000
	MOVEI AC3,400000	;AC3 IS NOW ORIGIN OF UPPER
	ADDI TAC,(AC3)		;RELOCATE PROT TO UPPER
	CAIL TAC1,(AC3)
	CAILE TAC1,(TAC)	;LEGAL
	JRST ECOMP		;NO
	TLNN AC2,SWP		;IS UPPER IN CORE
	JRST CPOPJ1
	MOVSI TAC,JHLDIN
	IORM TAC,JBTSTS(J)	;KEEP US IN
	EXCH J,AC1
	MOVSI TAC,COMSNB
	PUSHJ P,SETSIN		;AND GET HIM IN
	MOVE J,AC1
	POP P,(P)
	JRST DLYCM1		;AND DELAY

ECOMP:
	POP P,TAC		;POP OFF RETURN
ECOMA:
	JSP TAC,ERRMES		;ILLEGAL MEMORY REFERENCE

	ASCIZ /OUT OF BOUNDS
/

;"DEPOSIT LH RH LOC" - DEPOSITS XWD LH,RH IN LOCATION LOC
;IF LOC IS MISSING ASSUMB CURRENT LOC


DCOM:
	PUSHJ PDP,OCTIN		;GET LH
	JRST NOTENF		;NOT ENOUGH ARGUMENTS
	JRST COMERA		;ILLEGAL CHARACTER
	HRLM TAC1,IOS		;SAVE
	PUSHJ PDP,OCTIN		;GET RH
	JRST NOTENF		;NOT ENOUGH ARGUMENTS
	JRST COMERA		;ILLEGAL CHARACTER
	HRRM TAC1,IOS		;SAVE RH
	PUSHJ PDP,OCTIN		;GET LOC
	SKIPA TAC1,JOBEXM(JDAT)	;NOT SPECIFIED (DEPOSIT THIS)!
	JRST COMERA		;ILLEGAL CHARACTER
	PUSHJ P,TESTIN		;RETURN IF READY FOR DEPOSIT.
	 JRST ECOMP		;LOSE IF WRITE-PROT
	CAIGE TAC1,20		;IN USER ACS
	JRST .+3
	CAIG TAC1,JOBPFI	;NO, GREATER THAN HIGHEST LOC. PROTECTED
				;FROM IO IN JOB DATA AREA?
	JRST ECOMA
	HLLM TAC,(PDP)		;SAVE RELOCATION
	PUSHJ PDP,DEAT		;CHECK FOR AC REFERENCE
	HLRZ TAC,(PDP)		;GET RELOCATION
	SUBI TAC1,(AC3)		;ADJUST ADR FOR POSSIBLE SEGMENT
	ADD TAC1,TAC
	MOVEM IOS,@TAC1
IFN FTSWAP,<
	JUMPE AC3,.+2		;UPPER?
	SETOM STIME(AC1)	;YES, MARK IT ALTERED (LOWER WAS GOTTEN BY DEAT)
>
	POPJ PDP,



DEAT:
	MOVEM TAC1,JOBEXM(JDAT)	;STORE FOR NEXT TIME
IFN FTSWAP,<
	SETOM STIME(J)		;AND NOTE THIS CORE IMAGE CHANGED
>	MOVE TAC,JOBPC(JDAT)
	CAMN J,JOB		;MIGHT BE RUNNING IF HE SAID CCONT ETC.
	MOVE TAC,USRPC
	CAIL TAC1,20		;IS IT AN AC?
	POPJ PDP,		;NO
	TLNE TAC,USRMOD		;USER MODE?
	ADDI TAC1,JOBDAC	;YES USER ACS ARE HERE
	POPJ PDP,

;"BLANK" OR NO ALPHA NUMERIC BEFORE BREAK CHAR COMMAND
;DISPATCHED TO LIKE ANY OTHER COMMAND(O IN COMMAND TABLE)


CBLANK:

	CAIE TEM,12	; WAS BREAK A L.F.?
CAIN TEM,073;;replaced;;	CAIN TEM,";"	;NO, IS IT SEMI COLON(MONITOR COMMENT)
	POPJ PDP,	;YES, IGNORE
			;FALL IN UNKNOWN COMMAND

;COMMAND NOT IN COMMAND DIRECTORY

NOCOM:
	JRST COMERR	;NO, APPEND ? TO WHAT HE TYPED IN

; "FINISH DEVICE" - CLOSES,RELEASE AND DEASSIGNS DEVICE
FINIS:
	JUMPE	PROG,CPOPJ	; NO CORE, NO FINISH!
	PUSHJ	PDP,CTEXT1	; READ IN THE DEVICE NAME
	MOVEM	TAC1,JOBFDV(JDAT)	; SAVE THE SIXBIT OF THE DEVICE NAME
	MOVSI	TAC,TTYRNU	; PUT TTY INTO USER MODE
	IORM	TAC,-1(P)	; TELL COMRET
	JSP	TAC1,MSTART	; MAKE US A MONITOR JOB
	JSP	TAC,MONSTR	; NOW GET SOME ACS AND A PDL
	MOVE	TAC,JOBFDV(JDAT)	; SET UP TO SEARCH FOR THIS DEVICE
	JUMPE	TAC,FINALL	; NO DEVICE... FINISH ALL.
FIN3:
	PUSHJ	P,DEVLG		; TRY LOGICAL NAMES FIRST
	JRST	FIN1		; NOT FOUND, TRY PHYSICAL NAMES
	PUSHJ	P,FINRDV	; TRY TO FINISH IT
	PUSH	P,[FIN3+1]	; IF WE RETURN, THAT WASN'T THE RIGHT DEVICE
	JRST	DEV0		; CONTINUE SCANNING THE DEVICES

FIN1:
	PUSHJ	P,DEVPHY	; SEARCH PHYSICAL NAMES
	JRST	FIN2		; NO NAMES, ERROR
	PUSHJ	P,FINRDV
	PUSH	P,[FIN1+1]
	MOVE	AC1,DEVMOD(DDB)
	TLNN	AC1,DVTTY
	JRST	DEVLP2		; SEARCH FOR ANOTHER DEVICE OF SAME NAME

FIN2:
	PUSHJ	P,TTYFNU	; GET A TTY FOR US
	PUSHJ	P,INLMES	; GIVE AN ERROR MESSAGE
	ASCIZ /
FINISH WHAT?/
	PUSHJ P,PRCRCC
	JRST	FINXIT		; LEAVE TTY IN COMMAND MODE,
				; STOP JOB, AND RESCHEDULE


; ROUTINE TO FINISH A DEVICE BY RELEASING IT
; IT FIRST MATCHES IT TO A DEVICE DATA BLOCK IN USRJDA

FINRDV:
	SKIPGE	UCHN,USRHCU(PID)
	JRST	FIN2		; NO CHANNELS, NO DEVICES
				;BEWARE- YOU'D BETTER BE RUNNING ON P1
FINRD1:
	HRRZ	AC1,USRJDA(UCHN); GET DDB ADDRESS
	CAME	AC1,DEVDAT	; IS THIS IT
	SOJGE	UCHN,FINRD1	; NO, GET ANOTHER
	JUMPL	UCHN,FINSTK	; IF NOTHING FOUND, CHECK IO PDL
	PUSHJ P,FINREL		;RELEASE IT
FINRD2:
	PUSHJ	P,TTYFNU	; GET A TTY
	PUSHJ	P,PRCRCC
FINXIT:
	PUSHJ	P,TTYSTC	; KEEP THE TTY IN COMMAND MODE
	JRST	MSTOP		; STOP THE JOB NOW

FINREL:
	PUSH P,UCHN
	MOVSI UUO,(<RELEAS>)	; NOW SET UP TO RELEASE IT
	DPB UCHN,PUUOAC
	MOVE UCHN,DEVMOD(DDB)
	TRNE UCHN,ASSCON	;WILL DDB BE THERE AFTER RELEASE?
	JRST FINRL1		;YES
	XCT UUO			; RELEASE THE DEVICE
FINRL2:
	POP P,UCHN
	POPJ P,

FINRL1:
	PUSH P,DDB
	XCT UUO
	POP P,DDB
	MOVSI UCHN,DVDIRIIN	; CLEAR DIRECTORY IN CORE BIT
	ANDCAM UCHN,DEVMOD(DDB)
	JRST FINRL2

FINSTK:
	MOVE J,JOB(PID)
	SKIPL UCHN,JBTIOP(J)
	POPJ P,			;NOTHING ON STACK
FINST1:
	HRRZ AC1,(UCHN)
	CAME AC1,DDB
	JRST FINST2
	MOVE DDB,USRJDA
	EXCH DDB,(UCHN)
	MOVEM DDB,USRJDA
	PUSH P,UCHN
	MOVEI UCHN,0
	PUSHJ P,FINREL
	POP P,UCHN
	MOVE DDB,(UCHN)
	EXCH DDB,USRJDA
	MOVEM DDB,(UCHN)
	JRST FINRD2

FINST2:
	ADD UCHN,[1,,1]
	AOBJN UCHN,FINST1
	POPJ P,

FINALL:
	SKIPGE	UCHN,USRHCU(PID)	;SEE IF HE HAS CHANNELS OPEN
	JRST	FINAL3			;NONE LEFT OPEN.
FINAL1:
	SKIPE	DEVDAT,USRJDA(UCHN)	;IS THERE ANYONE HERE?
	PUSHJ P,FINREL
	SOJGE	UCHN,FINAL1
FINAL3:
	MOVE	J,JOB(PID)		;DEPARTMENT OF REDUNDANCY DEPARTMENT
	SKIPL UCHN,JBTIOP(J)		;ANY IO PDL?
	JRST FINST3
FINST4:
	SKIPN DDB,(UCHN)
	JRST FINST5
	SETZM (UCHN)
	MOVEM DDB,USRJDA
	PUSH P,UCHN
	SETZ UCHN,
	PUSHJ P,FINREL
	POP P,UCHN
FINST5:
	ADD UCHN,[1,,1]
	AOBJN UCHN,FINST4
	HRRZ AC1,JBTIOP(J)
	SETZM JBTIOP(J)
	PUSHJ P,FSGIVE
FINST3:
	PUSHJ	P,FKALL
	JRST	FINRD2

;HERE WE CHASE THROUGH ALL THE DDBS AND MAKE SURE NONE OF THEM BELONG TO THIS JOB
;FINISH (BY SUPPRESS CLOSE OUTPUT) ANY THAT MAY BE HUNG-OVER

FKALL:
	MOVEI	DDB,DEVLST-DEVSER
FKALL1:
	HLRZ	DDB,DEVSER(DDB)
	JUMPE	DDB,CPOPJ
	LDB	AC1,PJOBN
	CAIE	AC1,(J)
	JRST	FKALL1
	MOVE	AC1,DEVMOD(DDB)
	TRNN	AC1,ASSPRG		;SKIP IF ASSIGNED BY PROGRAM.
	JRST	FKALL1			;NO.
	MOVEM	DDB,USRJDA		;SAVE DDB POINTER. (CHANNEL 0)
	MOVSI	AC1,DVDIRIN
	ANDCAM	AC1,DEVMOD(DDB)
	CLOSE	0,3			;CLOSE CHANNEL 0. INHIBIT INPUT/OUTPUT CLOSE
	RELEAS	0,3			;RELEASE CHANNEL 0. INHIBIT I/O CLOSE
	JRST	FKALL			;START OVER FROM THE FRONT OF DEVICE CHAIN

;"RESOURCES" - PRINT OUT AVAILABLE DEVICES AND FREE BLOCKS ON THE DISK

FREDEV:

IFN FTDISK,<				;JS
	PUSHJ	P,INLMES
	ASCIZ	/DSK /
	MOVEI AC2,0		;UNIT 0 IS DSK, NOT UDP
FRUDP1:
	MOVEI TAC1,(AC2)
	PUSHJ	P,DSKRES	; GET FREE BLOCK COUNT FROM DISK SERVICE ROUTINE
	PUSHJ	P,RADX10	;CONVERT TO DECIMAL

FRUDP2:
	ADDI AC2,1		;NOW DO THE SAME FOR UDPS
	CAILE AC2,UPACKS
	JRST FRUDP9		;NO MORE UDPS
	PUSHJ P,INLMES
	ASCIZ /
/
	MOVE TAC,DKDBML(AC2)	;ELSE GET NAME
	MOVE TAC1,DEVNAM(TAC)
	PUSHJ P,PRNAME
	SKIPE TAC,SATADR(AC2)
	PUSHJ P,SATTAC		;TYPE SATID IF ANY
	MOVEI TAC,[ASCIZ / FREE/]
	SKIPE UDPCNT-1(AC2)
	MOVEI TAC,[ASCIZ / PUBLIC /]
	SKIPL UDPOWN-1(AC2)
	MOVEI TAC,[ASCIZ / PRIVATE /]
	SKIPE UDPOWN-1(AC2)
	JRST FRUDP3
	MOVEI TAC,[ASCIZ / DETACHED FROM SYSTEM/]
	SKIPE UDPCNT-1(AC2)
	MOVEI TAC,[ASCIZ / SWAPPING DEVICE/]
FRUDP3:
	PUSHJ P,CONMES
	SKIPE SATADR(AC2)
	JRST FRUDP1
	JRST FRUDP2
>
FRUDP9:
	PUSHJ P,INLMES
	ASCIZ /
DDC /
	MOVE TAC,DDFCNT		;GET NBR OF DD CHANNELS LEFT
	PUSHJ P,RADX10		; AND PRINT IT
	PUSHJ P,INLMES
	ASCIZ /
JSA /
	MOVE TAC1,JOBNM1
	SETZ TAC,
	MOVSI AC2,JNA
LOP03:
	TDNN AC2,JBTSTS(TAC1)	;IS THIS JOB SLOT AVAILABLE?
	ADDI TAC,1		;YES
	SOJG TAC1,LOP03		;CHECK NEXT SLOT
	PUSHJ P,DECLF		;PRINT NUMBER OF JOB SLOTS AVAILABLE

	PUSH P,[0]
	HLRZ AC1,DEVLST		;GET DDB POINTER
LOP01:
	MOVEI AC2,ASSCON+ASSPRG	;MASK FOR DEVICE ASSIGNED
	TDNN AC2,DEVMOD(AC1)	;ASSIGNED BY CONSOLE OR PROGRAM?
	PUSHJ PDP,LOP02		;DEV NOT ASG-CHECK AND PRINT
	HLRZ AC1,DEVSER(AC1)	;GET NEXT DDB
	JUMPN AC1,LOP01		;END OF CHAIN?
	PUSHJ P,CRLF		;YES
	JRST TPOPJ		;GET THAT EXTRA WORD OFF THE STACK

LOP02:
	MOVE TAC,DEVMOD(AC1)	;GET DEVICE CHARACTERISTICS
	TLNE TAC,DVTTY!DVDSK!DVIMP!DVUDP  ;IS IT A TTY OR DSK OR YE OLE IMP?
	POPJ PDP,		;YES - RETURN
LOP04:
	MOVEI TEM,","		;AND A COMMA
	SKIPE -1(P)
	XCT TYO
	MOVE TAC1,DEVNAM(AC1)	;NO-SET UP TAC1 AGAIN
	HRRZ AC2,DEVSER(AC1)	;IS THIS SAME DEVICE AS PREVIOUS ONE?
	CAMN AC2,-1(P)
	HRLZ TAC1,TAC1		;YES.  DONT PRINT NAME, ONLY NUMBER
	MOVEM AC2,-1(P)		;AND SAVE FOR NEXT DEVICE
	PUSHJ P,PRNAME		;GO AND PRINT IT OUT
	POPJ P,

SATTAC:
	PUSH P,TAC		;SAVE SAT ADDR JUST IN CASE
	MOVEI TEM,050;;"("		;(SATTAC CALLED BY PJOB FOR UDP)
	XCT TYO
	POP P,TAC
	MOVE TAC1,SATID(TAC)	;THIS IS VOLUME ID FOR UDPS
	PUSHJ P,PRNAME		;(IBM VOCABULARY TAKES OVER THE WORLD)
	MOVEI TEM,051;;")"
	XCT TYO
	POPJ P,

;RUNCHK, DLYCOR, DLYCR1
RUNCHK:
	CAMN ITEM,STUSER	;SYSTEM TAPE USER?
	JRST DLYCM1		;YES. DELAY
ACTCHK:
	JUMPE PROG,ACTCH1	;DOES JOB HAVE CORE IN MEMORY?
	TLNE AC1,SWP		;DEC 3.16
	JRST ACTCH1		;DEC 3.16
	PUSHJ PDP,ANYACT	;YES, ARE DEVICES ACTIVE?
	JRST DLYCM1		;YES, DELAY COMMAND.
ACTCH1:
	MOVE TAC1,-1(PDP)	;RESTORE COMMAND DISPATCH ADDRESS
	MOVE DDB,-2(PDP)	;RESTORE TTY DDB ADDRESS
	MOVE AC1,JBTSTS(ITEM)	;RESTORE JOB STATUS
	POPJ PDP,

;ROUTINE TO DELAY A COMMAND

;DELAYS COMMAND TO BE EXECUTED WHEN JOB IN CORE MEMORY
;AND POPS LEVEL UP ONE.



DLYCR2:
	MOVE	TAC1,LINSAV	;GET THE LINE NUMBER
	MOVSI	TAC,COMBIT
	CONO	PI,SCNOFF
	TDNE	TAC,TTYTAB(TAC1)
	SOS	COMCNT		;DECREMENT IF COMMAND BIT WAS SET
	ANDCAM	TAC,TTYTAB(TAC1)
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM
>
	CONO	PI,SCNON
	POPJ	P,

DLYCR1:
	PUSHJ	P,DLYCR2	;CLEAR COMBIT
	JRST	DLYCM1		;

DLYCOR:
	PUSHJ	P,DLYCR2	;CLEAR COMBIT
DLYCM:
	PUSHJ	PDP,DLYCOM	;REQUEUE JOB TO CMWQ 
↑DLYCM1:AOS	NDLYCMS		;COUNT A DELAYED COMMAND
	POP	P,TAC		;FLUSH THE RETURN TO COMRET
	POP	P,TAC1		;AND FLUSH THE COMMAND BITS
	POP	P,TAC1		;AND FLUSH THE TTY DDB POINTER.
	PUSHJ	P,TTYCM		;DELAY PRESENT COMMAND AND GET A NEW COMMAND
	POPJ	P,		;THERE ARE NO NEW COMMANDS
	JRST	COM0		;PROCESS A COMMAND.

;SEARCH DEVICE CHAIN FOR DSK WITH COUNTS ON
;CALL	MOVE ITEM,JOB NO
;	PUSHJ PDP,STOPCK
;	CAN'T STOP RETURN
;	OK TO STOP RETURN

IFN FTDISK,<

↑STOPCK:PUSH PDP,DEVDAT
	MOVEI DEVDAT,DSKDDB
	MOVSI TAC1,DSKFGS
STOPD:
	LDB TAC,PJOBN
	CAIE ITEM,(TAC)		;ASSIGNED TO THIS JOB?
	JRST STOPC		;NO
	TDNE TAC1,DEVIOS(DEVDAT)	;DUMP MODE I/O IN PROGRESS ?
	JRST STOPR1		;YES. DELAY
STOPC:
	HLRZ DEVDAT,DEVSER(DEVDAT)
	MOVE TAC,DEVMOD(DDB)	;LOOP THRU DSK AND UDP DDBS
	TLNE TAC,DVDSK
	JRST STOPD		;ONLY LOOK AT DVDSK ONES
	TLNE TAC,DVUDP
	JRST STOPC		;BUT KEEP SEARCHING IF DVUDP
	AOS -1(PDP)		;OK TO STOP
STOPR1:
	POP PDP,DEVDAT
	POPJ PDP,
>

;"FILES <filename or job number>" -- print status of open files.

FILCOM:
	MOVEI	AC1,DSKDDB
	PUSHJ	P,CTEXT1	;GET ARG OF COMMAND
	JUMPE	TAC1,FIL2	;NO ARG
	PUSH	P,TAC1		;SAVE ARG
	CAIN	TEM,"."		;DELIMITING PERIOD MEANS FILENAME EXT COMING
	JRST	FIL3		;READ EXT
	CAIN	TEM,"["		;DELIMITING LEFT BRACKET MEANS PPN COMING
	JRST	FIL4		;READ PPN
	PUSHJ	P,FIL2JB	;SEE IF ARG WAS A JOB NUMBER RATHER THAN FILENAME
	JRST	FIL5		;GOT JOB NUMBER
	PUSH	P,[0]		;MUST BE FILE NAME WITH ZERO EXTENSION.
FIL6D:
	SKIPN	AC2,DSKPPN(J)	;GET APPROPRIATE PPN FOR FILE
	MOVE	AC2,PRJPRG(J)
FIL6:
	PUSH	P,AC2		;SAVE PPN
	PUSHJ	P,FIL99		;SEE IF ANYTHING LEFT IN COMMAND LINE
	PUSHJ	P,CRLF		;BLANK LINE TO INDICATE STARTING NEW FILE SEARCH
FIL6A:
	PUSHJ	P,NXTDSK	;GET NEXT DSK DDB
	JRST	FIL6B		;NONE, DONE
	MOVE	TAC,DEVFIL(AC1)	;GET NAME OF FILE OPEN
	CAME	TAC,-2(P)	;SAME AS FILE OF INTEREST?
	JRST	FIL6A		;NOPE
	HLLZ	TAC,DEVEXT(AC1)	;GET EXT OF FILE OPEN
	CAME	TAC,-1(P)	;SAME AS FILE OF INTEREST?
	JRST	FIL6A		;NOPE
	MOVE	TAC,FILPPN(AC1)	;AND PPN
	CAMN	TAC,(P)		;SAME?
FIL6C:
	PUSHJ	P,PTFILE	;YES.  PRINT STATUS OF THIS FILE
	JRST	FIL6A		;NOT SAME, OR STATUS PRINTED OK.
	HRRZM	AC1,SAVDDB(DDB)	;NO ROOM TO PRINT FILE NAME.  SAVE OUR PLACE.
	JRST	.+2
FIL6B:
	SETZM	SAVDDB(DDB)	;WE FINISHED.  INDICATE NO PLACE TO CONTINUE.
	SUB	P,[3,,3]	;RE-ADJUST STACK, FLUSHING FILE NAME, EXT, PPN
	POPJ	P,

FIL4:
	SKIPA	TAC1,[0]	;ZERO FILE EXTENSION
FIL3:
	PUSHJ	P,CTEXT		;READ FILE EXTENSION
	PUSH	P,TAC1		;SAVE EXT
FIL3A:
	PUSHJ	P,PJPGNO	;READ PPN
	JRST	FIL6D		;NONE TYPED, GET DEFAULT PPN
	JRST	FIL6		;GO SAVE PPN TYPED

FIL99:
	PUSHJ	P,SKIPS1	;SEE IF ANYTHING EXTRANEOUS AT END OF LINE
	SUB	P,[4,,4]	;YES.  ERROR
	JRST	COMERA		;(SKIPS1 RETURNS UP A LEVEL IF FINDS END OF LINE)

FIL88:
	PUSHJ	P,SKIPS1	;COMEND MAKES THIS CHECK ALSO BUT ONLY REMOVES
	SUB	P,[2,,2]	;	ONE ENTRY FROM STACK INSTEAD OF TWO
	JRST	COMERA

FIL5:
	SUB	P,[1,,1]	;DISCARD SIXBIT JOB NUMBER ON STACK
	JUMPN	TAC,FIL5D	;ZERO JOB NUMBER MEANS OWN JOB,
FIL5C:
	SKIPN	TAC,J		; IF ANY.
	JRST	LOGPLS		; IF NONE, CANT HELP YOU
FIL5D:
	MOVE	TAC1,JBTSTS(TAC);SEE IF THIS JOB NUMBER IS ASSIGNED
	TLNE	TAC1,JNA
	TLNE	TAC1,JSEG	;NO SEGMENTS PLEASE
	JRST	NOTLOG		;NO SUCH JOB
	PUSH	P,TAC		;SAVE JOB NUMBER
	PUSHJ	P,FIL88		;MAKE SURE NOTHING EXTRANEOUS AFTER JOB NUMBER
	PUSHJ	P,CRLF		;BEGINNING NEW FILE SEARCH
FIL5A:
	PUSHJ	P,NXTDSK	;GET NEXT DSK DDB
	JRST	FIL5B		;NONE, DONE
	LDB	TAC1,[POINT 6,DEVCHR(AC1),5] ;PICK UP JOB NUMBER FROM DDB
	CAMN	TAC1,(P)	;IS IT THE JOB OF INTEREST?
FIL5E:
	PUSHJ	P,PTFILE	;YUP.  PRINT FILE STATUS
	JRST	FIL5A		;NOT CORRECT JOB, OR FILE STATUS PRINTED OK
	HRL	AC1,(P)		;NO ROOM TO PRINT FILE STATUS.  SAVE JOB NUMBER
	MOVEM	AC1,SAVDDB(DDB)	; AND CURRENT DSK DDB.
	JRST	TPOPJ		;RE-ADJUST STACK AND RETURN.
FIL5B:
	SETZM	SAVDDB(DDB)	;WE FINISHED.  INDICATE NO PLACE TO CONTINUE.
	JRST	TPOPJ

FIL2JB:
	TDNE	TAC1,[77,,-1]	;CONVERT SIXBIT TEXT TO JOB NUMBER
	JRST	CPOPJ1		;MORE THAN TWO CHARS MEANS NOT JOB NUMBER
	SETZ	TAC,
	LSHC	TAC,6		;GET FIRST SIXBIT CHAR
	SUBI	TAC,'0'		;CONVERT DIGIT TO BINARY
	JUMPL	TAC,CPOPJ1	;NOT DIGIT MEANS NOT JOB NUMBER
	CAILE	TAC,=9
	JRST	CPOPJ1		;NOT DIGIT
	JUMPE	TAC1,CPOPJ	;IF NO SECOND DIGIT, THEN DONE
	ROT	TAC1,6		;GET SECOND DIGIT
	SUBI	TAC1,'0'	;CONVERT SIXBIT DIGIT TO BINARY
	JUMPL	TAC1,CPOPJ1	;NO DIGEE, NO JOBEE
	CAILE	TAC1,=9
	JRST	CPOPJ1		;LOSE
	IMULI	TAC,=10		;SHIFT HIGH-ORDER DIGIT
	ADD	TAC,TAC1	; AND ADD IN LOW-ORDER DIGIT
	POPJ	P,		;DIRECT RETURN WITH JOB NUMBER IN TAC

FIL2:
	PUSHJ	P,COMEND	;MAKE SURE REALLY NO ARG
	HRRZ	TAC,SAVDDB(DDB)	;NO ARGUMENT.  GET PLACE WE QUIT LAST TIME.
	JUMPE	TAC,FIL5C	;FINISHED LAST TIME.  START OVER.
FIL2A:
	PUSHJ	P,NXTDSK	;GET NEXT DSK DDB
	JRST	FIL5C		;NO MORE.  CANT FIND PLACE TO CONTINUE.  START OVER.
	CAME	TAC,AC1		;IS THIS THE DDB WHERE WE QUIT?
	JRST	FIL2A		;NO, TRY AGAIN.
	HLRZ	TAC,SAVDDB(DDB)	;YES.  PICK UP JOB NUMBER WE WERE WORKING ON
	PUSH	P,TAC		;PUT JOB NUMBER ON STACK
	JUMPN	TAC,FIL5E	; AND CONTINUE PRINTING FILES FOR THAT JOB.
	MOVE	TAC,DEVFIL(AC1)	;NO JOB NUMBER.  MUST BE WORKING ON SPECIFIC FILE.
	MOVEM	TAC,(P)
	PUSH	P,DEVEXT(AC1)	; SAVE NAME, EXT, AND PPN OF FILE
	HLLZS	(P)		; CLEAR RIGHT HALF OF EXT WORD
	PUSH	P,FILPPN(AC1)
	JRST	FIL6C		;AND CONTINUE PRINTING REFERENCES TO THAT FILE

PTFILE:
	MOVEI	TAC,=39+4	;PRINT A FILE'S STATUS, AT MOST =39 CHARS NEEDED.
	CAML	TAC,TOFCTR(DDB)	;SEE IF WE HAVE ENOUGH ROOM IN OUTPUT BUFFER
	JRST	PTFIL1		;NOT ENOUGH ROOM.  PRINT " ..." (4 CHARS)
	LDB	TAC,[POINT 6,DEVCHR(AC1),5] ; GET NUMBER OF JOB WITH FILE OPEN
	MOVEI	TEM," "
	CAIGE	TAC,=10		;IF JOB NUMBER LESS THAN =10,
	XCT	TYO		; THEN PAD NUMBER WITH A SPACE
	PUSHJ	P,RADX10	;PRINT JOB NUMBER
	MOVE	TAC1,DEVFIL(AC1);GET FILE NAME
	PUSHJ	P,PR6SIX	; AND PRINT 6 CHARS AFTER SPACE
	HLLZ	TAC1,DEVEXT(AC1);GET FILE EXT
	PUSHJ	P,PR3SIX	; AND PRINT 3 CHARS AFTER SPACE
	MOVE	TAC1,FILPPN(AC1);GET FILE PPN
	PUSHJ	P,PR6SIX	; AND PRINT 6 CHARS AFTER SPACE
	MOVE	TAC,FILLNG(AC1)	;GET FILE LENGTH
	PUSHJ	P,DGETL1	; AND CONVERT TO RECORDS (DGETL1 IS IN DSKSER)
	SKIPE	TAC1,TAC	;IF NON-ZERO, SUBTRACT ONE TO GET NUMBER
	SUBI	TAC1,1		; OF LAST RECORD, NOT FIRST FREE RECORD
	PUSHJ	P,PRREC		; PRINT FILE LENGTH IN RECORDS
	MOVE	TAC1,USETP(AC1)	;GET CURRENT USET POINTER
	PUSHJ	P,PRREC		; AND PRINT IT
	MOVEI	TEM," "
	XCT	TYO		;PRINT A SPACE
	MOVEI	TEM,"U"
	TLNE	AC2,DVUDP	;IS THIS A UDP?
	XCT	TYO		;YES, PRINT "U"
	MOVE	TAC,DEVIOS(AC1)	;SEE WHAT IS HAPPENING TO THIS FILE
	TLNN	TAC,READB	;BEING READ?
	JRST	PTFIL2		;NO
	MOVEI	TEM,"R"		;YES.  PRINT "R"
	XCT	TYO
	MOVEI	TEM,"A"
	TLNE	TAC,ALTERB	;OPEN IN READ-ALTER MODE?
	XCT	TYO		;YUP,  PRINT "A" AFTER THE "R"
	MOVEI	TEM,"E"
	TLNE	TAC,IOEND	;END OF FILE?
	XCT	TYO		;YES, PRINT "E"
	JRST	CRLF		;PRINT CRLF AND RETURN FROM PTFILE
PTFIL2:
	MOVEI	TEM,"W"
	TLNE	TAC,WRITEB	;IS FILE BEING WRITTEN?
	XCT	TYO		;YES, PRINT "W"
	JRST	CRLF		;PRINT CRLF AND RETURN FROM PTFILE

PTFIL1:
	PUSHJ	P,INLMES
	ASCIZ	/ .../
	JRST	CPOPJ1

PR3SIX:
	MOVEI	UCHN,3		;PRINT 3 SIXBIT CHARS
	JRST	.+2
PR6SIX:
	MOVEI	UCHN,6		;PRINT 6 SIXBIT CHARS
	MOVEI	TEM," "
	XCT	TYO
PRSIXA:
	SETZ	TAC,
	LSHC	TAC,6		;GET NEXT SIXBIT CHAR
	MOVEI	TEM,40(TAC)	;PRINT ASCII
	XCT	TYO
	SOJG	UCHN,PRSIXA	;PRINTED ENOUGH CHARS YET?
	POPJ	P,		;YUP

PRREC:
	MOVEI	UCHN,5		;PRINT OCTAL NUMBER IN 6 CHARS WITH LEADING BLANKS
	MOVEI	TEM," "
	HRLZ	TAC1,TAC1	;PUT OCTAL NUMBER IN LEFT HALF OF TAC1
PRREC2:
	SETZ	TAC,
	LSHC	TAC,3		;GET NEXT OCTAL DIGIT
	JUMPN	TAC,PRREC1	;IF NON ZERO, GO PRINT
	XCT	TYO		;OTHERWISE, PRINT SPACE
	SOJG	UCHN,PRREC2	;PRINTED 5 LEADING SPACES YET?
PRREC3:
	SETZ	TAC,
	LSHC	TAC,3		;GET NEXT OCTAL DIGIT
PRREC1:
	MOVEI	TEM,"0"(TAC)	;PRINT ASCII DIGIT
	XCT	TYO
	SOJGE	UCHN,PRREC3	;PRINTED 6 CHARS YET?
	POPJ	P,		;YES.  DONE AT LAST

NXTDSK:
	HLRZ	AC1,DEVSER(AC1)	;GET LINK TO NEXT DDB
	JUMPE	AC1,CPOPJ	;DIRECT RETURN IF NONE
	MOVE	AC2,DEVMOD(AC1)	;GET DEVICE CHARACTERISTICS
	TLNN	AC2,DVDSK	;IS THIS A DSK DDB?
	JRST	NXTDSK		;NO.  GET NEXT DDB
	JRST	CPOPJ1		;YES.  SKIP RETURN WITH DSK DDB
;: CLKSER[J17,SYS] EOF.
;: UUOCON[J17,SYS]
COMMENT ⊗   VALID 00149 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00014 00002	UUOCON	NON-IO SECTION
C00017 00003	HERE WE FIGURE OUT WHOSE FAULT THE UUO IS AND WHO IT IS FOR
C00020 00004	UUO SETUP ROUTINES FOR P2
C00022 00005	HERE WE TELL THE WORLD WE HIT A UUO AT INTERUPT LEVEL AND TRY
C00024 00006	SAVE USER'S ACS, GET A PDL
C00026 00007	HERE WE SET UP A CHANNEL AND DISPATCH
C00029 00008	USRXIT  - WE RETURN HERE EVENTUALLY TO CHECK WITH SCHEDULER
C00032 00009	RESTORE ACS AND DISMISS UUO 
C00035 00010	GET HERE WHEN UUOPTR≠0 TO THINK ABOUT LETTING LOSER SIMULATE UUO
C00037 00011	ROUTINE TO ASSIGN A CHANNEL NUMBER
C00039 00012	TABLE OF UUO DISPATCH ADDRESSES
C00041 00013	IOT UUO DISPATCH TABLE
C00043 00014	CALL AND CALLI
C00046 00015	CALL UUO DISPATCH TABLE
C00049 00016	 THE FOLLOWING ARE STANFORD'S OWN PRIVATE CALLI'S
C00055 00017	 MACROS TO DEFINE CALLI TABLES
C00056 00018	EXIT UUO ROUTINE
C00058 00019	SETPOV - SET PUSH DOWN OVERFLOW TRAP
C00059 00020	RESET UUO ROUTINE
C00062 00021	 ROUTINE TO RESET ONE'S UPPER SEGMENT
C00063 00022	APRDKL  ROUTINE TO KILL ANY CLOCK INTERRUPT REQUESTS FOR JOB J
C00064 00023	APRENB - ROUTINE TO SET UP APR FOR USER TRAPPING
C00066 00024	PJOB, DATE, DAYCNT, ACCTIM, DSKTIM, JOBTIM, MSTIME UUO'S
C00068 00025	SLEEP	PUT JOB TO SLEEP FOR NSECONDS
C00069 00026	SWITCH	RETURN DATA SWITCHES
C00070 00027	DVCHR, DEVNUM
C00072 00028	GETPPN -- DSKPPN
C00076 00029	SETNAM, SETCRD, SETDDT, GETNAM
C00078 00030	WAIT FOR IO TO BECOME INACTIVE ON CHANNEL AC
C00079 00031	GETLN:	PUSHJ PDP,TTYFND	GET NAME OF TTY
C00080 00032	CRKSER -- READ THE PETIT CROCK, J. SAUTER, REST OF PAGE.
C00082 00033	 FINISH READING PCROCK, CONVERT TO STANDARD FORM
C00084 00034	LOGIN UUO.	FOR LOGIN CUSP ONLY.
C00088 00035	 ROUTINE TO SET UP SCHEDULER DATA STRUCTURE FOR A JOB
C00089 00036	SETPRV, GETPRV
C00092 00037	GET A PPN'S SERVICE LEVEL RESERVATION.
C00099 00038	LOGOUT UUO
C00100 00039	 ROUTINE TO READ SPACEWAR BUTTONS
C00101 00040	 ROUTINE TO COMPLEMENT STATE OF DUPLEXING
C00102 00041	 ROUTINE TO GET A WORD FROM MONITOR CORE
C00103 00042	 RUN A JOB UUO
C00105 00043	 SWAP UUO - CONTINUED . . .
C00108 00044	 SWAP UUO - LOG IN NEW JOB AND RUN THIS ON IT - PHANTOM STARTUP
C00112 00045	 ROUTINE TO DO THE GETTING OF A JOB FROM UUO LEVEL
C00115 00046	 ROUTINE TO SAVE ACCUMULATORS OVER RUNJOB UUO
C00117 00047	 EIOTM AND LIOTM UUO'S
C00118 00048	 UUO TO GET THE PHYSICAL NAME OF A DEVICE
C00119 00049	 GET A JOB'S JOB STATUS WORD
C00120 00050	 GET A TELETYPE'S DEVIOS
C00122 00051	COMMENT $		WAKEME
C00125 00052	TRANSLATE SYSTEM CALL TO/FROM SIXBIT.
C00128 00053	CALTU:	ANDI TAC1,777000
C00130 00054	CALT2:	MOVSI TAC1,-IUUMAX*2-40	TOTAL # MAJOR OPCODES
C00132 00055	SETPR2, BEGIN SEGUUO
C00134 00056	 HERE WE ADDRESS CHECK HIS PR REQUEST
C00135 00057	GETPR2
C00136 00058	 REMAP UUO . . .
C00138 00059	 REMAP - CHECK IF HE WANTS IT WRITE PROTECTED
C00140 00060	 REMAP - IF HE IS NOT ON 1K BOUNDARY, ADJUST HIM
C00143 00061	BLTUP - FAST UPWARDS BLT
C00145 00062	HERE WE ITERATE ON BLTS, POSSIBLY STARTING WITH A SMALLER ONE
C00147 00063	 UUO TO SET OR CLEAR USER WRITE-PROTECT BIT
C00148 00064	UNPURE - MAKE A WRITEABLE COPY OF WRITE-PROTECTED UPPER, IF NECESSARY
C00152 00065	UNPURE CONTINUED:
C00155 00066	 CORE UUO FOR HIGH SEGMENTS
C00158 00067	 CORE2 - SCAN FOR ALL JOBS USING THIS SEGMENT AND TELL THEM HE HAS CHANGED SIZE
C00159 00068	 ATTACH HIGH SEGMENT
C00162 00069	ATTSEG	 SEARCH FOR A SEGMENT OF A GIVEN NAME
C00163 00070	DETSEG  DETACH SEGMENT
C00166 00071	 DETSEG - COMMON SEGMENT UUO EXIT ROUTINE
C00167 00072	 GET NUMBER OF SEGMENT BELONGING TO JOB N
C00168 00073	 SEGSIZ CALLING . . .
C00169 00074	 SETNM2 CALLING . . .
C00171 00075	 ROUTINE TO GET YOUR SEGMENT'S NAME
C00172 00076	 THIS UUO FIRST KILLS ANY HIGH SEGMENT YOU MAY HAVE.
C00173 00077	 RETURNS LIST OF JOB NUMBERS WHO POINT TO YOUR UPPER SEGMENT.
C00174 00078	 SET PROTECTION ON A HIGH SEGMENT
C00176 00079		SUBTTL	INTUUO - UUOS FOR NEW STYLE INTERRUPT SYSTEM
C00177 00080	 INTENB
C00179 00081	 CLKENB, CLKENA  - ENABLE FOR USER CLOCK INTERRUPTS
C00183 00082	 INTORM - ROUTINE TO SET BITS IN INTERUPT ENABLE MASK
C00184 00083	 INTACM - CLEARS BITS IN INTERRUPT ENABLE MASK
C00185 00084	 INTENS, INTIIP - ROUTINES TO GIVE BACK INFORMATION
C00186 00085	 INTIRQ - TELLS YOU WHAT INTERRUPTS ARE PENDING
C00187 00086	 DISMIS - TERMINATES CURRENT I-LEVEL RUN
C00189 00087	 INTGEN - ROUTINE TO GENERATE AN INTERRUPT FOR YOURSELF
C00190 00088	 USKIP - ROUTINE TO TELL USER IF HE IS INSIDE A UUO
C00191 00089	 UWAIT - WAITS FOR UUO TO TERMINATE
C00193 00090	 DEBREAK - MAKES I-LEVEL PROCESS TAKE PLACE OF U-LEVEL PROCESS
C00194 00091	 IWAIT - GO INTO INTERRUPT WAIT UNTIL AWAKENED BY AN APPROPRIATE INTERRUPT
C00195 00092	 ROUTINE TO ENABLE INTERRUPTS AND THEN GO INTO INTERRUPT WAIT
C00196 00093	UUOS TO SET THE INTERRUPT MASK
C00198 00094	IMSKST  IMSKCL
C00199 00095	 CLKINT UUO  (CLKUUO) START UP A CLOCKED I-LEVEL JOB
C00204 00096	INTUUO - INTDEJ, IMSTW
C00206 00097	 IWKMSK, IMSKCR
C00207 00098	 INTDMP
C00209 00099	 INTDMP - ERROR RETURNS
C00210 00100	 ROUTINE TO GET A JOB NUMBER FROM A JOB NAME
C00211 00101	 INTIPI
C00213 00102	SUBTTL	UUOCON - STANFORD SPECIAL IO ROUTINES
C00214 00103	THIS UUO GETS THE STANDARD BUFFER LENGTH FOR A DEVICE
C00215 00104	 ROUTINE TO GET THE TIME CELLS AND CLEAR THEM
C00217 00105	RETURNS A CODE TELING WHETHER A JOB NAME IS LOGGED IN
C00219 00106	 DEVUSE - HOW MANY JOBS ARE WAITING FOR A PARTICULAR DEVICE.
C00223 00107	 JOBRD  UUO TO BLT DATA FROM SOME OTHER JOB'S CORE IMAGE TO YOURS.
C00226 00108	 JOBRD - PICK UP ADDRESS OF LAST WORD, ADDRESS CHECK IT
C00228 00109	 JOBRD - GET FREE STORAGE FOR DATA, PLANT CLOCK REQUEST TO DO TRANSFER
C00230 00110	 JOBRD - WE GET HERE AT CLOCK LEVEL . . .
C00234 00111	TMPCOR UUO - BEHAVES AS DESCRIBED IN DEC MANUAL
C00238 00112	CHECK & RELOCATE TMPCOR WCMA
C00240 00113	WRITE TMPCOR FILE
C00243 00114	UUOCON	IO SECTION
C00245 00115	IOPUSH, IOPOP, IOPDL
C00250 00116	 CLOSE UUO - CALLING SEQUENCE
C00251 00117	 CLOSE CODE - WAIT FOR IO TO FINISH, FLUSH BUFFERS
C00254 00118	 CLOSE CODE
C00257 00119	 CLOSE - CALL DEVICE DEPENDENT ROUTINE
C00258 00120	 INBUF - CALLING SEQUENCE
C00259 00121	 SET UP BUFFERS OF USER-SPECIFIED LENGTH
C00261 00122	 UINBF - CALLING SEQUENCE . . .
C00263 00123	ERROR MESSAGES FOR INBUF, OUTBUF, UINBF, AND UOUTBF UUOS
C00264 00124	OPEN UUO - PERFORMS SAME OPERATION AS INIT
C00265 00125	 INIT - CALLING SEQUENCE
C00267 00126	 INIT CODE - FIRST FIND DEVICE AND TRY TO ASSIGN IT
C00274 00127	 HERE WE ASK HIM IF HE IS WILLING TO WAIT FOR THE DEVICE
C00277 00128	 DEVICE WAIT - CAN'T GET IT, SEE IF HE WANTS DISK
C00278 00129	CALLING SEQUENCE
C00279 00130	LONG DISPATCH TABLE UUOS - GET HERE ONLY IF DEVICE HAS LONG
C00281 00131	RENAME UUO - HERE ON SHORT DISPATCH TABLE DEVICES TOO
C00283 00132	INPUT UUO
C00285 00133	 HERE IF INPUT NEEDS LOOKUP. GET FILE NAME FROM LOSER.
C00287 00134	 INPUT UUO - HERE, WE ARE SATISFIED DEVICE IS PROPERLY LOOKED UP
C00290 00135	 INPUT UUO CONT.
C00292 00136	HERE ON FIRST INPUT AFTER INIT, INIT & LOOKUP, OR INIT & LOOKUP & INPUT
C00294 00137	 CALL THE DEVICE INPUT ROUTIN
C00296 00138	 OUTPUT UUO - CALLING SEQUENCE
C00299 00139	HERE ON OUTPUT UUO
C00301 00140	 OUTPUT UUO - HERE WE ARE SATISFIED DEVICE HAS BEEN PROPERLY ENTERED
C00304 00141	 OUTPUT UUO - HERE, WE ADVANCE BUFFER ADDRESS, START OUTPUT, AND WAIT FOR
C00308 00142	 SUBROUTINE FOR OUTPUT UUO
C00309 00143	RELEASE A DEVICE
C00313 00144	 RELEAS CODE - SEE IF THERE IS ANYONE WAITING FOR THE DEVICE
C00314 00145	 UUOS TO TEST IO STATUS WORD
C00315 00146	 MORE STATUS UUOS
C00316 00147	 STILL MORE STATUS UUOS
C00317 00148	IN UUO - LIKE INPUT	SKIPS IF  EOF OR ERRORS
C00318 00149	SPACEWAR UUOS
C00319 ENDMK
C⊗;

SUBTTL	UUOCON	NON-IO SECTION
;UUOCON (BOTH SECTIONS) CONSISTS OF THE UUO TRAP HANDLER
;THE CALL UUO ROUTINES AND THE IO UUO ROUTINES
;SOME UUO DO DISPATCH TO OTHER ROUTINES OUTSIDE OF UUOCON
;ALL UUOS DROP THEMSELVES IN REAL LOCATION 40, AND TRAP TO 41.

;SYSTEM UUOS(40-77) FIRST SAVE THE USERS ACS IN RELATIVE LOC 0-17
;THEN THE FOLLOWING ACS ARE LOADED UP BEFORE DISPATCHING:
;	PDP	;PUSHDOWN LIST IN CURRENT JOB DATA AREA
;	PROG	;CURRENT JOB RELOCATION IN RH,PROTECTION IN LH
;	JDAT	;ADDRESS OF CURRENT JOB DATA AREA
;	UUO	;THE CONTENTS OF LOC 40 WITH PROG IN INDEX FIELD
;		;SO THAT RELOCATION CAN BE DONE FOR PICKING UP ARGUMENTS
;	DEVDAT	;ADR. OF DEVICE DATA BLOCK
;	IOS	;DEVICE IO STATUS WORD
;	DSER	;ADR. OF DEVICE SERVICE ROUT. DISPATCH TABLE
;	UCHN	;THE USER IO CHANNEL(AC FIELD) OF UUO

;RETURN IS PUT IN UUOPC(JOB)
;THEN IF CALL WAS FROM USER MODE, THE UUO ROUTINE IS CALLED
;WITH A PUSHJ, SO THAT ALL UUO ROUTINE RETURN WITH A POPJ PDP,
;WHICH WILL RETURN CONTROL TO UUOCON WHICH WILL RESTORE USERS
;ACS AND RETURN TO HIM
;IF THE CALL IS FROM EXEC MODE, THE UUO ROUTINE IS CALLED
;BY DOING JUST A JRST,  WHEN THE UUO ROUTINE RETURNS WITH
;A POPJ, IT WILL RETURN TO THE EXEC WITHOUT RESTORING
;ANY ACS
;CONTROL MAY ALWAYS BE RETURNED BY EXECUTING A
;	POPJ	P,
;WHICH WILL RESTORE THE ACS, APR BITS, AND RETURN.
;THE UUO HANDLER IS PURE IF THE FOLLOWING RESTRICTIONS ARE OBSERVED.
;RESTRICTIONS: UUOS CANNOT BE CALLED BY INTERRUPT SERVICE ROUTINES.

;HERE WE FIGURE OUT WHOSE FAULT THE UUO IS AND WHO IT IS FOR

↑UUO1:	MOVEM	17,UUO.SA+17		;SAVE ALL AC'S FOR ILLUUO FROM EXEC
	MOVEI	17,UUO.SA
	BLT	17,UUO.SA+16
	MOVE	17,UUO.SA+17		;RESTORE AC 17
	CONSO	PI,177⊗8		;ARE WE AT INTERRUPT LEVEL?
	JRST	NOPCK			;NO.
	EXCH	TAC,UUO0+P1PID		;SAVE TAC, GET PC OF UUO + 1
	TLNN	TAC,USRMOD		;USER MODE?
	JRST	UUOX			;UUO FROM EXEC WHILE PI IN PROG - ILLEGAL
	EXCH	TAC,UUO0+P1PID		;RESTORE TAC
NOPCK:
	SKIPN	SPWUUF			;ARE WE RUNNING SPACEWAR NOW?
	JRST	UUO1B			;NO.
	MOVEM	17,SPWSAC+17
	MOVEI	17,SPWSAC
	BLT	17,SPWSAC+16		;STUFF THE SPACEWARE AC'S AWAY.
	MOVEI	PID,P1PID
	JRST	SPWUUO			;LET SPWSER PROCESS IT

UUO1B:
	MOVEM	17,USRSAV+P1PID		;SAVE AC 17
	MOVE	17,UUO0+P1PID		;GET PROCESSOR FLAGS
	TLNE	17,USRMOD		;IS UUO FROM MONITOR?
	JRST	UUO1A			;NO. ORDINARY FROM USER MODE
	MOVE	DAT,UUO0+P1PID		;UUO FROM EXEC
	MOVEI	PID,P1PID
	MOVE	UUO,@UUOLOC(PID)
	MOVE	J,JOB(PID)
	JRST	UUOSY1			;UUO FROM SYSTEM

↑UUO1A:	SKIPE	17,JOBADR+P1PID		;GET JOB DATA AREA ADDRESS
	JRST	UUOSYS			;HAPPY
	MOVEI	PID,P1PID		;NO JOB DATA AREA
	JRST	NULJB			;MUST BE AILING NULL JOB

↑UUO3:	EXCH	TAC,UUO2+P1PID		;TRAP TO LOCATION 60.
IFN FTXCTR,<
	TLNN TAC,USRMOD
	JRST PGRSM			;SIMULATE XCTRS
↑UUO3A:>
	MOVEM	TAC,UUO0+P1PID		;ILLEGAL FOR NOW.
	MOVE	TAC,UUO2+P1PID		;RESTORE TAC.
	SETZM	@UUOLOC+P1PID		;MAKE LOOK LIKE ILL INSTR.
	JRST	UUO1			;TRAPPING TO 40.

;UUO SETUP ROUTINES FOR P2

↑P2UUO1:
	CONSO	PI,177⊗8		;INTERRUPT LEVEL?
	JRST	P2NOPCK			;NO.
	EXCH	TAC,UUO0+P2PID
	TLNN	TAC,USRMOD		;FROM USER MODE?
	JRST	P2UUOX			;NO, LOSE
	EXCH	TAC,UUO0+P2PID
P2NOPCK:
SKIPN	SPWUUF+P2PID
	JRST	P2UU1B			;NOT SPACEWAR LEVEL
	MOVEM	17,SP2SAC+17
	MOVEI	17,SP2SAC
	BLT	17,SP2SAC+16		;SAVE SPACEWAR AC'S
	MOVEI	PID,P2PID
	JRST	SPWUUO			;LET SPWSER THINK ABOUT THIS

P2UU1B:
	MOVEM	17,USRSAV+P2PID		;SAVE AC 17
	MOVE	17,UUO0+P2PID		;GET PROCESSOR FLAGS
	TLNE	17,USRMOD		;IS UUO FROM MONITOR?
	JRST	P2UU1A			;USER LEVEL UUO
	MOVE	DAT,UUO0+P2PID		;SYSTEM UUO
	MOVEI	PID,P2PID
	MOVE	UUO,@UUOLOC(PID)
	MOVE	J,JOB(PID)
	JRST	UUOSY1

↑P2UU1A:
	SKIPE	17,JOBADR+P2PID		;GET JOB DATA AREA ADDRESS
	JRST	U2OSYS			;THERE IS ONE.
	MOVEI	PID,P2PID		;NO CORE FOR JOB
	JRST	NULJB			;MUST BE AILING NULL JOB

↑P2UUO3:
	EXCH	TAC,UUO2+P2PID		;TRAP TO LOCATION 60.
	MOVEM	TAC,UUO0+P2PID		;ILLEGAL FOR NOW.
	MOVE	TAC,UUO2+P2PID		;RESTORE TAC.
	SETZM	@UUOLOC+P2PID		;MAKE LOOK LIKE ILL INSTR.
	JRST	P2UUO1			;TRAPPING TO 40.

;HERE WE TELL THE WORLD WE HIT A UUO AT INTERUPT LEVEL AND TRY
;TO FIGURE OUT WHAT TO DO!

UUOX:
	EXCH	TAC,UUO0+P1PID		;RESTORE TAC, UUO0
	CONO	PI,PIOFF		;HOLD EVERYTHING
	EXCH	P,ERRPD+P1PID		;GET A PDL
	PUSHACS
	MOVEI	PID,P1PID
	JRST	UUOX1

P2UUOX:
	EXCH	TAC,UUO0+P2PID
	CONO	PI,PIOFF
	EXCH	P,ERRPD+P2PID
	PUSHACS
	MOVEI	PID,P2PID
UUOX1:
	SOS	UUO0(PID)		;FIX UP ADDRESS FOR PRINTING AND RETURN
	PUSHJ	P,DISMES
	ASCIZ /ILLEGAL UUO FROM EXEC WHILE PI IN PROGRESS
PI = /
	CONI	PI,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISERR
	[ASCIZ/
P  = /]
	DISARG OCT,<ERRPD(PID)>	;OLD STACK
	[ASCIZ/    C(P) = /]
	-1
	HRRZ	TAC,ERRPD(PID)
	MOVE	TAC,(TAC)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISERR
	[ASCIZ/
PC = /]
	DISARG OCT,<UUO0(PID)>
	[ASCIZ/    UUO  = /]
	DISARG OCT,<@UUOLOC(PID)>
	[ASCIZ/
(WILL RETURN VIA JRST 2,@UUO0)
/]
	-1
	PUSHJ P,SYSFIX
	JFCL				;COULDN'T FIX ERROR
	CAIA
	JRST	UUOX2			;FIXED AN ERROR
	PUSHJ	P,DISFLUSH
	PUSHJ	P,DDTCALL
UUOX2:
	JUMPN	PID,P2UUX2
	POPACS
	EXCH	P,ERRPD(PID)
	CONO	PI,PION
	JRST	2,@UUO0+P1PID		;TRY TO GO ON!

P2UUX2:
	POPACS
	EXCH	P,ERRPD(PID)
	CONO	PI,PION
	JRST	2,@UUO0+P2PID

;SAVE USER'S ACS, GET A PDL

U2OSYS:
	MOVEM	16,16(17)
	MOVEI	16,(17)
	BLT	16,15(17)
	MOVE	TAC,USRSAV+P2PID
	MOVEM	TAC,17(17)
	MOVEI	PID,P2PID
	JRST	UUOSY2

UUOSYS:
	MOVEM	16,16(17)		;STORE AC16 IN USER 16
	MOVEI	16,(17)			;SET UP BLT POINTER
	BLT	16,15(17)		;MOVE REAL AC'S TO USER AREA
	MOVE	TAC,USRSAV+P1PID	;MOVE USER 17 TO USER'S AREA
	MOVEM	TAC,17(17)
	MOVEI	PID,P1PID
UUOSY2:
	MOVE	PROG,17			;LOAD UP POINTER TO USER PROGRAM AREA
IFN JDMPRG,<
	MOVE	JDAT,JOBDAT(PID)	;ADDRESS OF JOB DATA AREA
>
	MOVE	J,JOB(PID)		; PICK UP JOB NUMBER
	MOVE	DAT,UUO0(PID)		; SAVE RETURN IN ACS
	MOVE	UUO,@UUOLOC(PID)	; AND SAVE UUO ALSO
	SKIPE	INTACT(PID)
	SKIPA	P,INTSP(PID)		;USE INTERRUPT LEVEL PDL
	JSP	TAC,GETPDL		; GET US A PDL

;HERE WE SET UP A CHANNEL AND DISPATCH

↑UUOSY1:EXCH	DAT,UUOPC(J)		; SAVE RETURN
	MOVEM	DAT,UUOOPC(J)		; SAVE OLD RETURN IN CASE ILL. UUO INSIDE UUO CODE.
	SKIPE DAT,UUOPTR(J)
	JRST UUOSY4			;MAYBE LOSER WANTS TO SIMULATE IT
UUOSY3:
	TLNN	UUO,740000		;SYSTEM UUO?
ILEGAL:
	JRST	UUOERR			;NO, 0-37 ARE ILLEGAL,PRINT ERROR
	TLO	UUO,PROG		;SET FOR RELOCATION
	LDB	UCHN,PUUOAC		; SETUP USER DEVICE CHANNEL NUMBER
	LDB	TAC1,[POINT 9,UUO,8]	;PICK UP UUO OP CODE
	XORI	TAC1,700		; IS THIS AN IOT UUO?
	TRCN	TAC1,700
	JRST	UUOIOT			; YES, SEPARATE DISPATCH TABLE
	CAIL	TAC1,100		;ILLEGAL INSTRUCTION?
	JRST	ILLINS			;YES, STOP JOB AND PRINT ERROR
	PUSHJ	P,CHNSET		; CHECK CHANNEL NUMBER AND LOAD IOS AND DSER
	JRST	USRXIT			; NO CHANNEL, BUT UUO LEGAL ANYWAY
	JRST	USRXT1			; THINGS LIKE LOOKUP AND ENTER ON NON-DIRECTORY DEVICES GET HERE
	ROT	TAC1,-1			;DIVIDE UUO OPCODE BY 2, SAVE REMAINDER
	MOVE	DAT,UUOTAB-20(TAC1)	;GET DISPATCH TABLE ENTRY
DISP4:
	TLNN	TAC1,400000		;WAS UUO ODD?
	MOVS	DAT,DAT			;NO, USE LH OF DISPATCH ENTRY
	AOS	NUUOS
	PUSHJ	P,(DAT)			;NO, FROM USER. ROUTINES ALL RETURN BY POPJ
					;BEGINNING HERE WE WON'T TAKE USER INTS
USRXT0:

	JRST	USRXIT			;NO SKIP RETURN REQUIRED
	JRST	USRXT1
	MOVE	J,JOB(PID)
	AOSA	UUOPC(J)
USRXT1:
	MOVE	J,JOB(PID)
	AOS	UUOPC(J)		; SKIP RETURN TO USER

;USRXIT  - WE RETURN HERE EVENTUALLY TO CHECK WITH SCHEDULER
; TO SEE IF IT WANTS TO RESCHEDULE THIS JOB

↑USRXIT:MOVE	J,JOB(PID)
	SKIPN	SPWUUF(PID)		;ARE WE AT SPACEWAR LEVEL ?
	JRST	USRXT6			;NO.
	MOVE	TAC,UUOPC(ITEM)
	POP	P,UUOPC(J)		; RESTORE OLD PC WORD
	MOVEM	TAC,UUO0(PID)
	JUMPE	PID,USRXT7
	MOVSI	17,SP2SAC
	BLT	17,17
	XCT	SPWXCT+P2PID		;USUALLY JRST 2,@UUO0+P2PID

USRXT7:
	MOVSI	17,SPWSAC		; RESTORE SPW ACS
	BLT	17,17
	XCT	SPWXCT			;USUALLY JRST 2,@UUO0 ;RETURN TO SPW JOB

USRXT6:
	SKIPE	INTACT(PID)		;USER INTERRUPT LEVEL?
	JRST	USRXT4			;YES, SKIP SCHEDULING CHECK
	SKIPL	TAC,JBTSTS(J)		;STILL RUNNABLE?
	JRST	USRXT9			;NO - RUN BIT OFF - PUT HIM IN STOPQ
	TLNE	TAC,STOPIO		;YES?
USRXT2:
	PUSHJ	P,USRXTS		;NO, CAUSE CLK INT ON EXIT
	MOVSI	UCHN,INTWAIT		;ARE WE ENABLED FOR INTERRUPT WAIT INTERRUPT?
	TDNN	UCHN,JBTIEN(J)
	JRST	USRXT4			;NOT ENABLED FOR INT-WAIT INTERRUPT
	SETOM	INTHLD(PID)		;MAKE SURE WE DON'T GET TO INTNOW FROM HERE
	IORM	UCHN,JBTIRQ(J)
	SETZM	INTHLD(PID)		;INTNOW WILL WIN NOW
	SETOM	INTREQ(PID)
USRX4A:
	PUSHJ	P,USRXTS		;INT ON WAY BACK TO LOSER
USRXT4:
	MOVEI	DAT,USRXT5
	EXCH	DAT,UUOPC(J)
	TLNN	DAT,USRMOD
	JUMPN DAT,@DAT		;RETURN DIRECT IF EXEC MODE, UNLESS 0 (EXIT UUO)
REPEAT 0,<
	MOVSI	AC1,RUN2
	SKIPN	PID
	MOVSI	AC1,RUN1
	TDNN	AC1,JB2STS(J)
	PUSHJ	P,PSWITCH
>

;RESTORE ACS AND DISMISS UUO 

	MOVEM	DAT,UUO0(PID)
	MOVE	JDAT,JBTADR(J)		; MAKE SURE USER'S RELOCATION IS SET UP
	MOVSI	17,JOBAC(PROG)		;RESTORE ALL USER ACS
	JUMPE	PID,USRXT8
	BLT	17,17
	XCT	UUOXIT+P2PID		;JEN @UUO0+P2PID OR CONO PI,PIOFF
	SETOM	CLKFLG+P2PID		;CAUSES TRAP TO CLKIN0 INSTEAD OF CLKINT
	SETOM SCHEDF+P2PID
CONO PI,4201;;replaced;;	CONO	PI,PION!4000!<200⊗-CLKCHN>
	CONSO	PI,77000
	JRST	CL2IN0
	JRST	10,.-2

USRXT8:
	BLT	17,17
				; JEN WILL RESTORE FLAGS AND RETURN TO USER
				;DISMISS INTERRUPT ONLY ON TRPJEN UUO
				;IN ALL OTHER CASES NO INTERRUPTS
				;IN PROGRESS
	XCT	UUOXIT		;JEN @UUO0 OR CONO PI,PIOFF
	SETOM	CLKFLG		;HERE WITH INTS OFF IF CLOCK HAS TICKED (SEE CLKINT)
	SETOM SCHEDF		;IN CASE OF 0 PC FROM EXIT
CONO PI,4201;;replaced;;	CONO	PI,PION!4000!<200⊗-CLKCHN>	;NOW (GOES TO CLKIN0 SINCE CLKFLG<0)
	CONSO	PI,77000	;GET HERE ON TRPJEN (ALREADY IN PROGRESS)
	JRST	CLKIN0		;CH7, JUST GO
	JRST	10,.-2		;HIGHER CHN, DISMISS (SHOULDN'T RETURN)

;ROUTINE TO FORCE CLOCK BREAK UPON RETURN TO USER
;ONLY CALL WHEN NEARLY READY TO EXIT FOR INTNOW TO WORK.
USRXTS:
	MOVE	TAC,[CONO PI,PIOFF]
	MOVEM	TAC,UUOXIT(PID)
	POPJ	P,

;GET HERE IF RUN BIT WAS OFF
USRXT9:
	MOVNI	TAC,STOPQ
	MOVEM	TAC,JOBQUE(J)
	JRST	USRXT2		;GO FORCE SCHEDULE

USRXT5:
				;BEYOND HERE USER INTS OK
	CONO	PI,PIOFF
	SETOM	DISFLAG
	PUSHJ	P,DISMES
	ASCIZ	/πππππEXITING UUOCON WITHOUT HAVING ENTERED UUOCON
/
	PUSHJ	P,DISFLUSH
	JRST	AUTOLOAD

;GET HERE WHEN UUOPTR≠0 TO THINK ABOUT LETTING LOSER SIMULATE UUO
;UUOPTR POINTS TO TABLE (IN LOSER'S CORE) OF 3 3-WORD BLOCKS
;EACH BLOCK LOOKS LIKE THIS:

;WD0:	PLACE TO SAVE PC
;WD1:	PLACE TO SAVE UUO ITSELF
;WD2:	PC TO TRANSFER TO

;THE FIRST BLOCK IS USED FOR PDP-10 MAIN PROGRAM UUOS, THE SECOND FOR PDP-10
;INTERRUPT LEVEL UUOS, AND THE THIRD FOR PDP-10 SPACEWAR UUOS. NO PDP-6 UUOS
;CAN BE SIMULATED.  IF EITHER WD1≠0 OR WD2=0 IN A GIVEN BLOCK, THOSE
;UUOS ARE NOT GIVEN TO THE USER'S HANDLER.  THE WD1≠0 CONDITION HAS THE
;EFFECT OF AUTOMATICALLY DISABLING SIMULATION WHILE IN THE SIMULATOR.

UUOSY4:
	SKIPE	INTACT(PID)	;FIRST MAKE PNTR TO APPROP BLK
	ADDI	DAT,3
	SKIPE	SPWUUF(PID)
	ADDI	DAT,6
	XCTR	XR,[SKIPN 1(DAT)]	;NOW SEE IF HE REALLY WANTS TO SIMULATE THIS
	XCTR	XR,[SKIPN TAC,2(DAT)]
	JRST	UUOSY3			;NOPE, WE'LL DO OUR THING AS USUAL
	XCTR	XW,[MOVEM UUO,1(DAT)]
	TLO	TAC,USRMOD
	EXCH	TAC,UUOPC(J)		;SWAP PC'S AROUND
	XCTR	XW,[MOVEM TAC,(DAT)]
	JRST	USRXIT			;AND "RETURN" TO HIS SIMULATOR

↑SPWBLK←←6	;TELL SPWSER WHERE TO LOOK

;UUO TO SET UUOPTR TO ENABLE/DISABLE SIMULATOR
;CALL:
;	UUOSIM AC,
;SETS UUOPTR TO C(AC)

UUOSIM:
	MOVEM	TAC,UUOPTR(J)
	POPJ	P,

;ROUTINE TO ASSIGN A CHANNEL NUMBER

CHNSET:
	POP	P,DAT			;POP UP RETURN ADDRESS
	SKIPE	DDB,USRJDA(UCHN)	;GET ADRESS OF DEVICE DATA BLOCK
	CAMLE	UCHN,USRHCU(PID)	;IS IT LESS THAN OR EQUAL TO HIGHEST
					;USER IO CHANNEL IN USE FOR CURRENT JOB?
	JRST	NOCHAN			;CHANNEL NOT ASSIGNED
CHNSE1:
	MOVE	IOS,DEVIOS(DDB)		;GET DATA BLOCK STATUS WORD
	MOVE	DSER,DEVSER(DDB)	;SETUP IO SERVICE DISPATCH TABLE ADDRESS
	CAIL	TAC1,LNGUUO		;LONG DISPATCH TABLE UUO?
	JRST	CHNSE3			;YES
	JRST	2(DAT)

NOCHAN:
	MOVE	TAC,UUOPC(J)		;IS UUO FROM USER MODE?
	CAIGE	TAC1,IOUUO		;IO UUO?
	JRST	CHNSE2			;NO.
REPEAT 0,<
	PUSHJ	P,GOTOP1		;ALL IO DONE FROM P1
>
	TLNN	TAC,USRMOD
	JRST	CHNSE1			;EXEC MODE
	CAIE	TAC1,70			;YES,IS IT CLOSE OR RELEASE?
	CAIN	TAC1,71			;CLOSE AND RELEASE ALWAYS LEGAL
	JRST	(DAT)
	JRST	IOIERR			;NO, PRINT IO TO UNASSIGNED CHANNEL AND STOP JOB

CHNSE2:
	MOVEI DEVDAT,0		;SET DEVDAT 0 TO FLAG NON-IO UUO
	JRST 2(DAT)		;GO DISPATCH

CHNSE3:
	MOVE TAC,DEVMOD(DEVDAT)	;LONG DISPATCH TABLE UUO
	TLNE TAC,DVLNG		;DOES THIS DEVICE HAVE A LONG DISPATCH TABLE?
	JRST 2(DAT)		;YES, DISPATCH
	CAIGE TAC1,76		;NO, IS UUO LOOKUP OR ENTER?
	JRST (DAT)		;NO, RETURN TO USER
	JRST 1(DAT)		;YES, SKIP RETURN TO USER

;TABLE OF UUO DISPATCH ADDRESSES
;IN FORMAT:
;	XWD 40,41
;	XWD 42,43
;	.
;	XWD 76,77
;THERE'D BETTER BE EXACTLY 40 ENTRIES HERE

DEFINE UUOS{FOR X IN(CALL,INIT,,SPCWAR,,,,<CALLI>	;40-47
,OPEN,<TTYUUO,TTYUUO>,,,,RENAME,<IN,TIN>,<OUT,TOUT>	;50-57
,<SETSTS,SETIOS>,STATO,<GETSTS,USTATS>,<STATZ>		;60-63
,<INBUF,UINBF>,<OUTBUF,UOUTBF>,<INPUT,IN>,<OUTPUT,UOUT>	;64-67
,<CLOSE,CLOSE1>,<RELEAS,RELEA1>,MTAPE,<UGETF,UDGF>	;70-73
,<USETI,UDSI>,<USETO,UDSO>,<LOOKUP,UDLK>,<ENTER,UDEN>)}	;74-77

DEFINE UUOADR(C,A,B)
{IFE UUOPHZ,<DEFINE UUOAD1<0,A,B>;>XWD UUOAD2(C,\UUOAD1),UUOAD2(C,,A,B)
UUOPHZ←←1-UUOPHZ}

DEFINE UUOAD2!(C,X,A,B)
{IFIDN <A!B><><UUOERR+>IFDIF <B><><B+>IFDIF <A><><IFIDN <B><><C!A+>>0}

UUOPHZ←←0
UUOTAB:
;; HERE manual expand the ignobly programmed, rats nested,
;; macro expansion with lots of conditional assembly for
;;      UUOS { UUOADR U,X }
;; The result of the above commented out crap is a dispatch table for UUO routines
;; that could have been more clearly implemented in its day as follows:
;; `2013-03-02 bgbaumgart@mac.com'
BYTE(18)UCALL,UINIT,UUOERR,USPCWAR,UUOERR,UUOERR,UUOERR,UCALLI  ;40-47 CALL INIT - SPCWAR - - - CALLI
BYTE(18)UOPEN,TTYUUO,UUOERR,UUOERR,UUOERR,URENAME,TIN,TOUT      ;50-57 OPEN TTYUUO - - - RENAME IN OUT
BYTE(18)SETIOS,USTATO,USTATS,USTATZ,UINBF,UOUTBF,IN,UOUT	;60-67 SETSTS STATO GETSTS STATZ INBUF OUTBUF INPUT OUTPUT
BYTE(18)CLOSE1,RELEA1,UMTAPE,UDGF,UDSI,UDSO,UDLK,UDEN    	;74-77 CLOSE RELEASE MTAPE UGETF USETI USETO LOOKUP ENTER

XP IOUUO,55			;LOWEST IO UUO(RENAME)
XP LNGUUO,72			;LOWEST LONG DISPATCH TABLE UUO

;IOT UUO DISPATCH TABLE

UUOIOT:
	SUBI TAC1,700		; MAKE 700-777 INTO 0-77
	CAIL TAC1,2*IUUMAX	; DOES THIS ONE EXIST?
	JRST ILLINS		; NO, ILLEGAL INSTRUCTION
	AOS NIOTS		; BUMP NUMBER OF IOT UUOS USED
	ROT TAC1,-1
	MOVE DAT,IUUTAB(TAC1)	; PICK UP DISPATCH ADDRESS
	MOVEI DEVDAT,[SIXBIT /GARPLY/]	;INIT. FOR ERROR PRINTOUTS.
	AOS NNUUOS		; BUMP COUNT OF DISPATCHES
	JRST DISP4

DEFINE IUUOS{FOR X IN(<,CPOPJ>,DPYCLR,PPIOT,<UPGIOT>		;700-703
,<UINBF,MINBF>,<UOUTBF,MOUTBF>,<FBREAD,UFBRD>,<FBWRT,UFBWRT>	;704-707
,<MAIL,UMAIL>,PTYUUO,POINTS,<UPGMVE,UPGMOV>			;710-713
,UPGMVM,PGIOT,CHNSTS,<CLKINT,CLKUUO>				;714-717
,INTMSK,IMSKST,IMSKCL,INTUUO,IOPUSH,IOPOP,IOPDL)}		;720-726

UUOPHZ←←0
IUUTAB:
	;difficult macro IUUOS { UUOADR ,X }
BLOCK 14 ;place holder
; IFN UUOPHZ,<UUOADR>
IUUMAX←←.-IUUTAB

;UUO NAME TABLE, FOR FAIL, ETC.

IFE UUOPHZ,<IUUMAX*2,,UUOFLK;>;;else;;IUUMAX*2-1,,UUOFLK ;LINK TO TABLES FOR TTYUUO, ETC.
↑UUONAM:
UUOS{<SIXBIT,X,>}
IUUOS{<SIXBIT,X,>}


;CALL AND CALLI
; CALLING SEQUENCE
;	CALL D,[SIXBIT/NAME/]
; WHERE NAME IS THE NAME OF A SYSTEM ROUTINE.
; IF NO SYSTEM ROUTINE WITH THE SPECIFIED NAME IF FOUND, THIS ROUTINE
; EXITS TO UUOERR.
;CONTENTS OF USER AC PLACED IN AC TAC,UUO SET TO POINT
;TO USER AC, PROG IN LH.
;ITEM SET TO JOB NUMBER



UCALL:

	XCTR	XR,[MOVE DAT,(UUO)]	;PICK UP NAME OF SYSTEM ROUTINE
	MOVSI	TAC1,-UCLLEN
	CAME	DAT,UCLTAB(TAC1)	;SEARCH SYSTEM ROUTINE NAME TABLE
	AOBJN	TAC1,.-1
	TLZN	TAC1,-1			;CLEAR LH. WAS IT ZERO?
	JRST	UUOERR			;YES. RAN OUT OF TABLE
	JRST	UCALL1			;NO. DISPATCH.


;CALLI UUO	-	CALL IMMEDIATE
;CALLI D,E
;WHERE E IS RELATIVE INDEX IN CALL TABLE


↑UCALLI:
	HRRZ	TAC1,UUO
	CAIL	TAC1,UCLDLN		;EXCEED ?
	JRST	UCALL2			;YES. ERROR
UCALL1:
	POP	P,TAC			;REMOVE RETURN
	HRR	UUO,UCHN		;UUO AC FIELD
	XCTR	XR,[MOVE TAC,(UUO)]	;PICK UP CONTENTS OF USER AC
	ROT	TAC1,-1			;DIVIDE BY 2 AND SAVE REMAINDER
	MOVE	DAT,UCLJMP(TAC1)	;GET DISPACTH TABLE ENTRY
	MOVE	J,JOB(PID)
	JRST	DISP4			;AND GO DISPATCH

UCALL2:
	TRZN	UUO,400000		;IS HE ASKING FOR A STANFORD CALLI?
	JRST	UUOERR			;NO, SHOOT HIM!! BANG!
	MOVEI	TAC1,UCLDLN(UUO)
	CAIL	TAC1,UCLDLN		;IF NOT BIGGER THAN THIS, FLUSH IT!
	CAIL	TAC1,UCLLEN		;STILL TOO LARGE?
	JRST	UUOERR			;YES, FLUSH
	AOS	NSCALL			;BUMP NUMBER OF STANFORD CALLIS USED
	JRST	UCALL1

;CALL UUO DISPATCH TABLE
;NEW UUOS MUST BE ADDED AT END SINCE CALLI DEPENDS ON
;POSITION IN TABLE
;ALSO NUMBER OF DEC CALLIS MUST BE EVEN


DEFINE NAMES!,<
	X RESET,RESETUUO	;RESET IO
	X DDTIN,DDTIN		;EXT-GET DDT CHAR.
	X SETDDT,SETDDT		;SETDDT LOC IN PROTECTED JOB DATA
	X DDTOUT,DDTOUT		;EXT:SEND DDT CHAR.
	X DEVCHR,DVCHR		;DEVICE CHARACTISTICS
	X DDTGT,CPOPJ		;GET DDT MODE
	X GETCHR,DVCHR		;DEVICE CHAR.(DIFF. NAME)
	X DDTRL,CPOPJ		;RELEASE DDT MODE

	X WAIT,WAIT		;WAIT TILL DEVICE INACTIVE
	X CORE,CORUUO		;CORE UUO
	X EXIT,EXIT		;EXIT
	X UTPCLR,UTPCLR		;CLEAR DEC TAPE DIRECTORY 
	X DATE,DATE		;GET DATE
	X LOGIN,LOGIN		;LOGIN
	X APRENB,APRENB		;ENABLE APR FOR TRAPPING
	X LOGOUT,LOGOUT		;LOGOUT

	X SWITCH,SWITCH		;RETURN DATA SWITCHES
	X REASSIGN,REASSIGN	;REASSIGN DEVICE TO ANOTHER JOB
	X TIMER,TIMER		;RETURN JIFFY CLOCK TIME
	X MSTIME,MSTIME		;RETURN TIME OF DAY IN MS
	X GETPPN,GETPPN		;RETURN PROJECT-PROGRAMMER NUMBER
	X <>,UUOERR		;TRPSET ILLEGAL
	X <>,UUOERR		;TRPJEN ILLEGAL
	X RUNTIM,JOBTIM		;RETURN TOTAL JOB RUNNING TIME

	X PJOB,JOBNO		;RETURN JOB NUMBER
	X SLEEP,SLEEP		;SLEEP FOR N SECONDS, THEN RETURN TO USER
	X SETPOV,SETPOV		;SET PUSH DOWN OVERFLOW TRAP (FOR COMPAT ONLY)
	X PEEK,PEEK		;PEEK INTO SYSTEM CORE.		;JS
	X GETLN,GETLN		;GET NAME OF TTY
	X RUN,RUNUUO		;DEC'S SWAP UUO
	X SETUWP,SETUWP		;SET USER WRITE PROTECT
	X REMAP,REMAP		;REDO CORE MAP

	X GETSEG,CPOPJ		;GET SEGMENT
	X GETTAB,CPOPJ		;GETTAB ILLEGAL (ERROR RETURN) HERE.
	X <>,UUOERR		;SPY ALSO ILLEGAL
	X SETNAM,SETNAM		;SET JOB NAME
	X TMPCOR,TMPCOR		;TEMPORARY FILES FOR RPG, ETC.
	X <>,UUOERR		;FILL OUT THE TABLE
>

; THE FOLLOWING ARE STANFORD'S OWN PRIVATE CALLI'S

DEFINE STANFORD <
	X SPWBUT,SPCWAR		;READ SWITCH REGISTER
	X CTLV,CTLV		;PUT TTY IN NON-DUPLEX MODE.
	X <>,SETNAM		;SET JOB NAME FOR SYSTAT (OBSOLETE)
	X SPCWGO,SPCWGO		;ANOTHER SPACEWAR UUO
	X SWAP,SYSRJB		;RUN A JOB
	X EIOTM,EIOTM		;ENTER IOT USER MODE
	X LIOTM,LIOTM		;LEAVE IOT USER MODE
	X PNAME,PNAME		;GET A DEVICE'S PHYSICAL NAME
	X UFBGET,UFBGET		;GET A FAST BAND - 400010
	X UFBGIV,UFBGIV		;RELEASE A FAST BAND
	X UFBCLR,FBFLUSH	;RELEASE ALL FAST BANDS
	X JBTSTS,USTAT		;GET JOB STATUS WORD OF A JOB
	X TTYIOS,TTYIOS		;GET A JOB'S TELETYPES STATUS WORD
	X CORE2,CORE2		;FUNNY CORE UUO FOR HIGH SEGMENTS
	X ATTSEG,ATTSEG		;ATTACH HIGH SEGMENT
	X DETSEG,DETSEG		;DETACH HIGH SEGMENT
	X SETPRO,SETPRO		;CHANGE PROTECTION OF HIGH SEGMENT - 400020
	X SEGNUM,SEGNUM		;GET NUMBER OF HIGH SEGMENT
	X SEGSIZ,SEGSIZ	
	X LINKUP,LINKUP
	X DISMIS,DISMIS
	X INTENB,INTENB		; ENABLE INTERRUPTS
	X INTORM,INTORM
	X INTACM,INTACM
	X INTENS,INTENS		; 400030
	X INTIIP,INTIIP
	X INTIRQ,INTIRQ
	X INTGEN,INTGEN		; GENERATE AN INTERRUPT
	X UWAIT,UWAIT
	X DEBREAK,DEBREAK
	X SETNM2,SETNM2		; SET NAME OF UPPER, IF ANY
	X SEGNAM,SEGNAM		; GET NAME OF UPPER, IF ANY
	X IWAIT,IWAIT		; GO INTO A WAIT STATE, WAKE UP ON ANY INTERRUPT. - 400040
	X USKIP,USKIP		; SKIP IF A UWAIT REALLY HAS TO WAIT.
	X BUFLEN,BUFLEN		; RETURN BUFFER LENGTH FOR A DEVICE
	X NAMEIN,NAMEIN		; SEE IF THIS JOB NAME EXISTS
	X SLEVEL,SETLVL		; SET OR GET SERVICE LEVEL.
	X IENBW,IENBW		; ENABLE INTERRUPTS AND IMMEDIATELY GO INTO WAIT STATE
	X RUNMSK,RUNMSK		; SETS PROCESSOR RUN MASK
	X TTYMES,TTYMES		; SEND A STRING TO A TTY
	X JOBRD,JOBRD		; READ A BLOCK FROM A GUY'S CORE IMAGE - 400050
	X DEVUSE,DEVUSE		; TO TELL HOW MANY PEOPLE ARE WAITING FOR A DEVICE
	X SETPR2,SETPR2		; SET SECOND PROTECT-RELOCATE REGISTER!
	X GETPR2,PR2GET		; GET LAST SETPR2 VALUE
	X RLEVEL,RLEVEL		; GET CURRENT SERVICE LEVEL RESERVATION
	X UFBPHY,FBPHY		; GET PHYSICAL BAND NUMBER
	X UFBSKP,FBSKP		; SKIP IF NO TRANSFER IN PROGRESS
	X FBWAIT,FBWT		; WAIT FOR TRANSFER TO FINISH
	X UFBERR,FBERR		; SKIP IF NO ERRORS IN LAST TRANSFER. 400060
	X WAKEME,WAKEME		; SET ALFRED. TIME TO INITIALIZE A JOB.
	X GETNAM,GETNAM		;RETURN JOBNAME IN AC
	X SNEAKW,SNEAKW		; PEEK AT NEXT TTY CHAR. AND WAIT FOR IT
	X SNEAKS,SNEAKS		; PEEK AT NEXT TTY CHAR. AND SKIP IF ONE THERE
	X GDPTIM,GDPTIM		; GET TIME CELLS
	X SETPRV,SETPRV		; RESET JOBTPRV
	X DDCHAN,DDCHAN		;GET/RELEASE DD CHANS ETC.
	X VDSMAP,VDSMAP		;CHANGE VIDEO SWITCH MAPPING - 400070
	X DSKPPN,UDSKPPN	;GET OR SET DISK ALIAS PPN
	X DSKTIM,DSKTIM		;DATE & TIME A LA DSKSER
	X SETCRD,SETCRD		;SET JOB CREATION DATE & TIME
	X CALLIT,CALLIT		;TRANSLATE CALL TO CALLI OR VICE VERSA
	X XGPUUO,XGPUUO		;FONT COMPILER & XGPSER COMMUNICATION.
	X LOCK,LOCK		;LOCK A JOB IN CORE.
	X UNLOCK,UNLOCK		;UNLOCK A JOB
	X DAYCNT,DAYCT		;SYSTEM DATE TO DAY COUNT. - 400100
	X ACCTIM,ACCTIM		;RETURN <DATE>,,<TIME IN SECS>
	X UNPURE,UNPURE		;UNPURIFY UPPER SEGMENT
	X TMPCRD,TMPCRD		;READ OTHER JOB'S TMPCOR
	X DEVNUM,DEVNUM		;CONVERT LOGICAL DEV NAME OR CHANNEL # TO UNIT #
	X ACTCHR,ACTCHR		;WAIT FOR ACTIVATION AND RETURN CHAR WHICH DUN IT
	X UUOSIM,UUOSIM		;SET UP UUO SIMULATOR
	X PPSPY,PPSPY		;LIKE PPINFO FOR ANOTHER JOB
	X ADSMAP,ADSMAP		;SET/READ AUDIO SWITCH SELECTIONS -400110
	X BEEP,BEEP		;BEEP A TTY'S CHANNEL
	X WHO,WHOUUO		;READ SYSTEM OR USER WHO LINE
	X TTYJOB,TTYJNO		;GET JOB # ON THIS TTY
	X (,UUOERR)		;	"   IOPDL
	X GETPRV,GETPRV		;GET PRIVILEGES BY JOB #
	X TTYSKP,TTYSKP		;SKIP IF TTY INPUT UUO WON'T HANG
	X DIAL,DIAL		;DIAL UUO
>
;NOTE, USE UP THE UUOERR ENTRIES BEFORE MAKING NEW ONES

; MACROS TO DEFINE CALLI TABLES

DEFINE X! (A,B)
<
	<SIXBIT /A/>
>
↑UCLTAB:		;POINTER TO HERE IN OUTER
	XLIST
	NAMES
XP UCLDLN,.-UCLTAB
	STANFORD
	LIST
XP UCLLEN,.-UCLTAB
	UUONAM		;POINTER TO FIND REST OF UUO NAMES

DEFINE X!(A,B)
<IFE ZZ/2*2-ZZ,<DEFINE ZZZ<B>>
IFN ZZ/2*2-ZZ,<XWD ZZZ,B>
ZZ←←ZZ+1
>

ZZ←←0

UCLJMP:

	XLIST
	NAMES
	STANFORD
	LIST

IFN ZZ/2*2-ZZ,<XWD ZZZ,0>

;EXIT UUO ROUTINE

;(1-14-72) EXIT UUO WITH AC FIELD ≠ 0 WILL STOP JOB,
;TYPE CRLF DOT AND ALLOW USER TO TYPE CONTINUE
BLOCK 73;;adjust;;
EXIT:
	MOVE	TAC,JBTSTS(J)
	HRRE	TAC1,JBTLIN(J)
	JUMPL	TAC1,EXIT1	;KILL DETACHED JOB THAT EXIT!
	TLNN	TAC,JLOG	;LOGGED IN?
	JRST	EXIT1		;FLUSH DETATCHED OR UNLOGGED IN JOBS
	JUMPN	UCHN,EXIT2	;IS THIS CALLI N,12 WITH N≠0
	PUSHJ	P,IORELS	;FLUSH USER'S IO
	PUSHJ	P,RESETB	;RESET EVERYTHING ELSE
	PUSHJ	P,TTYFUW	;FIND TTY FOR CURRENT JOB
				;SET ITEM TO JOB NO.,DAT TO OUTPUT BYTE POINTER
				;DEVDAT TO TTY DDB
	SETZM JOBOPC(PROG)	;NO MORE OPC
	SETZM UUOPC(J)		;OR USER PC (NOTE ESTOP CHANGED TO GO TO USRXIT)
	SETZM UUOOPC(J)		;OR BACKUP USER PC
				;NOTE ALL THIS MEANS THAT THE NEXT START, ETC.
				;WILL LEAVE A 0 IN JOBOPC (HERE'S TO CLEAN RAID SCREENS)
	JSP TAC,PHOLD		;MOVE "EXIT" TO OUTPUT BUFFER
				;AND STOP JOB, AND START TTY
	ASCIZ /
EXIT/

EXIT1:
	PUSHJ	P,IORELS	;HERE TO KILL JOB.  FLUSH USER IO
	PUSHJ	P,KILSPW	; ZERO SPACEWAR CELLS
IFN FTSWAP,<	JRST	JOBKL	>
IFE FTSWAP,<	JRST	ESTOP	>


EXIT2:
	PUSHJ	P,KILSPW	; ZERO SPACEWAR CELLS
	PUSHJ	P,TTYFUW	;GET THE USER'S CONSOLE
	PUSHJ P,PRCRCC		;TYPE CRLF ↑C CRLF .
	PUSHJ	P,TTYSTC	;START THE TTY
	JRST	STOP1		;COPIED (BLINDLY) FROM HALT, (LAME EXCUSE)

;SETPOV - SET PUSH DOWN OVERFLOW TRAP
;CALL	MOVE AC,ADR. OF TRAP ON PD OVF
;	CALL AC,[SIXBIT /SETPOV/]


SETPOV:
	MOVEM TAC,JOBAPR(JDAT)
	MOVEI TAC,1B19
	JRST APRENB		;SET TRAP LOC.


;RESET UUO ROUTINE

↑RESET:	PUSHJ P,RESETSEG
RESETUUO:

	SKIPE SPWUUF(PID)		;AT SPACEWAR LEVEL?
	JRST SPWERR			;FLUSH THE BASTARD
	SKIPN INTACT(PID)
	JRST RESETA
	JSP TAC,UUOMES
	ASCIZ /RESET CALLED FROM I-LEVEL, OR SPACEWAR LEVEL
UUO/

RESETA:
	PUSHJ	P,IOKILL	;RELEASE ALL DEVICES
RESETB:
	PUSHJ	P,INTKILL	;CLEAR THE USER INTERRUPT SYSTEM (FLUSHES CLK REQS)
	PUSHJ	P,UNLOCK	;UNLOCK HIM IN CORE.
	SKIPE	TAC,JBTPR2(J)	;IS HE DOING PEEK-POKE?
	TRNE	TAC,2		;DON'T CLEAR PSEUDO-UPPER
	JRST	NOPR2		;NO
	SETZM	JBTPR2(J)	;CLEAR IT
	PUSHJ	P,GETPR
	DATAO	APR,TAC		;AND INDICATE IN PROT.,RELOC, REG.
NOPR2:
				;AND RETURN TO USER
	MOVE	J,JOB(PID)
	SKIPE	AC1,JBTFS(J)	;ANY FREE STORAGE?
	PUSHJ	P,FSGIVE	;YES, RETURN IT
	SETZM	JBTFS(J)
	PUSHJ	P,KILSPW
IFN FTSWAP,<
	PUSHJ	P,FBFLUSH	;RELEASE ALL HIS FAST BANDS
>
	SETZM	TAC
	PUSHJ	P,APRENB	;KILL HIS APR INTERRUPTS
	SKIPE	AC1,JBTMAIL(J)	;ANYTHING IN HIS MAILBOX ?
	PUSHJ	P,FSGIVE	;YES. RETURN THE FREE STORAGE.
	SETZM	JBTMAIL(J)	;EMPTY THE MAILBOX.
	PUSHJ	P,PTYCLR	;FLUSH HIS PSEUDO TTY'S, IF ANY.
	MOVSI	TAC,(J)
	PUSHJ	P,DDAREL	;FLUSH HIS DATA DISC CHANNELS
	PUSHJ	P,ADSRES	;RESET AUDIO SWITCH MAP
	MOVE	AC1,JBTLIN(J)	;PICK UP LINE CHARACTERISTICS
	CAME	AC1,[-1]	;DETACHED?
	TLNN	AC1,DISLIN!DDDLIN	;IF III OR DD, GO RESET THE DISPLAY
	POPJ	P,		;NO, NO RESET OF SCREEN
	JRST	DPYRST		;RESET HIS DPY, IF HE HAS ONE.

; ROUTINE TO RESET ONE'S UPPER SEGMENT

RESETSEG:

	PUSH	P,TAC
	PUSH	P,AC1
	PUSH	P,TAC1
	PUSH	P,DDB
	PUSHJ	P,FLUSHSEG	; FLUSH HIS UPPER, IF ANY
	CAME	ITEM,JOB(PID)	; IS THIS THE CURRENT JOB?
	JRST	RESTG1		; NO, DON'T BOTHER TO RESET PR
	PUSHJ	P,GETPR		; RESET HIS PROT-RELOC
	DATAO	APR,TAC
RESTG1:
	POP	P,DDB
	POP	P,TAC1
	POP	P,AC1
	POP	P,TAC
	POPJ	P,

;APRDKL  ROUTINE TO KILL ANY CLOCK INTERRUPT REQUESTS FOR JOB J

APRDKL:
	JUMPN PID,CPOPJ
	PUSH P,TAC1		;SAVE THIS IN CASE SOMEONE DEPENDS ON IT
	CONI PI,TAC1		;GET STATE OF PI SYSTEM
	ANDI TAC1,APROFF-1000	;MASK FOR ONLY STATE OF APR CHANNEL
	CONO PI,APROFF		;MAKE SURE CHANNEL IS OFF
	SKIPE TAC,APRLST
APRDK3:
	SKIPN AC1,(TAC)
	JRST APRDK1		;APRLST EMPTY OR END OF LIST
	CAIN J,(AC1)
	JRST APRDK2		;THIS IS OUR REQUEST
	ADDI TAC,2
	JRST APRDK3

APRDK2:
	PUSHJ P,APRDEL		;DELETE REQUEST POINTED TO BY TAC
	JFCL
APRDK1:
	CONO PI,2000(TAC1)	;TURN CHANNEL ON ONLY IF WE TURNED IT OFF.
	POP P,TAC1
	POPJ P,

;APRENB - ROUTINE TO SET UP APR FOR USER TRAPPING
;CALL:	CALL AC,[SIXBIT /APRENB/]
;WITH FOLLOWING APR CONSO FLAG BITS
;TO INDICATE WHICH APR CONDITIONS SHOULD
;TRAP TO USER WHEN TRAP OCCURS FROM USER MODE

;1B18	;CONS TRAP		;JS
;1B19	;PUSHDOWN OVERFLOW
;1B22	;ILLEGAL MEMORY
;1B23	;NON-EXISTENT MEMORY
;1B26	;CLOCK
;1B29	;PC CHANGE FLAG (AR FOV ON THE PDP-10)
;1B32	;ARITH. OVERFLOW

CPUMSK←←1B18!1B19!1B22!1B23!1B29!1B32	;MASK FOR CPU INT BITS (EXCEPT CLOCK)

↑APRENB:
	ANDI TAC,CPUMSK!1000		;MASK OUT ILLEGAL BITS ;JS
	MOVEM TAC,JOBENB(JDAT)		;SET RH TO CONSO BITS
	TDNE TAC,APRIN2(PID)
	JRST INTLOS
	IOR TAC,APRIN2(PID)		;MAKE SURE WE INCLUDE OTHER MOORER INTS
APREN2:
	HRRM TAC,APRIN1(PID)		;SET CONSO FLAGS IN APRSER ROUTINE WITH
					;WITH FLAGS USER IS ENABLED FOR
	XORI TAC,1B29+1B32		; COMPLEMENT PC CHNG AND AROV
	ADDI TAC,330			; DISABLE THE ENABLED ONES
	ANDI TAC,660
	CONO APR,APRCHN(TAC)		;ENABLE OR DISABLE PC CHANGE AND OR OVF
	POPJ PDP,

;PJOB, DATE, DAYCNT, ACCTIM, DSKTIM, JOBTIM, MSTIME UUO'S

JOBNO:
	MOVE	TAC,ITEM		;RETURN JOB NUMBER OF THIS JOB
	JRST	STOTAC			;STORE IN USER AREA.

DATE:
	MOVE	TAC,THSDAT		;RETURN DATE TO USER
	JRST	STOTAC

;CONVERT SYSTEM FORMAT DATE TO NUMBER OF DAYS SINCE 1-JAN-64
DAYCT:
	JUMPG	TAC,.+2		;ARGUMENT IN SYSTEM FORMAT TO DAY COUNT.
	MOVE	TAC,THSDAT	;ZERO OR NEGATIVE DATE GIVEN GETS TODAY'S DATE
	PUSHJ	P,DAYCNT	;THIS ROUTINE IS IN COMCON
	JRST	STOTAC

ACCTIM:
	MOVE	TAC,TIMDAT	;GET <DATE>,,<TIME IN SECS>
	JRST	STOTAC		;AND RETURN IT

DSKTIM:
	PUSHJ	P,DSKTM1	;RETURN DATE & TIME IN DSKSER FORMAT
	XCTR	XW,[MOVEM TAC1,(UUO)]
	POPJ	P,

;RETURN JOB RUNNING TIME IN MILLISECONDS
JOBTIM:
	JUMPL	TAC,RTZERO	;ILLEGAL JOB NUMBER
	CAIL	TAC,JOBN	
	JRST	RTZERO		;ILLEGAL JOB NUMBER
	JUMPG	TAC,.+2
	MOVEI	TAC,(J)		;ASSUME CURRENT JOB FOR ZERO ARGUMENT
	MOVE	TAC,TTIME(TAC)	;TOTAL JOB RUNNING TIME IN TICKS.
	JRST	MST1		;CONVERT TO MILLISECONDS AND RETURN

TIMER:
	MOVE	TAC,TIME	;RETURN TIME OF DAY IN JIFFIES
	JRST	STOTAC

;RETURN TIME OF DAY IN MILLISECONDS
MSTIME:
	MOVE	TAC,TIME	;GET TIME OF DAY
MST1:
	IMULI	TAC,=1000	;CONVERT TIME FROM JIFFIES TO MILLISECONDS
	IDIVI	TAC,JIFSEC	;DIVIDE BY NO. OF JIFFIES PER SECOND
	JRST	STOTAC

;SLEEP	PUT JOB TO SLEEP FOR NSECONDS
;CALL	CALL AC,[SIXBIT /SLEEP/]


↑SLEEP:
	IMULI TAC,JIFSEC	;MULTIPLY BY NO. OF JIFFIES PER SECOND
↑SLEEPT:MOVSI TAC1,CLKR
	TDNE TAC1,JBTSTS(ITEM)	;DOES THIS JOB HAVE A CLOCK QUEUE
				;REQUEST IN CLOCK QUEUE?
	JRST SETSLP		;YES, DO NOT PUT ANOTHER ONE IN
	TRNN TAC,7777		;0 TIME?  ;JS
SLEEP1:
	MOVEI TAC,1		;YES. SLEEP 1 JIFFY
	DPB ITEM,[POINT 6,TAC,23]
	HRLI TAC,WAKE		;ADR. IN RUNCSS WHEN JOB WAKES UP
	CONO PI,PIOFF
	IDPB TAC,CLOCK
	CONO PI,PION
	JRST SETSLP		;SET JOB STATUS WORD SO JOB WILL NOT RUN

;SWITCH	RETURN DATA SWITCHES

SWITCH:
	DATAI	TAC			;READ SWITCHES, FALL INTO STOTAC


;ROUTINE TO STORE TAC IN USER AREA AS SPECIFIED BY UUO
;MUST BE CALLED FROM UUO LEVEL WITH PROG SETUP
;ALSO PROG IN INDEX FIELD OF UUO

↑STOTAC:
	XCTR	XW,[MOVEM TAC,(UUO)]	;STORE TAC INTO USER'S AC
	POPJ	P,

;DVCHR, DEVNUM

DVCHR:
	PUSHJ	P,FNDDDB	;SEARCH FOR DEVICE (OR CHANNEL)
	TDZA	TAC,TAC		;NOT A DEVICE, RETURN ZERO
	SKIPA	TAC,DEVMOD(DDB)	;DEVICE FOUND,RETURN DEVMOD
	JRST	STOTAC		;RETURN ZERO, DEVICE NOT FOUND
	TLNN	TAC,DVUDP
	JRST	DVCHR2		;EASY OUT UNLESS UDP
	LDB	AC2,PUNIT	;UDP, SCAN ENTIRE DDB LIST OF THIS UDP
	MOVE	TAC1,DKDBML(AC2)
	MOVE	AC1,DEVNAM(DDB)
DVCHR0:
	HLRZ	TAC1,DEVSER(TAC1)
	CAME	AC1,DEVNAM(TAC1)
	JRST	DVCHR1		;END OF DDBS FOR THIS DEVICE
	IOR	TAC,DEVMOD(DDB)	;RETURN UNION OF ALL ASSCON AND ASSPRG BITS
	JRST	DVCHR0

DVCHR1:
	SKIPL	TAC1,UDPOWN-1(AC2)
	CAMN	TAC1,JOB(PID)
	TLO	TAC,DVAVAL	;AVAILABLE IF HIS OR PUBLIC
	JRST	STOTAC

DVCHR2:
	LDB	TAC1,PJOBN	;GET JOB NO.  USING DEVICE
	CAME	TAC1,JOB(PID)	;DOES CURRENT USER ALREADY HAVE IT?
	TDNN	TAC,[XWD TTYATC,ASSCON+ASSPRG]	;NO, IS IT ASSIGNED?
	TLO	TAC,DVAVAL	;NO, BUT HE CAN GET IT.
	JRST	STOTAC

DEVNUM:
	PUSHJ	P,FNDDDB
	POPJ P,			;NONE
	LDB TAC,PUNIT		;GET UNIT NUMBER
	AOS (P)
	JRST STOTAC

;GETPPN -- DSKPPN

;DSKPPN
;CALLING:
;	CALL AC,[SIXBIT/DSKPPN/]
;
;AC		MEANING
;0		RETURN CURRENT JOB'S DSKPPN
;1 TO JOBN-1	RETURN DSKPPN OF JOB IN AC
;-1		RESET DSKPPN OF CURRENT JOB
;ANYTHING ELSE	WILL TRY TO BE PPN TO SET DSKPPN TO
;		MUST HAVE NON-ZERO LEFT AND RIGHT HALVES

UDSKPPN:

IFN FTDSKPPN,<
	CAMN	TAC,[-1]	;REQUESTING A RESET?
	AOJA	TAC,RSTPPN	;YES, SET TAC TO 0 AND STORE IT
	TLNN	TAC,-1		;IS IT PPN?
	JRST	RTDSKPPN	;NO, MAYBE JUST GETTING SOMEONES DSKPPN
	TRNN	TAC,-1
	HRR	TAC,PRJPRG(J)	;COPY PRG FROM PRJPRG
RSTPPN:
	CAMN	TAC,PRJPRG(J)
	MOVEI	TAC,0		;THIS IS REALLY A RESET
	CAMN	TAC,MFDENT	;SAME AS 1,1?
	POPJ	P,		;DISALLOW SOME FORMS OF LOSSAGE.
	CAME	TAC,DSKPPN(J)
	SETZM	JBTUFD(J)	;CLEAR LOC OF UFD IF DEFAULT UFD IS CHANGING
	MOVEM	TAC,DSKPPN(J)	;SET NEW DISK ALIAS PPN
	POPJ	P,

RTDSKPPN:

	JUMPN	TAC,.+2
	MOVE	TAC,J			;WANTS HIS OWN
	MOVSI	TAC1,JNA
	CAIGE	TAC,JOBN		;LEGAL?
	TDNN	TAC1,JBTSTS(TAC)	;AND A REAL JOB?
	JRST	RTZERO			;NO
	SKIPN	TAC1,DSKPPN(TAC)	;IF THIS IS 0
	MOVE	TAC1,PRJPRG(TAC)	;THEN THIS IS IT
>;FTDSKPPN
IFE FTDSKPPN,<
	MOVE	TAC1,PRJPRG(J)
>;FTDSKPPN
	XCTR	XW,[MOVEM TAC1,(UUO)]	;RETURN IT
	POPJ	P,

↑RTZERO:MOVEI	TAC,0
	JRST	STOTAC

;RETURN PROJECT-PROGRAMMER NUMBER IN AC
GETPPN:

IFE FTLOGIN,<
	JRST	RTZERO
>
;;misplaced right end closing;;IFN FTLOGIN,<	
	MOVSI	TAC,JACCT		;ACCOUNTING PROGRAM?
	TDNE	TAC,JBTSTS(J)
	JRST	GETPPL			;YES. GETPPN DOES DIFFERENT THING
	MOVE	TAC,PRJPRG(J)
	JRST	STOTAC

GETPPL:
	SETZM	JBTUFD(J)	;ACCOUNTING: ANY OTHER USERS UNDER SAME PPN?
IFN FTDSKPPN,<
	SETZM	DSKPPN(J)	;RESET DISK ALIAS PPN
>
	MOVE	TAC,DUMPPN	;GET ALL POWERFULL PPN
	EXCH	TAC,PRJPRG(J)	;SET THIS JOB TO THAT PPN
	MOVEI	TAC1,JOBN-1	;LOOK THRU ALL THE WORLD
	CAMN	TAC,PRJPRG(TAC1);SKIP IF NOT MATCHED
	CAMN	J,TAC1		;MATCH. SKIP IF MATCH DIFFERENT FROM JOB NUMBER
	SOJG	TAC1,.-2	;NO MATCH OR MATCHED SELF. LOOP
	JUMPLE	TAC1,STOTAC	;IF TAC1 = 0 THEN NO MATCH
	AOS	(P)		;MAKE IT SKIP RETURN
	JRST	STOTAC		;GO RETURN

;SETNAM, SETCRD, SETDDT, GETNAM

SETNAM:
	MOVE J,JOB(PID)
	MOVEM TAC,JOBNAM(J)	;SET JOB NAME FOR SYSTAT
IFN FTSTAT,<PUSHJ P,NAMSTT>
	POPJ PDP,

;SET CREATION DATE & PROT

SETCRD:
	TLZE TAC,400000		;CLEAR & CHECK UNUSED BIT
	JRST SETCD2		;ANY OF THESE MEANS DO IT TO THE UPPER
SETCD1:
	MOVEM TAC,JOBCRD(J)
	TDNE TAC,[37,,-1]
	POPJ P,
	PUSHJ P,DSKTM1
	IORM TAC1,JOBCRD(J)
	POPJ P,

SETCD2:
	PUSH P,J	;SAVE FOR ACCESS
	LDB J,PSEGN
	JUMPE J,TPOPJ	;EASY IF NO UPPER
	MOVE AC1,TAC	;ELSE SAVE ARG
	PUSHJ P,ACCESS	;AND MAKE SURE THIS IS LEGAL
	JRST TPOPJ
	JRST TPOPJ
	SUB P,[1,,1]	;DON'T NEED THAT JOB # ANY MORE
	MOVE TAC,AC1
	JRST SETCD1


SETDDT:
	MOVEM	TAC,USRDDT(PID)	;ROUTINE TO SET ONE'S DDT STARTING ADDRESS
	POPJ	P,		;RETURN TO USER

GETNAM:
	JUMPLE	TAC,GETNA1	;GET JOBNAME GIVEN JOB NUMBER
	CAIL	TAC,JOBN
GETNA1:
	MOVE	TAC,J
	MOVE	TAC,JOBNAM(TAC)
	JRST	STOTAC

;WAIT FOR IO TO BECOME INACTIVE ON CHANNEL AC


WAIT:
	JUMPE DEVDAT,IOIERR	;CHANNEL ASSIGNED?
	JRST WAIT1		;WAIT TILL INACTIVE BEFORE
				;RETURNING TO USER.


GETLN:
	PUSHJ PDP,TTYFND	;GET NAME OF TTY
	MOVE TAC,DEVNAM(DEVDAT)
	JRST STOTAC

;CRKSER -- READ THE PETIT CROCK, J. SAUTER, REST OF PAGE.

;FOR A DESCRIPTION OF THE ON-LINE CALENDAR CLOCK SEE
;SAILON MEMO NUMBER 9.

;DATIME SKIPS RETURN IF CLOCK IS OK AND RETURNS IN DAT
;THE YEAR, MONTH, AND DAY IN STANDARD SYSTEM FORMAT.
;IN ITEM THE TIME TO THE NEAREST JIFFIE.

;USED TO SKIP RETURN.

↑DATIME:
	MOVEI TAC1,1000		; TRY ONLY 1000 TIMES
DAT2:
	CONI PCLK,TEM		;READ FAST PART.
	DATAI PCLK,TAC		;READ SLOW PART.
	JUMPG TAC,DAT1		;CLOCK IS VALID.
DAT2A:
	SOJG TAC1,DAT2		;INVALID, RETRY.
	POPJ PDP,		;TOO MANY RETRIES, CONSIDER IT SICK.

DAT1:
	SUBI TAC,5004		;NORMALIZE CROCK DATA.
	SUB TEM,[2020136700]	;AND FAST PART.
	LDB ITEM,[POINT 4,TEM,9]
	LDB DAT,[POINT 4,TAC,35]
	CAME DAT,ITEM		;DID READINGS GIVE THE SAME MINUTE?
	JRST DAT2A		;NO. GO RETRY.
	TLNE TAC,200000		;YEAR INVALID?
	POPJ PDP,		;YES. CROCK SICK.
	LDB ITEM,[POINT 4,TAC,19]	;MONTH.
	SUBI ITEM,4
	CAIL ITEM,=12
	POPJ PDP,
	IMULI ITEM,=31
	MOVEM ITEM,DAT
	LDB ITEM,[POINT 5,TAC,24]
	ADDM ITEM,DAT		;ADD IN DAY.

; FINISH READING PCROCK, CONVERT TO STANDARD FORM

	LDB TAC1,[POINT 4,TAC,11]
	CAILE TAC1,=7		;after 1979?
	POPJ PDP,		;YES.
	IMULI TAC1,=10
	LDB ITEM,[POINT 4,TAC,15]
	CAILE ITEM,=9
	POPJ PDP,		;19WHAT?
	ADD ITEM,TAC1
	CAIG ITEM,=67		;ITS AFTER 1-JAN-68.
	POPJ PDP,
	SUBI ITEM,=64		;NORMALIZE TO 1964.
	IMULI ITEM,=12*=31
	ADDM ITEM,DAT		;DAT IS NOW SET UP.
	LDB TAC1,[POINT 5,TAC,29]	;HOUR.
	CAIL TAC1,=24
	POPJ PDP,
	MOVE ITEM,TAC1
	IMULI ITEM,=60*=60*=60
	ANDI TAC,77		;MINUTES
	CAIL TAC,=60
	POPJ PDP,
	IMULI TAC,=60*=60
	ADD ITEM,TAC
	LDB TAC,[POINT 6,TEM,15]	;SECONDS.
	CAIL TAC,=60
	POPJ PDP,
	IMULI TAC,=60
	ADD ITEM,TAC		;ADD INTO RESULT.
	LDB TAC,[POINT 20,TEM,35]
	CAML TAC,[=1000000]	;CHECK MILLISECONDS.
	POPJ PDP,
	IDIVI TAC,<=1000000/JIFSEC>
	ADD ITEM,TAC
	CAML	DAT,THSDAT	;DONT GO BACKWARDS
	CAMGE	ITEM,TIME	;DONT GO BACKWARDS
	POPJ	P,		;LOSER.
	JRST CPOPJ1		;RETURN + 1.


;LOGIN UUO.	FOR LOGIN CUSP ONLY.
;	CALL AC,['LOGIN ']
;	AC = -N,,LOC
; 	LOC = LOCATION OF TABLE OF LENGTH N. TABLE HAS LOGIN GOODIES.
;(1-14-72 REWRITTEN BY REG)

IFN FTLOGIN,<			;ONLY FOR LOGIN SYSTEMS. (IFN INCLUDES SETPRV)
LOGIN:
	MOVSI	TAC1,JLOG	;LOAD ONE BIT.
	TDNE	TAC1,JBTSTS(J)	;SKIP IF JOB NOT LOGGED IN
	JRST	UUOERR		;LOGGED IN ALREADY.
	HLRO	AC1,TAC		;GET -WORD COUNT
	HRR	UUO,TAC		;BASE OF DATA TABLE
	MOVE	AC2,[XWD -LOGTOP,LOGTAB]	;SET A DEPOSIT/CONTROL WORD
LOGIN1:
	AOJG	AC1,LOGIN2	;INCREMENT USER'S COUNT. SKIP IF EXHAUSTED
	XCTR	XR,[SKIPA AC3,(UUO)]	;GET DATA FROM USER AND SKIP
LOGIN2:
	MOVEI	AC3,0		;NO DATA FROM USER. USE ZERO
	MOVEM	AC3,@(AC2)	;STORE DATA IN JOB TABLE
	ADDI	UUO,1		;PUSH USERS POINTER
	AOBJN	AC2,LOGIN1	;LOOP UNTIL WE FILL MONITOR TABLES
	IORM	TAC1,JBTSTS(J)	;SET JLOG BIT IN JBTSTS
	MOVSI	TAC1,JACCT	;
	ANDCAM	TAC1,JBTSTS(J)	;CLEAR ACCOUNTING BIT
	MOVE TAC1,JB2PRV(J)	;INITIALIZE PRIVS TO PASSIVE PRIVS
	MOVEM TAC1,JBTPRV(J)
IFN FTDISK,<	SETZM	JBTUFD(J)  ;ZERO UFD POINTER FOR NEW PPN
IFN FTDSKPPN,<	SETZM	DSKPPN(J)  ;INITIALIZE DISK ALIAS PPN
>;FTDSKPPN
>;FTDISK
↑SETLOG:			;SET-UP USER TABLES FOR LOGIN AND OTHERS!
	SKIPN	JBTJL(J)
	PUSHJ	P,PRIBUF

;SPREAD SERVICE LEVEL TO THIS NEW JOB
	HRRZ	AC1,PRJPRG(J)	;GET PROGRAMMER NAME
	MOVN	TAC,SLNRES	;LOAD -NUMBER OF RESERVATIONS
	JUMPE	TAC,CPOPJ	;NO RESERVATIONS.
	HRLZ	TAC,TAC		;-SLNRES,,0 IN TAC
LOGIN4:
	HRRZ	TAC1,SLRES(TAC)	;PROG NAME WHO HAS A RESERVATION
	CAME	TAC1,AC1	;MATCH?
	AOBJN	TAC,LOGIN4	;NO MATCH: LOOP
	JUMPGE	TAC,CPOPJ	;NO MATCH ANYWHERE.
	HLRZ	TAC,SLRES(TAC)	;GET HIS RESERVATION AS A RH FRACTION
	MOVEM	TAC,JBTGSL(J)	;SET GUARANTEED SERVICE LEVEL
	POPJ	P,		;STOW IT.

;TABLE OF TABLES SET BY LOGIN UUO. INCLUDE J AS INDEX REGISTER
;AND STORE @ THRU THIS TABLE.

LOGTAB:
	XWD J,PRJPRG	;USER NAME 
	XWD J,JB2PRV	;JOB PASSIVE PRIVLEGE BITS
LOGTOP←←.-LOGTAB	;NO. OF TABLES TO BE SET

; ROUTINE TO SET UP SCHEDULER DATA STRUCTURE FOR A JOB

↑PRIBUF:MOVEI AC3,JLLENGTH
	PUSHJ P,FSGET
	POPJ P,			;IF YOU LOSE, YOU LOSE
	MOVEM AC1,JBTJL(ITEM)
	SETZM JBTJLH(ITEM)
	SETZM JBTGSL(J)
	HRL AC2,AC1
	HRRI AC2,1(AC1)
	SETZM (AC1)
	BLT AC2,JLLENGTH-1(AC1)
	POPJ PDP,

;SETPRV, GETPRV
;	SETPRV	SET JBTPRV	JOB PRIVILEGE BITS
;	CALL AC,['SETPRV']
; JBTPRV WILL BE SET TO CONTENTS OF AC IF 
; EITHER PRIPRV IS SET IN CURRENT JBTPRV OR JBTSTS INDICATES JACCT SET
; RETURN CONTENTS OF JBTPRV IN AC.
; IF AC REQUESTS FEWER PRIVILEGES THAN ARE NOW ALLOWED, THEN
; THE REQUEST WILL BE SUCESSFUL
; IF C(AC) = -1 THEN ONLY RETURN CURRENT CONTENTS OF JBTPRV

SETPRV:
	CAMN	TAC,[-1]	;SKIP UNLESS SPECIAL CODE
	JRST	STPRV1		;JUST GIVE HIM THE CURRENT CONTENTS
	MOVSI	TAC1,PRIPRV	;THE PRIVILEGE PRIVILEGE BIT
	MOVSI	AC1,JACCT	;ACCOUNTING PROG, BIT
	TDNN	AC1,JBTSTS(J)	;SKIP IF JACCT SET
	TDNE	TAC1,JB2PRV(J)	;SKIP UNLESS PRIPRV SET
	MOVEM	TAC,JBTPRV(J)	;STORE NEW PRIV BITS IF JACCT ∨ PRIPRV
	CAMN	TAC,JBTPRV(J)	;ARE THESE THE SAME NOW?
	POPJ	P,		;YES RETURN QUICK
	ANDM	TAC,JBTPRV(J)	;TURN OFF THE ONES HE IS NOT REQUESTING
	AND	TAC,JB2PRV(J)	;LEAVE ON THE ONES HE CAN SET
	IORM	TAC,JBTPRV(J)	;AND SET THEM
STPRV1:
	MOVSI	TAC,PRIPRV	;RETURN PRIPRV FROM JB2PRV
	AND	TAC,JB2PRV(J)
	IOR	TAC,JBTPRV(J)	;GET THE REST FROM JBTPRV
	JRST	STOTAC		;GIVE THEM BACK TO THE USER

;GET PRIVILEGES FOR JOB
;CALLING SEQUENCE:
;	MOVE AC,[FUNC CODE,,JOB #]
;	GETPRV AC,
;	<ALWAYS RETURN HERE>
;CODE 0 ACTIVE PRIVILEGES
;CODE 1 PASSIVE PRIVILEGES

GETPRV:
	HLRZ AC1,TAC		;GET FUNCTION CODE
	CAIL AC1,MAXFNC		;LEGAL FUNCTION CODE
	JRST UUOERR		;NO, FLUSH
	HRRZ TAC,TAC		;GET JUST JOB #
	CAIGE TAC,JOBN		;JOB # TO LARGE?
	JUMPN TAC,.+2		;OR 0?
	MOVE TAC,J		;YES, USE CURRENT JOB
	XCT FNCTAB(AC1)		;DO FUNCTION
	JRST STOTAC		;RETURN ANSWER

FNCTAB:
	MOVE TAC,JBTPRV(TAC)
	MOVE TAC,JB2PRV(TAC)
MAXFNC←←.-FNCTAB
>

;GET A PPN'S SERVICE LEVEL RESERVATION.
;CALLING
;	MOVE AC,[SIXBIT /PPN/]		;ONLY THE PROG NAME IS USED
;	CALL AC,[SIXBIT /RLEVEL/]
;	RETURN HERE ALWAYS, AC = <SL RESERVATION IN %>,,PRG NAME,
;		IF RESERVATION ≠ 0, OTHERWISE AC = 0,,0.


RLEVEL:
	HRRZ	AC1,TAC		;GET PROGRAMMER NAME
	MOVN	TAC,SLNRES	;LOAD -NUMBER OF RESERVATIONS
	JUMPE	TAC,RTZERO	;NO RESERVATIONS: RETURN ZERO
	HRLZ	TAC,TAC		;-SLNRES,,0 IN TAC
RLEV1:
	HRRZ	AC2,SLRES(TAC)	;PROG NAME WHO HAS A RESERVATION
	CAME	AC2,AC1		;MATCH?
	AOBJN	TAC,RLEV1	;NO MATCH: LOOP
	JUMPGE	TAC,RTZERO	;JUMP IF NO MATCH.
RLEV2:
	HLRZ	TAC,SLRES(TAC)	;GET HIS RESERVATION AS A RH FRACTION
GETLV1:
	IMULI	TAC,=100	;MAKE IT LEFT HALF PERCENT
	ADDI	TAC,400000	;ROUND IT. (LIKE YOU DID IN CLKSER)
	HRR	TAC,AC1		;JOB NUMBER (OR PRG NAME) TO TAC
	JRST	STOTAC		;STOW IT.


;REG 12-5-72
SPRSSL:
	SETZM	JBTGSL+1	;SPREAD SERVICE LEVEL TO USERS WITH RESERVATIONS.
	MOVE	TAC,[JBTGSL+1,,JBTGSL+2]	
	BLT	TAC,JBTGSL+JOBN-1	;FIRST ZERO ALL LEVELS.
	SKIPLE	AC2,SLNRES	;GET THE NUMBER OF RESERVATIONS
	CAILE	AC2,SLRMAX	;SKIP IF REASONABLE NUMBER.
	POPJ	P,		;RETURN QUICK IF NONE.
SPRSS0:
	HRRZ	TAC1,SLRES-1(AC2)
	MOVE	AC1,JOBNM1	;LOOK THROUGH ALL THE JOBS
SPRSS1:
	HRRZ	TAC,PRJPRG(AC1)
	CAIE	TAC1,(TAC)
	JRST	SPRSS2
	HLRZ	TAC,SLRES-1(AC2)
	MOVEM	TAC,JBTGSL(AC1)
SPRSS2:
	SOJG	AC1,SPRSS1
	SOJG	AC2,SPRSS0
	POPJ	P,

;SET BELOW IS DISABLED!
;GET OR SET A JOBS SERVICE LEVEL.
;CALLING
;	MOVE AC,[XWD %SLEVEL,JOB # ]
;	CALL AC,[SIXBIT/SLEVEL/]
;	RETURN HERE ALWAYS
;IF %SLEVEL<0 RETURN  CURRENT %SL,,JOB NUMBER
;OTHERWISE SET SLEVEL OF JOB TO %SLEVEL
; SET IS ALLOWED ONLY IF JOB NUMBER GIVEN IS 0 OR USER'S JOB #
; IF SET COMMAND FAILS, USER'S AC WILL BE SET TO 
; - % AVAILABLE 
;ALSO SET IT FOR HIS OTHER JOBS.
;IF JOB # = 0 USE THIS JOB
;IF JOB # = -1, AND SERVICE LEVEL MONITOR IS THE USER,
;	THEN RESET THE SL RESERVATION TABLE.


SETLVL:
	HRRZ	AC1,TAC		;GET JOB NUMBER
	CAIL	AC1,JOBN	;LEGAL JOB?
	JRST	SETRES		;NO. MAYBE SL MONITOR CHANGING RESERVATIONS
	JUMPG	AC1,.+2		;SKIP UNLESS ZERO
	MOVE	AC1,J		;ZERO MEANS THIS JOB.

	PUSH	P,AC1		;THESE 5 INSTRUCTIONS: REG 12-5-72
	PUSHJ	P,SPRSSL	;SPREAD ALL SERVICE LEVELS
	POP	P,AC1
	HRRZ	TAC,JBTGSL(AC1)
	JRST	GETLV1
	
;;;	WE ARRIVE HERE IF A NEGATIVE JOB NUMBER IS SPECIFIED.
;;;	THIS IS ALWAYS ILLEGAL UNLESS THE JOB HAS THE SSL PRIVILEGE,
;;;	IN WHICH CASE THE CURRENT SLRESERVATION TABLE IS BEING RESET,
;;;	AND THE CALLING SEQUENCE WAS:
;;;	
;;;		MOVE AC,[XWD [ XWD <0,1OR2>,N
;;;			      <1ST TABLE ENTRY>
;;;			      <2ND TABLE ENTRY>
;;;				    ...
;;;			      <NTH TABLE ENTRY>],-1]
;;;		CALL AC,[SIXBIT /SLEVEL/]
;;;		FAILURE RETURN (N TOO LARGE, TOTAL SL TOO MUCH, ETC.)
;;;		SUCCESS RETURN

SETRES:
	CAIE	AC1,-1
	JRST	RTZERO
	MOVE	TAC1,JBTPRV(J)	;GET THE USER'S PRIV BITS
	TLNN	TAC1,SSLPRV	;SKIP IF HE HAS THE PRIVILEGE
	JRST	RTZERO		;RETURN ZERO.

;;;	THIS IS THE CODE THAT READS A NEW SL RESERVATION TABLE FROM
;;;	GSLMON AND GIVES THE RESERVED AMOUNTS TO ANYBODY CURRENTLY
;;;	LOGGED IN, DECREASING THE SL OF SCROUNGERS IF NECESSARY.

	XCTR	XR,[HLRZ TAC1,(UUO)]	;TAC1 ← USER REL. ADDR. OF TABLE INFO.
	PUSHJ	P,RELOCA	;CONVERT TAC1 TO ABSOLUTE ADDRESS
	JRST	UADERR		;  LOSER GOOFED

	HLRZ	AC2,(TAC1)	;AC2 ← CORE COST OF SL = 0,1 OR 2
	CAIL	AC2,3		;IS 0 ≤ (TAC) ≤ 2  ?
	MOVEI	AC2,1		;NO, MAKE IT 1.
	MOVEM	AC2,SLCOST	;STORE IN SL DATA AREA

	HRRZ	TAC,(TAC1)	;TAC ← (# OF RESERVATIONS)
	CAILE	TAC,SLRMAX	;TOO MANY RESERVATIONS?
	JRST	SETAL0		;YES, FAILURE EXIT
	MOVSI	AC2,(TAC1)	;SOURCE OF BLT.
	HRRI	AC2,SLNRES	;DESTINATION OF BLT
	XCTR	XR,[HLRZ TAC1,(UUO)]	;TAC1 ← USER REL. ADDR. OF TABLE INFO.
	ADDI	TAC1,(TAC)	;TAC1 ← USER REL. ADDR. OF TABLE'S END
	PUSHJ	P,RELOCB	;ADDRESS CHECK END OF SOURCE.
	JRST	UADERR		;  USER LOOSES
	BLT	AC2,SLNRES(TAC)	;BLT NEW RES TABLE INTO SYSTEM
	HRRZS	SLNRES		;ZERO OUT THE 0,1,OR 2 IN LEFT HALF,

	MOVEI	TAC1,0		;ADD UP NEW RESERVATIONS...
	HLRZ	AC1,SLNRES(TAC)
	ADD	TAC1,AC1
	SOJG	TAC,.-2

	CAIG	TAC1,<XWD MAXLEV,0>/=100+SLRMAX	;TOO MUCH RESERVED SL?
SETAL1:
	AOSA	(P)		;NOT TOO MUCH. SET SKIP RETURN
SETAL0:
	SETZM	SLNRES		;TOO MUCH. CLEAR TABLE.
	JRST	SPRSSL		;SPREAD NEW TABLE

;LOGOUT UUO

;JS

IFN FTLOGIN,<
LOGOUT:
	MOVSI TAC,JACCT		; IS HE REALLY THE LOGOUT ROUTINE?
	TDNN TAC,JBTSTS(ITEM)	; SEE IF THE ACCOUNTING BIT IS ON
	JRST UUOERR		; NOT ON, HE IS A FAKE!
	JRST JOBKL		; ALL OK. LOG HIM OUT.
>

IFE FTLOGIN,<

LOGIN:

LOGOUT:
	JRST UUOERR
>
			;JS, REST OF PAGE

; ROUTINE TO READ SPACEWAR BUTTONS

SPCWAR:
	CONI TV,TAC	;READ SWITCH REGISTER
	JRST STOTAC

; ROUTINE TO COMPLEMENT STATE OF DUPLEXING
; DOES NOT AFFECT DUPLEXING OF ALT-MODE

CTLV:
	JRST CTLV1	;IN TTYSER. COMPLEMENT STATE OF DUPLEXING.

; ROUTINE TO GET A WORD FROM MONITOR CORE

PEEK:
	HRRZS TAC		;ZERO LH OF TAC
	CAML TAC,RMEMSIZ	;OVER END OF CORE?
	JRST RTZERO		;YES. DONT LET HIM GET NON-EX MEM.
	MOVE TAC,@TAC
	JRST STOTAC

; RUN A JOB UUO
; FORMAT AS FOLLOWS . . .
;	CALL AC,[SIXBIT /SWAP/]
;AC:	E,,F

;E:	SIXBIT /DEVICE/
;	SIXBIT /FILENAME/
;	SIXBIT /EXTENSION/ + MODE BITS
;	XWD (CORESIZE - IN K),(STARTING ADDRESS)
;	SIXBIT /PROJ-PROG NUMBER/
; IF STARTING ADDRESS IS ZERO, C(JOBSA) WILL BE USED
; IF E=0, NO SAVE WILL BE DONE

;F:	SIXBIT /DEVICE/
;	SIXBIT /FILENAME/
;	SIXBIT /EXTENSION/ + MODE BITS
;	XWD (CORESIZE - IN K),(STARTING ADDRESS INCREMENT)
;	SIXBIT /PROJ-PROG NUMBER/
; IF F=0, NO RUN WILL BE DONE. IF E=F=0, THE UUO IS A NO-OP
; MODE BIT 35 = DO NOT START JOB. JUST GET CORE IMAGE.
; MODE BIT 34 = MAKE STARTING ADDRESS ABSOLUTE, NOT AN INCREMENT
; MODE BIT 33 = LOGIN NEW JOB AND RUN THIS THERE!
; MODE BIT 32 = DON'T SET JLOG


;THIS VERSION IS INCLUDED FOR COMPATIBILITY WITH DEC
RUNUUO:
	PUSHJ	P,SVUACS
	HLRM	TAC,SAVSAI(J)		;SET START INCREMENT
	XCTR	XR,[HRRZ TAC1,5(TAC)]
	MOVEM	TAC1,JOBCOR(JDAT)	;SET CORE SIZE
	HRROI	AC1,(TAC)		;COPY PNTR WITH "RUN" FLAG
	JRST	RUNUU2			;NOW ENTER SWAP UUO

; SWAP UUO - CONTINUED . . .

SYSRJB:
	SKIPE	SPWUUF(PID)
	JRST	SPWERR		;FLUSH SPACEWAR
	SKIPN	INTACT(PID)
	JRST	SYSRJ2
	JSP	TAC,UUOMES
	ASCIZ	/SWAP CALLED FROM I-LEVEL
UUO/
SYSRJ2:
	XCTR	XR,[SKIPN AC1,(UCHN)]	;PICK UP ADDRESSES OF TABLES, IF ANY
	POPJ	P,			;NONE, NO-OP
	MOVEM	AC1,JOBFDV(JDAT)	;SAVE TABLE ADDRESS OF GET SIDE
	MOVE	AC1,UUOPC(J)		;SAVE RETURN ADDRESS
	MOVEM	AC1,JOBOPC(JDAT)
	PUSHJ	P,SVUACS		;SAVE THE ACCUMULATORS IN FREE STORAGE
	HLRZ	AC1,JOBFDV(JDAT)	;PICK UP 'SAVE' TABLE ADDRESS
	JUMPN	AC1,SYSSJB		;IF NON-ZERO, DO A SAVE FIRST
SYSRJ1:
	HRRZ	AC1,JOBFDV(JDAT)	;GET 'RUN' TABLE ADDRESS BACK
	JUMPE	AC1,SYSRXT		;IF ZERO, EXIT GRACEFULLY
	XCTR	XR,[MOVE TAC1,2(AC1)]	;GET MODE BITS FIRST!
	TRNE	TAC1,4			;AND TEST FOR RUN ELSEWHERE BIT
	JRST	PHANTOM			;YES!
RUNUU2:
	PUSHJ	P,SYSRS			;DO THE RUN COMMAND BIT
PRUNJB:
	JSP	TAC1,SG1		;ASSIGN DEVICE, DO LOOKUP, AND RESET PDL
	JRST	NOFILE			;NO FILE?
	PUSHJ	P,GETJB			;READ JOB IN
	MOVSI	AC1,USRMOD		;MAKE SURE HE GETS INTO USER MODE
	HRR	AC1,JOBSA(JDAT)		;PICK UP STARTING ADDRESS
	MOVE	AC2,INCWRD(JDAT)	;PICK UP OUR MODE BITS AGAIN
	PUSH	P,AC1			;PUT THAT ADDRESS ON THE STACK
	MOVE	J,JOB(PID)		;PICK UP JOB NUMBER
	TRNE	AC2,2			;IF BIT 34 ON, INHIBIT ADDING IN HIS STARTING ADDRESS
	SKIPA	AC1,SAVSAI(J)		;INSTEAD, PICK UP INCREMENT AND USE IT!
	ADD	AC1,SAVSAI(J)		;PICK UP STARTING ADDRESS INCREMENT
	XCTR	XR,[SKIP (AC1)]		;SEE IF ADDRESS IS IN BOUNDS
	HRRM	AC1,(P)			;UPDATE STARTING ADDRESS
	PUSH	P,AC2			;SAVE OUR RANDOM GOOD BITS
	PUSHJ	P,RSUACS		;RESTORE USER'S ACCUMULATORS
	POP	P,AC2			;BRING BACK OUR R.G.B. WORD
	POP	P,UUOPC(J)
	TRNN	AC2,1			;IF MODE BIT 35 IS ON, DON'T START JOB
	JRST	USRXIT
	JRST	GETJ1

; SWAP UUO - LOG IN NEW JOB AND RUN THIS ON IT - PHANTOM STARTUP

PHANTO:
	HLLZ	TAC,SAVSAI(J)	;RESTORE ACS NOW, SINCE THEY ARE SAFE
	HRRI	TAC,(PROG)	;AND WE WILL GIVE THE TABLE TO THE NEW JOB
	BLT	TAC,17(PROG)
	XCTR	XR,[SKIPN TAC,5(AC1)]	;PRJPRG
	MOVE	TAC,PRJPRG(J)		;USE CURRENT PPN
	CAMN	TAC,PRJPRG(J)		;IS HE DOING IT TO HIMSELF?
	JRST	PHWIN			;YES
	CAMN	TAC,SYSPPN		;1,1
	JRST	PHLOS1			;LOSE.
PHWIN:
	PUSH	P,J			;SAVE PRESENT JOB NUMBER
	PUSH	P,PROG			;INIJOB CLOBBERS PROG!
	PUSHJ	P,INIJOB		;INITIALIZE A NEW JOB
	JRST	PHLOSE			;NO JOBS TO BE HAD
	JFCL	
	POP	P,PROG			;RESTORE PROG
	MOVSI	TAC,JNA
	IORM	TAC,JBTSTS(J)
	MOVEM	TAC1,JOBLOG(J)		;SAVE MODE BITS AND EXTENSION
	MOVSI	TAC,JLOG
	TRNN	TAC1,10			;THIS BIT SAYS DON'T SET JLOG
	IORM	TAC,JBTSTS(J)
	SETZM	JBTUFD(J)		;FLUSH THIS OR ELSE!
IFN FTDSKPPN,<SETZM DSKPPN(J)		;INITIALIZE DISK ALIAS PPN>
	SETZM	JBTKCJ(J)		;INITIALIZE KILO CORE SECONDS
	XCTR	XR,[MOVE TAC1,(AC1)]	;DEVICE
	MOVEM	TAC1,JOBDEV(J)
	XCTR	XR,[MOVE TAC1,1(AC1)]	;FILENAME
	MOVEM	TAC1,JOBNAM(J)
IFN FTSTAT,<PUSHJ P,NAMSTT>
	XCTR	XR,[MOVE TAC1,4(AC1)]	;LOC OF FILE
	MOVEM	TAC1,JOBPPN(J)
	MOVE	TAC,(P)			;GET OUR J TEMPORARILY
	XCTR	XR,[SKIPN TAC1,5(AC1)]	;PPN
	MOVE	TAC1,PRJPRG(TAC)	;NONE, USE CURRENT
	MOVEM	TAC1,PRJPRG(J)
	CAME	TAC1,PRJPRG(TAC)	;SAME AS CALLER?
	TDZA	TAC1,TAC1		;NO. ZERO CELL AND SKIP
	MOVE	TAC1,JBTPRV(TAC)	;SAME PPN. COPY OUR PRIVILEGE
	MOVEM	TAC1,JBTPRV(J)		;TO THE NEW GUY
	MOVE	TAC1,PRJPRG(TAC)	;GET OUR PPN
	CAME	TAC1,PRJPRG(J)		;SAME AS HIS?
	TDZA	TAC1,TAC1		;NO, NO PRIVELEGES
	MOVE	TAC1,JB2PRV(TAC)	;ALSO PASSIVE PRIVELEGES
	MOVEM	TAC1,JB2PRV(J)
	XCTR	XR,[MOVS TAC1,3(AC1)]	;GET S.A.,,CORE SIZE
	HRRZM	TAC1,JOBCRD(J)		;PASS ON CORE SIZE
	MOVE	TAC,(P)			;CALLERS JOB #
	HLR	TAC1,SAVSAI(TAC)
	MOVSM	TAC1,SAVSAI(J)		;GIVE AC BLK AND S.A. TO NEW JOB
	SETZM	SAVSAI(TAC)		;NO LONGER BELONGS TO CALLER
	ADDI	TAC1,(UCHN)
	MOVEM	TAC,(TAC1)		;CALLERS JOB # TO NEW JOB (IN SAME AC)
	XCTR	XW,[MOVEM J,(UCHN)]	;NEW JOB # TO CALLER
	PUSHJ	P,DELBTT
	POP	P,J
	JRST	SYSRX2			;DON'T BOTHER LOOKING FOR ACS

PHLOSE:
	POP	P,PROG
	POP	P,J
PHLOS1:
	HLRZ	TAC,SAVSAI(J)		;GET LOC OF SAVED AC'S
	ADD	TAC,UCHN		;LOC OF USERS AC
	SETZM	(TAC)			;RETURN 0 TO INDICATE LOSSAGE
	JRST	SYSRXT

; ROUTINE TO DO THE GETTING OF A JOB FROM UUO LEVEL

SYSSJB:
	PUSHJ PDP,SYSRS		; PICK UP ARGUEMENTS FROM USER
	JSP TAC1,SG1		; DO LOOKUP
	JFCL
	PUSH P,AC1
	HRRZ AC1,SAVSAI(ITEM)	; PICK UP STARTING ADDRESS
	JUMPE AC1,SYSSJ1
	XCTR	XR,[SKIP (AC1)]
	TLO AC1,USRMOD
	HRRM AC1,JOBSA(JDAT)
SYSSJ1:
	POP P,AC1
	PUSHJ PDP,SAVJB		; DO ACTUAL SAVE
	JRST SYSRJ1

SYSRXT:
	PUSHJ PDP,RSUACS	; RESTORE ACCUMULATORS
SYSRX2:
	MOVE TAC,JOBOPC(JDAT)	; GET UUO RETURN ADDRESS
	MOVEM TAC,UUOPC(ITEM)	; AND RETURN TO IT!
	JRST USRXIT		; MAKE IT LOOK LIKE A UUO EXIT (WHICH IT IS)

; ROUTINE TO PICK UP BITS OF USER'S GOODIE TABLE

SYSRS:
	XCTR	XR,[MOVE TAC1,(AC1)]	; PICK UP DEVICE NAME
	MOVEM	TAC1,DEVWRD(JDAT)	; STORE FOR SAVJOB
	XCTR	XR,[MOVE TAC1,1(AC1)]	;PICK UP FILE NAME
	MOVEM	TAC1,FILNAM(JDAT)
	MOVEM	TAC1,JOBNAM(J)		;THIS IS NEW JOB NAME TOO
IFN FTSTAT,<PUSHJ P,NAMSTT>
	XCTR	XR,[HLRZ TAC1,2(AC1)]	;PICK UP EXTENSION
	JUMPN	TAC1,.+2		;NOT SPECIFIED?
	MOVEI	TAC1,'DMP'		;HE REALLY WANTS .DMP
	HRLZM	TAC1,FILEXT(JDAT)
	XCTR	XR,[HRRZ AC2,2(AC1)]	;PICK UP MODE BITS INTO AC2
	MOVEM	AC2,INCWRD(JDAT)	;AND SAVE THEM FOR US TO SEE LATER
	XCTR	XR,[MOVE TAC1,4(AC1)]	;AND PPN TOO
	MOVEM	TAC1,JOBPPN(J)
	JUMPL AC1,CPOPJ			;THAT'S ALL FOR RUN UUO
	XCTR	XR,[HLRZ TAC1,3(AC1)]	;PICK UP CORE SIZE
	LSH	TAC1,12			;CONVERT TO RELOCATABLE ADDRESS
	JUMPE	TAC1,.+2		;UNLESS, OF COURSE, HE ASKED FOR NONE
	SUBI	TAC1,1
	MOVEM	TAC1,JOBCOR(JDAT)
	XCTR	XR,[HRRZ AC1,3(AC1)]	;PICK UP STARTING ADDRESS INCREMENT
	HRRM	AC1,SAVSAI(J)		;TUCK AWAY IN A CONVENIENT TABLE IN APRDAT
	POPJ	P,

; ROUTINE TO SAVE ACCUMULATORS OVER RUNJOB UUO

SVUACS:
	HLRZ	AC1,SAVSAI(J)	; ANY FREE STORAGE HERE ALREADY?
	JUMPE	AC1,SVUA2	; NO, GET SOME
	CAML	AC1,MEMSIZ	; IS IT IN THE FREE STORAGE AREA?
	CAML	AC1,RMEMSIZ	; IT IS ABOVE USER CORE. IS IT IN REAL CORE?
	JRST	.+2		;THINK ABOUT IT SOME MORE, ANDY.
	JRST	SVUA1		;YES, USE IT
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/GARBAGE IN SAVSAI LEFT HALF!
/
	POPACS
SVUA2:
	MOVEI AC3,20		; GET A 20-WORD BLOCK OF FREE STORAGE
	PUSHJ PDP,FSGET
	HALT .+1		; AT UUO LEVEL, SHOULDN'T HAPPEN
	HRLM AC1,SAVSAI(ITEM)	; SAVE THE POINTER
SVUA1:
	HRLI AC1,(PROG)		; SET TO BLT IN USER'S ACS
	HRR AC2,AC1
	BLT AC1,17(AC2)
	POPJ PDP,

RSUACS:
	HLLZ AC1,SAVSAI(ITEM)	; PICK UP FREE STORAGE POINTER
	JUMPE AC1,CPOPJ		;NOBODY HOME
	HRRI AC1,(PROG)
	BLT AC1,17(PROG)
	HLRZ AC1,SAVSAI(ITEM)
	SETZM SAVSAI(ITEM)	; ZERO OUT FS POINTER
	JRST FSGIVE

; EIOTM AND LIOTM UUO'S
; CAUSES A PROGRAM TO ENTER IOT USER MODE
; OR LEAVE IOT USER MODE

EIOTM:
	MOVE	TAC,JBTPRV(J)
	TLNN	TAC,LUPPRV
	JRST	UUOERR
	MOVSI	TAC,4000
	ORM	TAC,UUOPC(ITEM)
	POPJ	P,

LIOTM:
	MOVSI	TAC,4000
	ANDCAM	TAC,UUOPC(ITEM)
	POPJ	P,

; UUO TO GET THE PHYSICAL NAME OF A DEVICE
; PUT THE SIXBIT OF THE DEVICE LOGICAL NAME IN AN AC
; DO A 'CALL AC,[SIXBIT /PNAME/]
; AND THE ROUTINE SKIPS UPON SUCCESS (IE, IF DEVICE NAME EXISTS)
; AND RETURNS PHYSICAL NAME IN THAT AC

PNAME:
	PUSHJ	P,FNDDDB	; SEARCH FOR DEVICE NAME (OR CHANNEL #)
	POPJ	P,		; FAILURE
	MOVE	TAC,DEVNAM(DDB)	; PICK UP PHYSICAL NAME
	XCTR	XW,[MOVEM TAC,(UCHN)]
	JRST	CPOPJ1

; GET A JOB'S JOB STATUS WORD
; CALLING . . .
;	MOVE AC,<JOB NUMBER IN QUESTION>
;	CALL AC,[SIXBIT /JBTSTS/]
; RETURNS JOB STATUS WORD IN AC

USTAT:
	JUMPG TAC,.+2		; POSITIVE JOB NUMBER?
	MOVE TAC,J		; LESS OR EQUAL TO ZERO MEANS OWN JOB
	CAIL TAC,JOBN		; MUST BE LESS THAN MAXIMUM TOO
	JRST UUOERR		; OR ELSE, ERROR
	MOVE TAC,JBTSTS(TAC)	; GET STATUS WORD
	JRST STOTAC		; AND GIVE IT TO HIM


; GET A TELETYPE'S DEVIOS
; CALLING . . .
;	MOVE AC,<JOB NUMBER WHOSE TTY IOS YOU WANT>
;	CALL AC,[SIXBIT /TTYIOS/]

TTYIOS:
	JUMPL	TAC,TTYIO3		;TRY NAME IF ILLEGAL NUMBER
	CAIL	TAC,JOBN
	JRST	TTYIO3			;ILLEGAL AS A JOB NUMBER, TRY AS A DEV NAME.
	HLRZ	DDB,DEVLST
TTYIO1:
	HLRZ	TAC1,DEVNAM(DDB)	;IS THIS A TELETYPE?
	CAIE	TAC1,'TTY'
	JRST	TTYIO2			;NO. KEEP LOOKING.
	LDB	TAC1,PJOBN		;YES, DOES THE JOB NUMBER MATCH?
	CAIE	TAC1,(TAC)
	JRST	TTYIO2			;NO, SCAN SOME MORE
TTYIO5:
	MOVE	TAC,DEVIOS(DDB)		;YES, PICK UP HIS IOS
	JRST	STOTAC			;AND GIVE IT TO HIM

TTYIO2:
	HLRZ	DDB,DEVSER(DDB)		;PICK UP NEXT DEVICE DATA BLOCK ADDRESS
	JUMPN	DDB,TTYIO1		;AND GO BACK IF NOT END OF LIST
TTYIO4:
	MOVNI	TAC,1			; IF END OF LIST, GIVE HIM A -1 TO CHEW ON
	JRST	STOTAC

TTYIO3:
	PUSHJ	P,DEVSRC		;TRY SEARCHING FOR THIS SIXBIT NAME.
	JRST	TTYIO4			;LOSE.
	JRST	TTYIO5			;WIN.

COMMENT $		WAKEME
CALLED BY:
	MOVE	AC,<ADDRESS OF 3 WORD BLOCK>
	CALL	AC,['WAKEME'] OR CALLI AC,400061
	<ERROR:  JOB NAMED WAS NOT IN BATMAN AND ROBIN, ELSE MAINTMODE SET>


BLOCK CONTAINS
	JOBNAME
	PPN
	DATA

IF JOBNAME AND PPN ARE FOUND IN BATMAN AND ROBIN THEN 
SET ALFRED TO DATA.  DATA IS INTERPRETED AS FOLLOWS
	<0 MEANS NEVER START THIS
	=0 MEANS KEEP THIS JOB RUNNING
	>0 DATA IS INTERPRETED AS 
		DATE,,TIME IN MINUTES 
	WHEN TO START THIS AGAIN.

ALFRED IS ZEROED AT SYSINI, SO ALL JOBS NAMED IN BATMAN WILL
BE STARTED AT RELOADS AND RESTARTS

$
WAKEME:

IFN FTBAT,<
	SKIPE	MAINTMODE		;SKIP IF NORMAL MODE
	POPJ	P,			;ERROR RETURN IF MAINTMODE
	XCTR	XR,[MOVE AC1,(UCHN)]	;GET USER'S POINTER
	XCTR	XR,[MOVE AC2,(AC1)]	;GET JOBNAME
	XCTR	XR,[MOVE AC3,1(AC1)]	;GET PPN
	MOVSI	TAC,-BATLEN		;GET SIZE OF BATMAN
WAKEM1:
	CAMN	AC2,BATMAN(TAC)		;LOOK IN TABLE
	CAME	AC3,ROBIN(TAC)		;SAME AS TABLE?
	JRST	WAKEM2			;NO
	XCTR	XR,[SKIPGE AC3,2(AC1)]	;GET DATA FOR ALFRED
	JRST	WAKEM3			;RUN NEVER.
	MOVE	AC1,TIME
	IDIVI	AC1,=60*JIFSEC
	HRL	AC1,THSDAT
	CAMG	AC3,AC1			;SKIP IF RUN IN THE FUTURE
	SETZM	BATYET			;MAKE CH7 LOOK NEXT TICK
WAKEM3:
	MOVEM	AC3,ALFRED(TAC)		;STUFF IT
	JRST	CPOPJ1			;GIVE HIM SUCCESS RETURN

WAKEM2:
	AOBJN	TAC,WAKEM1		;LOOK THRU TABLE
>
	POPJ	P,			;LOSE


;TRANSLATE SYSTEM CALL TO/FROM SIXBIT.

;CALL:	MOVE AC,[SIXBIT OR NUMERIC UUO]
;	CALLIT AC,
;	RETURN WITH NUMERIC OR SIXBIT FORM (RESP.), 0 IF ERROR

;IF AC12-16 ≠ 0,  ARG IS ASSUMED TO BE SIXBIT (ALL UUO MNEMONICS ARE > 2 CHARS)
; NUMERIC REPRESENTATION WILL BE RETURNED, OR 0 IF THE SPECIFIED UUO DOES
; NOT EXIST.  NOTE THAT CALLING THIS WITH 1- OR 2-CHARACTER NAMES MAY HAVE 
; STRANGE RESULTS.

;IF AC12-17 = 0,  ARG IS ASSUMED TO BE A NUMERIC UUO OF SOME FORM.  THE AC AND
; ADDRESS FIELDS MUST BE 0 UNLESS RELEVANT FOR DECODING (I.E. ADR OF CALLI,
; AC OF TTYUUO, ETC.).  IF THE ARG IS A LEGAL UUO, ITS SIXBIT MNEMONIC WILL BE
; RETURNED, OTHERWISE 0.  IN THE EVENT OF AMBIGUITY, THE MORE SPECIFIC MNEMONIC
; WILL BE RETURNED (E.G. INCHRW RATHER THAN TTYUUO).

;IF AC12-17 = 1, THE MNEMONIC FOR THE SPECIFIED MAJOR OPCODE WILL BE RETURNED.
; THE AC AND ADDRESS FIELDS MUST BE 0.  THIS PROVIDES A WAY TO GET AT MNEMONICS
; SUCH AS "TTYUUO".

CALLIT:
	TLNE TAC,36		;IF ITS SIXBIT
	JRST CALT0		;    THEN GO LOOK IT UP
	HLRZ TAC1,TAC
	CAIE TAC1,(<CALLI>)
	JUMPN TAC1,CALTU
	ANDI TAC,-1
	CAIGE TAC,UCLDLN	;IF ITS A DEC CALLI
	JRST CALT1		;    THEN GET THE SIXBIT
	TRZN TAC,400000		;IF NOT A STANFORD CALLI
	JRST RTZERO		;    THEN RETURN 0
	MOVEI TAC,UCLDLN(TAC)	;GET ACTUAL POINTER
	CAIL TAC,UCLLEN		;IF ITS OFF THE END
	JRST RTZERO		;    THEN RETURN 0
CALT1:
	MOVE TAC,UCLTAB(TAC)	;ELSE PICK UP SIXBIT
	JRST STOTAC		;THEN PUT IT IN AC AND RETURN

CALT0:
	MOVSI TAC1,-UCLLEN
	CAME TAC,UCLTAB(TAC1)	;SEARCH CALLI SIXBIT TABLE
	AOBJN TAC1,.-1
	JUMPGE TAC1,CALT2	;IF OFF THE END, TRY FOR OPCODES
	MOVEI TAC,(TAC1)
	CAIL TAC,UCLDLN		;IF STANFORD CALL
	MOVEI TAC,400000-UCLDLN(TAC)	;THEN CONVERT
	HRLI TAC,(<CALLI>)	;MAKE IT A CALLI
	JRST STOTAC		; AND SHIP IT

CALTU:
	ANDI TAC1,777000
	CAIL TAC1,40000
	CAIL TAC1,700000+IUUMAX*2000
	JRST CALT0		;OUTSIDE UUO RANGE - TRY AS SIXBIT
	CAIL TAC1,100000
	CAIL TAC1,700000
	TRNE TAC,-1
	JRST CALT0		;IN BETWEEN RANGES OR RH NOT ZERO
	TLZE TAC,1
	JRST CALTU2		;SPECIAL - FORCE MAJOR OPCODE NAME
	MOVSI AC1,(TAC1)
	MOVSI AC2,1000(TAC1)
	MOVEI TAC1,UUONAM	;HEADER FOR SECOND LEVEL TABLES
CALTU1:
	HRRZ TAC1,-1(TAC1)
	JUMPE TAC1,CALTU2	;NO MORE - MUST BE PLAIN UUO
	CAMG AC1,-1(TAC1)
	CAMG AC2,-1(TAC1)
	JRST CALTU1		;NOT THIS ONE
	HLLZ AC3,-1(TAC1)	;GET OPCODE
	CAMLE TAC,AC3
	JRST RTZERO		;ILLEGAL AC FIELD
	ROT TAC,15
	ANDI TAC,17		;ISOLATE AC FIELD
	ADD TAC,TAC1
	MOVE TAC,(TAC)		;GET SIXBIT
	JRST STOTAC

CALTU2:
	TLNE TAC,(<17,>)
	JRST RTZERO		;AC FIELD MUST BE ZERO
	ROT TAC,9		;GET OPCODE
	CAIL TAC,700
	SKIPA TAC,UUONAM+40-700(TAC)
	MOVE TAC,UUONAM-40(TAC)
	JRST STOTAC

CALT2:
	MOVSI TAC1,-IUUMAX*2-40	;TOTAL # MAJOR OPCODES
	CAME TAC,UUONAM(TAC1)
	AOBJN TAC1,.-1
	JUMPGE TAC1,CALT3	;NOT FOUND - TRY SECOND LEVEL TABLES
	MOVEI TAC,40(TAC1)	;THIS WILL BE THE OPCODE
	CAILE TAC,77
	MOVEI TAC,700-40(TAC1)	;UNLESS IT'S ONE OF THESE
	ROT TAC,-9		;PUT IT IN THE RIGHT PLACE
	JRST STOTAC

CALT3:
	MOVE DAT,[,UUONAM(TAC1)];INIT TABLE PNTR TO HDR, (TAC1) FOR @ BELOW
CALT4:
	HRR DAT,-1(DAT)		;GET NEXT TABLE LOC
	TRNN DAT,-1
	JRST RTZERO		;IF NO MORE JUST RET 0 FOR FAILURE
	LDB TAC1,[270400,,-1(DAT)];GET MAX #
	MOVNI TAC1,1(TAC1)	;OFFSET BY 1 FOR COUNT
	MOVSI TAC1,(TAC1)	;MAKE AOBJN PNTR
	CAME TAC,@DAT
	AOBJN TAC1,.-1
	JUMPGE TAC1,CALT4	;TRY NEXT TABLE IF NOT FOUND
	HLLZ TAC,-1(DAT)	;FOUND - GET BASE OPCODE
	DPB TAC1,[270400,,TAC]	;SET CORRECT AC FIELD
	JRST STOTAC

;SETPR2, BEGIN SEGUUO
SUBTTL	UUO'S FOR HIGH SEGMENTS
BEGIN SEGUUO
;	SETPR2	UUO
;	MOVE AC,[XWD PROT.,RELOC]
;	CALL AC,['SETPR2']
;	<ERROR RETURN>
;	<SUCCESS RETURN>
;
;	RELOC IS ABSOLUTE ADDRESS YOU WISH AS YOUR BASE ADDRESS
;	IF THE LOW ORDER BIT IS ON THEN RELOC IS A RELATIVE ADDRESS
;	IN YOUR CORE IMAGE.
;	IF THE LOW ORDER BIT OF PROT IS ON THEN ACCESS IS WRITE PROTECTED
;	IF THE ACCESS IS ABSOLUTE AND YOU ARE NOT 1,2 THEN YOU ARE
;	AUTOMATICALLY WRITE PROTECTED.
;	BOTH PROT. AND RELOC. ARE TRUNCATED TO 1K BOUNDARIES WHEN LOADED
;	INTO THE PROT.-RELOC. REGISTER.
;	IN RELATIVE MODE PROT. IS ADJUSTED TO BE WITHIN YOUR CORE IMAGE.

↑SETPR2:
	TRNE TAC,1		;IS THIS RELATIVE?
	JRST PR2REL
	MOVEI TAC1,(TAC)
	ANDCMI TAC1,1777
	CAML TAC1,RMEMSIZ	;IS RELOC GREATER THAN MEMORY?
	POPJ P,			;YES, LOSE
	MOVE	TAC1,RMEMSIZ
	CAILE	TAC1,-1		;FULL HOUSE?
	JRST	SETPRW		;YES. LET HIM WRAP AROUND.
	HLRZ TAC1,TAC
	TRO TAC1,1777
	HRRZ AC1,TAC
	ANDCMI AC1,1777
	ADDI TAC1,(AC1)
	CAML TAC1,RMEMSIZ	;IS RELOC+PROTECT GREATER THAN MEMORY?
	POPJ P,			;YES
SETPRW:
	MOVE TAC1,JBTPRV(J)	;GET THIS GUY'S PRIV BITS
	TLNN TAC1,ACWPRV	;SKIP IF HE HAS ABS CORE WRITE PRIV
	TLO TAC,1		;NO, WRITE PROTECT AUTOMATICALLY
	JRST PR2SET

; HERE WE ADDRESS CHECK HIS PR REQUEST

PR2REL:
	HLRZ TAC1,JBTADR(J)	;JOBS PROTECTION
	HRRZ AC1,TAC		;RELOC REQUESTED(RELATIVE TO CORE IMAGE).
	ANDCMI AC1,1777
	CAMLE AC1,TAC1		;TOO HIGH?
	POPJ P,			;LOSE
	HLRZ AC1,TAC		;PROT.
	TRO AC1,1777
	HRRZ AC2,TAC
	ANDCMI AC2,1777
	ADDI AC1,(AC2)		;+RELOC
	CAMLE AC1,TAC1		;TOO BIG?
	POPJ P,			;YES, LOSE
PR2SET:
	PUSH P,TAC
	PUSHJ P,KILSEG
	POP P,TAC
	AOS (P)
	TRZ TAC,1776		;MAKE IT PRETTY
	TLO TAC,1776		;	"
↑STPR2:	MOVEM TAC,JBTPR2(J)
	JRST SEGXIT	;SET UP PR AND JOBRL2

;GETPR2
;CALLING SEQUENCE:
;	CALL AC,['GETPR2']
;	<ALWAYS RETURNS HERE>
;
;	AC NOW CONTAINS XWD PROT.,RELOC. 
;	LOW ORDER BIT OF PROT IS ON IF ACCESS IS WRITE PROTECTED.
;	LOW ORDER BIT OF RELOC IS ON IF RELATIVE MODE.

↑PR2GET:MOVE TAC,JBTPR2(J)
	JRST STOTAC		;GIVE HIM CURRENT VALUE

; REMAP UUO . . .
; CALLING . . .
;	MOVEI AC,<HIGHEST ADDRESS IN LOW PART>
;	CALL AC,[SIXBIT /REMAP/]
;	<NO CAN DO>
; RETURNS JOB NUMBER OF SEGMENT IN ACCUMULATOR
; IF SIGN BIT IN AC IS ON, SETS SEGMENT AS WRITE-PROTECTED

↑REMAP:
	PUSH P,TAC
	PUSHJ P,LINKSEG
	PUSHJ P,MAKESEG
	LDB TAC1,PSEGN
	JUMPE TAC1,TPOPJ
	MOVE TAC,JBTSTS(TAC1)	; IF WE GOT AN OLD ONE, MAKE SURE IT IS IN CORE
	TLNE TAC,SWP!SHF
	PUSHJ P,WSCHED		; WAIT FOR IT TO GET IN
	SKIPN JBTADR(TAC1)	; DID WE GET A FRESH SEGMENT, OR LINK ON TO AN EXISTING ONE?
	JRST REMAP1		; WE GOT A NEW ONE
	TLNE TAC,JSEG
	JRST REMAP6
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/AT REMAP WITHOUT UPPER SEGMENT.
J=/]
	DISARG(DCP,<-20+J(P)>)
	[ASCIZ/  TAC1=/]
	DISARG(DCP,<-20+TAC1(P)>)
	[ASCIZ/
/]
	-1
	POPACS
	JSP DAT,UERROR

; REMAP - CHECK IF HE WANTS IT WRITE PROTECTED

REMAP6:
	TLNE TAC,JWP		; IS IT WRITE PROTECTED?
	SKIPL (P)		; YES, IS THAT WHAT WE WANT?
	CAIA
	JRST REMAP5		; YES

	TLNN TAC,JWP		; IS IT UNPROTECTED?
	SKIPGE (P)		; YES, IS THAT WHAT WE WANT?
	CAIA
	JRST REMAP5
	PUSHJ P,MAKESEG		; NO, GET A NEW ONE
	LDB TAC1,PSEGN		;GET SEGMENT #
	JUMPE TAC1,TPOPJ	; LEAVE NOW IF WE DIDN'T GET ONE!
	JRST REMAP1

REMAP5:
	POP P,TAC		; GET NEW CORE ASSIGNMENT BACK
	HRRZS TAC
	ORI TAC,1777
	PUSHJ P,CORUUO
	CAIA
	JRST REMAP7
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/ERROR RETURN FROM CORUUO AT REMAP5
J=/]
	DISARG(DCP,<-20+J(P)>)
	-1
	POPACS
	JSP DAT,UERROR
REMAP7:
	LDB TAC1,PSEGN
	LDB UCHN,PUUOAC		; CORUUO USES UCHN ITSELF!
	JRST REMAP2

; REMAP - IF HE IS NOT ON 1K BOUNDARY, ADJUST HIM

REMAP1:
	SETCM TAC,(P)		; NOW WE DO THE SIMULATED UPWARDS BLT
	TRNN TAC,1777		; IS HE ALREADY AT A 1K BOUNDARY
	JRST REMAP3		; YES.
	HRRZ TAC,USRREL(PID)	; NO. GET AN EXTRA 1K TO BLT HIM UP INTO
	ADDI TAC,2000
	PUSHJ P,CORUUO
	CAIA
	JRST REMAP8
	POP P,TAC
	JRST KILSEG

REMAP8:
	HRRZ TAC,(P)
	PUSHJ P,BLTUP		;MOVE UP UPPER
	LDB TAC1,PSEGN
	LDB UCHN,PUUOAC		; CORUUO USES UCHN ITSELF!
REMAP3:
	POP P,TAC
	MOVSI DAT,JWP
	SKIPG TAC
	ORM DAT,JBTSTS(TAC1)
	HRRZS TAC
	ORI TAC,1777
	CAML TAC,USRREL(PID)
	JRST KILSEG
	HRLM TAC,JBTADR(J)
	HRLM TAC,JOBADR
	HRRM TAC,USRREL(PID)
	HRRM TAC,JOBREL(JDAT)
IFN FTSTAT,<
	PUSH P,TAC
	LSH TAC,-4
	ANDI TAC,37700
	ADDI TAC,CSZSTA+100
	PUSHJ P,STAPUT
	POP P,TAC
>;FTSTAT
	ADDI TAC,1(PROG)
	HRRM TAC,JBTADR(TAC1)
IFN FTSTAT,<
	LSH TAC,-4
	ANDI TAC,37700
	TRO TAC,CPSSTA
	PUSHJ P,STAPUT
>;FTSTAT
	HLRZ TAC,PROG
	SUB TAC,USRREL(PID)
	SUBI TAC,1
	HRLM TAC,JBTADR(TAC1)
IFN FTSTAT,<
	LSH TAC,-4
	ANDI TAC,37700
	ADDI TAC,CSZSTA+100
	PUSHJ P,STAPUT
>;FTSTAT
	HRL PROG,USRREL(PID)
	PUSH	P,TAC1			;REG. FIX CORTAB AT REMAP TIME.
	HRRZ	DSER,JBTADR(TAC1)	;GET THE LOWEST ADDRESS IN UPPER
	HLRZ	AC1,JBTADR(TAC1)	;GET THE PROTECTION OF UPPER.
	MOVEI	UCHN,0			;SET TO RELEASE CORE.
	PUSHJ	P,CORSTG		;RELEASE THIS FROM CORTAB
	MOVE	UCHN,(P)		;GET THE JOB NUMBER OF UPPER.
	HLRZ	AC1,JBTADR(UCHN)	;GET THE PROTECTION AGAIN
	PUSHJ	P,CORSTG		;CLAIM BLOCKS IN CORTAB
	POP	P,TAC1
	LDB	UCHN,PUUOAC		;RESTORE UCHN
REMAP2:
	XCTR	XW,[MOVEM TAC1,(UCHN)]
	AOS	(P)
	JRST	SEGXIT

;BLTUP - FAST UPWARDS BLT
;TAKES SOURCE ADDRESS-1 IN TAC (RELATIVE)
;BLTS UP REST OF CORE IMAGE TO NEXT 1K BOUNDARY
;CAN ALSO ENTER AT FASBLT WITH TAC1=DEST-1 AND AC2=END DEST
;CLOBBERS TAC,TAC1,AC1,AC2,AC3
;THIS CODE IS MORE OR LESS COPIED FROM CORE ROUTINES IN 'E'

↑BLTUP:	MOVEI TAC1,(TAC)
	IORI TAC1,1777		;DEST ADR
	HLRZ AC2,PROG
FASBLT:
	SUBI AC2,(TAC1)		;LENGTH OF XFER
	SUBI TAC1,(TAC)		;DIST OF XFER
	ADDI TAC,(PROG)		;RELOCATE
	CAILE AC2,(TAC1)	;EASY (NO OVERLAP) IF LENGTH<DIST
	JUMPGE TAC1,BLTUP1	;NOW WE NEED TO WORRY
	JUMPLE AC2,CPOPJ
	MOVEI AC3,(TAC)
	ADD AC3,TAC1		;GET BACK DEST
	HRLI AC3,(TAC)
	ADDI AC2,(AC3)		;END LOC+1
	BLT AC3,-1(AC2)
	POPJ P,

BLTUP1:
	CAILE TAC1,5		;THIS IS BELIEVED TO BE THE ROUGH BREAK-EVEN POINT
	JRST BLTUP2		;BETWEEN THE TWO METHODS
	JUMPE TAC1,CPOPJ
	MOVSI AC1,(<POP TAC1,(TAC1)>)
	HRRI AC1,(TAC1)
	MOVSI TAC1,377777(AC3)	;SET COUNT TO GO NEG AFTER APPROP # OF WDS
	HRRI TAC1,(TAC)
	ADDI TAC1,(AC3)		;INITIAL FETCH ADR
	MOVE AC2,[JUMPL TAC1,AC1]
	MOVE AC3,[POPJ P,]	;TO GET US BACK
	JRST AC1		;ROAR

;HERE WE ITERATE ON BLTS, POSSIBLY STARTING WITH A SMALLER ONE

BLTUP2:
	PUSH P,AC2
	IDIVI AC2,(TAC1)	;REMAINDER WILL BWE SIZE OF SHORT ONE
	MOVE AC2,(P)
	ADDI AC2,1(TAC)		;SOURCE END ADR+1
	HRLI AC2,(AC2)
	ADDI AC2,(TAC1)		;SOURCE END+1,,DEST END+1
	JUMPE AC3,BLTUP3	;SKIP INITIAL STEP IF 0 REMAINDER
	MOVSI AC1,(<BLT AC3,(AC2)>)
	HRRI AC1,-1(AC3)
	HRLI AC3,(AC3)
	SUBB AC2,AC3		;BACK UP & DUPLICATE POINTER
	XCT AC1
BLTUP3:
	HRLI TAC1,(<BLT AC3,(AC2)>)	;CREATE BLT WITH APPROP OFFSET
	MOVEM TAC1,(P)
	SOS (P)
	HRLI TAC1,(TAC1)	;DIST,,DIST
	MOVEI AC1,1(TAC)
	ADDI AC1,(TAC1)		;DEST ADR
BLTUP4:
	SUB AC2,TAC1		;BACKUP PNTR OVER NEXT BLT
	MOVE AC3,AC2		;DUPLICATE FOR BLT
	XCT (P)			;DO BLT
	CAIGE AC1,(AC2)		;DOWN TO STARTING DEST ADR YET?
	JRST BLTUP4		;NO - DO SOME MORE
	SUB P,[1,,1]
	POPJ P,

; UUO TO SET OR CLEAR USER WRITE-PROTECT BIT
; CALLING . . .
;	MOVE AC,<0 FOR CLEAR, ≠0 FOR SET>
;	CALL AC,[SIXBIT /SETUWP/]
;	<NO CAN DO>

↑SETUWP:
	PUSH P,J
	PUSH P,TAC
	LDB J,PSEGN
	JUMPN J,SETUW1
	POP P,TAC
	POP P,J
	JRST SEGXIT

SETUW1:
	PUSHJ P,ACCESS
	JFCL
	JRST SETUW2
	POP P,TAC1
	MOVSI TAC,JWP
	JUMPE TAC1,.+2
	IORB TAC,JBTSTS(J)
	JUMPN TAC1,.+2
	ANDCAB TAC,JBTSTS(J)
	HLRZ TAC1,JBTADR(J)	;FOR CORE2X
	JRST CORE2X	;UPDATE EVERYONE'S JOBRL2 WP FLAG

SETUW2:
	POP P,TAC
	POP P,J		; FORGET IMMEDIATELY IF READ-ONLY ACCESS
	SKIPE TAC
	JRST CPOPJ1
	POPJ P,

;UNPURE - MAKE A WRITEABLE COPY OF WRITE-PROTECTED UPPER, IF NECESSARY
;SKIPS IF SUCCESSFUL, IF ALREADY WRITEABLE, OR IF NO UPPER
;NO-SKIP MEANS COPY COULDN'T BE CREATED (JOB SLOTS OR CORE NEEDED)

↑UNPURE:
	LDB AC1,PSEGN
	JUMPE AC1,UNPNON	;NONE AT ALL, CHECK PR2
	MOVE TAC,JBTSTS(AC1)
	TLZN TAC,JWP
	JRST CPOPJ1		;NOT WRITE-PROTECTED
	MOVE TAC1,NJOBS(AC1)
	SOJE TAC1,UNPUR3	;SEE IF WE HAVE SOLE ACCESS
	PUSHJ P,ANYACT		;NO - WAIT FOR I/O & SPW
	PUSHJ P,IOWAIT
	LDB AC1,PSEGN
	PUSHJ P,ESTSEG		;TRY TO CREATE FRESH UPPER
	JRST SPWCNT		;NO JOBS
	MOVSI TAC,SWP
	IORM TAC,JBTSTS(J)	;PRETEND SWAPPED OUT SO CORGET WON'T CALL XPAND
	MOVEI PROG,		;NO CORE YET
	HLRZ TAC,JBTADR(AC1)	;HOW MUCH WE WOULD LIKE
	PUSHJ P,CORGET		;TRY TO GET IT
	JRST UNPNC		;NO CAN DO - MUST HACK VIA SWAPPER
	MOVSI TAC,SWP
	ANDCAM TAC,JBTSTS(J)	;FIX THIS BEFORE WE FORGET
	MOVE AC1,JOB
	LDB AC1,[600,,JBTSTS(AC1)]	;GET CURRENT SEGMENT AGAIN
	HLRZ TAC,PROG
	ADDI TAC,(PROG)
	HRL PROG,JBTADR(AC1)
	BLT PROG,(TAC)		;COPY DATA TO NEW SEGMENT
UNPURX:
	PUSH P,J
	MOVE J,JOB
	MOVE PROG,JBTADR(J)
	PUSHJ P,SPWCNT		;IN CASE SPW STOPPED
	PUSH P,AC1
	PUSHJ P,KILSEG		;GET RID OF OLD SEGMENT
	POP P,J
	POP P,TAC
	PUSHJ P,MAKSE2		;COPY PARAMETERS FROM OLD
	MOVE J,JOB(PID)
	DPB TAC,PSEGN		;THIS IS NOW OUR SEGMENT
IFN FTSTAT,<
	PUSHJ P,SEGSTT
	LDB TAC,PSEGN
>;FTSTAT
UNPUR2:
	MOVEI AC1,(TAC)
UNPU21:
	MOVE TAC,JOBNAM(AC1)	;MUNG JOBNAM SO THE OLD ONE IS STILL UNIQUE
	LSH TAC,-6		;CLEVERLY PRESERVING THE INFO FOR HUMANS
	MOVEM TAC,JOBNAM(AC1)
	MOVEI TAC,400(J)	;400 BIT WILL FEND OFF ACCESS
	DPB TAC,[331100,,JOBCRD(AC1)]	;CLEAR PROTECTION
	JRST SEGXT1		;RETURN SUCCESSFULLY

UNPUR3:
	MOVEM TAC,JBTSTS(AC1)	;OURS ALONE - JUST UNPROTECT IT
	JRST UNPU21

UNPNON:
	MOVSI TAC,1
	TSNE TAC,JBTPR2(J)	;IF HE HAS RELATIVE PR2
	ANDCAM TAC,JBTPR2(J)	;THEN UNPROTECT IT
	JRST SEGXT1		;NOW UPDATE PR & JOBHRL & SKIP RETURN

;UNPURE CONTINUED:
;HERE WE COULDN'T GET CORE IMMEDIATELY FOR THE NEW SEGMENT, SO WE'LL GET
;THE SWAPPER TO DO THE WORK

;FIRST WE MAKE SURE THE CORE AND DISK COPIES OF OUR PRESENT UPPER AGREE.
;IF NOT, WE WAIT WHILE TRYING TO FORCE A SWAP
UNPNC:
	MOVSI TAC,SWP
	ANDCAM TAC,JBTSTS(J)	;FIRST PUT THIS BACK
	MOVE AC1,JOB(PID)
	LDB AC1,[600,,JBTSTS(AC1)]	;GET BACK OLD UPPER #
	HLRZ TAC,JBTSWP(AC1)
	SKIPN STIME(AC1)
	JUMPN TAC,UNPNC4	;AH, UPPER HAS BEEN SWAPPED AND NOT CHANGED
	MOVSI TAC,JSEG!JNA!JLOG
	ANDCAM TAC,JBTSTS(J)	;MUST WAIT - MEANWHILE GIVE BACK JOB SLOT
	SETZM PRJPRG(J)
	MOVEI TAC,NULQ
	MOVNM TAC,JOBQUE(J)
	PUSHJ P,REQUE
	MOVE J,JOB(PID)		;NOW BE OURSELVES, WAITING FOR OUR UPPER TO GET SWAPPED
UNPNC1:
	LDB AC1,PSEGN
	HLRZ TAC,JBTSWP(AC1)
	SKIPN STIME(AC1)
	JUMPN TAC,UNPNC3	;NOW WE'RE ALMOST READY
	SKIPN FINISH		;NOT YET - SEE IF WE CAN DIDDLE THE SWAPPER
	SKIPE FORCE
	JRST UNPNC2		;NO - WAIT A LITTLE
	MOVEM AC1,FORCE		;YES - THIS OUGHT TO GET IT OUT THERE
	SETZM SWPCNT
UNPNC2:
	PUSHJ P,WSCHED		;WASTE A LITTLE TIME
	JRST UNPNC1		;AND TRY AGAIN

;SWAPPING IS NOW COMPLETE. NOW TRY TO GET BACK JOB SLOT.
UNPNC3:
	PUSHJ P,ESTSEG
	JRST SPWCNT		;AFTER ALL THAT WORK ...

;THE CORE AND DISK COPIES OF THE UPPER NOW AGREE. WE WILL STEAL THE CORE COPY,
;LEAVING THE OTHER LOSERS TO FIGHT OVER GETTING THE DISK ONE SWAPPED BACK IN.
UNPNC4:
	MOVSI TAC,SWP
	IORM TAC,JBTSTS(AC1)	;SEE US SCREW ALL THE OTHER POOR LOSERS
	MOVEI DSER,
	EXCH DSER,JBTADR(AC1)	;THE OLD UPPER IS NOW OFFICIALLY SWAPPED OUT!
	MOVEM DSER,JBTADR(J)	;GEE, WHAT AN EASY CORE UUO
	PUSH P,AC1
	HLRZ AC1,DSER		;NOW ALL WE HAVE TO DO IS FIX CORTAB
	ANDI DSER,-1
	MOVEI UCHN,
	PUSHJ P,CORSTG		;OUT WITH THE OLD JOB
	MOVEI UCHN,(J)
	HLRZ AC1,JBTADR(J)
	PUSHJ P,CORSTG		;AND IN WITH THE GOOD
	POP P,AC1		;RESTORE JOB NUMBER OF OLD SEG TO COPY DATA
	JRST UNPURX		;DO THE FINAL CLEANUP AND LEAVE

; CORE UUO FOR HIGH SEGMENTS
; CALLING . . .
;	MOVE AC,<HIGHEST REL. ADR. IN UPPER, INCLUDING 0>
;	CALL AC,[SIXBIT /CORE2/]
;	<ERROR RETURN>

↑CORE2:
	TRNE	TAC,377777		;IS HE REQUESTING ANY CORE AT ALL?
	JRST	CORE2A			;YES.
	AOS	(P)			;NO. GIVE HIM THE SUCCESS RETURN
	JRST	KILSEG			;AND KILL THE SEGMENT

CORE2A:
	ORI	TAC,1777		;ROUND UP TO NORMAL BOUNDARY
	ANDI	TAC,377777		;ZERO SOME BITS.
	PUSH	P,J
	LDB	J,PSEGN
	JUMPN	J,CORE2B		;JUMP IF WE HAVE A SEGMENT ALREADY.
	POP	P,J			;HERE WE HAVE TO MAKE A NEW SEGMENT
	PUSH	P,TAC
	PUSHJ	P,MAKESEG
	POP	P,TAC
	LDB	TAC1,PSEGN
	JUMPE	TAC1,SEGXIT		;WE LOSE SOMEHOW - NO SEGMENT AVAILABLE.
	PUSH	P,J
	LDB	J,PSEGN
	JRST	CORE2N			;AVOID ACCESS CHECK WHEN MAKING A NEW ONE

CORE2B:
	PUSH	P,TAC
	PUSH	P,-1(P)			;PUT JOB NUMBER ON TOP OF STACK
	PUSHJ	P,ACCESS
	JFCL				;LOSE?
	JRST	CORE2C			;LOSE?
	POP	P,(P)
	POP	P,TAC
CORE2N:
	MOVE	PROG,JBTADR(J)		;J HAS NUMBER OF THE UPPER.
	PUSHJ	P,CORUUO
	JRST	CORE2D
	PUSH	P,PROG
	MOVE TAC,JBTSTS(J)
	TLNN TAC,SWP!SHF	;SWAPPED OR MOVING?
	SKIPE XJOB(J)		;OR TRYING TO GROW?
	PUSHJ P,WSCHED		;YES, WAIT FOR IT
	POP P,PROG		;GET THIS BACK
	HLRZ TAC1,PROG
CORE2X:
	TLNE TAC,JWP
	TLO TAC1,400000		;TELL LOSERS ABOUT WRITE PROTECTION
	MOVE TAC,J
	TRO TAC1,400000
	AOS -1(P)		;SET FOR SUCCESS RETURN

; CORE2 - SCAN FOR ALL JOBS USING THIS SEGMENT AND TELL THEM HE HAS CHANGED SIZE

	MOVEI J,JOBN-1		;SET JOBRL2 FOR ALL JOBS USING THIS SEGMENT.
SETRL2:
	LDB TEM,PSEGN
	CAMN TEM,TAC
	SKIPN PROG,JBTADR(J)
	JRST .+2
	MOVEM TAC1,JOBRL2(PROG)
	SOJG J,SETRL2
CORE2D:
	POP P,J
	MOVE PROG,JBTADR(J)
	JRST SEGXIT

CORE2C:
	POP P,(P)
	POP P,TAC
	POP P,J
	JRST KILSEG


; ATTACH HIGH SEGMENT
; CALLING . . .
;	MOVE AC,<JOB NUMBER OR JOB NAME>
;	CALL AC,[SIXBIT /ATTSEG/]
;	<NO CAN DO, ERROR CODE IN AC>
;
; ERROR CODES:
; 0 - PROTECTION VIOLATION
; 1 - AMBIGUOUS ADDRESSEE
; 2 - NOT A HIGH SEGMENT
; 3 - DOES NOT EXIST
; 4 - ALREADY HAVE A HIGH SEGMENT

↑ATTSEG:
	LDB	TAC1,PSEGN
	SKIPN	JBTPR2(J)		;CAN'T ATTACH WHILE DOING PEEK-POKE
	JUMPE	TAC1,ATTSE5
	MOVEI	TAC,4
	JRST	ATTSER
ATTSE5:
	TDNE	TAC,[-100]
	JRST	ATTSGJ
ATTSE1:
	MOVE	TAC1,JBTSTS(TAC)
	TLNE	TAC1,JSEG
	JRST	ATTSE6
	MOVEI	TAC,1
ATTSER:
	XCTR	XW,[MOVEM TAC,(UCHN)]
	POPJ	P,

ATTSE6:
	PUSH	P,J
	MOVE	J,TAC
	PUSHJ	P,ACCESS
	JRST	ATTSE7
	JFCL
	MOVE	TAC1,J
	POP	P,J
	DPB	TAC1,PSEGN
IFN FTSTAT,<
	PUSH P,TAC
	PUSHJ P,SEGSTT
	POP P,TAC
>;FTSTAT
	AOS	NJOBS(TAC1)		; BUMP COUNT OF PEOPLE POINTING TO THIS SEGMENT
	SKIPN	AC1,JBTDTS(J)		;DOES HE HAVE A LIST OF DETACHED SEGMENTS?
	JRST	ATTSE2			;NO.
ATTSE3:
	LDB	DAT,PDSEGN		;YES, IS THERE A SEGMENT NUMBER THERE
	JUMPE	DAT,ATTSE2		;NO SEGMENTS LEFT IN LIST
	CAME	DAT,TAC1		;IS THIS THE ONE IN QUESTION?
	AOJA	AC1,ATTSE3		;NO, TRY THE NEXT ONE
	MOVE	TEM,AC1			;YES, RUN DOWN TO END OF LIST
	ADDI	TEM,1			;UPDATE LIST OF DETACHED SEGMENTS
ATTSE4:
	SKIPE	(TEM)			;IS THIS THE END OF LIST?
	AOJA	TEM,ATTSE4		;NO, TRY AGAIN
	MOVE	DAT,-1(TEM)		;MOVE LAST WORD ONTO WHERE WE'RE DELETING
	MOVEM	DAT,(AC1)
	SETZM	-1(TEM)			;ZERO THE END OF THE LIST
	SUBI	TEM,1
	CAME	TEM,JBTDTS(J)		;DOES HE HAVE ANY DETACHED SEGMENTS LEFT?
	JRST	ATTSE2			;YES, WE ARE DONE
	MOVE	AC1,JBTDTS(J)		;NO, WE CAN GIVE BACK FREE STORAGE
	PUSHJ	P,FSGIVE
	SETZM	JBTDTS(J)
ATTSE2:
	AOS	(P)
	PUSHJ	P,WSCHED		;MAKE SURE SEGMENT IS IN CORE
	JRST	SEGXIT			; NOW GO SET PROT-RELOC

;ATTSEG	 SEARCH FOR A SEGMENT OF A GIVEN NAME
ATTSGJ:
	MOVE	DAT,JOBNM1
ATTSG1:
	CAME	TAC,JOBNAM(DAT)
	JRST	ATTSG4
	MOVE	TAC1,JBTSTS(DAT)
	TLNN	TAC1,JSEG
	JRST	ATTSG4
	MOVE	TAC1,DAT
	JRST	ATTSG2
ATTSG4:
	SOJG	DAT,ATTSG1
	MOVEI	TAC,3
	JRST	ATTSER

ATTSG3:
	CAME	TAC,JOBNAM(DAT)
	JRST	ATTSG2
	MOVE	TEM,JBTSTS(DAT)
	TLNN	TEM,JSEG
	JRST	ATTSG2
	MOVEI	TAC,1
	HRL	TAC,DAT
	JRST	ATTSER

ATTSG2:
	SOJG	DAT,ATTSG3
	MOVE	TAC,TAC1
	JRST	ATTSE1		;GO TRY IT

ATTSE7:
	POP	P,J
	MOVEI	TAC,0
	JRST	ATTSER

;DETSEG  DETACH SEGMENT
; CALLING . . .
;	CALL AC,[SIXBIT /DETSEG/]
; IF AC=0, THEN THE SEGMENT IS DETACHED AND PLACED INTO A LIST
; OF THE SEGMENTS THIS GUY HAS DETACHED, SUCH THAT WHEN THE
; SYSTEM CALLES RESET, ALL HIS DETACHED SEGMENTS GO AWAY. IF AC LOW
; ORDER BIT IS ON, SEGEMENT WILL BE SPECIALLY DETACHED- WILL STICK AROUND
; UNTIL THE MAKER KJOBS.

↑DETSEG:
	SKIPE	JBTPR2(J)		;DOING PEEK-POKE?
	JRST	[SETZM	JBTPR2(J)	;FLUSH PEEK-POKE
		JRST	SEGXIT]
	LDB	TAC1,PSEGN
	JUMPE	TAC1,CPOPJ		;NO HIGH SEGMENT HERE, HOW STRANGE!
	SKIPE	AC1,JBTDTS(J)		;PUT THIS ON THE LIST OF DETACHED SEGMENTS.
	JRST	DETSE1			;HE HAS A DETACHED SEGMENT LIST ALREADY.
	MOVEI	AC3,JOBN		;NO, GET HIM ONE ABOUT THIS LONG.
	PUSHJ	P,UFSGET
	HRRZM	AC1,JBTDTS(J)
	JRST	DETSE2

DETSE1:
	SKIPE	(AC1)			;NOW RUN DOWN TO END OF LIST
	AOJA	AC1,DETSE1
DETSE2:
	TRNE	UCHN,1			;DOES HE HAVE THE 1-BIT ON IN THE AC FIELD?
	TLO	TAC1,400000		;YES, SET SPECIAL DET SEG.
	MOVEM	TAC1,(AC1)		;PUT THIS SEGMENT NUMBER IN THE TABLE
	SOSGE	NJOBS(TAC1)
	PUSHJ	P,NJERR
	SETZB	TAC,1(AC1)		;AND MARK THE END OF LIST
	DPB	TAC,PSEGN
IFN FTSTAT,<
	PUSHJ P,SEGSTT
	LDB TAC,PSEGN
>;FTSTAT
	JRST	SEGXIT

NJERR:
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/NJOB WENT NEGATIVE AT DETSEG
/
	POPACS
	SETZM	NJOBS(TAC1)
	POPJ	P,

; DETSEG - COMMON SEGMENT UUO EXIT ROUTINE

SEGXT1:
	AOS (P)
SEGXIT:
	PUSHJ P,GETPR
	DATAO APR,TAC
	LSH TAC,-11	;SET JOBHRL DIRECTLY FROM PR WD SO SETPR2 WILL WIN TOO
	TRNN TAC,JWP⊗<22-11>
	TLZA TAC,-1
	HRLI TAC,400000
	IORI TAC,401777
	CAMN PROG,JBTADR(J)
	JRST SEGXT3
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ/πππPROG CLOBBERED AT SEGXIT
PROG=/
	MOVE TAC,PROG
	PUSHJ P,DISOCT
	POPACS
	MOVE PROG,JBTADR(J)
SEGXT3:
	MOVEM TAC,JOBRL2(PROG)
	POPJ P,

; GET NUMBER OF SEGMENT BELONGING TO JOB N
; IF N IS ZERO, RETURNS YOUR SEGMENT NUMBER
; ZERO RETURNED MEANS NO SEGMENT

↑SEGNUM:
	CAIL	TAC,0
	CAIL	TAC,JOBN
	JRST	UUOERR
	CAIN	TAC,0
	MOVE	TAC,J
	MOVE	J,TAC
	LDB	TAC,PSEGN
	XCTR	XW,[MOVEM TAC,(UCHN)]
	POPJ	P,

; SEGSIZ CALLING . . .
;	CALL AC,[SIXBIT /SEGSIZ/]
; RETURNS HIGHEST LEGAL ADDRESS IN UPPER SEGMENT
; MINUS 400000
; RETURNS ZERO IF YOU DO NOT HAVE AN UPPER SEGMENT

↑SEGSIZ:
	LDB TAC,PSEGN
	JUMPE TAC,STOTAC
	HLRZ TAC,JBTADR(TAC)
	JRST STOTAC

; SETNM2 CALLING . . .
;	MOVE AC,[SIXBIT /<NAME YOU WISH YOUR UPPER TO HAVE>/]
;	CALL AC,[SIXBIT /SETNM2/]
;	<ERROR RETURN>
; IF YOU HAVE AN UPPER SEGMENT, GIVES IT THE NAME IN ACCUMULATOR AC.
; IF YOU DON'T HAVE AN UPPER, THIS UUO IS A NO-OP.
; UPON SUCCESS, AC IS CLEARED, UNLESS THERE IS ANOTHER SEGMENT OF THE SAME NAME,
;	 IN WHICH CASE YOU GET ITS JOB NUMBER

↑SETNM2:
	LDB TAC1,PSEGN
	JUMPE TAC1,CPOPJ1
	PUSH P,TAC
	PUSH P,J
	MOVE J,TAC1
	PUSHJ P,ACCESS
	JFCL
	JRST SETNM5
	POP P,TAC1
	POP P,JOBNAM(J)
IFN FTSTAT,<PUSHJ P,NAMSTT>
	MOVEI TAC1,JOBN-1
SETNM3:
	MOVE DAT,JBTSTS(TAC1)
	TLNN DAT,JSEG
	JRST SETNM4
	MOVE DAT,JOBNAM(TAC1)
	CAME TAC1,J
	CAME DAT,JOBNAM(J)
SETNM4:
	SOJG	TAC1,SETNM3
	XCTR	XW,[MOVEM TAC1,(UCHN)]
	JRST	CPOPJ1

SETNM5:
	POP P,J
	JRST TPOPJ

; ROUTINE TO GET YOUR SEGMENT'S NAME
; CALLING . . .
;	CALL AC,[SIXBIT /SEGNAM/]
; NAME (OR 0) RETURNED IN ACCUMULATOR

↑SEGNAM:
	LDB J,PSEGN
	MOVE TAC,JOBNAM(J)
	JRST STOTAC

; THIS UUO FIRST KILLS ANY HIGH SEGMENT YOU MAY HAVE.
; CALLING . . .
;	CALL [SIXBIT /LINKUP/]
;	<NO CAN DO>
; IT THEN ATTEMPTS TO MAKE A LINKUP WITH ANY HIGH SEGMENT
; IN CORE WITH YOUR CREDENTIALS.

↑LINKUP:
	PUSHJ P,LINKSEG
	POPJ P,
	JRST ATTSE2		; BRING UPPER INTO CORE, AND SKIP RETURN

; RETURNS LIST OF JOB NUMBERS WHO POINT TO YOUR UPPER SEGMENT.
; THE LIST TERMINATES WITH A ZERO
; IF YOU HAVE NO UPPER SEGMENT, ZERO IS RETURNED IN ADR
; ADR BETTER BE AT LEAST JOBN WORDS LONG.
; CALLING . . .
;	POINTS ADR

↑POINTS:
	LDB	DAT,PSEGN
	JUMPE	DAT,POINT3
	MOVEI	J,JOBN-1
POINT2:
	LDB	TAC1,PSEGN
	CAME	TAC1,DAT
	JRST	POINT1
	XCTR	XW,[MOVEM J,(UUO)]
	ADDI	UUO,1
POINT1:
	SOJG	J,POINT2
POINT3:
	XCTR	XW,[SETZM (UUO)]
	POPJ	P,

; SET PROTECTION ON A HIGH SEGMENT
; CALLING . . .
;	MOVE AC,<0-8 NEW PROTECTION KEY; 30-35 SEGMENT NUMBER>
;	CALL AC,[SIXBIT /SETPRO/]
;	<NO CAN DO>
;
; IF SEGMENT NUMBER IS ZERO, REFERS TO YOUR OWN SEGMENT

↑SETPRO:
	PUSH P,TAC
	PUSH P,J
	LDB J,[POINT 6,TAC,35]
	SKIPE J
	JRST SETP3
	MOVE J,(P)
	LDB J,PSEGN
	JUMPN J,SETP3
SETP1:
	POP P,J
	POP P,TAC
	POPJ P,

SETP3:
	MOVE TAC1,JBTSTS(J)
	TLNN TAC1,JSEG
	JRST SETP1
	PUSHJ P,ACCESS
	JFCL
	JRST SETP1
	MOVE TAC1,(P)
	MOVE TAC1,JBTPRV(TAC1)
	TLNE TAC1,SEGPRV	;SKIP UNLESS HE HAS SEGMENT PRIV
	JRST SETP2		;SEG PRIV. HE WINS
	TRNE TAC,400		;PROTECTION PROTECTED?
	JRST SETP1
SETP2:
	MOVE TAC,-1(P)
	LSH TAC,-=27
	ANDI TAC,377		;ONLY REAL BITS
	DPB TAC,[POINT =9,JOBCRD(J),8]
	AOS -2(P)
	JRST SETP1

BEND SEGUUO

	SUBTTL	INTUUO - UUOS FOR NEW STYLE INTERRUPT SYSTEM
; UUO TO SET THE PROCESSOR RUNNING MASK
; CALLING . . .
;	MOVE AC,[<RUN BITS>]
;	CALL AC,[SIXBIT /RUNMSK/]
; THE BITS ARE
; BIT 35 - RUNNABLE ON P1
; BIT 34 - RUNNABLE ON P2

RUNMSK:

REPEAT 0,<
	DPB TAC,PRUNB
>
	POPJ P,

; INTENB
; ENABLE INTERRUPTS . . .
;	MOVE AC,[MAGIC BITS]
;	CALL AC,[SIXBIT /INTENB/]

INTENB:
	PUSHJ P,INTCHK
	MOVE AC1,JBTIEN(J)	;OLD ENABLINGS
	MOVEM TAC,JBTIEN(J)	;NEW ENABLINGS
	XOR AC1,TAC
	TLNN AC1,INTCLK		;SKIP IF INTCLK CHANGING
	JRST INTAPC		;INTAPC NEEDS TAC = JBTIEN
	TLNN TAC,INTCLK		;SKIP IF TURNING INTCLK ON
	JRST INTEN1		;TURNING IT OFF
	PUSHJ P,CLKENB		;PLANT CLOCK REQUEST IN APRLST FOR 1 TICK
	JRST INTAPC

INTEN1:
	PUSHJ P,INTAPC
	MOVSI TAC,INTCLK
	ANDCAM TAC,JBTIRQ(J)	;FLUSH PENDING CLOCK INTERRUPT
	JRST APRDKL		;KILL ANY CLOCK REQUESTS WE MIGHT HAVE

INTCHK:
	TLZ TAC,INTWAIT		;UUO WAIT IS THE ONLY PROTECTED INTERRUPT BIT
	TDNN TAC,JOBENB(PROG)
	POPJ P,
INTLOS:
	JSP TAC,UUOMES
	ASCIZ /CONFLICT BETWEEN INTERRUPT ENABLINGS
UUO/

; CLKENB, CLKENA  - ENABLE FOR USER CLOCK INTERRUPTS
; CLKENA - SAME AS CLKENB EXCEPT TAC HAS NUMBER OF TICKS FOR REQ

CLKENB:
	PUSH P,TAC
	TDZA TAC,TAC		;FLAG NOT TO STORE TIME
CLKENA:
	PUSH P,TAC
	JUMPN PID,TPOPJ		;NO INTERRUPTS ON P2
CLKNB1:
	CONO PI,APROFF
	SKIPN AC1,APRLST
	JRST CLKNB2		;HAVE TO CREATE APRLST BLOCK
CLKNBL:
	SKIPN AC2,(AC1)		;FIND THE FIRST BLANK SPOT
	JRST CLKNB5		;END OF LIST AND THIS JOB HAS NO REQ YET
	CAIN J,(AC2)		;IS THERE AN ENTRY FOR THIS JOB?
	JRST CLKNB4
	ADDI AC1,2		;LOOP AROUND
	JRST CLKNBL

CLKNB2:
	CONO PI,APRON
	MOVEI AC3,2*JOBN
	PUSHJ P,UFSGET		;GET A BLOCK OF FREE STORAGE
	SETZM (AC1)
	CONO PI,APROFF
	SKIPN APRLST		;SEE IF SOMEONE ELSE HAS MADE IT ALREADY
	JRST CLKNB3		;NO, WE STILL GET TO DO IT
	CONO PI,APRON
	PUSHJ P,FSGIVE		;FALSE ALARM
	JRST CLKNB1
CLKNB3:
	MOVEM AC1,APRLST
	JRST CLKNBL

CLKNB4:
	JUMPE TAC,CLKNB7	;ALREADY AN ENTRY AND DON'T CHANGE TIME
CLKNB6:
	HRLM TAC,(AC1)
	MOVNM TAC,1(AC1)
CLKNB7:
	CONO PI,APRON
	POP P,TAC
	POPJ P,

CLKNB5:
	SETZM 2(AC1)		;MAKE A FRESH ENTRY
	HRRZM J,(AC1)
	JUMPN TAC,CLKNB6	;STORE NEW TIME
	MOVEI TAC,1
	JRST CLKNB6

; INTORM - ROUTINE TO SET BITS IN INTERUPT ENABLE MASK

INTORM:
	PUSHJ P,INTCHK
	MOVE AC1,TAC		;INTERRUPT BITS BEING TURNED ON
	IORB TAC,JBTIEN(J)	;TAC MUST HAVE JBTIEN AT INTAPC
	TLNE AC1,INTCLK
	PUSHJ P,CLKENB		;PLANT CLOCK REQ FOR 1 TICK
	JRST INTAPC

; INTACM - CLEARS BITS IN INTERRUPT ENABLE MASK

INTACM:
	PUSHJ P,INTCHK
	MOVE AC1,TAC		;INTERRUPT BITS BEING TURNED OFF
	ANDCAB TAC,JBTIEN(J)
	TLNE AC1,INTCLK		;SKIP IF NOT CLEARING INTCLK
	JRST INTEN1
INTAPC:
	ANDI TAC,CPUMSK
	HRRZM TAC,APRIN2(PID)	;ONLY LEGAL BITS
	IOR TAC,JOBENB(PROG)
	ANDI TAC,CPUMSK!1000	;MASK THIS TOO, SINCE IT'S UNPROTECTED
	JRST APREN2		;SET UP PROCESSOR CONO

; INTENS, INTIIP - ROUTINES TO GIVE BACK INFORMATION

INTENS:
	SKIPA TAC,JBTIEN(J)
INTIIP:
	MOVE TAC,JBTIIP(J)
	JRST STOTAC

; INTIRQ - TELLS YOU WHAT INTERRUPTS ARE PENDING

INTIRQ:
	MOVE TAC,JBTIRQ(J)
	JRST STOTAC

; DISMIS - TERMINATES CURRENT I-LEVEL RUN

DISMIS:
	SKIPE INTACT(PID)
	JRST DISM2
	SKIPE SPWUUF(PID)
	JRST SPWXIT		;MUST LEAVE THROUGH HERE!!!!!!!
	JRST DISLOS
DISM2:
	MOVEI AC1,INTDSM
DISM1:
	JUMPE UCHN,DISM3	;NONZERO AC FIELD REQUEUES JOB AS SPEC BY C(AC)
	MOVM TAC,JOBQUE(J)
	XCTR XR,[MOVE TAC1,(UCHN)]	;LH(AC) IS MASK FOR LEGAL SOURCE Q'S
	LSH TAC1,(TAC)
	JUMPGE TAC1,DISM3		;NOT IN LEGAL SOURCE Q
	XCTR XR,[HRRZ TAC,(UCHN)]	;GET NEW CODE
	CAIL TAC,NDISQS
	JRST DISM3			;OUT OF BOUNDS
	MOVE TAC,DISQTB(TAC)
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,REQUE
DISM3:
	CONO PI,PIOFF		;AVOID EXTRANEOUS CLK INTS
	MOVEM AC1,INTDISP(PID)
	HLLOS CLKFLG(PID)		; MAKE SURE CH7 KNOWS WE'RE COMING!
	CONO PI,PION!1B24!1⊗(7-CLKCHN)
	JUMPN PID,CL2INT
	JRST CLKINT

DISLOS:
	JSP TAC,UUOMES
ASCIZ /I-LEVEL UUO GIVEN WHEN NOT AT I-LEVEL
UUO/

DISQTB:
	TQ		;THESE ARE POSITIVE SO THEY WON'T GENERATE QXFER INTS
	RUNQ
	INTWQ
	IOWQ
NDISQS←←.-DISQTB

; INTGEN - ROUTINE TO GENERATE AN INTERRUPT FOR YOURSELF

INTGEN:
	SETCM AC1,JBTIEN(J)
	TDNN AC1,TAC
	JRST INTGN1
	JSP TAC,UUOMES
	ASCIZ /ATTEMPT TO GENERATE NON-ENABLED INTERRUPT
UUO/
INTGN1:
	IORM TAC,JBTIRQ(J)
	SETOM INTREQ(PID)
	SKIPN INTACT(PID)
	JRST WSCHED
	POPJ P,

; USKIP - ROUTINE TO TELL USER IF HE IS INSIDE A UUO

USKIP:
	SKIPN INTACT(PID)
	JRST DISLOS
	MOVE AC1,USRPC(PID)	;PC OF SUSPENDING MAIN JOB
	TLNN AC1,USRMOD
	AOS (P)
	POPJ P,

; UWAIT - WAITS FOR UUO TO TERMINATE

UWAIT:
	PUSHJ P,USKIP		;SKIP IF INTERRUPTED OUT OF A UUO, RETURNING
	JRST UWNPC		; IN AC1 THE PC OF THE SUSPENDED PROCESSES
	MOVE DSER,JBTSTS(J)	; HE HAS BEEN REQUEUED IF HE IS IN INTERRUPT WAIT,
				; NOW CHECK FOR SLEEPING.
	TLNE DSER,CLKR		; DOES HE HAVE A SLEEP REQUEST IN?
	PUSHJ P,UWAIT1		; YES, GO WAKE HIM UP
	MOVSI AC1,INTWAIT
	IORM AC1,JBTIEN(J)
	IORM AC1,JBTMSK(J)
	MOVE AC1,UUOPC(J)
	MOVEM AC1,JBTUPC(J)	;USER ADDRESS AFTER UWAIT
	JRST DISMIS

UWAIT1:
	MOVE TAC,J		;SIMULATE UUO LEVEL CALL BY PUTTING JOB NUMBER IN TAC
	JRST WAKE

UWNPC:
	MOVEM AC1,JOBTPC(PROG)
	MOVSI AC1,JOBDAC(PROG)	;GET MAIN PROGRAM ACS (20-37) BACK INTO REAL ACS
	HRRI AC1,JOBAC(PROG)
	BLT AC1,JOBAC+17(PROG)
	POPJ P,

; DEBREAK - MAKES I-LEVEL PROCESS TAKE PLACE OF U-LEVEL PROCESS

DEBREAK:

	SKIPN INTACT(PID)
	JRST DISLOS
	MOVEI AC1,INTDEB
	JRST DISM1

; IWAIT - GO INTO INTERRUPT WAIT UNTIL AWAKENED BY AN APPROPRIATE INTERRUPT

IWAIT:
	MOVEI AC1,INTWQ
	MOVNM AC1,JOBQUE(J)
	JRST WSCHED

; ROUTINE TO ENABLE INTERRUPTS AND THEN GO INTO INTERRUPT WAIT
; CALLING . . .
;	MOVE AC,[<INTERRUPT BITS>]
;	CALL AC,[SIXBIT /IENBW/]
; YOU ARE NOW IN INTERRUPT WAIT.

IENBW:
	MOVEI AC1,INTWQ		; PUT US IN INTERRUPT WAIT
	MOVNM AC1,JOBQUE(J)
	PUSHJ P,INTENB		; ENABLE INTERRUPTS
	JRST WSCHED		; WAIT.

;;UUOS TO SET THE INTERRUPT MASK
; CALLING . . .
;	INTMSK [<MASK BITS>]


INTMSK:
	XCTR XR,[MOVE AC1,(UUO)]
	MOVEM AC1,JBTMSK(J)
IMCALL:
	SKIPN INTACT(PID)	;DON'T CALL WSCHED IF ALREADY AT I-LEVEL
	TDNN AC1,JBTIRQ(J)	; DOES HE HAVE ANY INTERRUPTS PENDING?
	POPJ P,
	SETOM INTREQ(PID)	; YES, GIVE THEM
	JRST WSCHED

;IMSKST  IMSKCL
; THIS ONE SETS BITS IN THE MASK . . .

IMSKST:
	XCTR XR,[MOVE AC1,(UUO)]
	IORM AC1,JBTMSK(J)
	JRST IMCALL

; AND THIS ONE CLEARS BITS . . .

IMSKCL:
	XCTR XR,[MOVE AC1,(UUO)]
	ANDCAM AC1,JBTMSK(J)
	POPJ P,

; CLKINT UUO  (CLKUUO) START UP A CLOCKED I-LEVEL JOB
; CALLING . . .
;	CLKINT TIX
; TIX IS THE TIME IN TICKS BETWEEN STARTUPS
; IF TIX IS ZERO, ANY CLOCKED JOB IS FLUSHED

CLKUUO:
	TRNN UUO,-1		;ZERO TIX?
	JRST CLKUU2		;YES, GO KILL JOB
	MOVSI TAC,INTCLK
	IORM TAC,JBTIEN(J)	;ENABLE CLOCK INTERRUPTS
	ANDCAM TAC,JBTIRQ(J)	;FLUSH PENDING OLD CLOCK INTERRUPT
	HRRZ TAC,UUO
	JRST CLKENA		;PLANT THE CLOCK REQUEST

CLKUU2:
	PUSHJ P,APRDKL		;KILL CLOCK REQUEST
	MOVSI TAC,INTCLK
	ANDCAM TAC,JBTIEN(J)
	ANDCAM TAC,JBTIRQ(J)
	POPJ P,

;INTUUO - INTDEJ, IMSTW
; MULTI-PURPOSE INTERRUPT UUO

INTUUO:
	CAILE UCHN,INTMXU
	JRST UUOERR
	JRST @INTUTB(UCHN)

DEFINE UUOS{FOR X IN(INTDEJ,IMSTW,IWKMSK,INTDMP,INTIPI,IMSKCR)}
; UUOMAC INTUTB,INTUUO
;; manual expansion
INTUTB:
0+INTDEJ
0+IMSTW
0+IWKMSK
0+INTDMP
0+INTIPI
0+IMSKCR
UUOCNT←←.-INTUTB
INTUUO UUOCNT-1,UUOLNK
↑↑UUOLNK←←.
SIXBIT/INTDEJ/
SIXBIT/IMSTW/
SIXBIT/IWKMSK/
SIXBIT/INTDMP/
SIXBIT/INTIPI/
SIXBIT/IMSKCR/

INTMXU←←UUOCNT

; RESET INTERRUPT MASK AND JUMP TO ADDRESS UUO.
; CALLING . . .
;	INTDEJ ADR
; WITH THE FOLLOWING DATA . . .
; ADR:	<INTERRUPT BITS TO BE ORED INTO MASK>
;	<PC WORD TO GO TO>
; THIS UUO DOES NOT RETURN, BUT INSTEAD JUMPS TO THE ADDRESS
ORG INTDEJ;;workaround cheat TAG mismatch;;`2013-02-23 bgbaumgart@mac.com'
INTDEJ:
	XCTR XR,[MOVE TAC,1(UUO)];FETCH PC WORD
	TLO TAC,USRMOD		; KEEP THE LOSER OUT OF THE SYSTEM
	PUSH P,TAC
	PUSHJ P,IMSKST		; OR IN MASK BITS
	POP P,UUOPC(J)		; SET UP RETURN ADDRESS
	POPJ P,			; RETURN TO LOSER

; SET MASK FROM FIRST WORD OF UUO AND GO INTO WAIT STATE.
; CALLING . . .
;	IMSTW ADR
;
; ADR:	<MASK BITS>

IMSTW:
	MOVEI AC1,INTWQ		; PUT US INTO INTERRUPT WAIT FIRST
	MOVNM AC1,JOBQUE(J)
	PUSHJ P,INTMSK		; SET THE MASK
	JRST WSCHED		; DO THE WAIT STATE THING.

; IWKMSK, IMSKCR
; SET MASK THAT ALLOWS THE MAIN JOB TO BE AWAKENED
; FROM IWAIT QUEUE.
; CALLING . . .
;	IWKMSK ADR
;
; ADR:	<INTERRUPT BITS WHICH SHOULD AWAKEN>

IWKMSK:
	XCTR XR,[MOVE TAC,(UUO)]
	MOVEM TAC,JBTWKM(J)
	POPJ P,

;CLEAR SPECIFIED BITS OF MASK (PDP-10 ONLY) AND RETURN OLD MASK
;CALL:
;	IMSKCR ADR
;
;ADR:	BITS TO TURN OFF IN MASK, REPLACED BY OLD MASK VALUE

IMSKCR:
	MOVE TAC,JBTMSK(J)
	XCTR XR,[ANDCM TAC,(UUO)]
	EXCH TAC,JBTMSK(J)
	JRST STOTAC

; INTDMP
; ROUTINE TO DUMP OUT INFORMATION ABOUT A PARTICULAR JOB'S INTERRUPT
; CONDITION. CALLING . . .
;	INTDMP ADR
;	<FAILURE - ERROR CODE IN ADR+1>
;
; ADR:	<JOB NUMBER OR JOB NAME>
;	<ENABLE BITS OR ERROR CODE, 1 FOR NON-EX JOB NUMBER,
;		2 FOR AMBIGUOUS JOB NAME, 3 FOR NON-EX JOB NAME>
;	<P1 INTERRUPT MASK>
;	ZERO
;	<WAKEUP MASK>
;	<JOB QUEUE>

INTDMP:
	XCTR XR,[MOVE TAC,(UUO)]	;PICK UP JOB NUMBER OR NAME
	TDNE TAC,[-100]		; SEE WHICH IT IS
	JRST INTDGJ		; NAME, FIND OUT WHICH
	JUMPE TAC,INTDM2	; IF ZERO, USE HIS OWN
	CAIL TAC,JOBN		; IS JOB NUMBER IN BOUNDS?
	JRST INTDR1		; NO.  GIVE BAD JOB # ERROR RETURN
INTDM1:
	MOVE AC1,JBTIEN(TAC)	; GIVE THE GUY HIS ENABLE BITS
	XCTR XW,[MOVEM AC1,1(UUO)]
	MOVE AC1,JBTMSK(J)	; AND HIS PROCESSOR MASKS
	XCTR XW,[MOVEM AC1,2(UUO)]
	XCTR XW,[SETZM 3(UUO)]
	MOVE AC1,JBTWKM(TAC)	; HIS WAKEUP MASK
	XCTR XW,[MOVEM AC1,4(UUO)]
	MOVM AC1,JOBQUE(TAC)	; AND HIS CURRENT QUEUE
	XCTR XW,[MOVEM AC1,5(UUO)]
	JRST CPOPJ1		; GIVE SUCCESS RETURN

; INTDMP - ERROR RETURNS

INTDM2:
	MOVE TAC,J
	JRST INTDM1

INTDR3:
	MOVEI AC1,3
	JRST INTDR4

INTDR2:
	SKIPA AC1,[2]
INTDR1:
	MOVEI AC1,1
INTDR4:
	XCTR XW,[MOVEM AC1,1(UUO)]
	POPJ P,

INTDGJ:
	PUSHJ P,GJOBN		; GET JOB NUMBER FROM NAME IN TAC
	JRST INTDR2		; AMBIGUOUS NAME
	JRST INTDR3		; NON-EX NAME
	JRST INTDM1		; WIN!

; ROUTINE TO GET A JOB NUMBER FROM A JOB NAME

GJOBN:
	MOVEI AC1,JOBN-1
GJOBN1:
	CAMN TAC,JOBNAM(AC1)
	JRST GJOBN2
GJOBN4:
	SOJG AC1,GJOBN1
	JRST CPOPJ1

GJOBN2:
	MOVE AC2,JBTSTS(AC1)
	TLNE AC2,JSEG
	JRST GJOBN4
	MOVE AC2,AC1
	JRST GJOBN5
GJOBN3:
	CAMN TAC,JOBNAM(AC2)
	POPJ P,
GJOBN5:
	SOJG AC2,GJOBN3
	MOVE TAC,AC1
	JRST CPOPJ2

; INTIPI
; INTER-PROCESS INTERRUPT SYSTEM
; CALLING . . .
;	INTIPI ADR
;	<ERROR - CODE IN ADR+1 - 1 FOR NON-EX JOB NUMBER
;			2 FOR AMBIGUOUS JOB NAME
;			3 FOR NON-EX JOB NAME
;			4 FOR JOB NOT ENABLED FOR THOSE INTERRUPTS>
; ADR:	<JOB NUMBER OR NAME>
;	<INTERRUPT BITS OR ERROR CODE>

INTIPI:
	XCTR XR,[MOVE TAC,(UUO)]	;GET JOB NAME OR NUMBER
	TDNE TAC,[-100]
	JRST INTIP1		;JOB NAME
	JUMPE TAC,INTIP2	;IF 0 USE OWN JOB
	CAIL TAC,JOBN
	JRST INTDR1
INTIP3:
	XCTR XR,[MOVE AC1,1(UUO)]	;INTERRUPT BITS
	SETCM AC2,JBTIEN(TAC)
	TDNE AC1,AC2
	JRST INTIR4
	IORM AC1,JBTIRQ(TAC)
	SETOM INTREQ(PID)
	JRST CPOPJ1

INTIP1:
	PUSHJ P,GJOBN
	JRST INTDR2		;AMBIGUOUS
	JRST INTDR3		;NOT FOUND
	JRST INTIP3		;UNIQUE

INTIP2:
	MOVE TAC,J
	JRST INTIP3

INTIR4:
	MOVEI AC1,4
	JRST INTDR4

SUBTTL	UUOCON - STANFORD SPECIAL IO ROUTINES
;;UUO TO GET USE BITS FOR A CHANNEL
;	CHNSTS <CHANNEL NUMBER>,ADR
; PUTS USRJDA IN ADR, 0 FOR UNUSED.

CHNSTS:

	CAMLE	UCHN,USRHCU(PID)
	TDZA	TAC,TAC
	HLRZ	TAC,USRJDA(UCHN)
	XCTR	XW,[MOVEM TAC,(UUO)]
	POPJ	P,

;;THIS UUO GETS THE STANDARD BUFFER LENGTH FOR A DEVICE
;	MOVE AC,[DEVICE NAME IN SIXBIT]
;	CALL AC,[SIXBIT /BUFLEN/]
;	<RETURNS HERE WITH BUFFER LENGTH, OR 0, IN AC>

BUFLEN:
	PUSHJ P,FNDDDB		; LOOK FOR DEVICE WITH THIS NAME (OR CHANNEL #)
	JRST RTZERO		; GIVE BACK A ZERO IF NOT FOUND
	LDB TAC,PDVBLN		; RETURN BUFFER LENGTH
	JRST STOTAC

; ROUTINE TO GET THE TIME CELLS AND CLEAR THEM
; CALLING . . .
;	MOVE AC,<ADDRESS OF 2-WORD BUFFER>
;	CALL AC,[SIXBIT /GDPTIM/]
; RETURNS KEYBOARD TIME IN <BUFFER> AND DISPLAY TIME IN <BUFFER>+1
; CLEARS BOTH CELLS IN THE MONITOR
; RETURNS ZEROS IF YOU ARE NOT A DPY

GDPTIM:

REPEAT 0 < ;GDPTIM UUO REMOVED 23-MAR-73
	MOVE	TAC1,JBTLIN(J)		;GET OUR LINE NUMBER
	XCTR	XR,[MOVE TAC,(UCHN)]	;FIND WHERE TO STUFF DATA
	SETZB	AC1,AC2			;ZERO A PAIR OF AC'S 
	TLNE	TAC1,DISLIN!DDDLIN	;SKIP IF NOT III OR DATA DISK
	SKIPN	DDB,LETAB-DPYL0(TAC1)
	JRST	NOTDPY			;NOT A DPY
	EXCH	AC1,DPKTIM(DDB)		
	EXCH	AC2,DPGTIM(DDB)
NOTDPY:
	XCTR	XW,[MOVEM AC1,(TAC)]
	XCTR	XW,[MOVEM AC2,1(TAC)]
>;END DELETION OF GDPTIM
	POPJ	P,


;;RETURNS A CODE TELING WHETHER A JOB NAME IS LOGGED IN
;	MOVE AC,[<JOB NAME IN SIXBIT>]
;	CALL AC,[SIXBIT /NAMEIN/]
;	<NO SUCH JOB - ERROR CODE IN AC>
;
; ERROR CODE IS 3 FOR MULTIPLY DEFINED JOB NAME, 1 FOR NO SUCH NAME

NAMEIN:

	MOVEI TAC1,JOBN-1
NAMEI1:
	CAME TAC,JOBNAM(TAC1)	; IS THIS IT?
NAMEI2:
	SOJG TAC1,NAMEI1
	JUMPN TAC1,NAMEI4
	MOVEI TAC,1
	JRST STOTAC	; NO SUCH NAME, GIVE ERROR 1 RETURN
NAMEI4:
	MOVE AC1,JBTSTS(TAC1)
	TLNN AC1,JNA		; NOW, IS IT A JOB?
	JRST NAMEI2
	MOVE AC2,TAC1		;GIVE BACK JOB NUMBER
NAMEI3:
	SOJLE TAC1,NAMEI5	; SEARCH REMAINDER OF NAMES FOR MATCH
	CAME TAC,JOBNAM(TAC1)
	JRST NAMEI3
	MOVE AC1,JBTSTS(TAC1)
	TLNN AC1,JNA
	JRST NAMEI3
	MOVEI TAC,3
	JRST STOTAC
NAMEI5:
	MOVE TAC,AC2
	AOS (P)			; SKIP RETURN
	JRST STOTAC		; AND GIVE HIM THE JOB NUMBER

; DEVUSE - HOW MANY JOBS ARE WAITING FOR A PARTICULAR DEVICE.
; CALLING . . .
;	MOVE AC,<DEVICE NAME>
;	CALL AC,[SIXBIT /DEVUSE/]
; RETURNS NUMBER OF JOBS WAITING FOR THIS DEVICE IN AC (NOT INCLUDING YOUR JOB)

DEVUSE:
	PUSHJ	P,FNDDDB	; PICK UP DEVICE DATA BLOCK ADDRESS
	JRST	RTZERO		; NO SUCH DEVICE, NOBODY WAITING FOR IT!
	MOVEI	AC1,JOBN-1	; PREPARE TO SCAN JOB TABLES
	SETZ	TAC,
DEVUS1:
	CAME	DDB,JBTDVW(AC1)	; IS THIS THE DEVICE?
DEVUS2:
	SOJG	AC1,DEVUS1	; NO, LOOP AROUND
	JUMPE	AC1,DEVUS3	; RETURN ARGUMENT AND LEAVE
	CAIN	AC1,(J)
	JRST	DEVUS2		; DON'T COUNT YOURSELF.
	MOVE	AC2,JBTSTS(AC1)	; SEE IF THE JOB EXISTS
	MOVM	AC3,JOBQUE(AC1)	; AND IF IT IS IN DEVICE WAIT
	TLNE	AC2,JNA
	CAIE	AC3,DWQ
	JRST	DEVUS2
	AOJA	TAC,DEVUS2	; BUMP COUNT AND LOOP BACK

DEVUS3:
	MOVE	TAC1,DEVMOD(DDB)
	TLNE	TAC1,DVUDP
	JRST	DEVUS4		;COMPLICATED FOR UDP
	LDB	AC1,PJOBN	;GET JOB NUMBER OF DEVICE OWNER
	TLNE	TAC1,TTYATC
	TRO	AC1,100000
	TRNE	TAC1,ASSCON
	TRO	AC1,400000
	TRNE	TAC1,ASSPRG
	TRO	AC1,200000
	HRL	TAC,AC1
	JRST	STOTAC

DEVUS4:
	LDB AC1,PUNIT		;UDP, SCAN ALL DDBS FOR ASSCON, ASSPRG
	MOVE AC2,DKDBML(AC1)	;MODEL DDB FOR THIS UDP
	MOVE AC3,DEVNAM(DDB)
DEVUS5:
	HLR AC2,DEVSER(AC2)
	CAME AC3,DEVNAM(AC2)
	JRST DEVUS7		;NO MORE DDBS
	MOVE TAC1,DEVMOD(AC2)
	TRNE TAC1,ASSCON
	TLO AC2,400000
	TRNE TAC1,ASSPRG
	TLO AC2,200000
	LDB AC1,[POINT 6,DEVCHR(AC2),5]
	CAIE AC1,(J)		;EXTRA BITS FOR UDP ONLY,
	JRST DEVUS6		;NAMELY ASSCON AND ASSPRG FOR YOUR OWN JOB
	TRNE TAC1,ASSCON
	TLO AC2,40000
	TRNE TAC1,ASSPRG
	TLO AC2,20000
	JRST DEVUS5

DEVUS6:
	TRNE TAC1,ASSCON	;AND SEPARATELY FOR OTHER JOBS
	TLO AC2,10000
	TRNE TAC1,ASSPRG
	TLO AC2,4000
	JRST DEVUS5

DEVUS7:
	LDB TAC1,PUNIT		;GET UDP NUMBER
	HLRZ AC1,AC2		;FLAGS INTO AC1
	TRO AC1,2000		;THIS IS PRIVATE OWNERSHIP FLAG
	SKIPGE UDPOWN-1(TAC1)	;SKIP IF PRIVATE
	TRZA AC1,2000		;PUBLIC, TURN OFF PRIVATE FLAG
	ADD AC1,UDPOWN-1(TAC1)	;JOB NUMBER OF OWNER OR 0 FOR PUBLIC
	HRL TAC,AC1
	JRST STOTAC

; JOBRD  UUO TO BLT DATA FROM SOME OTHER JOB'S CORE IMAGE TO YOURS.
; CALLING . . .
;	MOVEI AC,ADR
;	CALL AC,[SIXBIT /JOBRD/]
;	<ERROR - CODE IN ADR+1>
;
;ADR:	<JOB NAME OR NUMBER>
;	<XWD -NWDS,HISADR - OR ERROR CODE,
;		1 FOR NON-EX JOB NUMBER
;		2 FOR AMBIGUOUS JOB NAME
;		3 FOR NON-EX JOB NAME
;		4 FOR ADDRESS OUT OF BOUNDS
;		5 FOR JOB NOT LOGGED IN
;		6 FOR BLOCK TOO LARGE!>
;	<ADDRESS IN YOUR CORE IMAGE WHERE YOU WANT THE DATA>

JOBRD:
	HRR	UUO,TAC		; PUT DATA BLOCK ADDRESS IN UUO
	SKIPE	AC1,JBTFS(J)	; DOES HE HAVE ANY FREE STORAGE?
	PUSHJ	P,FSGIVE	; YES, RETURN IT
	SETZM	JBTFS(J)
	XCTR	XR,[HLRO TAC,1(UUO)]	; PICK UP LENGTH OF TRANSFER
	CAMGE	1,[-2000]	; MORE THAN ONE K?
	JRST	[MOVEI	AC1,6	; YES, VERBOTEN
		JRST INTDR4]	; BLOCK TOO LARGE --  RPH 4-14-73
	XCTR	XR,[MOVE TAC,(UUO)]	; PICK UP JOB NUMBER OR NAME
	TDNE	TAC,[-100]	; IS IT A NUMBER?
	JRST	JOBRD1		; NO, GO PARSE IT
	JUMPLE	TAC,INTDR1	; IF NON-EX JOB NUMBER, FLUSH HIM NOW
	CAIL	TAC,JOBN
	JRST	INTDR1
JOBRD2:
	MOVE	AC1,JBTSTS(TAC)	; JOB NUMBER OK, SEE IF JOB EXISTS
	TLNN	AC1,JNA
	JRST	[MOVEI	AC1,5
		JRST	INTDR4]	; NO SUCH JOB
	TLNE	AC1,SWP!SHF	;IS OTHER GUY BEING SWUFFLED OR SCHWAPPED?
	JRST	JOBRD3		;YES, THIS IS HARDER
	HLRZ	AC1,JBTADR(TAC)	; NOW DOES IT HAVE ENOUGH CORE?
	XCTR	XR,[HRRZ AC2,1(UUO)]	; PICK UP STARTING ADDRESS
	MOVE	TAC1,AC2
	ADD	TAC1,JBTADR(TAC)	; RELOCATE THE ADDRESS
	XCTR	XR,[HLRO AC3,1(UUO)]	; AND WORD COUNT
	MOVN	AC3,AC3

; JOBRD - PICK UP ADDRESS OF LAST WORD, ADDRESS CHECK IT

	ADDI	AC3,(AC2)		; THIS IS LAST WORD TO BE TRANSFERRED
	SUBI	AC3,1
	CAILE	AC3,(AC1)
	JRST	JOBRD4
	SUBI	AC3,(AC2)		; GET BACK WORD COUNT-1
JOBRD5:
	XCTR	XR,[HRRZ AC2,2(UUO)]	; PICK UP ADDRESS IN HIS CORE
	ADD	AC3,AC2			; AND END OF TRANSFER
	HLRZ	AC1,PROG		; PICK UP OUR PROTECTION
	CAIG	AC2,(AC1)
	CAILE	AC3,(AC1)
	JRST	JOBRD6
	ADDI	AC2,(PROG)		; COMPUTE ABSOLUTE ADDRESS OF DESTINATION
	ADDI	AC3,(PROG)		; ABSOLUTE ADDRESS OF LAST WORD.
	HRL	AC2,TAC1		; PUT INTO BLT
	BLT	AC2,(AC3)		; DO THE TRANSFER
	AOS	(P)			; INDICATE SUCCESS RETURN
	SKIPN	AC1,JBTFS(J)		; IS THERE ANY FREE STORAGE THERE?
	POPJ	P,			; NO, LEAVE NOW
	SETZM	JBTFS(J)		; NOT ANY MORE
	JRST	FSGIVE			; YES, RETURN IT

JOBRD6:
	SKIPN	AC1,JBTFS(J)		; IF NO FREE STORAGE, GIVE ERROR MESSAGE
	JRST	JOBRD4
	SETZM	JBTFS(J)
	PUSHJ	P,FSGIVE
JOBRD4:
	MOVEI	AC1,4
	JRST	INTDR4

JOBRD1:
	PUSHJ	P,GJOBN		; GET JOB NUMBER FROM JOB NAME
	JRST	INTDR2
	JRST	INTDR3
	JRST	JOBRD2

; JOBRD - GET FREE STORAGE FOR DATA, PLANT CLOCK REQUEST TO DO TRANSFER

JOBRD3:
	XCTR	XR,[HLRO AC3,1(UUO)]	; PICK UP WORD COUNT
	MOVN	AC3,AC3
	ADDI	AC3,1
	PUSHJ	P,UFSGET		; F.S. BLOCK IS MINIMUM OF 6 WORDS
	HRL AC1,TAC			; STORE JOB TO READ IN JBTFS
	MOVEM	AC1,JBTFS(J)		; SAVE FREE STORAGE ADDRESS
	MOVE DAT,J			; ARG IS JOB NUMBER
	HRLI DAT,JOBRCK			; ROUTINE TO CALL
	PUSHJ P,DPYTIM
	XCTR	XR,[MOVE AC2,1(UUO)]
	MOVEM	AC2,(AC1)
JOBRDX:
	MOVNI	AC3,IOWQ		; WAIT FOR IT ALL
	MOVEM	AC3,JOBQUE(J)
	PUSHJ	P,WSCHED		; WAIT FOR GUYS TO FILL IT
	SKIPN AC1,JBTFS(J)		; BLOCK STILL THERE?
	JRST JOBRD6			; NO, GIVE ILL ADDR ERROR
	HRRZI	TAC1,1(AC1)		; PICK UP ADDRRESS PLUS ONE
	SKIPGE (AC1)			; DONE YET?
	JRST JOBRDX			; NO, WAIT AGAIN
	SKIPE	TAC,(AC1)		; WAS THERE AN ERROR?
	JRST	JOBRDY			; YES, RETURN CODE
	XCTR	XR,[HLRO AC3,1(UUO)]
	MOVN	AC3,AC3
	SOJA	AC3,JOBRD5		; GO DO BLT TO USER

JOBRDY:
	XCTR XW,[MOVEM TAC,1(UUO)]	; STORE ERROR CODE
	SETZM JBTFS(J)
	JRST FSGIVE			; RETURN BLOCK

;FREE STORAGE BLOCK LOCATIONS
;	BEFORE			AFTER
;0	-WC,,MA TO READ		-1=ERROR, 0=SUCCESS
;1	RANDOM			DATA TO END OF BLOCK
;2					.

; JOBRD - WE GET HERE AT CLOCK LEVEL . . .

JOBRCK:
	HRRZ J,DAT		;JOB # IS ARG
	SKIPN TEM,JBTFS(J)	; DID FREE STORAGE BLOCK GO AWAY?
	POPJ P,			; YES, DISAPPEAR
	HLRZ TAC,TEM		;GET JOB # WE ARE READING
	MOVE AC1,JBTSTS(TAC)
	TLNN AC1,JNA		; IS JOB STILL THERE?
	JRST JOBRC3		; NO, ERROR
	TLNE AC1,SHF		;IF SHUFFLING
	JRST DPYTIM		;JUST REPLANT CLOCK REQUEST
	TLNE AC1,SWP		;IF SWAPPED,
	JRST JOBRCQ		;BRING HIM IN
	PUSHJ P,JRDBLT		;DO BLT
	JRST JOBRC2		;NOW CONTINUE USER

JOBRCQ:
	MOVE J,TAC		;TRANSFER CONTROL TO SWAP IN LIST
	MOVSI TAC,JRDSNB
	JRST SETSIN

;CALL WITH TEM=FS BLOCK, TAC=JOB # WE ARE READING FROM
JRDBLT:
	HRRZ AC2,(TEM)		; PICK UP STARTING ADDRESS
	HLRO AC3,(TEM)		; AND WORD COUNT
	MOVNS AC3
	HLRZ AC1,JBTADR(TAC)
	ADDI AC3,(AC2)
	SUBI AC3,1
	CAILE AC3,(AC1)
	JRST JRDBL1
	SUBI AC3,-1(AC2)	; BACK UP TO JUST WORD COUNT - 1
	ADD AC2,JBTADR(TAC)	; RELOCATE
	HRLI AC2,1(TEM)		; PREPARE TO MOVE DATA
	MOVSS AC2
	ADD AC3,TEM		; ADD IN FS ADDRESS
	BLT AC2,(AC3)
	SETZM (TEM)		; CLEAR THE ERROR FLAG
	POPJ P,

JRDBL1:
	MOVEI TAC,4
	MOVEM TAC,(TEM)		; FLAG ERROR
	POPJ P,

;ENTER HERE WITH TAC=JOB JUST SWAPPED IN, J=JOB # WHO WANTS TO READ HIM
;CALLED FROM FININ
↑JRDWIN:PUSH P,TEM		;FIRST SAVE SOME ACS
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	HRRZ TEM,JBTFS(J)
	PUSHJ P,JRDBLT		;DO BLT
	PUSHJ P,JOBRC2		;RESTART USER
JRDLEV:
	POP P,AC3		;NOW RESTORE ACS
	POP P,AC2
	POP P,AC1
	POP P,TEM
	POPJ P,

;CALLED FROM FININ
↑JRDLOS:PUSH P,TEM		;FIRST SAVE SOME ACS
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	HRRZ TEM,JBTFS(J)	; J IS JOB # OF JOB DOING JOBRD
	PUSHJ P,JOBRC1		; GIVE ADDR ERROR RETURN ON SWAP ERROR
	JRST JRDLEV

;DONE, RESTART USER
JOBRC3:
	SKIPA TAC,[5]		;NO JOB THERE
JOBRC1:
	MOVEI TAC,4		;ADDR ERROR
	MOVEM TAC,(TEM)
JOBRC2:
	MOVM AC3,JOBQUE(J)
	CAIE AC3,IOWQ		;IS HE WERE WE LEFT HIM?
	JRST [	MOVE AC1,JBTFS(J);NO, GIVE BACK FS AND GO AWAY
		SETZM JBTFS(J)
		JRST FSGIVE]
	MOVNI AC3,RUNQ
	MOVEM AC3,JOBQUE(J)
	JRST REQUE

;TMPCOR UUO - BEHAVES AS DESCRIBED IN DEC MANUAL

TMPMAX←←400	;MAX TOTAL SIZE OF ONE JOB'S TMPCOR FILES

;FORMAT OF TMPCOR BLOCK
TMPLNK←←0	;DOUBLE LINK WORD
TMPNAM←←1	;NAME,,SIZE
TMPPPN←←2	;PPN (ALIAS) OF TMP FILE
TMPDAT←←3	;BEGINNING OF DATA

TMPCRD:
	XCTR XR,[HRRZ DSER,(TAC)]	;TMPCOR TO OTHER JOB:
	JUMPN DSER,.+2
	MOVEI DSER,(J)
	MOVEI TAC1,0
	CAMLE DSER,JOBNM1
	JRST TMPCR1
	MOVE AC1,JBTSTS(DSER)
	TLNN AC1,JNA
	JRST TMPCR1			;NO SUCH JOB
	XCTR XR,[SKIPN UUO,2(TAC)]	;GET JOB, ALIAS FROM USER
	MOVE UUO,PRJPRG(DSER)		;DEFAULT IS HIS PPN
	JRST TMPCO1

TMPCOR:
	MOVEI DSER,(J)			;TMPCOR TO YOURSELF:
	SKIPN UUO,DSKPPN(DSER)		;DSER IS YOUR JOB
	MOVE UUO,PRJPRG(DSER)		;UUO IS YOUR ALIAS
TMPCO1:
	HLRZ TAC1,TAC
	CAIL TAC1,NUMTMP
	JRST UUOERR
	CAIE DSER,(J)
	SKIPGE TMPDSP(TAC1)		;ONLY SOME ALLOWED FOR TMPCRD
	JRST .+2
	JRST UUOERR
	PUSHJ P,@TMPDSP(TAC1)
	JRST .+2
	AOS (P)
TMPCR1:
	XCTR XW,[MOVEM TAC1,(UCHN)]	;STORE PARAM FROM TAC1 (OFTEN SIZE)
	POPJ P,

TMPDSP:
	SETZ TMPSZ1			;4.9 IMPLIES ALLOWED FOR OTHER JOBS
	SETZ TMPRED
	TMPRDD
	TMPWRT
	SETZ TMPDIR
	TMPCLR
NUMTMP←←.-TMPDSP

;CALCULATE AMT OF ROOM LEFT (TMPMAX-CURRENT TOTAL)
TMPSZ1:
	AOSA (P)
TMPWRX:
	PUSHJ P,FSGIVE		;HERE IF XFER ABORTS AFTER GETTING FS
TMPSIZ:
	MOVEI TAC1,TMPMAX
	JSP DAT,TM1SCN		;COUNT ALL FILES WITHOUT REGARD TO ALIAS
	 SUB TAC1,TMPNAM(AC1)
	 TLZA TAC1,-1
	POPJ P,

;SCAN A JOB'S TMPCOR FILES AND EXECUTE 2 INSTRS FOLLOWING CALL
TMPSCN:
	HRRZ AC3,JBTTCR(DSER)
TMPSC1:
	SKIPN AC1,AC3
	JRST 2(DAT)
	CAME UUO,TMPPPN(AC1)	;IGNORE ALL TMP FILES WITH WRONG ALIAS
	JRST TMPSC2
	HRRZ AC3,TMPLNK(AC1)	;SAVE LINK NOW IN CASE DELETING
	XCT (DAT)
	XCT 1(DAT)		;THIS ONE USUALLY SKIPS
	JRST 3(DAT)		;BUT SKIP RETURN NOW IF NOT
	JRST TMPSC1
TMPSC2:
	HRRZ AC3,TMPLNK(AC1)
	JRST TMPSC1

;SCAN A JOB'S TMPCOR FILES AND EXECUTE 2 INSTRS FOLLOWING CALL--IGNORE ALIAS
TM1SCN:
	HRRZ AC3,JBTTCR(DSER)
TM1SC1:
	SKIPN AC1,AC3
	JRST 2(DAT)
	HRRZ AC3,TMPLNK(AC1)	;SAVE LINK NOW IN CASE DELETING
	XCT (DAT)
	XCT 1(DAT)		;THIS ONE USUALLY SKIPS
	JRST 3(DAT)		;BUT SKIP RETURN NOW IF NOT
	JRST TM1SC1

;FIND REQUESTED TMPCOR FILE
TMPFND:
	XCTR XR,[HLLZ TAC1,(TAC)]
	JSP DAT,TMPSCN
	 HLLZ AC2,TMPNAM(AC1)
	 CAMN AC2,TAC1
	POPJ P,
	JRST CPOPJ1

;CHECK & RELOCATE TMPCOR WCMA
TMPSET:
	MOVEI TAC1,-1		;UPPER LIM ON WC
TMPST1:
	XCTR XR,[HLRE AC2,1(TAC)]
	JUMPGE AC2,CPOPJ
	MOVN AC2,AC2		;+ WC
	CAILE TAC1,(AC2)	;USE MIN OF FILE & USER WC'S
	SKIPA TAC1,AC2
	MOVEI AC2,(TAC1)
	XCTR XR,[HRRZ AC3,1(TAC)]	;START ADR-1
	PUSH P,AC1
	ADDI TAC1,(AC3)		;CALCULATE END ADR
	PUSHJ P,RELOCA		;CHECK IT
	JRST UUOERR
	MOVEI TAC1,1(AC3)	;START ADR
	PUSHJ P,RELOCB		;CHECK THAT TOO
	JRST UUOERR
	POP P,AC1
	JRST CPOPJ1

;READ TMPCOR FILE
TMPRED:
	PUSHJ P,TMPFND		;LOOK FOR FILE
	JRST TMPSIZ		;NOT THERE - RETURN FREE SIZE
	HRRZ TAC1,TMPNAM(AC1)	;LIMIT XFER TO SIZE
	PUSHJ P,TMPST1
	JRST TMPRDX
	JUMPL TAC1,UUOERR	;CAN'T CLOBBER WRITE PROTECTED CORE
	HRLI TAC1,TMPDAT(AC1)
	ADDI AC2,(TAC1)
	BLT TAC1,-1(AC2)
TMPRDX:
	HRRZ TAC1,TMPNAM(AC1)	;RETURN ACTUAL FILE SIZE
	JRST CPOPJ1

;READ & DELETE TMPCOR FILE
TMPRDD:
	PUSHJ P,TMPRED		;TRY TO READ FILE
	POPJ P,
	AOSA (P)		;SET SKIP & SKIP INTO TMPDEL

;READ & CLEAR TMPCOR DIRECTORY
TMPCLR:
	JSP TEM,TMPDR2		;SET TEM TO CALL TMPDEL FOR EACH ITEM

;DELETE TMPCOR FILE SPECIFIED BY (AC1)
TMPDEL:
	MOVE AC2,TMPLNK(AC1)
	TRNE AC2,-1
	HLLM AC2,(AC2)
	MOVS AC2,AC2
	HLRM AC2,(AC2)
	JRST FSGIVE

;WRITE TMPCOR FILE
TMPWRT:
	PUSHJ P,TMPFND	;SEE IF IT ALREADY EXISTS
	JRST .+2	;NO
	PUSHJ P,TMPDEL	;YES - DELETE IT
	PUSHJ P,TMPSET
	JRST TMPSIZ	;NO XFER
	MOVSI DAT,(TAC1)	;SAVE USER ADR
	PUSHJ P,TMPSIZ
	CAILE AC2,(TAC1)
	POPJ P,			;NOT ENOUGH ROOM LEFT
	MOVEI AC3,TMPDAT(AC2)
	PUSHJ P,UFSGET		;GET A BLOCK
	PUSHJ P,TMPSET		;NOW DO THIS AGAIN (MAY HAVE MOVED)
	JRST TMPWRX
	MOVSI DAT,(TAC1)	;LH OF BLT PNTR
	MOVSI TAC1,JBTTCR(DSER)
	HRR TAC1,JBTTCR(DSER)	;& LINK IT IN
	MOVEM TAC1,TMPLNK(AC1)
	HRRM AC1,JBTTCR(DSER)
	HRLM AC1,(TAC1)
	XCTR XR,[HLL AC2,(TAC)]	;GET NAME
	MOVEM AC2,TMPNAM(AC1)	;STORE NAME & SIZE
	MOVEM UUO,TMPPPN(AC1)	;AND ALIAS WITH TMP FILE
	HRRI DAT,TMPDAT(AC1)	;MAKE BLT PNTR
	ADDI AC2,(DAT)		;CALC END ADR
	BLT DAT,-1(AC2)
	JRST TMPSZ1		;SKIP RETURN WITH NEW FREE CNT

;READ TMPCOR DIRECTORY
TMPDIR:
	MOVEI TEM,CPOPJ		;NO DELETING
TMPDR2:
	PUSHJ P,TMPSET
	JFCL
	JUMPL TAC1,UUOERR	;ERR IF R/O CORE
	MOVSI AC2,1(AC2)	;BUGGER BY 1 FOR PRE-AOBJN
	MOVN AC2,AC2
	HRRI AC2,(TAC1)		;MAKE AOBJN PNTR
	MOVEI TAC1,		;INIT CNT
	JSP DAT,TMPSCN
	 PUSHJ P,TMPDR1
	 CAIA
	JRST CPOPJ1

TMPDR1:
	MOVE TAC,TMPNAM(AC1)	;GET NAME & SIZE
	AOBJP AC2,.+2
	MOVEM TAC,-1(AC2)	;STORE IF ROOM
	AOJA TAC1,(TEM)		;COUNT ITEM & DO EXIT THING

;DELETE ALL TMPCOR FILES (REGARDLESS OF ALIAS PPNS)
TMPKIL:
	MOVEI DSER,(J)		;THIS ROUTINE DOES OWN JOB!!
	JSP DAT,TM1SCN		;FIND ALL TMP FILES, IGNORING ALIAS
	 PUSHJ P,TMPDEL		;DELETE EACH ONE
	 CAIA
	POPJ P,

SUBTTL	UUOCON	IO SECTION
;FOR PURPOSES OF COMMENTING THIS SUBROUTINE THE
;TERM 'BUFFER HEADER' SHALL REFER TO THE 3 WORD HEADER
;WHICH IS USED BY THE USER PROGRAM AND THIS EXEC FOR
;REFERING TO THE RING BUFFERS.

;THE CONTENTS OF THE 3 WORD HEADER (AS SET BY THE MONITOR
;		ON EACH INPUT AND OUTPUT UUO).
;		BIT 18-35=ADDRESS OF SECOND WORD OF THE
;		CURRENT BUFFER IN RING WHICH USER IS REFERENCING
;	WORD 2:	BYTE POINTER TO CURRENT ITEM.
;	WORD 3:	POSITIVE ITEM COUNT (NO. OF ITEMS LEFT ON
;		INPUT, NO. OF FREE ITEMS TO GO ON OUTPUT).

;EACH BUFFER IN THE RING HAS FOLLOWING FORMAT (AS THE USER SEES IT)

;	WORD 1:	RESERVED FOR BLOCK NUMBER FOR FIXED ADDRESS DEVICES
;	WORD 2:	BIT 0=USE BIT FOR THIS BUFFER
;		BIT 1-17=NO. OF WORDS WHICH FOLLOW (LENGTH OF BUFFER)/
;		BIT 18-35=ADDRESS OF SECOND WORD OF NEXT BUFFER IN RING
;	WORD 3:	LH=LINK TO NEXT BLOCK (SET BY MONITOR FOR DECTAPE)
;		RH=NO. OF WORDS OF DATA WHICH FOLLOW (USUALLY
;		SET BY EXEC EXCEPT IF THE USER HAS SPECIFIED
;		THAT HE WANTS TO COMPUTE WORD COUNT
;		HIMSELF INSTEAD OF HAVING THE MONITOR DO IT
;		USING THE BYTE POINTER IN THE 3 WORD HEADER).

;IOPUSH, IOPOP, IOPDL

;IOPUSH CHN,ID
;	PUSH DEVICE ON CHANNEL "CHN" ON STACK WITH ID "ID"
IOPUSH:
	SKIPE AC1,JBTIOP(J)
	JRST IOPSH1
	MOVEI AC3,IOPDLN
	PUSHJ P,UFSGET
	MOVEM AC1,JBTIOP(J)
IOPSH1:
	HLRZ AC3,AC1
	CAIN AC3,-IOPDLN
	POPJ P,			;NO SPACE ERROR
	SUBM AC1,AC3
	CAMLE UCHN,USRHCU
	TDZA DDB,DDB
	MOVE DDB,USRJDA(UCHN)
	MOVEM DDB,(AC3)
	SETZM USRJDA(UCHN)
	SKIPN TAC,USRHCU
	JRST IOPSH2		;USRHCU STAYS AT 0 EVEN IF NO CHANNELS OPEN
IOPSH3:
	SKIPN USRJDA(TAC)
	SOJG TAC,IOPSH3
	MOVEM TAC,USRHCU
IOPSH2:
	MOVEM UCHN,1(AC3)
	HRLM UUO,1(AC3)		;SAVE ID ON STACK WITH CHANNEL NUMBER
	SUB AC1,[2,,0]
IOPOP3:
	MOVEM AC1,JBTIOP(J)
	JRST CPOPJ1

;IOPOP CHN,ID
;	RELEASE DEVICE ON CHANNEL "CHN", POP DEVICE WITH ID "ID" INTO CHANNEL "CHN"
IOPOP:
	PUSHJ P,FIOPID		;FIND ID WHICH USER SPECIFIED
	POPJ P,			;NO STACK, OR NOT FOUND
IOPOP0:
	SKIPE DDB,USRJDA(UCHN)	;IS A DEVICE ALREADY ASSIGNED TO THIS CHAN?
	CAMLE UCHN,USRHCU(PID)	;YES, IS THIS CHAN. LE HIGHEST CHAN. FOR THIS USER?
	JRST IOPOP2		;NO, NO PREVIOUS DEVICE TO RELEASE
	HRRZ DSER,DEVSER(DDB)
	PUSH P,AC3		;SAVE POINTER TO ENTRY WE WILL POP
	PUSHJ P,RELEA0		;RELEASE PREVIOUS DEVICE ON THIS CHAN.
	POP P,AC3
IOPOP2:
	MOVE DDB,(AC3)		;THIS POINTS TO STACK ENTRY
	MOVEM DDB,USRJDA(UCHN)	;NEW DEV ON THIS CHANNEL
	JUMPE DDB,IOPOP4	;DON'T READJUST USRHCU IF POPPING A NULL CHANNEL
IOPOP1:
	CAMG UCHN,USRHCU
	JRST IOPOP4
	AOS TAC,USRHCU
	SETZM USRJDA(TAC)
	JRST IOPOP1

IOPOP4:
	MOVE AC1,JBTIOP(J)
	ADD AC1,[2,,0]
	JUMPG AC1,IOPOP5
	HLRE AC2,AC1
	SUBM AC1,AC2
	HRRZ AC3,AC3
	CAIN AC3,(AC2)		;ARE WE THE END ENTRY?
	JRST IOPOP3		;YES, SKIP BLT
	HRLI AC3,2(AC3)		;BLT DOWN ONE ENTRY
	BLT AC3,-1(AC2)		;LAST WORD OF LAST ENTRY
	JRST IOPOP3

IOPOP5:
	SETZM JBTIOP(J)
	AOS (P)
	JRST FSGIVE

IOPDL:
	CAIL UCHN,IOPDLL	;LEGAL IOPDL FUNTION?
	JRST UUOERR		;NO
	JRST @IOPDLD(UCHN)	;DISPATCH

;IOPDL 0,
;	RETURN ALL STACKED DEVICES TO WHERE THEY CAME FROM
IOPDL0:
	SKIPL AC3,JBTIOP(J)
	POPJ P,
	HLRE AC1,AC3
	SUB AC3,AC1
	HRRZ UCHN,-1(AC3)	;GET JUST CHANNEL NUMBER
	TRZ UUO,-1		;MAKE SURE WE GET TOP OF STACK
	PUSHJ P,IOPOP
	POPJ P,
	JRST IOPDL

;IOPDL 1,
;	RELEASE ALL STACKED DEVICES
IOPDL1:
	SKIPL JBTIOP(J)
	POPJ P,			;DONE
	TRZ UUO,-1		;DO IT TO TOP OF STACK
	PUSHJ P,IOPDL2		;RELEASE IT
	POPJ P,			;FOO
	JRST IOPDL1		;LOOP TILL ALL GONE

;IOPDL 2,ID
;	RELEASE STACKED DEVICE WITH ID "ID".
IOPDL2:
	PUSHJ P,FIOPID
	POPJ P,			;NOT FOUND
	MOVE DDB,(AC3)		;GET DEVICE HE WANTS RELEASED
	EXCH DDB,USRJDA		;EXCHANGE WITH CHAN 0
	MOVEM DDB,(AC3)		;WHICH WE SAVE ON STACK
	SETZ UCHN,		;NOW RELEASE CHANNEL 0 AND POP OLD ONE BACK THERE
	JRST IOPOP0

IOPDLD:
	IOPDL0
	IOPDL1
	IOPDL2
IOPDLL←←.-IOPDLD

FIOPID:
	SKIPL AC3,JBTIOP(J)	;ANY STACK AT ALL?
	POPJ P,			;NO
	HLRE AC1,AC3
	SUBI AC3,2(AC1)		;POINT TO TOP OF STACK
	MOVNI AC1,2(AC1)
	HRL AC3,AC1		;PUT COUNT IN LEFT HALF
	TRNN UUO,-1		;ANY ID?
	JRST CPOPJ1		;NO, 0 IS ALWAYS TOP OF STACK
IOPID1:
	HLRZ AC1,1(AC3)		;GET ID
	CAIN AC1,(UUO)
	JRST CPOPJ1		;FOUND IT
	SUB AC3,[2,,2]
	JUMPG AC3,IOPID1	;MORE TO GO?
	POPJ P,			;NO, NOT FOUND

; CLOSE UUO - CALLING SEQUENCE
;	CLOSE D,
;	EXIT		ALWAYS RETURNS HERE
; THIS ROUTINES PROCESSES THE CLOSE UUO AND DETERMINES WHETHER THE
;OUTPUT ROUTINE SHOULD BE CALLED IF OUTPUT WERE ACTIVE, CLEARS
;THE INPUT BUFFER AREA IF INPUT WERE ACTIVE, AND CLEARS THE 
;ITEM COUNTS OF BOTH INPUT AND OUTPUT HEADERS SERVING TO BOTH
;TERMINATE THE USE OF THE DEVICE AND SET THE I/O ROUTINES TO
;ACCEPT ANOTHER INPUT OR OUTPUT COMMAND IN A CLEAR STATE.
;IN THE CASE OF OUTPUT DEVICES, THE CLOSE ROUTINE OF THE DEVICE HANDL-
;ING ROUTINE IS CALLED IN CASE ANY SPECIAL HANDLING IS REQUIRED.

; CLOSE CODE - WAIT FOR IO TO FINISH, FLUSH BUFFERS

↑CLOSE1:
	PUSHJ PDP,WAIT1		; WAIT UNTIL DEVICE IS INACTIVE
	ANDCMI UUO,777774	;ZERO ALL BUT CLOSE-INHIBIT BITS IN RH OF UUO
	TRNN UUO,CLSIN		;SUPPRESS INPUT CLOSE?
	TLOE DEVDAT,ICLOSB	;NO. INPUT ALREADY BEEN CLOSED?
	JRST UCLS2		;YES
	LDB TAC,PIOMOD		;NO
	CAIN TAC,2
	POPJ PDP,		;SAVE MODE.
	CAIGE TAC,SD		;DUMP MODE?
	JRST UCLSBI		;NO. CLOSE BUFFERED INPUT.
UCLS5:
	PUSHJ PDP,DCLI(DSER)	;YES. DISPATCH TO DEVICE DEP. ROUTINE
	JRST UCLS2		;MUST NOT DESTROY UUO,DEVDAT,DSER,UCHN
UCLSBI:
	MOVE TAC,DEVMOD(DEVDAT)
	TLNE DEVDAT,INBFB+INPB	;WAS AN INPUT BUFFER SETUP?
	JRST UCLS4		;
	TLNE TAC,DVDSK!DVIMP	;NO.  CLOSING DISK OR IMP?
	JRST UCLS5		;YES. DO CLOSE
	JRST UCLS2		;NO.
UCLS4:
	TLNE TAC,DVLNG
	PUSHJ PDP,DCLI(DSER)	;YES, CLOSE INPUT
	HRRZ TAC1,DEVBUF(DEVDAT)
	XCTR	XR,[HRRZ DAT,(TAC1)]	;PICK UP FIRST WORD OF BUFFER HEADER
	LDB AC3,PDVBLN		; PICK UP BUFFER LENGTH
	ADDI AC3,(DAT)		; ADD IN BUFFER ADDRESS
	XCTR	XRW,[MOVES (AC3)]	; ADDRESS CHECK BUFFER ADDRESS
	XCTR	XR,[HRR TAC1,(TAC1)]	; REMEMBER CURRENT BUFFER IN TAC1
	HRLZI TAC,IOUSE		;USED BOTH FOR HEADER AND EACH BUFFER
	JUMPE DAT,UCLS1		;HAS A RING BEEN SETUP?(NO IF 0)
	SETZM AC1
	LDB TEM,PDVBLN		; FIGURE OUT THE MAXIMUM NUMBER OF BUFFERS
	HLRZ AC3,PROG
	IDIVI AC3,(TEM)
	ADDI AC3,2		; AND THIS IS CERTAINLY A GOOD UPPER BOUND!
UCLS0:
	XCTR	XR,[HRR DAT,(DAT)]	; ADVANCE CURRENT INPUT BUFFER ADDRESS
	CAIN AC1,(DAT)		;IS THIS THE SAME BUFFER AS LAST ONE?
	JRST UCLS1		;YES. BAD RING. LOOPING ON ITSELF.
	MOVEI AC1,(DAT)		;IS ADDRESS OK?
	XCTR	XRW,[ANDCAM TAC,(DAT)]; CLEAR USE BIT
	SOJL AC3,UCLS1
	CAME TAC1,DAT		;DONE?
	JRST UCLS0

; CLOSE CODE

UCLS1:
	HRRZ DAT,DEVBUF(DEVDAT)
	XCTR XRW,[IORM TAC,(DAT)]	; FLAG AS VIRGIN BUFFER IN HEADER
	XCTR XW,[SETZM 2(DAT)]		; CLEAR INPUT ITEM COUNT
	MOVE IOS,[XWD IOEND,IODEND]
	ANDCAB IOS,DEVIOS(DEVDAT)
UCLS2:
	TRNN UUO,CLSOUT		;SUPPRESS OUTPUT CLOSE?
	TLOE DEVDAT,OCLOSB	;NO. OUTPUT ALREADY CLOSED?
	JRST UCLS3		;YES
	LDB TAC,PIOMOD		;NO.
	CAIN TAC,2		;SAVE MODE?
	JRST UCLS3		;YES.
	CAIGE TAC,SD		;DUMP MODE?
	JRST UCLSBO		;NO. CLOSE BUFFERED OUTPUT
UCLS7:
	PUSHJ PDP,DCL(DSER)	;YES. DISPATCH TO DEVICE DEP. ROUTINE
	JRST UCLS3
UCLSBO:
	TLNN DEVDAT,OUTBFB+OUTPB	;WAS AN OUTPUT BUFFER SET UP?
	JRST UCLS6		;NO
	HLR DAT,DEVBUF(DEVDAT)	; RESTORE DAT NOW.
	XCTR XR,[SKIPG (DAT)]
	JRST UCLS6		; DO NOT CLOSE UNLESS DISK OR IMP
	HLRZ AC1,PROG		; PICK UP LENGTH OF LOWER
	LDB AC2,PSEGN
	HLRZ AC2,JBTADR(AC2)	; AND ADD IN LENGTH OF UPPER
	ADDI AC1,2(AC2)
	LDB AC2,PDVBLN
	ADDI AC2,2		; PICK UP SIZE OF BUFFER
	IDIVI AC1,(AC2)		; GET MAXIMUM NUMBER OF BUFFERS HE COULD HAVE
	PUSH P,AC1		; AND SAVE IT
UCLS2A:
	MOVE DSER,DEVSER(DEVDAT)
	MOVE AC1,DEVOAD(DEVDAT)
	SOSL (P)		; DECREMENT MAXIMUM NUMBER OF BUFFERS WE WILL LOOK AT
	XCTR	XR,[SKIPL (AC1)]	; NO. HAS SERVICE ROUTINE WRITTEN
				;ITS NEXT BUFFER YET?
	JRST UCLS2B		;YES
				;NO. START OUTPUT DEVICE.
	TRZ	IOS,760000
	PUSH PDP,UUO		; SAVE UUO
	PUSHJ PDP,DOU(DSER)
	POP PDP,UUO		; RESTORE UUO
	PUSHJ	PDP,WAIT1	;WAIT TILL MOST BUFFERS FILLED
	TRNN	IOS,760000	;ERROR?
	JRST UCLS2A		;RETURN WHEN ALL EMPTIED

; CLOSE - CALL DEVICE DEPENDENT ROUTINE
				;OF SHUFFLING REQUIRED STOPS DEVICE

UCLS2B:
	SUB P,[XWD 1,1]		; NORMALIZE STACK, THROW AWAY MAXIMUM BUFFER COUNT
	MOVE DSER,DEVSER(DEVDAT)
	PUSHJ PDP,DCL(DSER)	;CLOSE OUTPUT BUFFER
	HLRZ DAT,DEVBUF(DEVDAT)
	HRLZI TAC,IOUSE
	XCTR XRW,[IORM TAC,(DAT)]
	XCTR XW,[SETZM 2(DAT)]
	PUSHJ PDP,WAIT1
	TLO DEVDAT,OCLOSB	;SET OCLOSB AFTER OUTPUT IS COMPLETE
UCLS3:
	HLLM DEVDAT,USRJDA(UCHN)
	POPJ PDP,		;EXIT THIS UUO

UCLS6:
	MOVSI TAC,DVDSK!DVIMP	;ALWAYS CALL DEVICE ROUTINE FOR DISK AND IMP
	TDNE TAC,DEVMOD(DEVDAT)
	JRST UCLS7
	JRST UCLS3

; INBUF - CALLING SEQUENCE
;	INBUF D,N
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
;CALLING SEQUENCE
;	OUTBUF D,N
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED
; SETS UP AN N BUFFER RING FOLLOWING THE USER'S PROGRAM FOR DEVICE
; D AND INITIALIZES THE JOB BUFFER AREA HEADER:
;	JBFADR0:=1,	JBFADR 1-17:=0
;	JBFADR 18-35:=ADDRESS OF FIRST BUFFER IN RING
;INPUT SETS DEVIAD:=ADDRESS OF FIRST BUFFER IN RING
;OUTPUT SET DEVOAD:=ADDRESS OF FIRST BUFFER IN RING
;BUFPNT IS RESTORED.

; SET UP BUFFERS OF USER-SPECIFIED LENGTH

UOUTBF:

	TLNN DEVDAT,OBUFB	; SEE IF THERE EXISTS AN OUTPUT BUFFER HEADER
	JRST ILLOBF		; NO HEADER, GIVE ERROR MESSAGE
	TLO DEVDAT,OUTBFB	; FLAG OUTBUF UUO DONE
	PUSH PDP,BUFPNT		;SAVE BUFPNT ON STACK
	PUSHJ PDP,BUFCLC	;SET UP BUFFER RING
UOBF2:
	HLR TAC,DEVBUF(DEVDAT)	;TAC:=OUTPUT BUFFER AREA HEADER ADDRESS
	HRRM BUFPNT,DEVOAD(DEVDAT)	;DEVOAD:=ADDRESS OF FIRST BUFFER
				;IN RING
UOBF1:
	XCTR XW,[MOVEM BUFPNT,(TAC)]
				;JBFADR:=IOUSE,ADDRESS OF FIRST BUFFER
				;IN RING
	LDB TAC,PUUOAC
	MOVEM DEVDAT,USRJDA(TAC)
	POP PDP,BUFPNT		;RESTORE BUFPNT FROM STACK
	POPJ PDP,		;EXIT THIS UUO

UINBF:

	TLNN DEVDAT,IBUFB	; IS THERE AN INPUT BUFFER HEADER?
	JRST ILLIBF		; NO, ERROR
	TLO DEVDAT,INBFB	; FLAG INBUF UUO DONE
	PUSH PDP,BUFPNT		;SAVE BUFPNT ON STACK
	PUSHJ PDP,BUFCLC	;SET UP BUFFER RING
UINBF1:
	HRRM BUFPNT,DEVIAD(DEVDAT)	;DEVIAD:=ADDRESS OF FIRST BUFFER
				;IN RING
	HRR TAC,DEVBUF(DEVDAT)	;TAC:=INPUT BUFFER AREA HEADER ADDRESS
	JRST UOBF1

; UINBF - CALLING SEQUENCE . . .
;	UINBF D,ADR
; WHERE D IS CHANNEL NUMBER AND ADR IS ADDRESS OF TWO WORD BLOCK
; THE FIRST WORD OF WHICH IS THE NUMBER OF BUFFERS YOU WANT
; THE SECOND WORD IS THE LENGTH OF EACH BUFFER
; SAME FOR UOUTBF.

MINBF:
	PUSHJ PDP,CHNSET	; GIVE ERROR IF IO TO UNASSIGNED CHANNEL
	   JFCL
	   JRST CHNERR
	TLNN DEVDAT,IBUFB	; IS THERE A BUFFER HEADER ADDRESS?
	JRST ILLIBF		; NO, GO COMPLAIN
	TLO DEVDAT,INBFB
	PUSH PDP,BUFPNT
	PUSHJ PDP,MBFSET	; DO ALL THE DIRTY
	JRST UINBF1

CHNERR:
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/IO TO UNASSIGNED CHANNEL AFTER UUO LEVEL CHECK.
CALLED FROM MINFB OR MOUTBF. J=/]
	DISARG(DCP,<-20+J(P)>)
	[ASCIZ/  UUO=/]
	DISARG(OCT,<-21+UUO(P)>)
	[ASCIZ/
/]
	-1
	POPACS
	JSP DAT,UERROR

MOUTBF:
	PUSHJ PDP,CHNSET
	   JFCL
	   JRST CHNERR
	TLNN DEVDAT,OBUFB
	JRST ILLOBF
	TLO DEVDAT,OUTBFB
	PUSH PDP,BUFPNT
	PUSHJ PDP,MBFSET
	JRST UOBF2

MBFSET:
	MOVE AC1,UUO
	XCTR	XR,[HRR UUO,(AC1)]		;MAKE UUO LOOK LIKE NORMAL INBUF
	XCTR	XR,[MOVM TAC,1(AC1)]	;AND PICK UP BUFFER LENGTH
	JRST	BUFCLM			;NOW CLEAR OUT THAT MANY BUFFERS THAT BIG

;;ERROR MESSAGES FOR INBUF, OUTBUF, UINBF, AND UOUTBF UUOS

ILLOBF:
	JSP TAC,ERRPTU		; PRINT A BIT, SET UP TTY DEVDAT
	ASCIZ /OUTPUT /
	PUSHJ PDP,ERNAM		; PRINT "DEVICE XXX"
	JSP TAC,UUOMES		; PRINT MESSAGE AND STOP JOB
	ASCIZ / HAS NO OUTPUT BUFFER HEADER, UUO/

ILLIBF:
	JSP TAC,ERRPTU	; SET UP FOR ERROR PRINTOUT
	ASCIZ /INPUT /
	PUSHJ PDP,ERNAM		; PRINT "DEVICE XXX"
	JSP TAC,UUOMES
	ASCIZ / HAS NO INPUT BUFFER HEADER, UUO/

;OPEN UUO - PERFORMS SAME OPERATION AS INIT
;MAY BE USED EASILY BY REENTRANT PROGRAMS
;CALLING SEQUENCE FROM USER AREA
;	OPEN D,ADR
;	ERROR RETURN
;	DEVICE INITED

;LH(ADR)=0,RH(ADR)=DATA MODE THIS INIT
;LH(ADR+1)=OUTPUT BUFFER HEADER ADDRESS
;RH(ADR+1)=INPUT BUFFER HEADER ADDRESS
;C(ADR+2,...,ADR+5)=SAME AS LOOKUP OR ENTER


↑UOPEN:	XCTR	XR,[SKIP 2(UUO)]	; ADDRESS CHECK GOODIE TABLE
	MOVEI	DAT,1(UUO)	;SETUP REL ADR OF ARGUMENTS
	XCTR	XR,[HRR UUO,(UUO)]	;SET UP RH WITH DATA MODE TO LOOK LIKE INIT
	JRST	UINIT0

; INIT - CALLING SEQUENCE
;	INIT D,MODUS	D=JOB DEVICE CHANNEL
;			MODUS=IORDEL,IOCON,IOWC,MODE.
;	SIXBIT/NAME/	DEVICE NAME
;	XWD OBUF,IBUF	BUFFER AREA HEADER ADDRESSES
;	EXIT1		DEVICE NOT AVAILABLE
;	EXIT2		DEVICE PROPERLY ASSIGNED
;THE LEFT HALF OF NAME CONTAINS THE THREE LETTER DEVICE MNEMONIC,
;   THE RIGHT HALF IS EITHER ZERO (SYSTEM WILL ASSIGN AN ARBITRARY
;   UNIT) OR NON-ZERO TO REQUEST A SPECIFIC UNIT (LEFT JUSTIFIED).
;IF THE SELECTED DEVICE IS NOT AVAILABLE, CONTROL RETURNS TO EXIT1.
;OTHERWISE, THE DEVICE IS ASSIGNED TO THE USER AND ATTACHED TO HIS
;CHANNEL D.  THE DEVICE IS INITIALIZED IN THE FOLLOWING MANNER AFTER
;IOACT IS ZERO:
;	IOBEG:=1
;	DATA MODE:=BITS 32-35 OF AC UUO
;	IOCON:=BIT 31 OF AC UUO
;	IOWC:=BIT 30 OF AC UUO
;	IORDEL:=BIT 29 OF AC UUO
;	IOACT:=IODEND:=IOBKTL:=IODTER:=IODERR:=IOIMPM:=0
;	JBFADR:=JBFCTR:=0 FOR THE SPECIFIED BUFFERS.
;	DEVBUF:=OBUF,IBUF

; INIT CODE - FIRST FIND DEVICE AND TRY TO ASSIGN IT

↑UINIT:	MOVE DAT,UUOPC(ITEM)	;SETUP DAT WITH REL ADR OF ARGUMENTS TO INIT
	PUSHJ P,UINIT0		;DO THE INIT
	JRST .+2		;NOW SET UP KLUDGEY MULTIPLE SKIP RETURN
	AOS UUOPC(ITEM)		;(ONLY AFTER ALL THRU WAITING, ETC.)
	AOS UUOPC(ITEM)
	JRST CPOPJ1		;RETURN WITH ONE MORE SKIP

UINIT0:
	PUSH PDP,DAT		; NOW SAVE POINTER TO ARGUEMENT LIST
UINITG:
	SKIPE DEVDAT,USRJDA(UCHN)	;IS A DEVICE ALREADY ASSIGNED TO THIS CHAN>?
	CAMLE UCHN,USRHCU(PID)	;YES, IS THIS CHAN. LESS OR EQUAL TO HIGHEST
				;CHAN. FOR THIS USER?
	JRST UINITA		;NO, NO PREVIOUS DEVICE TO RELEASE
	PUSH PDP,UUO		;SAVE UUO
	PUSH PDP,DAT		;SAVE POINTER TO ARGS.
	PUSHJ PDP,RELEA0	;RELEASE PREVIOUS DEVICE ON THIS CHAN.
	POP PDP,DAT		;RESTORE REL. ADR. OF ARGS.
	POP PDP,UUO		;RESTORE UUO
UINITA:
	XCTR XR,[MOVE TAC,(DAT)]	;GET DEVICE NAME FROM USER
UINITK:
	MOVE J,JOB(PID)		;JOB NUMBER
	PUSHJ P,DEVSRC		;SEARCH FOR DEVICE NAME
				;(SET SYSDEV BIT IN LH OF
				;DEVDAT IF THIS IS SYSTEM TAPE)
	JRST UINXIT		; MUST POP DAT OFF THE STACK BEFORE LEAVING
	MOVE AC1,DEVCMR(DDB)
	TLNE AC1,DEVMAS		;SKIP IF OK TO INIT WITHOUT HAVING ASSIGNED OR INITED
	JRST UNITAC		;CHECK IF ASSIGNED
UNITAD:
	MOVE TAC,DEVNAM(DDB)	;PHYSICAL DEVICE NAME
	CAME TAC,[SIXBIT /DSK/]	;NOT DISK?
	CAME TAC,SYSTAP		;SYSTEM TAPE DEVICE?
	JRST UINITB		;NO, DISK OR NOT SYSTEM TAPE
	AOSE STREQ		;SYSTEM TAPE, INCREMENT REQUEST COUNT
	PUSHJ PDP,STWAIT	;SYSTEM TAPE BUSY, PUT JOB IN WAIT
	MOVEM ITEM,STUSER	;SET THIS JOB AS ONLY USER OF SYSTEM TAPE
				;CONTROL C DOES NOT STOP JOB WHILE USING S. T.
UINITB:

	MOVEI TAC1,ASSPRG	;TRY TO ASSIGN IT BY PROGRAM
	PUSHJ PDP,ASSASG
	JRST UINITW		;NOT AVAILABLE, SEE IF HE WILL WAIT FOR IT
	PUSHJ P,SETMOD		;SET DDB IOS STATUS WORD
	JRST UINITR		;LOSE. ILLEGAL MODE.
	MOVSI IOS,IOBEG		;FLAG INIT JUST DONE
	IORB IOS,DEVIOS(DEVDAT)
				;FROM RT. HALF OF UUO
	MOVE TAC,DEVMOD(DDB)	;GET GOOD BITS
	TLNE TAC,DVTTY		;IS IT A TTY?
	TLNE TAC,TTYATC		;AND NOT HIS CONSOLE?
	JRST UINITL		;NO
	MOVSI IOS,TPMON
	ANDCAB IOS,DEVIOS(DDB)	;THEN NOT IN MONITOR MODE ANY MORE
UINITL:
	SKIPGE USRHCU(PID)	; IS USRHCU SCREWED UP?(NEGATIVE?)
	SETZM USRHCU(PID)	; YES, ZERO IT
UINITM:
	CAMG UCHN,USRHCU(PID)	; IS THIS CHANN. > HIGHEST CHANN. IN USE?
	JRST UINITC		;NO
	AOS TAC,USRHCU(PID)	;YES, BUMP HIGHEST SO FAR BY ONE
	SETZM USRJDA(TAC)	;AND CLEAR IT OUT
	JRST UINITM		;AND KEEP LOOKING

UNITAC:
	PUSH P,DDB		;SAVE MODEL DDB
UNTAC1:
	LDB AC1,PJOBN		;CHECK FOR ASSIGNED OR INITED ALREADY
	CAIN AC1,(J)
	JRST UNTAD1		;SAME JOB MEANS ASSIGNED OR INITED
	PUSHJ P,DEVLP2		;COME, LET US CONTINUE OUR SEARCH
	CAIA
	JRST UNTAC1		;GOT ANOTHER, KEEP CHECKING
	POP P,DDB
	JSP TAC,ERRPTU		;RAN OUT, HE LOSES
	ASCIZ /MUST ASSIGN /
	PUSHJ P,ERNAM		;TYPE "DEVICE MUMBLE"
	JRST EXCALP		;AT USER/EXEC XXX

UNTAD1:
	POP P,(P)
	JRST UNITAD

; INIT - SET UP BUFFERS AND INITIALIZE THEM

UINITC:
	POP PDP,DAT		;RESTORE POINTER TO ARGUMENT LIST
	TLO DEVDAT,INITB	;SET INIT UUO BIT
	XCTR XR,[HLRZ TAC1,1(DAT)]	;OUTPUT BUFFER HEADER FROM USER
	JUMPE TAC1,UINIT4	;WAS ONE SPECIFIED?
	HRLM TAC1,DEVBUF(DEVDAT);YES, SET DEVICE DATA BLOCK
	TLO DEVDAT,OBUFB	;SET OUTPUT BUFFER SPECIFIED BIT
	PUSHJ PDP,UINITZ	;INITIALIZE OUTPUT BUFFER HEADER
UINIT4:
	XCTR XR,[HRRZ TAC1,1(DAT)]	;INPUT BUFFER HEADER FROM USER
	JUMPE TAC1,UINIT5	;WAS ONE SPECIFIED?
	HRRM TAC1,DEVBUF(DEVDAT);YES, SET DEVICE DATA BLOCK
	TLO DEVDAT,IBUFB	;SET INPUT BUFFER SPECIFIED BIT
	MOVSI IOS,IOEND		;CLEAR END OF FILE FLAG
	ANDCAB IOS,DEVIOS(DEVDAT);AND RETAIN IOS
	PUSHJ PDP,UINITZ	;INITIALIZE INPUT BUFFER HEADER
UINIT5:
	MOVEM DEVDAT,USRJDA(UCHN);STORE UUO BITS AND  DEVICE
				;DATA BLOCK ADDRESS
	JRST CPOPJ1		;SUCCESSFUL RETURN

UINXIT:
	POP	P,DAT		; RESTORE STACK LOSER EXIT.
	POPJ	P,

UINITR:
	PUSH	P,DDB		;SAVE LOSER DDB
	JSP	TAC,ERRPTU
	ASCIZ	/ILLEGAL DATA MODE FOR /
	PUSHJ	P,ERNAM
	EXCH	DDB,(P)		;SAVE TTY DDB, GET LOSER DDB
	PUSHJ	P,RELEA7	;RELEASE DEVICE.
	POP	P,DDB		;RESTORE TTY DDB
	JRST	EXCALP		;SEND THE BEDBUG LETTER

; HERE WE ASK HIM IF HE IS WILLING TO WAIT FOR THE DEVICE
; PUT HIM IN DEVICE WAIT (DWQ) IF HE WANTS TO WAIT
; ROUTINE TO WAIT FOR DEVICE TO BECOME AVAILABLE FOR INIT

UINITW:
	TRNE	UUO,400			;DOES HE WANT ERROR RETURN?
	JRST	UINXIT			;YES. GIVE IT NOW
	MOVE	TAC1,JBTPRV(J)
	TLNE	TAC1,LUPPRV		;LOCAL-USER?
	JRST	UINTW1			;YES BYPASS TEST FOR SPECIAL DEV
	MOVE	TAC1,DEVCMR(DDB)
	TLNE	TAC1,DEVLUP
	JRST	UINXIT
UINTW1:
	HRRZM DDB,JBTDVW(J)	; SAVE THE DEVICE DATA BLOCK ADDRESS
	PUSH P,UUO
	PUSH P,UUOPC(J)
	PUSH P,UCHN
	TRNE UUO,IOPAR		; DO WE ASK HIM?
	JRST SETWAT		; NO, WAIT AUTOMATICALLY
SETIWT:
	PUSHJ P,TTYFUW		; WAIT FOR OUTPUT, SET UP DAT AND DDB
	HRRZ TAC1,JBTDVW(J)
	MOVE TAC1,DEVNAM(TAC1)
	PUSHJ P,PRNAME
	PUSHJ P,TYPGO
	TYPE { IS BUSY, WILL YOU WAIT?}
	PUSHJ P,UCTEXT
	HRRZ DDB,JBTDVW(J)	; PICK UP DDB ADDRESS OF DESIRED DEVICE
	MOVE TAC,[XWD TTYATC,ASSCON!ASSPRG]
	TDNE TAC,DEVMOD(DDB)	; THE AND OF THESE FOR TTY
	JRST SETRC
	LDB TEM,PJOBN		; PICK UP JOB NUMBER
	JUMPE TEM,GOTIT		; NOT CLAIMED, WE CAN GET IT
SETRC:
	CAME TAC1,[SIXBIT /Y/]
	CAMN TAC1,[SIXBIT /YES/]
	CAIA
	JRST SETNOW
SETWAT:
	MOVEI TAC1,DWQ
	MOVNM TAC1,JOBQUE(J)
	PUSHJ P,WSCHED
	HRRZ	DDB,JBTDVW(J)
	MOVE	TAC,[XWD TTYATC,ASSCON+ASSPRG]
	TDNE	TAC,DEVMOD(DDB)
	JRST	SETWAT		;LOSE
	LDB	TEM,PJOBN
	JUMPE	TEM,GOTIT
	CAIE	TEM,(J)
	JRST	SETWAT
GOTIT:
	TYPE {GOTCHA!}
	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	MOVE DAT,(P)
	JRST UINITG

; DEVICE WAIT - CAN'T GET IT, SEE IF HE WANTS DISK

SETNOW:
	TYPE {DIRECT IO TO DISK?}
	PUSHJ P,UCTEXT
	JUMPN TAC1,SETERY
SETERX:
	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	HRRZ DDB,JBTDVW(J)	;IN CASE WE NEED THIS ANYWAY (FOR ERR PRINT)
	JRST UINXIT
SETERY:
	CAME TAC1,[SIXBIT /Y/]
	CAMN TAC1,[SIXBIT /YES/]
	CAIA
	JRST SETERX
	MOVSI TAC,'DSK'
	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	JRST UINITK

UCTEXT:

	INCHWL JOBTM5		; INPUT A CHARACTER WHICH WE WILL THROW AWAY!
	MOVEI DAT,TTIBUF(DDB)	; SET UP ADDRESS OF DATA BUFFER
	PUSHJ P,CTEXT1
	PUSHJ P,SKPBRK		; MOVE OUT TO END OF LINE
	POPJ P,

;CALLING SEQUENCE
;	PUSHJ PDP,UINITZ
;	EXIT		RETURNS HERE IF MEMORY NOT EXCEEDED.
;SETS JBFADR:=JBFCTR:=0 FOR THE BUFFER AREA HEADER WHOSE ADDRESS
;IS IN AC TAC1.  ALSO,JBFPTR 0-5:=JBFPTR 12-17:=0,JBFPTR 6-11:=BYTE SIZE


UINITZ:
	XCTR	XW,[SETZM (TAC1)]	; CLEAR FIRST WORD OF BUFFER HEADER
	XCTR	XW,[SETZM 2(TAC1)]	; AND LAST WORD OF BUFFER HEADER
	PUSH	P,TAC1
	PUSHJ	P,SETBYT	; SET BYTE SIZE ACCORDING TO MODE
	TLZ	TAC,770077
	POP	P,TAC1
	XCTR	XRW,[HLLM TAC,1(TAC1)]
	POPJ	P,		;RETURN

;LONG DISPATCH TABLE UUOS - GET HERE ONLY IF DEVICE HAS LONG
;DISPACTH TABLE
;DISPACTH TO DEVICE DEPENDENT SERVICE ROUTINE
;ENTER UUO - ENTER FILE NAME IN DIRECTORY



UDEN:
	MOVEI TAC,CLSIN
	TLNN DDB,ENTRB		; HAS THIS FILE BEEN OPENED FOR WRITING?
	JRST UDEN1		; NO, SUPRESS CALL ON CLOSE CODE
	TLNN DEVDAT,OCLOSB	;FILE OPEN?
	PUSHJ PDP,UDLKC		;YES. CLOSE IT.
UDEN1:
	TLO IOS,IOBEG
	TRZ IOS,776000
	MOVEM IOS,DEVIOS(DEVDAT)
	TLO DEVDAT,ENTRB
	TLZ DEVDAT,OCLOSB
	HLLM DEVDAT,USRJDA(UCHN)	;STORE UUO BITS
	JRST DEN(DSER)

;LOOKUP UUO - LOOKUP FILE NAME IN DIRECTORY



UDLK:
	MOVEI TAC,CLSOUT
	TLNN DEVDAT,ICLOSB	;FILE OPEN?
	PUSHJ PDP,UDLKC		;YES. CLOSE IT
	TDZ IOS,[XWD IOEND,776000]
	MOVEM IOS,DEVIOS(DEVDAT)
	TLO DEVDAT,LOOKB
	TLZ DEVDAT,ICLOSB
	HLLM DEVDAT,USRJDA(UCHN)	;STORE UUO BITS
	JRST DLK(DSER)


↑UDLKC:	PUSH PDP,UUO
	HRRI	UUO,(TAC)
	PUSHJ PDP,CLOSE1
	POP PDP,UUO
	JRST	WAIT1

;RENAME UUO - HERE ON SHORT DISPATCH TABLE DEVICES TOO



URENAM:
	MOVE TAC,DEVMOD(DEVDAT)	;IS THIS DEVICE A LONG DISPATCH TABLE?
	TLNE TAC,DVLNG
	JRST DRN(DSER)		;YES, DISPATCH TO SERVICE ROUT.
	JRST CPOPJ1		;NO. GIVE SKIP RETURN TO USER

;SETO UUO - SET NEXT OUTPUT BLOCK NUMBER(DECTAPE)

UDSO:
	JRST DSO(DSER)

;SETI UUO - SET NEXT INPUT BLOCK NUMBER

UDSI:
	JRST DSI(DSER)

;GETF UUO - GET NEXT FREE BLOCK

UDGF:
	JRST DGF(DSER)

;MTAPE UUO - MAGTAPE OPERATIONS

UMTAPE:
	JRST DMT(DSER)

;UTPCLR - CLEAR DECTAPE DIRECT.

UTPCLR:
	MOVE TAC,DEVMOD(DEVDAT)	;IS THIS A LONG DISPATCH TABLE?
	TLNN TAC,DVLNG
	POPJ PDP,		;NO,RETURN
	JRST DCLR(DSER)		;YES, DISPATCH

;INPUT UUO

;1)  IF OUTPUT ACTIVE ON THIS CHANNEL, WAIT FOR IT TO COMPLETE.
;2)  IF DUMP MODE, WAIT FOR DEVICE INACTIVE, CALL SERVICE
;	ROUTINE TO START INPUT, WAIT TILL COMPLETE, THEN RETURN TO USER.
;3)  IF NO BUFFER RING SETUP, SET UP 2 RING BUFFER.
;4)  IF FIRST REFERENCE, START SERVICE ROUTINE, GO TO
;5)  FLAG CURRENT BUFFER AS FREE TO RECEIVE MORE INPUT
;	(USE BIT SET TO 0).
;	START SERVICE ROUTINE FILLING FIRST BUFFER WITH USE BIT 0
;	(NEXT BUFFER OR ONE AHEAD OF IT)
;	(SERVICE ROUTINE WILL SET USE BIT WHEN IT FINISHES FILLING
;	BUFFER).
;7)  IF NEXT INPUT BUFFER IS FULL OF DATA, GO TO 10).
;8)  PUT JOB IN IO WAIT TILL NEXT BUFFER FILLED.
;9)  IF NEXT INPUT BUFFER STILL NOT FILLED, CHECK FOR END
;	OF FILE OR ERROR BITS SET BY SERVICE ROUTINE.
;10) CONVERT WORD COUNT AS STORED BY SERVICE ROUTINE IN THIRD
;	WORD OF BUFFER TO ITEM COUNT AND STORE IN THIRD WORD
;	OF HEADER (ITEM COUNT) ALSO SET BYTE POINTER (SECOND
;	WORD OF HEADER) AND RETURN TO USER.


; HERE IF INPUT NEEDS LOOKUP. GET FILE NAME FROM LOSER.

SETFILE:
TYPE {PLEASE TYPE FILE NAME.}
	INCHWL JOBTM5
	MOVEI DAT,TTIBUF(DDB)	;GODDAMN SYSTEM
	PUSHJ P,CTEXT1		; READ IN FILE NAME IF ANY
	JUMPN TAC1,NOCLR
CLRIN:
	PUSHJ P,SKPBRK
	JRST SETFILE
NOCLR:
	MOVEM TAC1,JOBTM1(PROG)
	PUSHJ P,CTEXT1
	HLLZM TAC1,JOBTM2(PROG)
	SETZM JOBTM3(PROG)
	PUSHJ P,PJPGNO
IFE FTDSKPPN,<MOVE AC2,PRJPRG(J)>
IFN FTDSKPPN,<	JRST	[SKIPN	AC2,DSKPPN(J)	;DA, WHICH WAY DID 'E GO BOSS
			MOVE	AC2,PRJPRG(J)
			JRST	.+1]>
	MOVEM	AC2,JOBTM4(PROG)
	PUSHJ	P,SKPBRK
	POPJ	P,


↑IN:	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,DVDSK
	TLNE DDB,LOOKB		; DOES THIS DEVICE NEED A LOOKUP?
	JRST IN2		; NO, FORGET IT.
	PUSH P,UUO
	PUSH P,UUOPC(J)
	PUSH P,UCHN
	TYPE {LOOKUP NEEDED.}
IN4:
	PUSHJ P,SETFILE
	MOVE UUO,[LOOKUP JOBTM1]
	MOVE UCHN,(P)
	DPB UCHN,PUUOAC
	XCT UUO
	CAIA
	JRST IN5
	TYPE {LOOKUP FAILED}
	JRST IN4
IN5:
	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	MOVE DDB,USRJDA(UCHN)
	HRRZ DSER,DEVSER(DDB)
	MOVE IOS,DEVIOS(DDB)

; INPUT UUO - HERE, WE ARE SATISFIED DEVICE IS PROPERLY LOOKED UP

IN2:
	TLNE IOS,IO		;IS THIS DEVICE ALREADY DOING OUTPUT?
	PUSHJ PDP,WAIT1		;YES, WAIT TILL IT IS FINISHED.
	TLO DEVDAT,INPB		;FOR THIS DEVICE.
	TLZ DEVDAT,ICLOSB
	HLLM DEVDAT,USRJDA(UCHN)	;IN LH OF CURRENT JOB DEVICE CHANNEL
	LDB TAC,PIOMOD		;IO MODE
	CAIE TAC,2		;SAVE MODE?
	CAIL TAC,SD		;IT THE IO MODE DUMP(SD,D,DR)?
	JRST INDMP		;YES
	TLNN DEVDAT,IBUFB	;INPUT BUFFER HEADER SPECIFIED IN INIT?
	JRST ADRERR		;NO, FLUSH THE BASTARD!
IN1:
	HRR	JBUF,DEVBUF(DDB);NO, GET ADDRESS OF BUFFER HEADER
	MOVSI	TAC,IOUSE	;BUFFER IN USE BIT
	MOVE	IOS,DEVIOS(DDB)	;GET A NEW COPY OF IOS
	XCTR	XR,[SKIPG (JBUF)]	;HAS A BUFFER RING BEEN SET UP (RH NON-ZERO)
				;WHICH HAS BEEN REFERENCED BY PREVIOUS INPUT (BIT0=0)
	JRST	INPUTF		;NO. GO SET UP BUFFER IF NECESSARY AND DO FIRST IO
	PUSHJ	P,BCHECK	;CHECK BUFFERS!
	JRST	ADRERR		;ADDRESS CHECK
	XCTR	XR,[MOVE TAC1,(JBUF)]
	MOVE	IOS,DEVIOS(DDB)		;DEC 3.16
	XCTR	XR,[TDNN TAC,(TAC1)]	;DEC 3.16
	JRST	INPT1			;DEC 3.16
	XCTR	XRW,[ANDCAB TAC,(TAC1)]
				;FLAG CURRENT BUFFER AS FREE TO
				;RECEIVE MORE INPUT, CLEAR USE BIT
				;AND GET POINTER TO NEXT BUFFER
	XCTR	XRW,[HRRM TAC,(JBUF)]	;SET WORD 1 IN 3 WORD HEADER TO NEXT BUFFER
	TRNE IOS,IOACT		;IS THE DEVICE ALREADY ACTIVE
	JRST INPT0C		;YES
	MOVE AC1,DEVMOD(DEVDAT)	;GET DEVICE CHARACTERISTIC WORD
	TLNN AC1,DVTTY		;IS IT A TTY?
	XCTR	XR,[HRR TAC,(TAC)]	;GET POINTER 1 BUFFER AHEAD OF NEXT BUFFER
				;IF NOT TTY.
	XCTR	XR,[SKIPL (TAC)]	;IS THE USE BIT SET?
	PUSHJ	P,CALIN		;NO, START SERVICE ROUTINE FILLING EMPTY BUFFER

; INPUT UUO CONT.

INPT0C:
	XCTR	XR,[HRR TAC1,(TAC1)]	;GET USE BIT FOR NEXT BUFFER
INPT0A:
	XCTR	XR,[SKIPGE (TAC1)]	;IS USE BIT SET YET?(BUFFER FILLED YET?)
	JRST	INPUT2		;YES, RETURN IMMEDIATELY TO USER
INPT2:
				;DEC 3.16
	PUSHJ	P,WSYNC		;NO, PUT JOB IN IO WAIT TILL BUFFER FILLED.
	XCTR	XR,[SKIPL (TAC1)]	;RETURN WHEN BUFFER FILLED. CHECK TO MAKE SURE.
	JRST	INEOF		;NO, MUST BE EOF OR ERROR
INPUT2:
	ADDI	TAC1,1		;YES, GET WORD COUNT AS SET BY IO SERVICE
	XCTR	XR,[HRRZ ITEM,(TAC1)];RH OF 3RD WORD(FIRST SO-CALLED DATA WORD)
	SOJA	TAC1,IOSETC	;SET ITEM COUNT AND BYTE POINTER
				;IN 3 WORD HEADER AND RETURN TO USER
INPT1:
	TRNN	IOS,IOACT	;DEC 3.16
	PUSHJ	P,CALIN		;DEC 3.16
	JRST	INPT2		;DEC 3.16

INEOF:
	TDNN	IOS,[XWD IOEND,IODEND!IODERR!IOBKTL!IODTER!IOIMPM]
				;EOF OR ERROR BIT SET BY SERVICE ROUTINE
	JRST	INEOFE		;NO,
	TLNE	IOS,IOEND	;IS THIS EOF?
	TRO	IOS,IODEND	;YES, SET USER EOF BIT.
	IORM	IOS,DEVIOS(DDB)
	POPJ	P,		;RETURN TO USER'S PROGRAM

INEOFE:
	JSP	DAT,UERROR	;MONITOR ERROR AT UUO LEVEL
	POPJ	P,

;HERE ON FIRST INPUT AFTER INIT, INIT & LOOKUP, OR INIT & LOOKUP & INPUT
INPUTF:
	XCTR	XRW,[ANDCAB TAC,(JBUF)]
				;MARK THAT BUFFERS HAVE BEEN REFER
				;BY CLEARING SIGN BIT OF 1ST WORD IN 3 WORD
				;IN 3 WORD BUFFER HEADER
	JUMPE	TAC,INPUT3	;HAS A RING BEEN SET UP YET?
	PUSHJ	P,BCHECK
	JRST	ADRERR		;ADDRESS CHECK
	XCTR	XR,[MOVE TAC1,(JBUF)]
	XCTR	XR,[SKIPG (TAC1)]
	JRST	INPUT2
	HRRM	TAC,DEVIAD(DDB)	;YES, STORE ADR. OF 2ND WORD OF
				;A BUFFER FOR SERVICE ROUTINE
	PUSHJ	P,CALIN		;YES. GO START IO SERVICE ROUTINE
				;FILLING BUFFER
	JRST	INPT0A

INPUT3:
	HRRI	UUO,2		;BUFFERS NOT SETUP YET. - MAKE 2
	PUSHJ	P,UINBF
	HRRI	UUO,0		;CLEAR RIGHT HALF
	JRST	IN1


INDMP:
	PUSHJ	P,DDI(DSER)	;CALL SERVICE ROUTINE
	JRST	WSYNC		;THEN WAIT TILL IO  FINISHED BEFORE
				;RETURNING TO USER.
				;*** NOTE: ADCSER THINKS IT CAN RETURN
				; TO USER WITHOUT WAITING BY
				; A `JRST TPOPJ', THUS SKIPPING WSYNC

; CALL THE DEVICE INPUT ROUTIN

CALIN:
	TLNE	IOS,IOEND
	POPJ	P,
	PUSH	P,TAC1
	PUSH	P,JBUF
	HRRZ	AC1,DEVIAD(DDB)	;IS FIRST ADR. ABOVE JOB DATA AREA?
	CAIG	AC1,JOBPFI
	JRST	ADRERR		;NO, PRINT ERROR AND STOP JOB
	XCTR	XR,[HLRZ AC2,(AC1)]	;GET LENGTH OF BUFFER
	TRZ	AC2,IOUSE	;CLEAR USE BIT IN CASE IT IS ON(TTY)
	ADD	AC1,AC2
	XCTR	XRW,[MOVES (AC1)]	; ADDRESS CHECK LAST ADDRESS OF BUFFER
	PUSHJ	P,DIN(DSER)	;DISPATCH TO IO SERVICE ROUTINE
	POP	P,JBUF
	POP	P,TAC1
	POPJ	P,

↑BCHECK:MOVEI	AC1,(JBUF)
	CAIG	AC1,JOBPFI	;CHECK PROTECTED PART THIS WAY
	POPJ	P,
	XCTR	XRW,[MOVES AC1,(AC1)]	;AND THE REST THIS WAY
	HRRZ	AC1,AC1
	CAIG	AC1,JOBPFI
	POPJ	P,
	XCTR	XRW,[MOVES (AC1)]
	JRST	CPOPJ1

; OUTPUT UUO - CALLING SEQUENCE
;     OUTPUT D,
;     EXIT
;OR
;     OUTPUT D, ADR
;     EXIT

;IF INPUT IS ACTIVE, WAIT FOR IT TO COMPLETE.
;IF DUMP MODE WAS SELECTED BY THE LAST INIT UUO OR SETSTS UUO
;   THE PROGRAM WAITS UNTIL THE DEVICE IN INACTIVE AND THEN
;   WRITES THE DUMPFILE AND RETURNS CONTROL TO THE USER'S PROGRAM
;   WHEN IO HAS COMPLETED.
;IF THE MODE IS NOT DUMP, THEN
;1) IF ADR IS NOT ZERO, WAIT FOR DEVICE TO BECOME INACTIVE THEN SET THE
;   CURRENT BUFFER ADDRESS EQUAL TO ADR AND AN INDICATOR (JBFADR0)
;   SPECIFYING THAT THIS BUFFER RING HAS NEVER BEEN REFERENCED FROM THE
;   USER'S PROGRAM BY AN INPUT OR AN OUTPUT UUO.  OTHERWISE, GO TO
;   2) DIRECTLY.

;2) IF THE BUFFER RING HAS NEVER BEEN REFERENCED (JBFADR0=1), THE
;   BUFFER IS CLEARED, IOUSE SET TO ZERO AND
;      IF THE CURRENT BUFFER ADDRESS IS ZERO, A TWO BUFFER RING IS SET UP.
;      THEN GO TO 8
;
;3) IF THE BUFFER RING HAS BEEN REFERENCED (JBFADR0=0	,THEN A CHECK IS
;   MADE TO DETERMINE IF THE WORD COUNT IS TO BE COMPUTED.
;      IF THE WORD COUNT IS TO BE COMPUTED (IOWC=0), IT IS SET EQUAL
;      TO THE ADDRESS FOR THE LAST DATA WORD MINUS THE ADDRESS OF THE
;      BUFFER MINUS ONE.

;4) IOUSE IS SET TO ONE, INDICATING THAT THE BUFFER IS FULL OR BEING
;   EMPTIED, AND THE CURRENT BUFFER ADDRESS IS ADVANCED.

;5) IF THE DEVICE IS NOT ACTIVE (IOACT=0), OUTPUT IS STARTED.
;6) IF THE CURRENT BUFFER IS FULL OR BEING EMPTIED (IOUSE=1),
;   THE PROGRAM WAITS UNTIL THE DEVICE FINISHES THE BUFFER
;   (THE OUTPUT SERVICE ROUTINE CLEARS THE USE BIT WHEN
;   IT FINISHES OUTPUTTING A BUFFER).
;7) THE CURRENT BUFFER IS CLEARED.
;8) THE ITEM POINTER IS INITIATED TO THE CURRENT BUFFER ADDRESS+1
;   AND THE ITEM COUNT IS SET TO THE PRODUCT OF THE BUFFER SIZE
;   MINUS ONE AND THE INTEGER PART OF 36/BYTE SIZE.
;9) RETURN TO THE USER'S PROGRAM

;HERE ON OUTPUT UUO


UOUT:
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,DVDSK
	TLNE DDB,ENTRB
	JRST UOUT1
	PUSH P,UUO
	PUSH P,UUOPC(J)
	PUSH P,UCHN
	TYPE {ENTER NEEDED.}
OUT4:
	PUSHJ P,SETFILE
	MOVE UUO,[LOOKUP JOBTM1]
	MOVE UCHN,(P)
	DPB UCHN,PUUOAC
	PUSH P,JOBTM4(PROG)	;LOOKUP CLOBBERS THIS.
	XCT UUO
	JRST OUT5		;DOESN'T EXIST OR ERROR WILL BE DETECTED BY ENTER
	POP P,JOBTM4(PROG)
	TYPE {FILE ALREADY EXISTS. DELETE?}
	INCHWL JOBTM5
	MOVEI DAT,TTIBUF(DDB)
	PUSHJ P,CTEXT1
	PUSHJ P,SKPBRK
	CAME TAC1,['Y     ']
	CAMN TAC1,['YES   ']
	JRST OURDN
	JRST OUT4
OUT5:
	POP P,JOBTM4(PROG)	;RESTORE PPN
OURDN:
	HLLZS JOBTM2(PROG)
	SETZM JOBTM3(PROG)
	MOVE UUO,[CLOSE]
	MOVE UCHN,(P)
	DPB UCHN,PUUOAC
	XCT UUO			;MAKE SURE WE DON'T GET INTO ALTER MODE
	MOVE UUO,[ENTER JOBTM1]
	MOVE UCHN,(P)
	DPB UCHN,PUUOAC
	XCT UUO
	CAIA
	JRST OUT3
	TYPE {ENTER FAILED}
	JRST OUT4
OUT3:
	POP P,UCHN
	POP P,UUOPC(J)
	POP P,UUO
	MOVE DDB,USRJDA(UCHN)
	MOVE IOS,DEVIOS(DDB)
	HRRZ DSER,DEVSER(DDB)

; OUTPUT UUO - HERE WE ARE SATISFIED DEVICE HAS BEEN PROPERLY ENTERED

UOUT1:
	TLO DEVDAT,OUTPB	;SET OUTPUT UUO BIT
	TLZ DEVDAT,OCLOSB	;CLEAR CLOSE OUTPUT BIT

;HERE FROM DEVICE SERVICE ROUTINES ON CLOSE UUO

↑OUT:	TLNN IOS,IO		;IS THIS DEVICE ALREADY DOING INPUT?
	PUSHJ PDP,WAIT1		;YES, WAIT TILL IT BECOMES INACTIVE
	HLLM DEVDAT,USRJDA(UCHN);SAVE NEW BIT SETTINGS.
	LDB TAC,PIOMOD		;GET DATA MODE SET BY INIT OR SETSTS.
	CAIE TAC,2		;SAVE MODE?
	CAIL TAC,SD		;IS IT DUMP MODE(SD,DR,D)?
	JRST OUTDMP		;YES.
	TLNN DDB,OBUFB		; IS THERE AN OUTPUT BUFFER HEADER?
	JRST ADRERR		; NO, ERROR
	PUSHJ PDP,OUTA		;NO, CHECK FOR NON-ZERO ADDRESS(USER
				;CHANGING RING)
	HLR JBUF,DEVBUF(DEVDAT)	;REL. ADDR. OF OUTPUT BUFFER HEADER
	XCTR XR,[SKIPG TAC1,(JBUF)]
				; CHECK FIRST WORD OF BUFFER HEADER
	JRST OUTF		;RING NOT SET UP OR FIRST REFERENCE TO RING
	PUSHJ P,BCHECK		;RING SET-UP, CHECK IT
	JRST ADRERR		;ADDRESS CHECK
	XCTR XR,[SKIPG (TAC1)]	;DID WE SOME HOW GET BACK TO HIM WITH NO FREE BUFFERS? RPH
	JRST OUTAGN		;YES, LET DEVICE WORRY ABOUT IT!  RPH
	AOS JBUF		;COMPUTE WORD COUNT FROM BYTE POINTER
	XCTR XR,[HRRZ TAC,(JBUF)]	;GET RH OF BYTE POINTER.
	ADDI TAC1,1		;REL. ADDR. OF 3RD WORD IN BUFFER.
	SKIPN TAC		;BYTE POINTER INITIALIZED ;DWP(JS)
	TDZA TAC,TAC		;NO. SET WORD COUNT = 0	  ;DWP(JS)
	SUB TAC,TAC1		;DISTANCE FILLED BY USER.
	TRNE IOS,IOWC		;DOES USER WANT SYSTEM TO COMPUTE WORD
				;COUNT FROM BYTE POINTER?
	JRST OUT2		;NO.
	HRRZ AC1,TAC1		;YES, PROCEED IF ADDR. OF WORD COUNT IN BOUNDS
	ADDI AC1,(TAC)		;CHECK ENDING ADDRESS.
	XCTR XRW,[MOVES (AC1)]
	SOJ TAC1,		; BACK UP POINTER TO LENGTH AND LINK WORD
	XCTR XLB,[LDB AC1,[POINT 17,(TAC1),17]]
	CAMLE TAC,AC1		; IS THERE MORE DATA THAN THERE IS BUFFER?
	JRST ADRERR		; YES, USER ERROR
	AOJ TAC1,		; RESET BUFFER WORD COUNT POINTER
	XCTR XRW,[HRRM TAC,(TAC1)]	;STORE WORD COUNT IN 3RD WORD OF BUFFER.

; OUTPUT UUO - HERE, WE ADVANCE BUFFER ADDRESS, START OUTPUT, AND WAIT FOR
; OUTPUT TO FINISH BEFORE RETURNING TO USER

OUT2:
	SUBI JBUF,1		;REL. ADDR. OF 1ST WORD IN HEADER
				;(POINTER TO CURRENT BUFFER).
	SUBI TAC1,1			;REL. ADDR. OF 2ND WORD IN BUFFER
					;(LINK TO NEXT BUFFER).
	HRLZI TAC,IOUSE		;FLAG CURRENT BUFFER CONTAINS ACTIVE DATA.
	XCTR XRW,[IORB TAC,(TAC1)]
	XCTR XRW,[HRRM TAC,(JBUF)]	;ADVANCE CURRENT BUFFER ADDRESS
	XCTR XRW,[HLLZS 1(JBUF)]	; ZERO OUT RH OF BYTE PTR TO NOTE NOT YET INITIALIZED - DWP (JS) /JAM
OUTAGN:
	XCTR XW,[SETZM 2(JBUF)]	;CAN'T USE NEXT BUFFER YET!!   RPH
	MOVE IOS,DEVIOS(DEVDAT)	;IS DEVICE ACTIVE?
	MOVSI AC1,DEVAOA	; CAN WE CALL THIS SERVICE ROUTINE IF IOACT IS ON?
	TDNN AC1,DEVCMR(DEVDAT)	; THIS BIT IN THIS WORD WILL TELL US
	TRNN IOS,IOACT
	PUSHJ PDP,DOU(DSER)	;NO,START OUTPUT.
	HLR JBUF,DEVBUF(DEVDAT)	;JBUF TO REL. ADDR. OF BUFFER HEADER
	XCTR XR,[MOVE TAC1,(JBUF)];TAC1 TO REL. ADDR. OF 2ND WORD OF BUFFER.
	XCTR XR,[SKIPL (TAC1)]	;HAS SERVICE ROUTINE EMPTIED NEXT BUFFER
	JRST OUTS		;YES, CLEAR AND RETURN
	TRNE IOS,740000		;ANY ERRORS TO SHOW LOSER?   RPH
	POPJ P,			;YES, LET HIM SEE THEM	     RPH
	PUSHJ P,WSYNC		;NO, WAIT.
	JRST OUTS		;CLEAR BUFFER AND RETURN TO LOSER, HOPING THAT THE BUFFER IS NOW REALLY FREE

OUTF:
	XCTR XR,[SKIPE TAC1,(JBUF)]
	JRST OUTF1
	HRRI UUO,2
	PUSHJ PDP,UOUTBF
	HLR JBUF,DEVBUF(DEVDAT)
OUTF1:
	PUSHJ P,BCHECK		;CHECK BUFFER ADDRESSES
	JRST ADRERR		;ADDRESS CHECK
	MOVSI	TAC,IOUSE
	XCTR XRW,[ANDCAB TAC,(JBUF)];IOUSE:=0
	HRRM TAC,DEVOAD(DEVDAT)
OUTS:
	XCTR XR,[HRRZ TAC,(JBUF)]	;CLEAR NEXT OUTPUT BUFFER.
	PUSHJ	P,BUFCLR	;BEING CLEARED.
	JRST	ADRERR		;ADDRESS CHECK
	XCTR	XR,[HRR TAC1,(JBUF)]
	XCTR	XLB,[LDB ITEM,[POINT 17,(TAC1),17]]
	SOJA	ITEM,IOSETC
				;ADDRESS+1
				;JBFCTR:=(BUFFER SIZE-1)*[36/BYTE
				;SIZE]
				;RETURN TO USER'S PROGRAM

OUTDMP:
	PUSHJ PDP,DDO(DSER)
				;NOTE THAT XGPSER (AND ADCSER) THINKS IT CAN RETURN
				;WITHOUT WAITING BY JRST TPOPJ
	JRST WSYNC		;WAIT BEFORE RETURNING TO USER

; SUBROUTINE FOR OUTPUT UUO
;CALLING SEQUENCE:
;	PUSHJ PDP,OUTA
;	EXIT		ALWAYS RETURNS HERE
;IF THE ADDRESS FIELD OF AC UUO IS ZERO,EXIT. OTHERWISE,CHECK IOACT.
;IF IOACT=1, WAIT FOR IOACT=0.
;SET JBFADR18-35:=ADDRESS FIELD OF AC UUO. JBFADR0:=1 AND EXIT.

↑OUTA:	TRNN	UUO,777774		;IS BUFFER ADDRESS SPECIFIED?
	POPJ	P,			;NO
	PUSHJ	P,WAIT1
	HLR	JBUF,DEVBUF(DDB)
	XCTR	XRW,[HRRM UUO,(JBUF)]
	HRRM	UUO,DEVOAD(DDB)
	MOVSI	TAC,IOUSE
	XCTR	XRW,[IORM TAC,(JBUF)]
	POPJ	P,			;RETURN

;RELEASE A DEVICE


RELEA0:

↑RELEA3:
	TRZ	UUO,-1		;CLOSE BOTH INPUT AND OUTPUT.  HERE FROM IORELS
↑RELEA1:			;ALLOW SUPPRESION ON RELEASE UUO
	PUSHJ	P,CLOSE1
	HRRZ	TAC,DEVSER(DDB)	;DISPATCH ADDRESS IS THE ONLY THING RELEVANT
	CAIN	TAC,(DSER)	;COMPARE
	JRST	RELE1A
	PUSHACS
	PUSH	P,(DDB)		;DEVICE NAME
	MOVE	TAC,DSER
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/ DSER CLOBBERED BY CLOSE1 AT RELEA1. /
	POP	P,TAC1
	PUSHJ	P,DISSIX
	PUSHJ	P,DISTAB
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	POPACS
	MOVE	DSER,DEVSER(DDB)
RELE1A:
	PUSHJ	P,WAIT1		;WAIT FOR DEVICE TO BECOME INACTIVE
↑RELEA5:
	PUSHJ	P,DRL(DSER)		;DISPATCH TO DEVICE SERVICE ROUTINE
	MOVEI	IOS,IOACT		;CLEAR IO ACTIVE BIT
	ANDCAB	IOS,DEVIOS(DDB)		;AND RETURN WITH IOS SET
	SETZB	DAT,USRJDA(UCHN)	;CLEAR DEVICE ASSIGNMENT
	SKIPGE	TAC,USRHCU(PID)
	MOVEI	TAC,17
RELEA4:
	HRRZ	TAC1,USRJDA(TAC)
	JUMPN	DAT,RELE4A		;NON-ZERO CHAN. ALREADY?
	MOVE	DAT,TAC1		;NO, SET DAT WHEN FIRST(HIGHEST) FOUND
	MOVEM	TAC,USRHCU(PID)		;STORE HIGHEST IN USE CHANNEL
RELE4A:
	CAIE	TAC1,(DDB)		;IS THIS DEVICE SAME AS ONE BEING RELEASED?
	SOJGE	TAC,RELEA4
	JUMPGE	TAC,CPOPJ	;DON'T FLUSH THIS DDB IF OPEN ON ANOTHER CHANNEL
	HLLZS	DEVIAD(DDB)	;CLEAR INPUT BUFFER ADDRESS
	HLLZS	DEVOAD(DDB)	;AND OUTPUT BUFFER ADDRESS.

;CALLED FROM ERROR STOP ROUTINE(ESTOP)
↑RELEA9:
	MOVE	TAC,DEVNAM(DDB)		;IS THIS SYSTEM TAPE?
	CAME	TAC,[SIXBIT /DSK/]	;DSK IS NEVER QUEUED
	CAME	TAC,SYSTAP
	JRST	RELEA7			;IS DISK OR NOT SYSTEM TAPE
	MOVSI	TAC,777760		;PREPARE TO ZERO OUT MOST OF DEVIAD AND DEVOAD
	ANDCAM	TAC,DEVIAD(DDB)
	ANDCAM	TAC,DEVOAD(DDB)
	SKIPN	STUSER			;HAS COUNT ALREADY BEEN REDUCED AT ESTOP?
	JRST	RELEA7			;YES
	SETZM	STUSER			;YES, CLEAR SYSTEM USER NO.
	SOSL	STREQ			;YES, REDUCE COUNT
	SETOM	STAVAL			;SOMEONE IS WAITING, SET AVAILABLE FLAG/
RELEA7:
	MOVEI	TAC1,ASSPRG		;CLEAR ASSIGNED BY PROGRAM BIT
↑RELEA6:
	ANDCAB	TAC1,DEVMOD(DDB)	;CALLED FROM DEASSIGN
	TRZ	TAC1,777		;CLEAR JOB NO. FIELD
	TDNE	TAC1,[XWD TTYATC,ASSCON+ASSPRG]
	POPJ	P,			;DEVICE ASSIGNED BY OTHER MEANS TOO
	DPB	TAC1,PJOBN		;CLEAR JOB NUMBER
	MOVE	TAC1,DEVCMR(DDB)
	TLNN	TAC1,DEVSHR		;SHARABLE DEV?
	JRST	RELDVW			;NO - WAKE UP WAITERS IF ANY
	PUSH P,DAT		; IF AT COMMAND LEVEL, SAVE TTY POINTER
	PUSH P,DDB		; AND DDB ADDRESS
	PUSH P,DSER
	HRRZ DSER,DEVSER(DDB)	;GET POINTER TO DEVICE DEPENDENT ROUTINES
	PUSHJ PDP,DGIVDD(DSER)	;RETURN DDB TO STORAGE
	POP P,DSER
	POP P,DDB
	POP P,DAT		; RESTORE COMMAND POINTER
	POPJ P,

; RELEAS CODE - SEE IF THERE IS ANYONE WAITING FOR THE DEVICE
; IF SO, WAKE HIM UP.

RELDVW:
	PUSH P,DDB
	PUSH P,UUO
	PUSH P,DAT
	PUSH P,J		;SAVE OLD JOB NUMBER
	HRRZS DDB
	MOVEI DAT,DVWSCAN	; SCAN ALL JOBS IN DEVICE WAIT
	JSP UUO,QSCAN
	JRST RELDVX
	CAME DDB,JBTDVW(J)
	JRST (AC1)		; GO RESCAN
	MOVEI AC1,RUNQ
	MOVNM AC1,JOBQUE(J)	; WAKE HIM UP
	PUSHJ P,REQUE
RELDVX:
	POP P,J
	POP P,DAT
	POP P,UUO
	POP P,DDB
	POPJ P,

; UUOS TO TEST IO STATUS WORD
;CALLING SEQUENCE
;	STATO D,MASK
;	EXIT1		ALL SELECTED BITS ARE 0
;	EXIT2		SOME SELECTED BITS ARE 1
;TESTS BITS OF I/O STATUS WORD OF DEVICE ON USER'S CHANNEL D WHICH
;ARE SELECTED BY MASK.


↑USTATO:
	TRNE IOS,(UUO)		; SKIP IF ANY INDICATED BITS ARE ONE
	AOS (PDP)
	POPJ PDP,		;RETURN TO USER

; MORE STATUS UUOS
;CALLING SEQUENCE
;	GETSTS D,ADR
;	EXIT		ALWAYS RETURNS HERE
;STORES I/O STATUS WORD OF DEVICE ON CHANNEL D IN LOCATION ADR.




↑USTATS:
	HRRZ TAC,IOS		; GET USER HALF OF IOS
	JRST STOTAC		;ADDRESS CHECK AND STORE IN USER AREA

; STILL MORE STATUS UUOS
;CALLING SEQUENCE
;	STATZ D,MASK
;	EXIT1		SOME SELECTED BITS ARE 1
;	EXIT2		ALL SELECTED BITS ARE 0

;TESTS BITS OF I/O STATUS WORD OF DEVICE ON USER'S
;CHANNEL D WHICH ARE SELECTED BY MASK.


↑USTATZ:
	TRNN IOS,(UUO)		; SKIP IF ALL INDICATED BITS ARE ZERO
	AOS (PDP)
	POPJ PDP,		;RETURN TO USER




;IN UUO - LIKE INPUT	SKIPS IF  EOF OR ERRORS


↑TIN:	PUSHJ PDP,IN		;DO INPUT UUO
	TRNE IOS,IOBKTL+IODTER+IODERR+IOIMPM+IODEND
	AOS (PDP)
	POPJ PDP,


;OUT UUO - LIKE OUTPUT  -  SKIPS IF ERRORS


↑TOUT:	PUSHJ PDP,UOUT		;DO OUTPUT UUO
	TRNE IOS,IOBKTL+IODTER+IODERR+IOIMPM
	AOS (PDP)
	POPJ PDP,



;SPACEWAR UUOS

SPCWGO:
	MOVEI	UUO,(TAC)		;SETUP STARTING ADDRESS.
	HLLZ	UCHN,TAC		;MODE BITS IN UCHN LEFT
	HLR	UCHN,TAC		;TICKS IN UCHN RIGHT
	AND	UCHN,[740000,,17]	;FLUSH IRRELEVANT BITS
	JRST	SPCWG1

;UUO43 IS THE SPACEWAR UUO.  SEE SPWSER FOR MORE DETAILS - JS

USPCWAR:
ANDI	UCHN,17		;TICKS ONLY
SPCWG1:
	MOVE TAC,JBTPRV(J)
	TLNE TAC,LUPPRV
	JRST	SPWCON		;LET SPACE WAR SERVICE FIGURE OUT WHAT TO DO
	JRST	UUOERR		;ILLEGAL FOR REMOTE JOBS
BEND APRSER
;: UUOCON[J17,SYS] EOF.
;: SCHEDU[J17,SYS]
COMMENT ⊗   VALID 00058 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00007 00002	BEGIN SCHEDU 
 SUBTTL SCHEDULING ALGORITHM FOR SWAPPING SYSTEM
C00009 00003	NXTJOB DECREMENTS CURRENT JOB'S QUANT. AND PROTECT
C00012 00004	BUG TRAP
C00014 00005	CKJB1:	JUMPN	PID,SCHED
C00017 00006	 SCAN JOB STATUS TABLES FOR A JOB TO RUN
C00019 00007	 THIS ROUTINE CHECKS TO SEE IF THE JOB IN J IS REALLY RUNNABLE
C00021 00008	 HERE WE SEE IF THIS JOB'S HIGH SEGMENT IS IN CORE
C00023 00009	 AT THIS POINT, WE HAVE ALMOST DECIDED ON A JOB
C00024 00010	2-PROCESSOR ROUTINES TO INTERLOCK JOBS
C00026 00011	 HERE, WE SORT THE RUN QUEUE INTO PRIORITY ORDER
C00030 00012	 THIS ROUTINE CALCULATES THE VARIOUS JOB PRIORITIES
C00033 00013	 CALCULATE ONE JOB'S NEW PRIORITY
C00039 00014	 ADD UP THE SERVICES TO HIS VARIOUS RELATIVES
C00043 00015	QCSS	24 JULY 67
C00046 00016	QUEUE INITIALIZATION
C00048 00017	DELETES A JOB FROM ITS "SOURCE-Q", DETERMINES A "DEST-Q"
C00049 00018	CALLING SEQUENCE:
C00057 00019	 JOB IS NOT RUNNING.  REQUEUE HIS SEGMENT IF NEEDED.
C00060 00020	SCANS THE QS RETURNING THE NUMBERS OF THE JOBS IN THE QS.
C00062 00021	↑QSCAN:	SKIPN QR,(DAT)	END OF SCAN TABLE?
C00064 00022	DEFINE X'(A),<
C00065 00023	CORRESPONDENCE TABLE BETWEEN JOB STATUS CODES AND QUEUE TRANSFER TABLES
C00067 00024	IFN FTSWAP,<
C00069 00025	HERE RESIDES ALL THE SWAP IN LIST CODE -- RPH 1/15/74
C00074 00026	SWAP	4 AUG 67
C00076 00027	↑SWAP:	PUSH PDP,[SWPXIT]	 MAKE SURE WE EXIT THROUGH HERE
C00078 00028	 WE COME HERE TO FINISH A SWAPPING INPUT REQUEST
C00081 00029	 HERE WE CONTINUE ANY SPW JOB THAT WAS ACTIVE AND GIVE SWAPIN INTS
C00085 00030	 WE CLEAR JOB DATA AREA IF REQUIRED ALSO
C00086 00031	HERE WE CHECK ALL THE SWAPIN BITS
C00089 00032	CHECK IF UPPER WANTS IN
C00091 00033	HERE THERE'S A SWAPIN ERROR.
C00093 00034	ERROR AND NOT WRITE PROTECTED SEGMENT, OR LOWER.
C00095 00035	 HERE WE CHECK THE NUMBER OF DDB'S HE HAS, ALSO REGENERATE JOB DATA AREA
C00098 00036	 ROUTINE TO RELEASE A JOB'S SWAPPING BANDS (LIBRASCOPE ONLY)
C00099 00037	 AND HERE IS WHERE WE GO TO FINISH A SWAP OUTPUT REQUEST
C00103 00038	SCAN FOR INPUT - LOOK FOR A JOB ON THE DISK WHICH OUGHT TO COME IN.
C00107 00039	 "DEADUP" IS CALLED FROM NEAR SCNIN2, IF THE JOB TO BE SWAPPED IN IS AN
C00110 00040	 THIS SENDS THE MESSAGE TO A DEADLOCKED LOWER
C00111 00041	 HERE WE SEE IF JOB CAN EVER FIT. IF SO, TRY TO COMPACT CORE TO GET HIM IN
C00113 00042	 HERE WE HAVE DETECTED A CORE DEADLOCK
C00115 00043	 CLOCK REQUEST TIMES OUT IN 15-SOME-ODD-SECONDS AND COMES HERE:
C00117 00044		GCMAX - ROUTINE TO CALCULATE HOW MUCH CORE IS AVAILABLE FOR A
C00122 00045	SCAN FOR OUTPUT
C00126 00046	FORCE4:	CAME J,SEGWAIT		 IF WAITING FOR SEGMENT, MUST STAY IN
C00129 00047	OUTPUT A JOB
C00134 00048	 ROUTINE TO ADD THIS JOB'S SIZE TO CURRENT TOTAL AND SEE IF WE
C00136 00049	 ROUTINE TO DECREMENT REFERENCE TO THIS JOB'S UPPER, IF ANY
C00137 00050	 ALL SWAP RETURNS THROUGH HERE
C00138 00051	INPUT A JOB
C00140 00052	XPAND SETS CONDITIONS TO GET MORE CORE FOR A JOB BY SWAPPING IT OUT
C00143 00053	SWPSER	4 AUG 67
C00146 00054	 FAST-BAND SWAPPER . .  .
C00148 00055	 HERE WE HAVE ENOUGH BANDS, SET UP CALL
C00150 00056	 LIBRASCOPE INPUT ROUTINE
C00152 00057	 LIBRASCOPE SWAPPING ERROR ROUTINES
C00153 00058	FIND A SERIES OF BLOCKS ON THE DISK TO SWAP ONTO. CALLED
C00155 ENDMK
C⊗;

BEGIN SCHEDU 
 SUBTTL SCHEDULING ALGORITHM FOR SWAPPING SYSTEM
;11 SEPT 67 REDESIGNED PERIODICALLY BY JAM (AND OTHERS)


;AC'S
QJ←DDB		;QJOB WORD
Q←PROG		; QUEUE NUMBER
PC←UUO		; PC ON QUEUE SCAN CALLS
QR←AC1		; RESCAN ADDRESS ON QUEUE SCAN CALLS

;INITIALIZE SCHEDULER  (CALLED FROM IOINI1 BEFORE ALL OTHER
;	DEVICES ARE INITIALIZED)


↑NXTINI:
REPEAT 0,<
	SYNINI	JBTCSC
	MOVE	DDB,[XWD JBTOWN,JBTOWN+1]
	SETZM	JBTOWN
	BLT	DDB,JBTOWN+JOBN-1
>
	SETZM	SCHBEG		;ZERO JOB PRIORITY STUFF
	MOVE	DDB,[XWD SCHBEG,SCHBEG+1]
	BLT	DDB,SCHEND
	MOVEI	DDB,MAXQ		;MAXIMUM NUMBER OF QUEUES
NXTIN1:
	SETZM	AVALTB(DDB)		;CLEAR SHARABLE DEVICE AVAIL. FLAGS
	SETOM	REQTAB(DDB)		;SET SHARABLE DEVICE REQUEST COUNT
					;TO -1,  I.E. NO JOB WAITING OR
					;USING DEVICE OTHER THAN INITIALIZATION
	SOJGE	DDB,NXTIN1
	SETZM	SWPCNT			;CLEAR SWAPPER COUNT
	SETZM	SCHMQT			;WAKE SWAPPER UP THE FIRST TIME AROUND
	SETZM	QJOB
	MOVE	DDB,[XWD QJOB,QJOB+1]
	BLT	DDB,QJOB+JOBN-1
IFN FTSWAP,<
	PUSHJ	P,FBINI
	JRST	SWPINI
>
IFE FTSWAP,<POPJ P,>

;NXTJOB DECREMENTS CURRENT JOB'S QUANT. AND PROTECT
;TIMES AND REQUEUES IT IF QUANT. TIME GONE TO 0.
;SERVICES ANY JOB REQUEUING REQUESTED AT OTHER PRIORITY
;LEVELS THEN CALLS SHUFFLER,SWAPPER AND SCHEDULER
;MAKES NO ASSUMPTIONS RE. ACS
;RETURNS NEXT JOB TO RUN IN J.


↑NXTJOB:
	JUMPN PID,SCHD1		;PDP-6 GETS TO RUN THE NULL JOB A LOT.

; HERE, WE SEE IF CURRENT JOB IS RUNNABLE. IF IT IS, WE
; SEE IF ITS QUANTUM TIME HAS RUN OUT. IF IT HAS, WE REQUEUE THE
; JOB. IF NOT, WE LEAVE NOW

CKJB3:
	SKIPN J,JOB(PID)	;CURRENT JOB NO., IS IT NULL JOB?
	JRST CKJB1		;YES,GO SEE IF OTHER JOBS NEED RESCHEDULING
	CONO PI,PIOFF		;AVOID CONFUSION BETWEEN NEXT 2 INSTRS
	MOVE DAT,JOBQUE(J)	;PICK UP HIS NEW QUEUE
	MOVMM DAT,JOBQUE(J)	;STORE BACK POS (NO MORE INT NEEDED)
	CONO PI,PION
	MOVM DDB,DAT		;GET POSITIVE FORM
	HLRZ IOS,JBTSTS(J)	;GET JOB STATUS BITS AND CODES
	ANDCMI IOS,RUNMSK	;MASK OUT DO NOT CARE BITS
	CAIE IOS,RUNABLE	;IS CURRENT JOB RUNABLE?
	JRST CKJB10		;NO, REQUE CURRENT JOB
	CAIE DDB,RUNQ		; IS HE STILL RUNNABLE?
	CAIN DDB,TQ
	CAIA
	JRST CKJB10		; NO. REQUE HIM.
	SKIPE TIMEF(PID)	;YES, IS THIS A TIME INTERRUPT?
	SOSLE SCHMQT(PID)	; YES, DO WE RUN THE SCHEDULER THIS TICK?
	CAIA			;  NO
	JRST CKJB9		;  YES
IFN FTSWAP,<	SKIPE XJOB(J)	; NO, THIS JOB EXPANDING?
	JRST CHKXJ1		; YES, SCHEDULE TO GET SWAPPED OUT>
	LDB DDB,PSEGN		; GOT AN UPPER?
	JUMPE DDB,CPOPJ		; NO, FORGET IT
IFN FTSWAP,<	SKIPE XJOB(DDB)	;IS HIS UPPER SEGMENT EXPANDING?
	JRST CHKXJ3		;  YES	>
	MOVE DDB,JBTSTS(DDB)	;IS IT IN TRANSIT?
	TLNE DDB,SHF!SWP
	JRST CKJB2A		; YES, SHUT THIS JOB OFF
	POPJ P,			;  NO

;BUG TRAP
CHKXJB:
	SKIPE XJOB	;THIS SHOULD BE SET.
	POPJ P,		;ALL IS WELL
	AOS XJOB	;GET IT TAKEN CARE OF.
	PUSHACS
	PUSHJ	P,DISJOB
	PUSHJ	P,DISMES
	ASCIZ	/ XJOB(J) SET BUT NOT XJOB(0)
/
	POPACS
	POPJ P,

CHKXJ4:
	PUSH P,J
	MOVE J,DDB
	PUSHJ P,CHKXJB
	POP P,J
	POPJ P,

CHKXJ3:
	PUSHJ P,CHKXJ4
	JRST CKJB2A

CHKXJ1:
	PUSHJ P,CHKXJB
	JRST CKJB2A

CKJB9:
	MOVEI DAT,QQMQT		; RESET SCHEDULER WAIT TIME
	MOVEM DAT,SCHMQT(PID)
	AOS NTMOS		; BUMP NUMBER OF TIME-OUTS
	CAIE DDB,TQ		; IF IN TQ, WE HAVE TO REQUEUE THIS JOB
	JRST CKJB2A
	MOVEI	DDB,RUNQ	; PUT HIM INTO STANDARD RUN QUEUE
	MOVEM	DDB,JOBQUE(J)	;SAVE QUEUE CODE (POS SINCE INT TAKEN CARE OF HERE)
	SKIPA DAT,[-1,,QRUNW]
CKJB10:

	HRR DAT,QBITS(DDB)	;GET ADR FROM POS CODE IN DDB, PRESERVE SIGN OF ORIG
	PUSHJ P,QXFER
	MOVE J,JOB(PID)
CKJB2A:

REPEAT 0,<
	PUSHJ P,JOBRLS		;ARRIVE HERE TO TURN OFF A JOB
>

CKJB1:
	JUMPN	PID,SCHED
CKJB2:
	SETZ TAC1,
	CONO PI,PIOFF		;MAKE SURE LIST STAYS HONEST
	SKIPN J,QJOB
	JRST CKJB4
	EXCH TAC1,(J)		;GET LIST LINK AND ZERO THIS ENTRY
	HRRZM TAC1,QJOB		;LINK HIM OUT
	CONO PI,PION
	SUBI J,QJOB		;GET JOB NUMBER
	CONO PI,PIOFF		;PROBABLY BETTER DUPLICATED THAN OFF TOO LONG
	MOVE DAT,JOBQUE(J)	;NEW QUEUE, - => GEN INT IF ENABLED
	MOVMM DAT,JOBQUE(J)	;INT NO LONGER NEEDED
	CONO PI,PION
	MOVM DDB,DAT		;GET POS FORM
	HRR DAT,QBITS(DDB)	;AND BITS (PRESERVE SIGN)
	PUSHJ P,QXFER		;DO THE QXFER THING
	JRST CKJB2

CKJB4:
	CONO PI,PION		;TURN PI'S BACK ON
	MOVEI QJ,AVLNUM		;CK AVAL FLAGS FOR SHAR. DEVS.
CKJB6:
	SKIPN AVALTB(QJ)	;FLAG=0?
	SOJGE QJ,CKJB6		;YES - TRY NEXT ONE
	CAIGE QJ,MINQ		;LESS THAN MIN. SHAR. DEV.Q?
	JRST CKJB7		;YES. IGNORE.
	MOVN J,QJ		;NO--GET 1ST JOB IN Q
	HRRE J,JBTQ(J)
	JUMPLE J,CKJB8		;FINISHED Q?
	MOVNI DAT,RUNQ		; REQUEUE HIM TO THE RUN QUEUE
	MOVEM DAT,JOBQUE(J)
	HRROI DAT,QRUNW		;- SO INT CAN HAPPEN
	SETZM AVALTB(QJ)	;CLEAR AVAL FLAG
	PUSHJ PDP,QXFER		;REQUEUE THE JOB AND PUT IT IN
				;PROCESSOR Q SO SCHEDULER WILL RUN IT
CKJB8:
	SOJG QJ,CKJB6		;CONTINUE IF ANY MORE FLAGS TO LOOK AT
CKJB7:
				;NONE--GO SHUFFLE AND SWAP
	SKIPE INTREQ		;BUT FIRST A WORD FROM OUR INTERRUPTS
	PUSHJ P,INTRUN		;(QXFER MAY HAVE GENERATED INTS)
IFE FTSWAP,<	
	PUSHJ PDP,CHKSHF
>
IFN FTSWAP,<
	HGMAC(10)
	PUSHJ PDP,SWAP
	HGMAC(6)	>

; SCAN JOB STATUS TABLES FOR A JOB TO RUN

SCHED:
	AOS NSCHEDS		; COUNT NUMBER OF TIMES THROUGH HERE
	MOVEI DAT,ALLRUNSCAN	; SCAN TQ AND RUNQ ONLY
	JSP PC,QSCAN
	JRST SCHD1		; NOBODY LEFT, RUN NULL JOB
	PUSH P,DAT		; SAVE POINTER TO QUEUE SCAN LIST
	PUSHJ P,CHKJOB		; IS HE REALLY RUNNABLE?
	JRST SCHPDR		; NO, TRY NEXT GUY
	POP P,DAT
	JRST SCH1		; YES, DO IT

SCHPDR:
	POP P,DAT
SCH2:
	JRST (QR)

REPEAT 0,<			;FLUSH THIS
SCHSCN:
	MOVE J,JOB(PID)		; START AT CURRENT JOB NUMBER MINUS ONE
SCHD2:
	SOJG J,SCHD3		; WRAP JOB 0 AROUND TO MAXIMUM LEGAL JOB NUMBER
	MOVEI J,JOBN-1
SCHD3:
	PUSHJ P,CHKJOB		; IS HE REALLY RUNNABLE?
	JRST SCH2		; NO
	JRST SCH1		; YES, DO IT.

SCH2:
	CAIN J,1		; IS THIS JOB 1?
	SKIPE JOB(PID)		; IF THIS IS JOB 1 AND THE NULL JOB RAN LAST, WE ARE DONE
	CAMN J,JOB(PID)		; ARE WE BACK TO WHERE WE STARTED?
	JRST SCHD1		; YES, RETURN NULL JOB
	JRST SCHD2		; NO, SCAN NEXT JOB
>;END REPEAT 0

; THIS ROUTINE CHECKS TO SEE IF THE JOB IN J IS REALLY RUNNABLE
; RETURNS IF NOT RUNNABLE, TAKES SKIP RETURN IF RUNNABLE

CHKJOB:
	HLRZ	IOS,JBTSTS(J)		;PICK UP STATUS BITS
	ANDCMI	IOS,RUNMSK		;ZERO THE BITS THAT DON'T MATTER
IFN FTSWAP,<
	SKIPE	XJOB(J)
	JRST	CHKXJB			;JOB IS EXPANDING.  CAN'T BE RUN.
>
	CAIN	IOS,RUNABLE		;IS THIS JOB RUNNABLE
	JRST	SCHD4			;YES.  MAKE SURE THAT SEGMENT IS THERE.
	TRNE	IOS,RUN
	POPJ	P,
	MOVM	DAT,JOBQUE(J)
	CAIE	DAT,RUNQ
	POPJ	P,
	PUSHACS
	MOVSI	DAT,RUN
	ANDCAM	DAT,JBTSTS(J)
	MOVNI	DAT,STOPQ
	MOVEM	DAT,JOBQUE(J)
	PUSHJ	P,REQUE
	PUSHJ	P,DISJOB
	PUSHJ	P,DISMES
	ASCIZ	/  IN RUNQ; NOT RUNNABLE. JBTSTS= /
	MOVE	TAC,JBTSTS(J)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	POPACS
	POPJ	P,

; HERE WE SEE IF THIS JOB'S HIGH SEGMENT IS IN CORE

SCHD4:
	LDB DDB,PSEGN		; DOES THIS JOB HAVE A HIGH SEGMENT?
	JUMPE DDB,CPOPJ1
	JUMPN PID,CPOPJ
	MOVE DSER,JBTSTS(DDB)
	TLNE DSER,SWP		; IF SO, IS IT IN CORE?
	JRST SCH5		;NO. SWAPPED OUT. LET'S DRAG IT IN!
	TLNE DSER,SHF
	POPJ P,
	SKIPE XJOB(DDB)
	JRST CHKXJ4
	MOVM DSER,JOBQUE(DDB)
	CAIN DSER,STOPQ
	JRST SCH3
	MOVEI DSER,STOPQ
	MOVNM DSER,JOBQUE(DDB)
	MOVEI DAT,QSTOPW
	PUSH P,J
	MOVE J,DDB
	PUSHJ P,QXFER
	POP P,J
SCH3:
	CAMN J,SEGWAIT
	SETZM SEGWAIT
	JRST CPOPJ1

SCH5:
	SKIPE SEGWAIT
	POPJ P,
	MOVEM J,SEGWAIT
	MOVM DAT,JOBQUE(DDB)
	CAIN DAT,SEGQ
	POPJ P,			; YES, DON'T REQUEUE HIM
	PUSH P,J		; SWAPPED OUT. BRING IT IN
	MOVE J,DDB
	MOVEI DAT,SEGQ
	MOVNM DAT,JOBQUE(J)
	MOVEI DAT,QSEGW		; PUT IT IN SEGMENT WAIT QUEUE
	PUSHJ P,QXFER
	POP P,J
	POPJ P,

; AT THIS POINT, WE HAVE ALMOST DECIDED ON A JOB
; WE CLAIM IT AND RETURN

SCH1:

REPEAT 0,<
	MOVE DDB,JB2STS(J)
	JUMPE PID,SCH6
	TLNN DDB,RUN2
	JRST SCH2
	JRST SCH4
SCH6:
	TLNN DDB,RUN1
	JRST SCH2
SCH4:
	PUSHJ P,JOBGET
	JRST SCH2
>
	POPJ	P,		;RETURN

SCHD1:
	SETZ J,			;RETURN NULL JOB
	SKIPN PID		; FOR P1, WE WILL
	AOS NNULLJS		; BUMP NUMBER OF TIMES NULL JOB SELECTED
	POPJ PDP,

;;2-PROCESSOR ROUTINES TO INTERLOCK JOBS
		;JBTOWN(J) > 0 MEANS JOB J IS BEING RUN BY P1
		;JBTOWN(J) < 0 MEANS JOB J IS BEING RUN BY P2
REPEAT 0,<

JOBGET:

	PSYNC JBTCSC
	JUMPE PID,JOBG3
	SKIPLE JBTOWN(J)
	JRST JOBG1
	SOS JBTOWN(J)
	JRST JOBG2
JOBG3:
	SKIPGE JBTOWN(J)
	JRST JOBG1
	AOS JBTOWN(J)
JOBG2:
	AOS (P)
JOBG1:
	XSYNC JBTCSC
	POPJ P,

JOBRLS:

	JUMPE PID,JOBRL1
	AOSLE JBTOWN(J)
	JRST JOBRER
	POPJ P,
JOBRL1:
	SOSL JBTOWN(J)
	POPJ P,
JOBRER:
	PUSHACS
	PUSHJ P,ALTNOW
	JFCL
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ /ππJOB RELEASED ILLEGALLY
/
	POPACS
	DEBCHECK
	SKIPN DISFLAG
	JRST JOBR2
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

JOBR2:
	JUMPE PID,.+2
	SOSA JBTOWN(J)
	AOS JBTOWN(J)
	POPJ P,
>

; HERE, WE SORT THE RUN QUEUE INTO PRIORITY ORDER

↑ORDER:					;CALLED WHEN ORDYET≠0
	MOVE	DDB,INTIME+P1PID	;TOTAL INTERRUPT TIME
	EXCH	DDB,OINTIME		;SAVE IT
	SUB	DDB,OINTIME		;-(RECENT INTERRUPT TIME)
	MOVE	J,UPTIME+P1PID		;CURRENT UPTIME
	EXCH	J,OUTIME		;SAVE IT
	SUB	J,OUTIME		;-(CHANGE IN UPTIME)
	MOVE	DSER,DDB		;SAVE -(RECENT INTERRUPT TIME)
	SUB	DDB,J			;(DELTA UPTIME)-(DELTA INTERRUPT TIME)
	MOVEM	DDB,JLFACTOR		;SAVE AS WEIGHTING FACTOR.
	MOVEM	DDB,RJLFACTOR
	MOVSI	DDB,1
	IDIVM	DDB,RJLFACTOR		;AVOID REMAINDER
	IMULI	DSER,=1000
	IDIVM	DSER,J
	MOVEM	J,JLRIT			;SAVE RECENT INTERRUPT FRACTION, *1000

	MOVE	TAC,[XWD JBTNPR,JBTPRI]
	BLT	TAC,JBTPRI+JOBN-1
	MOVNI	Q,RUNQ
ORD3:
	HRRE	Q,JBTQ(Q)		;PICK UP FIRST JOB IN RUN QUEUE
	JUMPL	Q,ORDX			;NO MORE, EXIT.
ORD2:
	HRRE	DSER,JBTQ(Q)		;GET NEXT JOB IN QUEUE.
	JUMPL	DSER,ORDX		;IF NO NEXT JOB, WE'RE DONE.
	MOVE	DDB,JBTPRI(DSER)	;COMPARE PRIORITIES.
	CAMG	DDB,JBTPRI(Q)
	JRST	ORD3		;RIGHT ORDER  PRI[Q]>PRI[DSER].  ADVANCE IN QUEUE.
	HLRE	UCHN,JBTQ(Q)	;WRONG ORDER. SCAN BACKWARDS TO FIND RIGHT SPOT
ORD1:
	JUMPL	UCHN,ORDINS		;JUMP IF THERE'S NO FURTHER BACKWARDS.
	CAMG	DDB,JBTPRI(UCHN)	;IS THIS WHERE IT SHOULD BE?
	JRST	ORDINS			;YES. PRI[UCHN]>PRI[DSER]
	HLRE	UCHN,JBTQ(UCHN)		;ADVANCE BACKWARDS.
	JRST	ORD1

;DELETE ENTRY POINTED TO BY DSER; INSERT IT AFTER ENTRY POINTED TO BY UCHN.
ORDINS:
	MOVE	DDB,JBTQ(DSER)	;DELETE HIM FROM OLD POSITION.
	HLLM	DDB,JBTQ(DDB)	;SET BACKWARDS LINK IN GUY FORWARD FROM US.
	MOVS	DDB,DDB
	HLRM	DDB,JBTQ(DDB)	;SET FORWARDS LINK IN GUY BACKWARD FROM US.
	MOVE	DDB,JBTQ(UCHN)	;ADD US AFTER (FORWARDS FROM) OUR TRUE PREDECESSOR
	HRRM	DDB,JBTQ(DSER)	;FLINK[DSER]←FLINK[UCHN]
	HRRM 	DSER,JBTQ(UCHN)	;FLINK[UCHN]←DSER
	HRLM	UCHN,JBTQ(DSER)	;BLINK[DSER]←UCHN
	HRLM	DSER,JBTQ(DDB)	;BLINK[FLINK[DSER]]←DSER
	JRST	ORD2		;HE IS IN PLACE, SCAN SOME MORE (DON'T ADVANCE Q)

ORDX:
	SETZM	ORDYET			;TELL PDP-6 THAT WE'VE FINISHED OUR SORT
	POPJ	P,

; THIS ROUTINE CALCULATES THE VARIOUS JOB PRIORITIES
; IT DOES SO BY TAKING THE CURRENT JOB LOADING FACTOR,
; DEFINED TO BE TIME WAITING FOR COMPUTE TIME OVER REAL TIME,
; AND PUTS IT IN A TABLE WITH THE PREVIOUS JLLENGTH
; FACTORS. THEN IT MAKES A WEIGHTED AVERAGE OF THESE AND
; ADDS IT INTO THE JOBS TOTAL JOB LOADING HISTORY, WHICH IS
; DECAYED EXPONENTIALLY BY SUBTRACTING A FRACTION EVERY SO OFTEN

GRSPRI←←360000

IFE FTSWAP,<
↑JLCAL:	POPJ	P,
>

IFN FTSWAP,<
↑JLCAL:	MOVE	J,ORDYET		;HAS THE PDP-10 DONE IT'S THING YET?
	JUMPN	J,CPOPJ			;IF NOT, WAIT FOR IT
	SOSLE	J,JLCYET
	JRST	JLCA1
	SETZM	SWPCNT
	MOVEI	DDB,JLTIME
	MOVEM	DDB,JLCYET

	SETOM	ORDYET
	JUMPE	PID,ORDER		;IF WE'RE THE PDP-10, NO NEED TO INTERLOCK
	POPJ	P,

JLCA1:
	ROT	J,-1		;DIVIDE BY 2
	JUMPL	J,CPOPJ		;SKIP ODD TICKS.
	CAIL	J,JOBN		;LEGAL JOB NUMBERS ONLY
	POPJ	P,
	SKIPE	DDB,JBTJL(J)	;IS THERE A HISTORY TABLE?
	JRST	JLCA3		;YES, GO RECOMPUTE PRIORITY
	MOVSI	DDB,(3B2)	;NO. MAKE A SILLY ASSUMPTION
	MOVEM	DDB,JBTNPR(J)
	POPJ	P,

; CALCULATE ONE JOB'S NEW PRIORITY
; DECAY PAST, WEIGHT NEAR PAST, THEN COMPUTE PRIORITY
; JBTJLH = DISTANT PAST CELL.
; JBTJL  = TABLE OF FS BLOCKS, ONE-PER-JOB. KEEPS RECENT HISTORY.
; JBTNPR = JOB'S NEW PRIORITY.
; JBTRNB = AMOUNT OF CPU TIME THAT JOB HAS ACCUMULATED SINCE LAST CALL HERE.

JLCA3:
	MOVN	DSER,JBTJLH(J)		;FIRST, DECAY DISTANT PAST
	ASH	DSER,-5
	ADDM	DSER,JBTJLH(J)		;PAST ← (31/32)*PAST

	MOVE	UCHN,(DDB)		;ADD OLDEST TO DISTANT HISTORY
	ADDM	UCHN,JBTJLH(J)		;PAST ← PAST+OLDEST "RECENT" HISTORY

	MOVSI	DSER,1(DDB)		;BLT DOWN RECENT HISTORY
	HRRI	DSER,(DDB)
	BLT	DSER,JLLENGTH-2(DDB)	;MAKE ROOM FOR NEW FACTOR

	HRRZ	DSER,JBTRNB(J)		;PICK UP RUN TIME USED
	IMUL	DSER,RJLFACTOR		;DIVIDE BY USEABLE TIME. = PROCESSOR LEVEL
	MOVEM	DSER,JLLENGTH-1(DDB)	;SET IN LAST POSITION IN TABLE (MOST RECENT)
					;1,,0 = 100% PL

	MOVE	DSER,JBTSTS(J)		;GIVE LOGIN AND LOGOUT GOOD SERVICE
	TLNN	DSER,JACCT		;ACCOUNTING?
	JRST	JLCA15			;NO.
	HRLZI	DDB,377777		;GIVE THEM THE HIGHEST POSSIBLE PRIORITY
	HLR	DDB,JBTPRI(J)	;RANDOM	;PUT IN SOME NUMBERS FOR GOOD MEASURE
JLCA9:
	MOVEM	DDB,JBTNPR(J)		;SAVE USER'S PRIORITY
	POPJ	P,

JLCA15:
	SETZB	AC3,JBTRNB(J)		;
	MOVEI	TEM,=100		;WEIGHT.
	MOVEI	AC1,0			;COUNT WEIGHTS USED
	MOVSI	DSER,JLLENGTH-1
	HRRI	DSER,JLLENGTH-1(DDB)	;DSER ← <JLLENGTH-1,,ADDRESS OF DATA>
JLCA4:
	MOVE	AC2,(DSER)		;PICK UP HISTORICAL JOB LOAD
	IMULI	AC2,(TEM)		; %PL * WEIGHT
	ADDI	AC1,(TEM)		;SUM OF ALL WEIGHTS.
	ADD	AC3,AC2
	MOVEI	AC2,(TEM)
	LSH	AC2,-3
	SUBI	TEM,(AC2)		;WEIGHT ← (7/8)*WEIGHT.
	SUB	DSER,[1,,1]
	JUMPG	DSER,JLCA4		;LOOP THROUGH JOB HISTORY

	MOVE	AC2,JBTJLH(J)		;PICK UP DISTANT PAST
	IMULI	AC2,(TEM)		;JUST TO MAKE CURVES JOIN
	ADDI	AC1,(TEM)		;ADD UP WEIGHTS.
	ADD	AC3,AC2
	SUB	AC3,[3B2]		;USAGE - DEFAULT PRIORITY = -(PRIORITY)
	MOVNM	AC3,JBTNPR(J)		;THIS IS THEN HIS PRIORITY

; CHECK THIS JOB'S SERVICE LEVEL TO SEE IF HE DESERVES HIGHER PRIORITY.
;AC2 = SERVICE GUARANTEE LEVEL, TEM = SUM OF ALL THE SERVICE LEVELS

	SKIPE	JBTGSL
	POPJ	P,
	HRRZ	AC2,JBTGSL(J)		;PICK UP THE SERVICE LEVEL GUARANTEE
	CAILE	AC2,320000		;MORE THAN 40.625% SERVICE LEVEL?
	MOVEI	AC2,320000		;REDUCE TO 40% - REG'S UNFAIRNESS.
	HRRZ	DDB,PRJPRG(J)
	MOVEI	TEM,0			;ADD UP SERVICES TO RELATIVES.
	MOVEI	DSER,JOBN-1		;INDEX FOR LOOP THRU JOBS
JLCA5:
	HRRZ	UCHN,PRJPRG(DSER)
	CAIN	DDB,(UCHN)		;DOES THIS GUY HAVE THE SAME PPN
	SKIPN	UCHN,JBTJL(DSER)	;YES, DOES HE HAVE ANY PAST
	JRST	JLCA6			;NO. LOOP FOR NEXT GUY

	HRLI	UCHN,-JLLENGTH		;AOBJN POINTER TO PL HISTORY
	ADD	TEM,(UCHN)		;ADD IN THE SERVICE LEVEL
	AOBJN	UCHN,.-1

JLCA6:
	SOJG	DSER,JLCA5		;NOW LOOP AROUND TO LOOK FOR ANOTHER GUY WITH SAME PPN
	IDIVI	TEM,JLLENGTH		;NORMALIZE PL.  SUM OF PL OF ALL RELATIVES.

; ADD UP THE SERVICES TO HIS VARIOUS RELATIVES
	CAMG	AC2,TEM		; SEE IF HE GOT MORE THAN HE BARGAINED FOR
	POPJ	P,		; YES, HE NOW JUST FOLLOWS HIS PRIORITY
	SKIPN	SLCOST		; ARE WE CHARGING FOR CORE?
	JRST	JLCA20		;NO SKIP THIS STUFF.
	PUSH	P,AC2		;SAVE HIS GSL 
	PUSH	P,TEM		;SAVE ACTUAL PL
	MOVEI	TAC1,JOBN-1	; OK. NOW SEE IF HE IS A CORE LEVEL VIOLATOR
	HRRZ	AC1,PRJPRG(J)
	MOVEI	AC2,0		;COUNT SUM OF CORE SIZES.
JLCA10:
	HRRZ	AC3,PRJPRG(TAC1)
	MOVM	DAT,JOBQUE(TAC1)	; PICK UP HIS QUEUE CODE
	CAME	AC1,AC3
	JRST	JLCA11
	CAIE	DAT,TQ		;ADD HIS CORE SIZE IF RUNNING OR LOCKED IN
	CAIN	DAT,RUNQ
	JRST	JLCA14
	CAIE	DAT,DIOWQ
	SKIPE	JBTST2(TAC1)	;SPACEWAR DOES THIS TOO
	JRST	JLCA14
	MOVEI	DAT,JLOCK
	TDNN	DAT,JBTSTS(TAC1)
	JRST	JLCA11

JLCA14:
	PUSH	P,TAC1		;SAVE JOB NUMBER WE'RE THINKING ABOUT.
	PUSHJ	P,CORSGT	;GET HIS CORE SIZE IN TAC1
	ADDI	AC2,(TAC1)	;ADD IN TO CORE TOTAL
	MOVE	TAC1,(P)	;GET JOB NUMBER BACK
	LDB	TAC1,[POINT 6,JBTSTS(TAC1),35]
	JUMPE	TAC1,JLCA13
	MOVEI	DDB,JOBN-1	;HE GETS CHARGED FOR (1/N) OF HIS HIGH SEGMENT CORE
	MOVEI	UCHN,0		;WHERE N WILL BE THE NUMBER OF PEOPLE POINTING AT THIS SEGMENT
JLCA12:
	LDB	DSER,[POINT 6,JBTSTS(DDB),35]
	CAMN	DSER,TAC1
	SKIPL	JBTSTS(DDB)	; ONLY IF HE IS ACTIVE
	CAIA
	ADDI	UCHN,1		; BUMP NUMBER OF JOBS POINTING TO THIS SEGMENT BY ONE
	SOJG	DDB,JLCA12
	PUSHJ	P,CORSGT	;GET THE SIZE OF THIS UPPER
	MOVE	TAC,TAC1
	IDIVI	TAC,(UCHN)	; GET HIS SHARE OF THE UPPER SEGMENT CORE
	ADD	AC2,TAC		; AND ADD IT IN TO THE TOTAL
JLCA13:
	POP	P,TAC1
JLCA11:
	SOJG	TAC1,JLCA10	; LOOP AROUND FOR NEXT JOB

	LSH	AC2,-=10	; CONVERT TO NUMBER OF 1K BLOCKS
	MOVSI	AC2,(AC2)	; PUT CORE IN K IN LEFT HALF
	MOVE	AC3,SLCOST	;AC3←1 OR 2 (LOW OR HIGH COST, RESPCTIVELY)
;;	IDIV	AC2,[=1000		;CONVERT TO ONE PERCENT FOR EACH
;;		  =500]-1(AC3)	;	10K (LO) OR 5K(HI) OF CORE
	IDIV	AC2,153251(AC3) ;;DMP;;
	POP	P,TEM		; GET PROCESSOR LEVEL
	ADD	TEM,AC2		; CALL THIS PROCESSOR LEVEL TOO.
	POP	P,AC2		; GET BACK HIS GSL
JLCA20:
	CAMLE	TEM,AC2		; IS HE OVER HIS GUARANTEE?
	POPJ	P,		; YES, HE IS OFFICIALLY A SCROUNGER
	MOVSI	DDB,GRSPRI	; NO, GIVE HIM HIGH PRIORITY
	HLR	DDB,JBTNPR(J)	; WITH HIS REAL PRIORITY AS HIS LOW-ORDER BITS
	MOVEM	DDB,JBTNPR(J)
	POPJ	P,
>

SUBTTL	QCSS	24 JULY 67
;THIS ROUTINE MUST BE ASSEMBLED WITH THE CONFIGURATION
;TAPE TO DEFINE NUMBER OF JOBS
;THIS SECTION CONTAINS 2 ROUTINES FOR Q MANIPULATION
;AND NECESSARY TABLES FOR SPECIFING OPERATIONS PERFORMED
;BY THEM.



;STORAGE:
;EACH Q IS A RING STRUCTURED, FOWARD AND BACKWARD
;LINKED SRING LIST. THE "FIRST" LINK IN A Q IS
;A Q-HEADER POINTING TO THE FIRST AND LAST MEMBERS OF THE Q.
;A NULL Q HAS ONE LINK--THE Q-HEADER ITSELF.  THE LINKS MAKING
;UP THE QS ARE CONTAINED IN A TABLE (JBTQ) WITH NEGATIVE
;INDICIES (ADDRESSES LESS THAN JBTQ) USED FOR Q-HEADERS AND
;POSITIVE INDICIES USED FOR MEMBERS (JOBS). THUS ONLY ONE WORD
;PER LINK IS NECESSARY--ITS ADDRESS RELATIVE TO JBTQ GIVES THE
;JOB NO. (OR Q NO. IF NEGATIVE) WHICH IT REPRESENTS WHILE
;ITS CONTENTS CONTAINS THE LINKING POINTERS. THESE
;POINTERS ARE ALSO INDICIES RELATIVE TO JBTQ RATHER THAN
;ABSOLUTE ADDRESSES--RH(LINK)=FOWARD POINTER;
;LH(LINK)=BACKWARD POINTER.
;A JOB IS ASSUMED TO BE IN NO MORE THAN ONE Q AT A TIME, AND
;THE NULL JOB (JOB 0) DOES NOT APPEAR IN THE QS  (I.E. JBTQ
;ITSELF IS THE Q-HEADER FOR Q 0).

;ROUTINES:
;BOTH ROUTINES ARE "TABLE DRIVEN" IN THE SENSE THAT THE
;CALLING ROUTINE PROVIDES THE ADDRESS OF A TABLE WHICH
;DEFINES THE SPECIFIC OPERATIONS TO BE PERFORMED.

;QUEUE INITIALIZATION
;PUT ALL JOBS IN NULL QUEUE(JOB NO. NOT ASSIGNED)
;CALLED ON RESTART AT LOC. 143


↑QINI:
	MOVNI DDB,MXQUE		;MAKE ALL QUEUE HEADERS POINT TO THEMSELVES
	HRL DDB,DDB		;BACKWARD POINTERS TOO
	MOVEM DDB,JBTQ(DDB)
	AOBJN DDB,.-1
	MOVEI DDB,-NULQ		;PUT JOBS ALL IN NULQ QUEUE
	MOVSM DDB,JBTQ+1	;BACK POINTER FOR JOB 1
	MOVEI J,JOBN-1		;MAX. JOB NO.
	MOVEM DDB,JBTQ(J)	;FOR. POINTER OF JOBMAX JOB NO.
	HRLM J,JBTQ-NULQ	;SET NULQ HEADER TO POINT TO JOB1
	MOVEI DDB,1		;AND JOBMAX
	HRRM DDB,JBTQ-NULQ	;FORWARD POINTER
	MOVNI DSER,NULQ
QINI1:
	HRRM J,JBTQ-1(J)	;JOB I-1 POINT TO JOB I
	MOVEM DSER,JOBQUE(J)
	SOJLE J,CPOPJ		;FINISHED?
	SETZM JBTQ
	HRLM J,JBTQ+1(J)	;BACK POINTER JOB I+1 POINTS TO JOB I
	JRST QINI1

;DELETES A JOB FROM ITS "SOURCE-Q", DETERMINES A "DEST-Q"
;ACCORDING TO ONE OF 3 FUNCTIONS, AND INSERTS THE JOB AT
;THE BEGINNING OR END OF THIS DEST-Q.
;THE DRIVING TABLES ARE "TRANSFER TABLES":
;
;
;T. TABLE:	XWD <0 OR -1>, -<QUEUE NUMBER>


;CALLING SEQUENCE:
;	MOVE  J,[JOB NUMBER]
;	MOVEI/HRROI DAT,TRANS TABLE ADDRESS	;DAT NEG MEANS GEN QXFER INT IF NECC
;	PUSHJ PDP,QXFER
;  ON RETURN J IS UNALTERED; LH(Q)=-1  IF QUANT. TIME NOT
;  RESET; =QUANT. TIME IF RESET;RH(Q)=DEST.Q

↑QXFER:	CAIGE	J,JOBN		;JOB NUMBER TOO HIGH?
	JRST	QXFER1		;J OK
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISERR
	[ASCIZ/ILLEGAL JOB NUMBER AT QXFER.
J=/]
	DISARG(DCP,<-20+J(P)>)
	[ASCIZ/
/]
	-1
	POPACS
	POPJ	P,
QXFER1:
	JUMPGE DAT,QXFER2	;NO INT NEEDED IF POS
	MOVSI DSER,INTQXF	;DOES HE WANT INT ON Q XFER?
	TDNN DSER,JBTIEN(J)
	JRST QXFER2
	IORM DSER,JBTIRQ(J)
	SETOM INTREQ
QXFER2:
	SETZM	SWPCNT		; FIRE UP SWAPPER WHEN THE SITUATION CHANGES
	AOS	NQXFERS		;COUNT A QUEUE TRANSFER
	MOVE	Q,(DAT)		;GET TRANSFER TABLE ADDRESS

	TLNE	Q,200000	;ARE WE NOW WAITING FOR THE SYSTEM?
	JRST	QXFER3		;YES
	MOVE	DSER,UPTIME	;NO, WE ARE WAITING FOR THE USER.
	SKIPGE	JBTWAT(J)	;WERE WE ALREADY WAITING FOR THE USER?
	ADDM	DSER,JBTWAT(J)	;NO.  NOTE THAT WE ARE NOW
	JRST	QXFER4

QXFER3:
	MOVN	DSER,UPTIME	;WE ARE WAITING FOR THE SYSTEM
	SKIPL	JBTWAT(J)	;WERE WE ALREADY WAITING FOR THE SYSTEM?
	ADDM	DSER,JBTWAT(J)	;NO.  NOTE THAT WE ARE NOW
QXFER4:
	HRRE DSER,Q		; SAVE QUEUE CODE IN DSER
	MOVM DSER,DSER		;GET THE Q CODE. PUT IT IN JBTSTS FOR THIS JOB
	CAIG DSER,MAXQ		;IF RELEVANT TYPE
	DPB DSER,[POINT JWSIZ,JBTSTS(J),JWPOS]

IFN FTSTAT, <			;GATHER STATISTICS.
	PUSH P,TAC
	LSH DSER,6
	MOVEI TAC,QUESTA(DSER)
	PUSHJ P,STAPUT
	POP P,TAC
>;FTSTAT

	MOVE	DSER,JBTQ(J)	;DELETE JOB FROM SOURCE-Q
	MOVS	UCHN,DSER	;DSER=FORW. LINK, UCHN=BACK LINK
	HRRM	DSER,JBTQ(UCHN)	;GO BACK AND LINK FORWARD PAST THIS JOB
	HRLM	UCHN,JBTQ(DSER)	;GO FORWARD AND LINK BACKWARD PAST THIS JOB
	CAME	Q,QRUNW		;ARE WE ENTERING THE RUN QUEUE?
	JRST	QXF3		;NO
	MOVE	AC2,JBTPRI(J)	;GET THIS GUY'S PRIORITY
	CAMGE	AC2,[3B2]	;SKIP IF BIG: WE WILL SCAN FORWARD
	JRST	QXSB		;SMALL PRIORITY: SCAN BACKWARDS.
	HRRE	DSER,JBTQ(Q)	;SEARCH AHEAD. PICK UP FORWARD LINK
	JUMPL	DSER,QXF3	;NO ONE HERE. THERE'S NO ORDERING NEEDED
QXF6:
	CAML	AC2,JBTPRI(DSER)	;IS THIS THE RIGHT PLACE FOR HIM?
	JRST	QXF8		;YES. OUR (J) PRIORITY > HIS (DSER)
	HRRE	DSER,JBTQ(DSER)	;OUR PRIORITY IS SMALL, KEEP LOOKING
	JUMPGE	DSER,QXF6	;LOOP UNLESS END OF LIST, STICK HIM AT BOTTOM.
	JRST	QXF3		;GO STICK HIM IN AT THE BOTTOM.
QXF8:
	HLRZ	UCHN,JBTQ(DSER)	;PUT US BEFORE DSER, AND AFTER DSER'S BACK LINK.
	HRLZM	UCHN,JBTQ(J)	;STICK HIS BACK LINK IN AS OUR BACK LINK.
	HRLM	J,JBTQ(DSER)	;STICK US IN AS DSER'S BACK LINK.
	HRRM	DSER,JBTQ(J)	;STICK DSER IN AS OUR FORWARD LINK.
	HRRM	J,JBTQ(UCHN)	;STUFF US IN AS UCHN'S FORWARD LINK.
	JRST	QXF4		;ALL DONE WITH TRANSFER.

QXSB:
	HLRE	DSER,JBTQ(Q)	;SORTING IN FROM THE BOTTOM. FOLLOW BACK.
	JUMPL	DSER,QXF3	;JUMP IF Q IS EMPTY. PUT US IN THE END.
QXF5:
	CAMG	AC2,JBTPRI(DSER)	;SKIP IF OUR PRIORITY ≥ HIS PRIORITY
	JRST	QXF9		;OUR PRIORITY IS SMALL. WE HAVE A HOME.
	HLRE	DSER,JBTQ(DSER)	;LINK BACKWARDS.
	JUMPGE	DSER,QXF5	;CONTINUE SCAN FOR A PLACE TO PUT US.
	JRST	QXF7		;WE BELONG AT TOP OF Q.

QXF9:
	HRRZ	UCHN,JBTQ(DSER)	;WE BELONG BELOW DSER. GET DSER'S FORWARD LINK
	MOVEM	UCHN,JBTQ(J)	;SET OUR FORWARD LINK FROM DSER'S LINK.
	HRRM	J,JBTQ(DSER)	;SET US AS DSER'S FORWARD LINK.
	HRLM	DSER,JBTQ(J)	;SET DSER AS OUR BACKWARDS LINK
	HRLM	J,JBTQ(UCHN)	;SET US AS UCHN'S BACKWARDS LINK.
	JRST	QXF4		;ALL DONE.

;QXF3 IS TO ADD GUY AT THE END OF THE QUEUE
;QXF7 IS TO ADD GUY AT THE BEGINNING OF THE QUEUE

QXF3:
	HLR	Q,JBTQ(Q)	;GET THE LAST LINK IN Q.
				;UCHN WILL BE SET TO THE Q-HEADER.
QXF7:
	MOVE	UCHN,JBTQ(Q)	;UCHN IS FORWARD LINK AND Q IS Q-HEADER.
	HRRM	J,JBTQ(Q)	;SET FORWARD LINK:
				;F/ INSERT IN Q HEAD. B/ INSERT AT END.
	HRLM	J,JBTQ(UCHN)	;SET BACK LINK:
				;F/ INSERT IN FIRST.  B/ INSERT AT Q-HEAD.
	HRRZM	UCHN,JBTQ(J)	;SET OUR FORWARD LINK
	HRLM	Q,JBTQ(J)	;SET OUR BACK LINK.

QXF4:
	JUMPL	Q,QNORUN	; RETURN IF QUANTUM TIME NOT REQUESTED

;HERE WE ARE IS JOB IS COMING INTO A RUN QUEUE

QFIX1:
	SETZ	DSER,		;CLEAR WAIT STATE CODE IN JBTSTS:
	DPB	DSER,[POINT JWSIZ,JBTSTS(J),JWPOS]
	POPJ	P,		;RETURN

; JOB IS NOT RUNNING.  REQUEUE HIS SEGMENT IF NEEDED.

QNORUN:
	CAMN	J,SEGWAIT	; WAS THIS GUY WAITING FOR HIGH SEGMENT?
	SETZM	SEGWAIT		; YES, NOT ANY MORE
	LDB	DSER,PSEGN	; DOES THIS JOB HAVE A HIGH SEGMENT?
	JUMPE	DSER,CPOPJ	; NO, FORGET IT
	MOVM	UCHN,JOBQUE(DSER)	; YES, IS IT IN SEGMENT WAIT QUEUE?
	CAIE	UCHN,SEGQ
	POPJ	P,		;NO, RETURN
	PUSH	P,J		;YES, IF NO ONE ELSE WANTS SEGMENT, REQUE IT
	MOVEI	J,JOBN-1	;LOOK THRU ALL THE WORLD.
QNORU1:
	LDB	UCHN,PSEGN
	CAIE	UCHN,(DSER)	;SAME SEGMENT?
	JRST	QNORU3		;NOPE.
	MOVE	AC2,JBTSTS(J)	;GET JOB STATUS OF THIS GUY
	TLNE	AC2,SWP		; DOESN'T COUNT IF HE'S SWAPPED OUT
	JRST	QNORU3		;SO LOOK FOR SOMEONE ELSE.
	MOVM	UCHN,JOBQUE(J)	;AND HIS QUEUE
	CAIE	UCHN,RUNQ	;IS THIS GUY RUNNABLE?
	CAIN	UCHN,TQ
	JRST	QNORU4		;THIS GUY WANTS THIS SEGMENT!
QNORU3:
	SOJG	J,QNORU1	;LOOP.
	MOVNI	DAT,STOPQ	;NO ONE CARES FOR THIS.
	MOVEM	DAT,JOBQUE(DSER)	
	MOVEI	DAT,QSTOPW	;NO RUNNABLE JOB USING THIS SEGMENT, REQUEUE IT
	MOVE	J,DSER
	PUSHJ	P,QXFER
QNORU4:
	POP	P,J		;RETURN BY POPPING J.
	POPJ	P,		;AND POPJ.

;SCANS THE QS RETURNING THE NUMBERS OF THE JOBS IN THE QS.
;THE ORDER AND MANNER IN WHICH THE QS ARE SEARCHED IS
;DETERMINED BY A "SCAN TABLE" ADDRESSED IN THE CALLING SEQ.
;THE SCAN TABLE HAS THE FORM:
;
;SCANTAB:	XWD <Q1>,<CODE1>	;SCN Q1 ACCRDING TO CODE1
;		...
;		XWD <QN>,<CODEN>	;QN ACCORDING TO CODEN
;		Z		;ZERO TERMINATES TABLE
;
;EACH Q MAY BE SCANNED IN ONE OF FOUR WAYS SPECIFIED BY <CODE>
;THE CODES ARE:
;
;QFOR	SCAN WHOLE Q FOWARD
;QFOR1	SCAN FOR ONLY THE 1ST MEMBER (IF ANY)
;QBAK	SCAN WHOLE Q BACKWARD
;QBAK1	SCAN BACKWARD FOR ALL MEMBERS EXCEPT THE 1ST
;
;CALLING SEQ.
;
;	MOVEI DAT,SCAN TABLE ADDRESS
;	JSP PC,QSCAN	;SET UP PC FOR REPEATED RETURNS
;	...		;RETURN HERE WHEN NO MORE JOBS
;	...		;RETURN HERE WITH NEXT JOB IN AC J
;			;   AND ITS Q IN LH(QR)
;
;	PERFORM ANY NECESSARY TESTING OF THIS JOB
;	J,DAT,PC,QR MUST BE PRESERVED
;
;	JRST (QR)	;RETURN TO QSCAN TO GET NEXT JOB
;			;   IF THIS ONE NOT ACCEPTABLE
;

↑QSCAN:	SKIPN QR,(DAT)	;END OF SCAN TABLE?
	JRST (PC)	;YES--RETURN TO CALL+1
	HLRE J,QR	;NO--GET NO. OF Q
	JRST (QR)	;DISPATCH

QFOR1:
	MOVEI QR,QFORB	;ONLY THE FIRST JOB

QFOR:
	HRRE J,JBTQ(J)	;SCAN FOWARD ALL JOBS
	JUMPGE J,1(PC)	;RETURN THIS JOB NO. CALL+2 UNLESS--
QFORB:
	AOJA DAT,QSCAN	;END OF THIS Q--GET NEXT Q

QBAK1:
	HLRE J,JBTQ(J)	;SCAN BACKWARD ALL JOBS EXCEPT 1TT
	SKIPLE JBTQ(J)	;IS THIS THE FIRST MEMBER?
	JRST 1(PC)	;NO--RETURN CALL+2
	AOJA DAT,QSCAN	;YES--GET NEXT Q

QBAK:
	HLRE J,JBTQ(J)	;SCAN BACKWARD ALL JOBS
	JUMPG J,1(PC)	;RETURN CALL+2 WITH JOB NO. UNLESS
	AOJA DAT,QSCAN	;BEG OF THIS Q--GET NEXT Q

QFOR2:
	HRRE J,JBTQ(J)	; ALL BUT FIRST JOB
	HRRI QR,QFOR	; PUT UP NEW RESCAN ADDRESS
	JUMPGE J,QFOR	; IF NOT END OF QUEUE, GET SECOND JOB
	AOJA DAT,QSCAN	; END OF QUEUE, TRY NEXT ONE

DEFINE X'(A),<

↑A'Q←←ZZ
ZZ←←ZZ+1
>
	ZZ←←0
	QUEUES
	LOC←←ZZ
NQUEUE←←LOC		;NO. OF QUEUES COUNTING RUN QUEUE
XP MAXQ,NQUEUE-1	;MAX. STATE CODE WHICH HAS AN AVAL FLAG
XP MINQ,STQ		;MINIMUM SHARABLE DEVICE QUEUE
XP AVLNUM,MAXQ		;MAX. STATE CODE WHICH HAS AN AVAL FLAG

;DEFINE STATE CODES WHICH DO NOT HAVE AVAL AND REQ FLAGS


DEFINE X!(A)
<
↑A!Q←←LOC
LOC←←LOC+1
>
	CODES
	PQUEUES		; PROCESSOR QUEUES TOO!!

;CORRESPONDENCE TABLE BETWEEN JOB STATUS CODES AND QUEUE TRANSFER TABLES
;USED BY SCHEDULER
;RUNCSS SETS JOB STATUS WORD TO NEW STATE CODE.
;SCHEDULER SETS UP QUEUE TRANSFER TABLE ADDRESS FROM
;FOLLOWING TABLE USING NEW STATE CODE AS INDEX

DEFINE X!(A)
<	Q!A!W
>


↑QBITS:	QUEUES
	CODES
	PQUEUES


;400000,,0 BIT MEANS IS NOT RUNNABLE QUEUE
;200000,,0 BIT MEANS QUEUE REQUIRES WAITING FOR THE SYSTEM RATHER THAN THE USER

QFUCKW:

QTW:
	XWD 200000,-TQ
QRUNW:
	XWD 200000,-RUNQ
QSTW:
	XWD 600000,-STQ		; SYST TAPE
QDTW:
	XWD 600000,-DTQ		; DEC TAPE
QDCW:
	XWD 600000,-DCQ		; DATA CONTROL WAIT
QMTW:
	XWD 600000,-MTQ		; MAG TAPE
QIOWW:
	XWD 400000,-IOWQ	; IOW(EXDEPT TTY) HELD IN IOWQ
QINTWW:
	XWD 400000,-INTWQ	; INTERRUPT WAIT QUEUE
QDIOWW:
	XWD 600000,-DIOWQ
QNULW:
	XWD 400000,-NULQ	; NULL QUEUE JOB NO. NOT ASSIGNED
↑QSTOP:
QSTOPW:
	XWD 400000,-STOPQ	; UNRUNABLE JOBS TO END OF STOPQ
↑QSEGW:	XWD 600000,-SEGQ	; SEGMENT WAIT QUEUE
QDWW:
	XWD 400000,-DWQ		; DEVICE WAIT GOES BACK TO DEVICE WAIT

IFN FTSWAP,<
ISCAN:
	;SCAN FOR INPUT
	XWD -SEGQ,QFOR	; SEGMENT WAIT QUEUE
	XWD -TQ,QFOR	; TELETYPE IO WAIT QUEUE
	XWD -RUNQ,QFOR
	XWD -DCQ,QFOR1
	XWD -STQ,QFOR1
	XWD -DTQ,QFOR1
	XWD -MTQ,QFOR1
	XWD -DCQ,QFOR2
	XWD -STQ,QFOR2
	XWD -DTQ,QFOR2
	XWD -MTQ,QFOR2
	0

; TABLE TO DECIDE ON WHICH JOB TO SWAP OUT
OSCAN:
	XWD -STOPQ,QBAK	;UNRUNABLE JOBS FIRST
	XWD -MTQ,QBAK1
	XWD -DTQ,QBAK1
	XWD -STQ,QBAK1
	XWD -DCQ,QBAK1
	XWD -MTQ,QFOR1
	XWD -DTQ,QFOR1
	XWD -STQ,QFOR1
	XWD -DCQ,QFOR1
	XWD -DWQ,QBAK
	XWD -INTWQ,QBAK
	XWD -IOWQ,QBAK
	XWD -RUNQ,QBAK
	XWD -TQ,QBAK
	0

ALLRUNSCAN:

	XWD -TQ,QFOR
RUNSCAN:

	XWD -RUNQ,QFOR
	0

↑DVWSCAN:
	XWD -DWQ,QFOR
	0

TQSCAN:
	XWD -TQ,QFOR
	0

;HERE RESIDES ALL THE SWAP IN LIST CODE -- RPH 1/15/74

;CALL WITH C(J)=JOB, C(TAC)=BIT TO SET
↑SETSIN:CONO PI,PIOFF
	SETZM SWPCNT			;RUN SWAPPER
	TDNE TAC,JBTSIN(J)		;BIT ON ALREADY?
	JRST PIONJ			;YES, LEAVE
IFN FTSTAT,<PUSH P,TAC
	PUSH P,TAC1
	JFFO TAC,.+1
	LSH TAC1,6
	MOVEI TAC,SINSTA+4000(TAC1)	;SETTING BIT
	PUSHJ P,STAPUT
	POP P,TAC1
	POP P,TAC
>;FTSTAT
	IORM TAC,JBTSIN(J)		;TURN IT ON
	ANDCA TAC,JBTSIN(J)		;PICK UP ALL OTHER BITS
	JUMPN TAC,PIONJ			;LEAVE IF ALREADY LINKED IN
	LDB TAC,PSINB0			;PUT AT END OF LIST
	DPB J,PSINB0			;NOW WE ARE END
	DPB TAC,PSINBJ			;AND WE POINT TO OLD LAST
	DPB J,PSINFT			;AND HE POINTS TO US
	SETZ TAC,
	DPB TAC,PSINFJ			;AND WE ARE END
	JRST PIONJ			;ALL DONE

;ENTER HERE WITH C(J)=JOB, C(TAC)=BIT(S) TO CLEAR
↑CLRSIN:CONO PI,PIOFF
	TDNN TAC,JBTSIN(J)		;IN CASE SOMEONE SNUCK IN
	JRST PIONJ
IFN FTSTAT,<PUSH P,TAC
	PUSH P,TAC1
	JFFO TAC,.+1
	LSH TAC1,6
	MOVEI TAC,SINSTA(TAC1)		;CLEARING BIT
	PUSHJ P,STAPUT
	POP P,TAC1
	POP P,TAC
>;FTSTAT
	ANDCAB TAC,JBTSIN(J)		;TURN OF REQUESTED BIT
	TLNE TAC,-1			;ANY BITS LEFT ON?
	JRST PIONJ			;YES, DON'T HAVE TO DE-LINK
	LDB TAC,PSINFJ			;GET OUR FORWARD LINK
	PUSH P,J			;USE J HERE
	LDB J,PSINBJ			;AND OUR BACKWARD LINK
	DPB J,PSINBT			;STORE OUR BACK IN OUR FORWARD
	DPB TAC,PSINFJ			;AND OUR FORWARD IN OUR BACK
	POP P,J
	SETZM JBTSIN(J)			;ZERO FOR TESTS
	JRST PIONJ			;ALL DONE

;ENTER HERE WITH J SETUP TO FLUSH ALL SWAPIN BITS (DOESN'T CLOBBER ACS)
↑FLUSIN:PUSH P,TAC			;KEEP THIS ROUTINE AUTONOMOUS
	MOVE TAC,JBTSIN(J)
	TLNN TAC,HLDSNB			;BITS WHICH MAY SET JHLDIN
	PUSHJ P,FLUHLD			;FLUSH
	TLNN TAC,JRDSNB
	JRST FLUSN1
	PUSHJ P,JRSRCH			;IF JOB READ BIT ON
	  JRDLOS			;SEND EVERYONE TO LOSE ROUTINE
FLUSN1:
	MOVSI TAC,-1
	PUSHJ P,CLRSIN			;CLEAR ALL BITS
	POP P,TAC
	POPJ P,

;SEARCH FOR ALL OTHER JOBS TRYING TO READ THIS ONE (J)
;AND CALL SUBROUTINE FOLLOWING CALL ON JRSRCH
↑JRSRCH:PUSH P,J
	MOVEI J,JOBN-1			;SCAN ALL JOBS
JRSRC1:
	HLRZ TAC,JBTFS(J)
	CAME TAC,(P)
	JRST JRSRC2
	MOVE TAC1,@-1(P)		;GET ROUTINE TO CALL
	PUSHJ P,(TAC1)			;CALL IT
JRSRC2:
	SOJG J,JRSRC1
	POP P,J
	JRST CPOPJ1			;SKIP ROUTINE NAME

;FLUSH JHLDIN FROM UPPER OR LOWERS OF THIS JOB
↑FLUHLD:PUSH P,TAC
	PUSH P,J
	MOVE TAC,JBTSTS(J)
	TLNN TAC,JSEG			;SEGMENT?
	JRST FLUHL1			;NO, EASY
	MOVEI J,JOBN-1
FLUHL2:
	LDB TAC,PSEGN			;GET HIS SEGMENT
	CAME TAC,(P)			;DOES THIS JOB POINT TO US?
	JRST FLUHL3			;NO
	MOVSI TAC,JHLDIN
	ANDCAM TAC,JBTSTS(J)
FLUHL3:
	SOJG J,FLUHL2
FLUHL4:
	POP P,J
	POP P,TAC
	POPJ P,

FLUHL1:
	LDB J,PSEGN
	JUMPE J,FLUHL4			;ANY SEGMENT?
	MOVSI TAC,JHLDIN
	ANDCAM TAC,JBTSTS(J)		;CLEAR BIT IN UPPER
	JRST FLUHL4

;CALLED FROM SCNIN TO SWAP GUYS IN JBTSIN IN FIRST
GETSIN:
	SETZ J,
	MOVEI QR,GETSN1
GETSN1:
	LDB J,PSINFJ			;FOLLOW FORWARD LINK
	JUMPN J,(PC)			;GOT ANOTHER JOB
	JRST 1(PC)			;NO MORE

SUBTTL	SWAP	4 AUG 67

;SWAPPER CALLED EVERY CLOCK TIC.
;SINCE MOST OPERATIONS STARTED BY THE SWAPPER REQUIRE SEVERAL
;TICS TO RUN TO COMPLETION, SEVERAL FLAGS(FINISH,FIT,FORCE,
;XPANDF) ARE USED TO "REMEMBER" PREVIOUS STATES.
;THE BASIC ALGORITHM:
;IS CORE SHUFFLER WAITING FOR IO TO FINISH FOR SOME JOB?
;  YES--TRY AGAIN TO SHUFFLE(WHEN IO STOPS)
;IS CORE SHUFFLER STILL WAITING FOR IO TO FINISH?
;  YES--RETURN AND DO NOTHING
;IS SWAPPER STILL BUSY?
;  YES--RETURN AND DO NOTHING
;SCAN QS FOR 1ST JOB OUT OF CORE.
; IF NONE--RETURN
;A:
; IF ONE--WILL IT FIT IN LARGEST HOLE IN CORE?
;  YES--START INPUT AND RETURN
;  NO--IS TOTAL FREE CORE(CORTAL) ENOUGH TO ACCOMMODATE IT?
;    YES--CALL CORE SHUFFLER
;       IS SHUFFLER WAITING FOR IO TO STOP?
;         YES--RETURN AND DO NOTHING
;         NO--GO TO A:
;   NO--"REMBER" THIS JOB FOR INPUT AND LOOK FOR OUTPUT:
;ANY JOBS WAITING TO XPAND CORE BY SWAP OUT/IN?
; YES--OUTPUT ONE AND RETURN
; NO--SCAN QS BACKWARD FOR JOB IN CORE WHOSE PROTECT TIME
;		(SET ON INPUT) HAS GONE TO 0.
;  IF NONE--RETURN
;  IF ONE--IS IT SWAPPABLE?
;   YES--OUTPUT AND RETURN
;   NO--SET SWP BIT(FORCE JOB TO BECOME SWAPPABLE)--RETURN








;SOME DEVICE DEPENDENT CODE IS MARKED WITH A "*"

↑SWAP:	PUSH PDP,[SWPXIT]	; MAKE SURE WE EXIT THROUGH HERE
	SOSLE SWPCNT		;SHOULD WE RUN THE SWAPPER THIS TICK?
	POPJ PDP,		;NO.
	MOVEI TAC,500		; RUN THE SWAPPER EVERY SO OFTEN
	MOVEM TAC,SWPCNT
	SKIPE SHFWAT		;IS CORE SHUFFLER WAITING FOR IO TO STOP
				;FOR SOME JOB?
	PUSHJ PDP,CHKSHF	;YES, CALL CORE SHUFFLER TO SEE IF
				;IO STOPPED YET
	SKIPN SHFWAT		;IS SHUFFLER STILL WAITING?
	SKIPE SQREQ		;*NO--IS SWAP SERV. ROUT. STILL BUSY?
	POPJ PDP,		;*YES--RETURN
	SKIPN FBACT		; ARE WE SWAPPING ON FAST BANDS TODAY?
	JRST .+3		; NO, FORGET IT
	SKIPE SWPBSY		; YES, IS THE FAST BANS SWAPPER STILL BUSY?
	POPJ PDP,		; YES, COME BACK LATER
FINSWP:
	SKIPN J,FINISH		;NO--ANY IN/OUTPUT TO FINISH?
	JRST SWP2		;NO-
	SETZM SWPCNT		; SET TO RESCAN NEXT TIME AROUND
	JUMPL J,FINOUT		;YES--INPUT OR OUTPUT?

; WE COME HERE TO FINISH A SWAPPING INPUT REQUEST

FININ:

	MOVEM J,LASTIN#
;RESTORE PARTS OF HIS JOB DATA AREA FROM JBTPDL IF IT WAS SAVED THERE....
	MOVE	DAT,JBTSTS(J)	;GET STATUS
	TLNN	DAT,JSEG	;SKIP IF THIS IS A SEGMENT
	TRZN	DAT,SAVJDA	;NOT A SEGMENT. DOES HE HAVE A DATA AREA SAVED?
	JRST	FININA		;SEGMENT OR NOT SAVED IN PDL
	SKIPN	JBTPDL(J)
	JRST	FININA		;CANT BE IN THE PDL IF THERE'S NO PDL.

	MOVEM	DAT,JBTSTS(J)	;NOT SAVED ON PDL ANYMORE.
	HRLZ	TAC1,JBTPDL(J)	;SOURCE (SORT OF)
	HRR	TAC1,JBTDAT(J)	;DESTINATION (SORT OF)
	ADD	TAC1,[<JBTPLN+JOBPRT-JOBPFI>,,JOBPRT]	;ADD OFFSETS.
	HRRZ	DAT,JBTDAT(J)
	BLT	TAC1,JOBPFI(DAT);RESTORE JOB DATA AREA TO USER CORE.
	
FININA:
	SKIPE	DAT,SERA	;ANY INPUT ERRORS?
	JRST	INERR		;YES
	LDB	DAT,IMGOUT	;*INPUT--RETURN STORAGE TO DEVICE
	HLRZ	TAC,JBTSWP(J)	;*1ST BLOCK ADDR.
	PUSHJ	P,FXSAT		;*
	MOVE	JDAT,JBTDAT(J)
IFN JDMPRG,<
	MOVE	PROG,JBTADR(J)
>
	MOVE	DDB,JBTSTS(J)	;IS THIS A HIGH SEGMENT?
	TLNN	DDB,JSEG
	JRST	FININ5		;NOT A SEGMENT.
	PUSHJ	P,UAPPLY	;FOR ALL LOWERS OF THIS UPPER,
	 PUSHJ	P,SPWCNT	;CONTINUE SPACEWAR (ARGUMENT TO UAPPLY)
	SKIPN	AC1,SEGWAIT	
	JRST	FININ1		;SEGWAIT WASN'T SET.
	LDB	AC1,[POINT 6,JBTSTS(AC1),35]
	CAIE	AC1,(J)		;WAS THAT GUY WAITING FOR US?
	JRST	FININ1		;NO. SEGWAIT WASN'T SET ON OUT ACCOUNT
	SETZM	SEGWAIT		;IT WAS OUR FAULT. CLEAR SEGWAIT
	MOVNI	AC1,STOPQ
	MOVEM	AC1,JOBQUE(J)
	PUSHJ	P,REQUE		;QUEUE THIS SEGMENT BACK TO STOPQ
	JRST	FININ1

; HERE WE CONTINUE ANY SPW JOB THAT WAS ACTIVE AND GIVE SWAPIN INTS
; NOTE HERE THAT THE ONLY WAY I KNOW THAT A JOB WITH SPW ACTIVE CAN
; GET SWAPPED OUT IS IF IT EXPANDS ITS CORE SIZE, OR IF THE FREE
; STORAGE MECHANISM NEEDS THE 1K BLOCK THE JOB IS SITTING ON.

FININ5:
	PUSHJ P,SPWCNT		; CONTINUE ITS SPW JOB, IF ANY
	MOVE DDB,JOBPC(JDAT)
	TLNE DDB,USRMOD
	JRST FININ1		;NO
	HRRZ DDB,JOBDPG(JDAT)	;YES, ADJUST PROG AND PDP IN DUMP AC AREA
	SUBI DDB,(PROG)		;OLD RELOC-NEW RELOC
	MOVNS DDB		;NEW RELOC-OLD RELOC
	HRRZ DSER,JOBDAC+PDP(JDAT); SEE IF DUMP PDL IS IN USER'S AREA
	CAMLE DSER,SYSSIZ	; IS IT ABOVE SYSTEM
	CAML DSER,MEMSIZ	; AND BELOW FREE STORAGE AREA?
	JRST FINZR2		; NO
	ADDM DDB,JOBDAC+PDP(JDAT)	; YES, RELOCATE PDL
FINZR2:
	MOVEM PROG,JOBDPG(JDAT)	;STORE NEW AC PROG
FININ1:
	LDB DSER,PSEGN		; # OF UPPER
	JUMPE DSER,FINZRL	;NONE IF 0
	MOVE DDB,JBTSTS(DSER)
	HLRZ DSER,JBTADR(DSER)	;PROTECTION OF UPPER
	JUMPN DSER,FINZR1
	LDB DSER,PSEGN
	LDB DSER,[POINT 8,JBTSWP(DSER),35]
	ASH DSER,12
	SUBI DSER,1
FINZR1:
	TLNE DDB,JWP
	TLO DSER,400000		;FLAG WRITE PROT
	TRO DSER,400000		;MAKE IT UPPER SEG ADDR
FINZRL:
	MOVSI DDB,SWP		;CLEAR SWP BIT
	ANDCAB DDB,JBTSTS(J)
	TLNN DDB,JSEG		;ONLY SET JOBRL2 FOR LOWERS
	CAMN DSER,JOBRL2(PROG)	;AND SEE IF ITS REALLY NECESSARY
	JRST FINZ1A
	SKIPE JBTPR2(J)
	JRST FINZ1A		;AVOID CLOBBERING PEEK-POKE JOBRL2
	SETOM STIME(J)		;MARK CORE IMAGE MODIFIED IF CHANGED
	MOVEM DSER,JOBRL2(PROG)	;SET NEW SEG2 JOBREL
FINZ1A:
	HRRE	DSER,JBTLIN(J)
	JUMPL	DSER,FINDET	;DETACHED?
	MOVSI	DDB,DLYBIT
	CONO	PI,SCNOFF	;KEEP TTYSER OUT
	TDNN	DDB,TTYTAB(DSER);WAS HE DELAYED?
	JRST	NOTSET		;NO.
	MOVSI	DDB,COMBIT
	TDNE	DDB,TTYTAB(DSER);COMMAND ALREADY IN?
	JRST	NOTSET		;YES
	AOS	COMCNT		;NOW LOOK AT HIM AGAIN!
	IORM	DDB,TTYTAB(DSER);SET BIT
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM	;MAKE SURE ALL IS WELL
>
NOTSET:
	CONO PI,SCNON
FINDET:
	MOVSI DSER,INTSWD
	TDNN DSER,JBTIEN(J)
	JRST FININ2
	IORM DSER,JBTIRQ(J)
	PUSH P,J
	PUSHJ P,INTRUN
	POP P,J
FININ2:


; WE CLEAR JOB DATA AREA IF REQUIRED ALSO

	SETZM STIME(J)		; MARK FRESH IMAGE IN CORE
	SKIPN	BLTSWP		;ARE WE TESTING CORE IMAGE AFTER SWAP IN?
	JRST	FINAFB		;NO.
 
	SETCM	DDB,JBTADR(J)	;- SIZE IN LEFT
	HRR	DDB,JBTADR(J)	;GET ADDRESS IN RIGHT
	JUMPL	DDB,.+3
	MOVE	DSER,(DDB)
	AOBJP	DDB,.-1
	MOVE	DSER,(DDB)
	AOBJN	DDB,.-1

FINAFB:
	MOVE DDB,JBTSTS(J)	; PICK UP JOB STATUS WORD AGAIN(MAY BE CLOBBERED BY INTRUN)
	TRZN DDB,WIPEJD		; MUST WE WIPE THE JOB DATA AREA?
	JRST FININS		; NO, GO AHEAD
	HRRM DDB,JBTSTS(J)
	MOVE PROG,JBTADR(J)
	PUSHJ P,CLRINI
FININS:


;HERE WE CHECK ALL THE SWAPIN BITS
	HLRZ TAC,JBTSIN(J)
	JUMPE TAC,NSINBT	;NO JBTSIN BITS ARE SET. SKIP THIS STUFF.
	PUSH P,J
	MOVSI TAC,HLDSNB	;BITS WHICH MAY CAUSE JHLDIN TO BE SET ELSEWHERE
	TDNE TAC,JBTSIN(J)
	PUSHJ P,FLUHLD		;FLUSH
	MOVSI TAC,INTSNB
	TDNN TAC,JBTSIN(J)	;INTERRUPT HANDLER TRYING TO GET HIM IN?
	JRST NOSINT		;NO
	PUSHJ P,CLRSIN		;YES, TURN OFF BIT
	PUSH P,HGCODE
	MOVEI TAC,7
	MOVEM TAC,HGCODE
	PUSHJ P,INTRUN
	POP P,HGCODE
	MOVE J,(P)		;RESET J
NOSINT:
	MOVSI TAC,BATSNB	;PHANTON TRYING TO START UP?
	TDNN TAC,JBTSIN(J)
	JRST NOSBAT
	PUSHJ P,CLRSIN
	PUSHJ P,BATSW		;FINISH HIM OFF
	MOVE J,(P)
NOSBAT:
	MOVSI TAC,JRDSNB	;JOB READ?
	TDNN TAC,JBTSIN(J)
	JRST NOSJRD
	PUSHJ P,CLRSIN
	PUSHJ P,JRSRCH		;FIND EVERYONE TRYING TO READ THIS JOB
	 JRDWIN			;AND SEND THEM HERE
	MOVE J,(P)
NOSJRD:
	MOVSI TAC,COMSNB	;COMMAND WAIT?
	TDNN TAC,JBTSIN(J)
	JRST NOSCOM
	PUSHJ P,CLRSIN
	PUSH P,HGCODE
	MOVEI TAC,1
	MOVEM TAC,HGCODE
	SKIPE COMCNT
	PUSHJ P,COMMAND		;CALL COMMAND DECODER (NOTE THIS MAY NOT GET THE RIGTH GUY)
	POP P,HGCODE
NOSCOM:
	POP P,J
	MOVSI TAC,SPWSNB
	TDNE TAC,JBTSIN(J)	;FORCED OUT BY FS OR LOCK AND SPACEWAR ACTIVE?
	PUSHJ P,CLRSIN		;YES. JUST CLEAR BIT.
NSINBT:
	

;CHECK IF UPPER WANTS IN
	MOVE DSER,J
	LDB J,PSEGN		; DOES THIS JOB HAVE AN UPPER?
	JUMPE J,SWAPSCAN	; NO, SCAN FOR MORE INPUT
	MOVE DDB,JBTSTS(J)
	TLNN DDB,SWP		; IS HIGH SEGMENT SWAPPED OUT?
	JRST SWAPSCAN		; NO
	MOVM UCHN,JOBQUE(DSER)
	CAIE UCHN,RUNQ		;LOWER RUNABLE?
	CAIN UCHN,TQ
	PUSHJ P,FININ7		;YES, CAUSE UPPER TO COME IN
	LDB TAC,IMGIN		; NOW, CAN UPPER FIT IN NOW?
	CAMG TAC,BIGHOL
	JRST INJOB		; YES, GET IT
	JRST SWAPSCAN

FININ7:
	MOVNI DAT,SEGQ
	MOVEM DAT,JOBQUE(J)
	SKIPN SEGWAIT
	MOVEM DSER,SEGWAIT	; MAKE SURE THIS GUY STAYS AROUND!
	MOVEI DAT,QSEGW
	JRST QXFER

;HERE THERE'S A SWAPIN ERROR.

INERR:
	SKIPN	FBACT			;LIBRASCOPE FAST BANDS?
	TRNE	DAT,IODTER!IODERR	;NO. IBM DISK.  ANY ERRORS?
	JRST	.+2			;L'SCOPE OR IBM ERRORS.
	JRST	FININ8			;GO TRY DOING INPUT AGAIN.
	MOVE	DDB,JBTSTS(J)
	TLNN	DDB,JSEG
	JRST	INERNS			;THIS WAS A LOWER.
	SKIPE	FBACT
	SKIPE	FIRSTOUT
	JRST	INERNS			;WE HAVE NO SPARE COPY (THAT WORKS)
;THIS IS A WRITE PROTECTED UPPER. TRY TO SWAP IN THE SPARE.
	SETOM	FIRSTOUT		;FLAG TO AVOID COMING HERE AGAIN.
	SETZM	SERA			;CLEAR SWAPPER ERROR FLAG
	LDB	DDB,IMGIN		;THIS IS LIFTED DIRECTLY FROM INJOB
	LDB	TAC,IMGOUT
	CAML	DDB,TAC
	MOVE	DDB,TAC
	LSH	DDB,=18+=10
	MOVN	TAC1,DDB
	HRR	TAC1,JBTADR(J)
	MOVE	DAT,[XWD J,JB2SWP]
	HLRZ	DSER,JBTSWP(J)
	ADDI	DSER,1
	HRRZS	JBTSWP(J)		;NO PRIMARY SWAPPING BANDS IN USE
	JRST	FBIREQ

FININ8:
	SETZM	FIRSTOUT		;FOR IBM DISK ERRORS, WE TRY AGAIN
	SETZM	FIT
	JRST	INJO1

;ERROR AND NOT WRITE PROTECTED SEGMENT, OR LOWER.

INERNS:
	PUSHJ P,FLUSIN
	MOVE DDB,JBTSTS(J)	; IS THIS A HIGH SEGMENT?
	TLNN DDB,JSEG
	JRST INERR7		;NO.

	MOVSI DDB,SWP		; YES, CALL KILSEG ON ALL JOBS THAT POINT TO THIS SEGMENT
	ANDCAM DDB,JBTSTS(J)
	MOVE AC1,PRJPRG(J)
	MOVEM AC1,JOBNAM(J)	; MAKE SURE NO ONE WILL ATTATCH TO HIM
IFN FTSTAT,<PUSHJ P,NAMSTT>

	PUSHJ	P,UAPPLY
	 PUSHJ	P,SEGERR	;CALL SEGERR FOR EACH LOWER.
	JRST	SWAPSCAN


;TRY TO RECONSTRUCT JOB DATA AREA

INERR7:
	MOVE PROG,JBTADR(J)
	SETZ DAT,
	SKIPN TAC,JOBHCU(PROG)	; ANY IO CHANNELS?
	JRST INERC0		; NO, REGENERATE ANY WHAT MAY EXIST
	MOVEI TAC1,JOBJDA(PROG)	; SCAN THEM ALL AND CHECK FOR VALIDITY
	HRLI TAC1,TAC
INERJL:
	SKIPN DDB,@TAC1		; PICK UP ADDRESS OF IO DDB
INERJ1:
	SOJGE	TAC,INERJL
	JUMPL	TAC,INERCN	;IF ALL CHECKED OUT OK, GO ON
	HRRZ	DDB,DDB
	CAIL	DDB,CHKBEG	;DDB IN SYSTEM LOW CORE?
	CAML	DDB,MEMSIZ	;NO. IN FREE STORAGE?
	CAML	DDB,RMEMSIZ	;MUST BE IN PHYSICAL CORE.
	AOJA	DAT,INERR1	;LOSER.
	AOJA	DAT,INERJC	;IS OK.

; HERE WE CHECK THE NUMBER OF DDB'S HE HAS, ALSO REGENERATE JOB DATA AREA

INERC0:
	SETZM JOBJDA(PROG)	; MAYBE NO CHANNELS??????
INERCN:
	SETZ TAC,
	HLRZ DDB,DEVLST		; COUNT NUMBER OF DDB'S ON CHAIN THAT ARE HIS
INERC1:
	MOVE AC1,DEVMOD(DDB)
	TRNN AC1,ASSPRG		; DOES HE HAVE IT INITED?
	JRST INERC2
	LDB AC1,PJOBN
	CAIN AC1,(J)
	ADDI TAC,1
INERC2:
	HLRZ DDB,DEVSER(DDB)
	JUMPN DDB,INERC1
	CAIN DAT,(TAC)		; DID WE CHECK AS MANY AS WE FOUND?
	JRST INERR4		; YES, ALL IS WELL
	JRST INERR1		; NO, REGENERATE DATA AREA

INERJC:
	LDB AC1,PJOBN		; NOW CHECK JOB NUMBERS
	CAIN AC1,(J)
	JRST INERJ1
INERR1:
	MOVE PROG,JBTADR(J)
	PUSHJ P,CLRJB1		; CLEAN IT OUT
	SETZM JOBHCU(PROG)
	MOVEI DSER,JOBJDA(PROG)
	HLRZ DDB,DEVLST
INERR2:
	SETZM (DSER)
	MOVE UCHN,DEVMOD(DDB)
	TRNN UCHN,ASSPRG	; DOES HE HAVE IT INITED??
	JRST INERR3
	LDB UCHN,PJOBN		; DOES THIS DDB BELONG TO HIM?
	CAME UCHN,J
	JRST INERR3
	MOVEM DDB,(DSER)	; YES, PUT ITS ADDRESS IN JOBJDA
	AOS JOBHCU(PROG)
	ADDI DSER,1
INERR3:
	HLRZ DDB,DEVSER(DDB)	; MOVE DOWN TO NEXT DDB
	JUMPN DDB,INERR2
	PUSHJ P,ESTOP
INERR4:
	MOVE DSER,JOBHCU(PROG)
	MOVSI DAT,GOBIT
INERRG:
	MOVEI DDB,JOBJDA(PROG)
	ADD DDB,DSER
	MOVE DDB,(DDB)
	MOVE UCHN,DEVMOD(DDB)
	TLNE UCHN,DVDSK!DVUDP
	ANDCAM DAT,DEVIOS(DDB)	;CLEAR GOBIT SO USER DOESN'T HANG
	SOJGE DSER,INERRG
	MOVM J,FINISH
INERR6:
	MOVSI DDB,SWP
	ANDCAM DDB,JBTSTS(J)
	SETZM XPANDF
	SETZM FINISH
SEGERR:
	CAMN J,SEGWAIT
	SETZM SEGWAIT
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/
SWAP READ ERROR /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	POPACS
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
	ASCIZ /SWAP READ ERROR/
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC
	MOVE AC1,JBTSTS(J)
	TLNE AC1,JLOG		; IS HE REALLY LOGGED IN?
	JRST STOP1
	JRST ESTOP

; ROUTINE TO RELEASE A JOB'S SWAPPING BANDS (LIBRASCOPE ONLY)

GIVEBANDS:

	SKIPN FBACT
	POPJ P,
	HLRZ UCHN,JB2SWP(J)
	SKIPN UCHN
	HLRZ UCHN,JBTSWP(J)
INERX:
	PUSHJ P,FBGIVE
	CAIE UCHN,MAXFB
	SOJA UCHN,INERX
	HRRZS JBTSWP(J)
	HRRZS JB2SWP(J)
	POPJ P,

; AND HERE IS WHERE WE GO TO FINISH A SWAP OUTPUT REQUEST

FINOUT:

	MOVNS J			;FINISH OUTPUT, -FINISH=JOB NO.
	SKIPN SERA		;ANY ERRORS
	JRST FINOU1
	PUSHJ P,GIVEBANDS	; RELEASE ALL HIS BANDS AND TRY AGAIN
	JRST OUTJOB

FINOU1:
	SKIPE FBACT
	SKIPE FIRSTOUT
	JRST OUTP1
	MOVE DDB,JBTSTS(J)
	TLNN DDB,JSEG
	JRST OUTP1
	SETOM FIRSTOUT
	HLRZ DDB,JBTADR(J)
	MOVNM DDB,TAC		; IF A WRITE-PROTECTED UPPER, SWAP OUT A SPARE COPY
	HRRZ TAC1,JBTADR(J)
	HRLI TAC1,-1(TAC)
	MOVE DAT,[XWD J,JB2SWP]
	HLRZ DSER,JBTSWP(J)
	ADDI DSER,1
	JRST FBOREQ

OUTP1:
	MOVEI TAC,0		;RETURN CORE
	MOVE PROG,JBTADR(J)	;XWD PROTECT.,RELOC.
IFN JDMPRG,<
	MOVE JDAT,JBTDAT(J)	;JOB DATA AREA
>
	PUSHJ PDP,CORE0
	JSP DAT,CERROR		;SHOULD NEVER HAPPEN
	SKIPN	FSCLKF		;FREE STORAGE FORCING USERS?
	SKIPE	LOCKNO		;NO. LOCK UUO FORCING?
	TDZA	TAC,TAC		;THIS GUY IS BEING FORCED BY FS OR LOCK (ZERO TAC) 
	JRST	SWAPSCAN
	MOVE	DDB,JBTSTS(J)
	TLNE	DDB,JSEG	;SEGMENT?
	PUSHJ	P,UAPPLY	;YES. APPLY ROUTINE TO ALL LOWERS
	PUSHJ	P,PSPWAC	;IS SPACEWAR ACTIVE FOR THIS USER? (SET TAC)
	JUMPE	TAC,SWAPSCAN	;NO.
	PUSHJ	P,SETSIN	;FORCE THIS GUY TO GET SWAPPED IN

SWAPSCAN:

	SETZM	XPANDF		;CLEAR XPANDING JOB OUTPUT TO DISK FLAG
	SETZM	FINISH		;CLEAR FINISH FLAG
SWP2:
	SKIPE	J,FORCE		;WAITING FOR JOB TO BECOME SWAPPABLE?
	JRST	FORCE1		;YES
	SETZM	FIT		;RESCAN FOR INPUT NEXT TIME
	SKIPE	XJOB		;IS THERE SOMEONE WHO WANTS TO BE KICKED OUT?
	JRST	SCNIN		;YES.  SCNIN WILL DO IT (BELIEVE IT OR NOT)
	SKIPGE	FSCLKF		;ARE WE WAITING FOR FREE STORAGE?
 	POPJ	P,		;YES.
	SKIPG	J,LOCKNO	;ARE WE WAITING FOR A JOB TO BE LOCKED IN?
	JRST	SCNIN		;NO.
	MOVE	DDB,JBTSTS(J)	;IS THE LOCKING JOB STILL IN CORE?
	TLNN	DDB,SWP		;
	POPJ	P,		;JOB IS STILL IN CORE. FOREGO SWAPIN UNTIL LOCKNO=0
	JRST	SCNINX		;J AND DDB ARE SET TO GET THIS GUY IN.


PSPWAC:
	SKIPN	SPWGO(J)
	SKIPE	SP2GO(J)
	MOVSI	TAC,SPWSNB	;INDICATE WE HAVE SPACEWAR ACTIVE
	POPJ	P,

;SCAN FOR INPUT - LOOK FOR A JOB ON THE DISK WHICH OUGHT TO COME IN.
JN←←TEM

SCNIN:

	HGMAC	(2)		;TELL HG ROUTINES WE ARE IN SCNIN

;FORCE EXPANDING JOBS OUT before SCAN FOR INPUT
	PUSHJ	P,XPAND1	;CHECK XPANDING JOB FIRST
	SKIPN	SQREQ		;*WERE THERE ANY?
	SKIPE	FORCE
	POPJ	P,		;YES
	SKIPN	FBACT		; ARE WE SWAPPING IN FBPACK TODAY?
	JRST	.+3		; NO
	SKIPE	SWPBSY		; YES, IS THE FBPACK SWAPPER BUSY?
	POPJ	P,		; YES, LEAVE NOW

	PUSHJ P,GCMAX		;GET TOTAL AMOUNT OF AVAILABLE CORE (CORE IS 
	MOVEM AC3,CORMX		;AVAILABLE IF NOT OCCUPIED BY SYSTEM OR SPW JOBS)
				;OR LOCKED CORE.
	JSP PC,GETSIN
	JRST SCNINZ		;FOUND A JOB IN SWAP IN LIST
	MOVEI DAT,ISCAN		;NO MORE IN SWAP IN LIST, TRY QUEUES
	JSP PC,QSCAN		;C(J)← NEXT MOST IMPORTANT JOB TO SWAP IN
	POPJ	P,		;(THERE IS NO NEXT MOST IMPORTANT JOB)
SCNINZ:
	MOVE DDB,JBTSTS(J)	;THIS JOB OUT OF CORE?
	TLNN DDB,SWP
	JRST (QR)		;NO--CONTINUE SCAN
	
SCNINX:
	LDB TAC,IMGIN		;YES--WILL IT FIT IN BIGGEST HOLE?
SCNIN1:

IFN FTSTAT,<
	PUSH P,TAC
	MOVEI TAC,FITSTA
	PUSHJ P,STAPUT
	POP P,TAC
>;FTSTAT
	CAMG TAC,BIGHOL
	JRST INJOB		;YES
	MOVEM J,FIT		;NO--SET FIT FLAG
	
	
SCNIN2:
	MOVE DDB,JBTSTS(J)
	TLNE DDB,JSEG		;IS THIS JOB AN UPPER SEGMENT?
	JRST DEADUP		;  YES
	LDB DDB,PSEGN		;GET NUMBER OF THIS JOB'S UPPER SEGMENT
	MOVE DSER,JBTSTS(DDB)
	TLNN DSER,SWP		;IS UPPER SEGMENT IN CORE?
	JRST DEADR1		;  YES, (OR ELSE THERE IS NO UPPER)
	LDB DSER,IMGINT		;C(DSER) ← INCORE IMAGE SIZE OF THE UPPER
	ADD TAC,DSER		;C(TAC) ← CORZ SIZE OF SWAPPED OUT PORTION OF JOB
DEADR1:
	MOVE AC3,CORMX		;AC3 ← TOTAL CORE SPACE AVAILABLE TO OUR JOB
	SKIPN TAC1,DDB		;DOES THIS JOB HAVE AN UPPER SEGMENT?
	JRST DEADR9		;  NO
	PUSHJ P,GCMCK		;  YES, IS IT'S SIZE ALREADY REFLECTED IN CORMX?
	JRST DEADR9		;  YES
	PUSHJ P,CORSGT		;  NO, C(TAC1) ← SIZE OF UPPER SEGMENT
	SUB AC3,TAC1		;AC3 ← (AVAILABLE CORE) - (UPPER CORE SIZE)
DEADR9:
	LDB DDB,IMGIN
	LSH DDB,=10		;DDB ← CORE SIZE OF JOB (LOWER SEG ONLY)
	CAMG DDB,AC3		;WILL WE FIT INTO AVAILABLE CORE?
	JRST SCNIN9		;  YES
	PUSHJ P,DEADLOCK	;  NO
	JRST (QR)		;CONTINUE SCAN FOR A JOB TO SWAP IN

; "DEADUP" IS CALLED FROM NEAR SCNIN2, IF THE JOB TO BE SWAPPED IN IS AN
;UPPER SEGMENT AND NO SINGLE HOLE IS LARGE ENOUGH TO CONTAIN IT;
;	CODE BY JAM		COMMENTS BY JHS

DEADUP:
	SETZB DSER,JN
	SETZM ISONE
	MOVE DDB,J
	MOVEI J,JOBN-1		;SCAN JOB TABLE, LOOKING FOR OUR LOWERS
DEADU1:
	LDB UCHN,PSEGN
	CAIE UCHN,(DDB)		;IS THIS JOB POINTING TO US?
DEADU2:
	SOJG J,DEADU1		;  NO, CONTINUE SCAN
	JUMPE J,DEADU3		;JUMP WHEN SCAN COMPLETED
	MOVE UCHN,JBTSTS(J)
	TLNN UCHN,JHLDIN	;LOWER HOLDING?
	SKIPE JBTSIN(J)
	JRST DEADU7		;COMING IN
	MOVM UCHN,JOBQUE(J)	;IF OUR LOWER IS
	CAIE UCHN,RUNQ		;IN RUNQ OR TQ
	CAIN UCHN,TQ		;THEN GO TO DEADU7
	JRST DEADU7		;ELSE CONTINUE SCAN
	MOVE UCHN,JBTMSK(J)
	AND UCHN,JBTIEN(J)
	AND UCHN,JBTIRQ(J)
	JUMPN UCHN,DEADU7
	SKIPN JBTST2(J)
	JRST DEADU2		;NONE OF THE ABOVE, CONTINUE SCAN
DEADU7:
	MOVE TAC1,JBTSTS(J)
	TLNE TAC1,SWP		;THIS LOWER OF OURS IS SWAPPED OUT?
	JRST DEADUC		;	YES
	HLRZ TAC1,JBTADR(J)
	ADDI TAC1,1
	LDB UCHN,IMGINT
	LSH UCHN,=10
	ADDI TAC1,(UCHN)	;C(TAC1) ← COMBINED SIZE OF LOWER AND UPPER
	CAMG TAC1,CORMX		;BOTH WILL FIT IN CORE AT ONE TIME?
	SETOM ISONE		;  YEP, INDICATE THAT THERE ISONE THAT FITS
DEADUC:
	MOVE TAC1,J
	PUSHJ P,CORSGT		;C(TAC1) ← SIZE OF LOWER
	CAMG TAC1,DSER		;HAS SUCH A LARGE LOWER BEEN FOUND BEFORE?
	JRST DEADU2		;  NO, CONTINUE SCAN FOR LOWERS
	MOVE DSER,TAC1		;  YES, REMEMBER SIZE IN DSER
	MOVE JN,J		;   AND REMEMBER JOB# IN JN
	JRST DEADU2		;	AND CONTINUE SCAN
	
DEADU3:
	JUMPN JN,DEADU4		;ARRIVE HERE WHEN SCAN FOR LOWERS COMPLETE
	MOVE J,DDB		;ARRIVE HERE IF WE HAVE NO LOWERS ! (?)
	JRST (QR)		;DON'T BRING IN UPPER, LOOK FOR SOME OTHER
				;  JOB TO SWAP IN

; THIS SENDS THE MESSAGE TO A DEADLOCKED LOWER
	
DEADU4:
	MOVE J,JN		;C(JN) = JOB# OF LARGEST LOWER SEGMENT
	MOVE UCHN,TAC		;C(TAC) = SIZE OF UPPER SEGMENT
	LSH UCHN,=10
	ADD UCHN,DSER
	CAMG UCHN,CORMX		;WILL LARGEST LOWER BE LOCKED OUT?
	JRST SCNIN9		;  NO, GO SHUFFLE ETC.
	PUSH P,DDB		;  YES, ETC.
	CAMN J,SEGWAIT
	SETZM SEGWAIT
	PUSHJ P,DEADLOCK
	POP P,J
	SKIPN ISONE
	JRST (QR)
	JRST SCNIN9

		;NOTE:  IF MORE THAN ONE LOWER IS SO LARGE THAT
		;  IT TOGETHER WITH THE UPPER WON'T FIT, THEN ONLY
		;  ONE OF THEM WILL GET THE DEADLOCK MESSAGE,
		;  AND THIS IS PROBABLY A BUG.

; HERE WE SEE IF JOB CAN EVER FIT. IF SO, TRY TO COMPACT CORE TO GET HIM IN
; IF NOT, SCAN FOR SOMEBODY ELSE

SCNIN9:
	MOVEI DDB,SDEAD1	; J MAY CONTAIN THE NUMBER OF THE LOWER HERE
	ANDCAM DDB,JBTSTS(J)	; TELL SOMEONE WE GOT HIM IN.
	CAMLE TAC,CORTAL	; ENOUGH FREE CORE TO EVENTUALLY
				;FIT IN CORE?
	JRST SCNOUT		;NO, SCAN FOR SOME JOB TO OUTPUT TO MAKE ROOM
	PUSHJ PDP,CHKSHF	;YES, CALL CORE SHUFFLER TO MOVE JOBS AROUND
	SKIPN FORCE		;REG 12/3/73 SHUFFLER CAN SET FORCE!
	SKIPE SHFWAT		; SHUFFLER WAITING FOR IO OR SPW?
	POPJ PDP,		; YES, GOODBYE
	MOVE J,FIT		; NO, SEE IF WE WILL FIT NOW
	LDB TAC,IMGIN
	CAMG TAC,BIGHOL
	JRST INJOB
	HGMAC	(2)
	JRST SCNIN2

RESCNIN:

	MOVEI DAT,ALLRUNSCAN
	JSP PC,QSCAN
	JRST NOFIT
	MOVE DDB,JBTSTS(J)
	TLNN DDB,SWP
	JRST (QR)
	LDB TAC,IMGIN
	LDB DDB,PSEGN		; SECOND SEGMENT NUMBER
	JUMPE DDB,RESCN2
	MOVE DSER,JBTSTS(DDB)
	TLNN DSER,SWP
	JRST RESCN2
	LDB DSER,[POINT 8,JBTSWP(DDB),35]
	ADD TAC,DSER
RESCN2:
	CAMLE TAC,CORTAL
	JRST (QR)
	LDB TAC,IMGIN
	JRST SCNIN1

; HERE WE HAVE DETECTED A CORE DEADLOCK

DEADLOCK:

	MOVEI DDB,SDEADIN
	TDNE DDB,JBTSTS(J)
	POPJ P,			; WE KNOW ABOUT HIM
	PUSH P,J
	TRO DDB,SDEAD1		;NOTE REALLY DEAD AT THIS TIME.
	ORM DDB,JBTSTS(J)	; MARK IT AS DETECTED
	PUSHJ P,GCS
	CAMLE DSER,CORMAX	; IS HE TOO BIG ALTOGETHER, OR IS SOMEONE KEEPING HIM OUT
	JRST DEADL2		; TOO BIG ALTOGETHER.
	PUSHJ P,HALFIN
	JRST DEADL1

HALFIN:
	LSH J,=12		; SOMEBODY'S FAULT. TELL HIM ABOUT IT.
	ADD J,[XWD HALFD,=30*JIFSEC]
PLANT:
	CONO PI,PIOFF
	IDPB J,CLOCK(PID)
	CONO PI,PION
	POPJ P,

DEADL2:
	PUSHJ P,DEACLN
DEADL1:
	POP P,J
	POPJ P,

DEACLN:
	LSH J,=12
	ADD J,[XWD SDEAD,=15*JIFSEC]
	JRST PLANT		;GO PLANT IT

; CLOCK REQUEST TIMES OUT IN 15-SOME-ODD-SECONDS AND COMES HERE:

SDEAD:
	MOVEI J,SDEADIN
	ANDCAB J,JBTSTS(TAC)	;CLEAR SDEADIN (NO MORE CLOCK REQUESTS).
	TRNN J,SDEAD1		;HAS HE BEEN IN SINCE DETECTION?
	POPJ P,			;YES
	MOVE J,TAC
	PUSHJ P,GCS
	CAMG DSER,CORMAX
	POPJ P,
	MOVM DDB,JOBQUE(J)	; SEE IF HE HAS STOPPED HIS JOB
	CAIN DDB,STOPQ
	JRST DEACLN		; YES, WE WILL GIVE HIM SOME TIME
	PUSHJ P,FLUSIN		;FLUSH FROM SWAP IN LIST
	PUSH P,J
	LDB J,PSEGN
	SKIPE J
	PUSHJ P,FLUSIN		;ALSO UPPER
	POP P,J
	PUSHJ P,TTYERP		; FIND HIS TTY FOR HIM
	PUSHJ P,INLMES
	ASCIZ /CORE DEADLOCK.

/
	PUSHJ P,PRCRCC
	PUSHJ P,TTYSTC
	JRST STOP1

HALFD:
	MOVE J,TAC
	MOVM AC3,JOBQUE(J)
	MOVE TAC,JBTSTS(J)
	CAIE AC3,STOPQ		;CLEAR BIT IF HE STOPPED HIMSELF
	TRNN TAC,SDEAD1		;HAS HE BEEN IN SINCE DETECTION?
	JRST KILLIN
	PUSHJ P,GCS
	CAMG DSER,CORMAX
	JRST HALFD1
	PUSH P,J
	JRST DEADL2
HALFD1:
	PUSH P,DSER
	PUSHJ P,GCMAX
	POP P,DSER
	CAMG DSER,AC3
	JRST KILLIN
	PUSHJ P,TTYERR			;THIS GUY ONLY SETS ERROR BIT
					;DOESN'T CLEAR INPUT UNLESS NECESSARY
	PUSHJ P,INLMES
	ASCIZ /
YOU ARE LOCKED OUT OF CORE!
/
	MOVSI IOS,USRB
	IORB IOS,DEVIOS(DDB)
	PUSHJ P,TTYSTR
	JRST HALFIN

KILLIN:
	MOVEI DDB,SDEADIN
	ANDCAM DDB,JBTSTS(J)
	POPJ P,

;	GCMAX - ROUTINE TO CALCULATE HOW MUCH CORE IS AVAILABLE FOR A
;	JOB ON THE DISK WHICH WANTS TO COME IN.  CORE IS CONSIDERED
;	TO BE AVAILABLE IF IT IS USER CORE NOT OCCUPIED BY SPW JOBS.

GCMAX:
	SETZM	GCBITS			;72 BITS FOR REMEMBERING
	SETZM	GCBITS+1
	MOVE	AC3,SYSTOP		;COMPUTE -(LOKTOP-SYSTOP)
	SUB	AC3,LOKTOP		;LOCKED CORE SIZE = LOKTOP-SYSTOP
	ADD	AC3,CORMAX		;ADD SIZE FROM SYSTOP TO MEMSIZ
	SKIPG	SPWACT			;ANY ONE IN SPW MODE?
	POPJ	P,			;NO. THIS IS SIMPLE
	PUSH	P,DDB
	PUSH	P,[POINT 6,SPWGO(JN),5]	;GET A BYTE POINTER
	PUSHJ	P,GCLP			;CALL THINK ABOUT P1 SPW JOBS
	MOVE	DSER,[POINT 6,SP2GO(JN),5];GET ANOTHER BYTE POINTER
	MOVEM	DSER,(P)		;STUFF IT WHERE GCLP WILL SEE IT
	PUSHJ	P,GCLP
	SUB	P,[1,,1]		;ADJUST STACK(A LESS USEFUL COMMENT-FW)
	POP	P,DDB
	POPJ	P,

GCLP:
	MOVEI	JN,0			;INITIALLY LOOK AT LIST BASE
GCLP1:
	LDB	JN,-1(P)		;GET NUMBER OF SOME SPW JOB.
	JUMPE	JN,CPOPJ		;0 MEANS END OF LIST.
	SKIPN	JBTST2(JN)		;SKIP IF SPACEWAR IS ACTIVE
	JRST	GCLP1			;NOT STILL ACTIVE
	MOVEI	DDB,(JN)		;GET JOB NUMBER INTO DDB
	PUSHJ	P,GCMCK			;HAVE WE SEEN THIS JOB BEFORE?
	JRST	GCLP1			;YES. DON'T COUNT AGAIN
	MOVEM	IOS,GCBITS(DSER)	;SO WE WON'T COUNT THIS JOB AGAIN
	MOVE	DDB,JBTSTS(JN)	
	TRNE	DDB,JLOCK		;IS THIS JOB LOCKED IN?
	JRST	GCLP2			;YES. DON'T COUNT IT TWICE
	HLRZ	DSER,JBTADR(JN)		;GET THE PROTECTION
	SUBI	AC3,1(DSER)		;DECREASE THE AVAILABLE SIZE.
GCLP2:
	ANDI	DDB,77			;SEGMENT NUMBER FROM JBTSTS
	JUMPE	DDB,GCLP1		;LOOP IF NO SEGMENT
	PUSHJ	P,GCMCK			;SEGMENT SEEN BEFORE?
	JRST	GCLP1			;YES. DON'T DO IT AGAIN.
	MOVEM	IOS,GCBITS(DSER)	;DON'T COUNT THIS SEGMENT AGAIN
	HLRZ	DDB,JBTADR(DDB)		;GET THE PROTECTION SIZE
	SUBI	AC3,1(DDB)
	JRST	GCLP1			;LOOP

;JOB NUMBER IN DDB. SKIP IF WE'VE NOT SEEN THIS JOB BEFORE.
;IOS IS SET WITH WORD TO DEPOSIT IF YOU WANT TO MARK THIS JOB AS SEEN:
; USE	MOVEM	IOS,GCBITS(DSER)	TO REMEMBER HAVING SEEN THIS JOB.
GCMCK:
	MOVE	DSER,DDB
	ANDI	DSER,1		;THIS BIT WILL INDEX THE TWO WORD BIT TABLE
	MOVEI	IOS,1		;THIS BIT WILL BE SHIFTED TO UNIQUE POSITION
	ROT	DDB,-1
	ROT	IOS,-=16(DDB)	;
	ROT	DDB,1		;RESTORE DDB
	IOR	IOS,GCBITS(DSER);TURN ON OTHER JOB BITS WE HAVE SEEN AND SET
	CAME	IOS,GCBITS(DSER);IS THIS AN OLD JOB NUMBER?
	AOS	(P)		;  NO, SKIP RETURN
	POPJ	P,		;  YES, NORMAL RETURN


GCS:
	MOVE TAC1,J
	PUSHJ P,CORSGT		; ADD UP HIS CORE SIZE AND SEE IF WE ARE STILL DEADLOCKED
	MOVE DSER,TAC1
	LDB TAC1,PSEGN
	MOVE DDB,TAC1
	JUMPE TAC1,CPOPJ
	PUSHJ P,CORSGT
	ADD DSER,TAC1
	POPJ P,


;SCAN FOR OUTPUT

SCNOUT:
	HGMAC(3)
;(CODE TO LOOK FOR EXPANDING JOBS HAS BEEN MOVED TO SCNIN)
	MOVE DDB,CORTAL		;INITIALIZE FREE CORE COUNTER
	MOVEM DDB,SUMCOR
	SETZM MAXSIZ		;CLEAR SIZE OF LARGEST JOB
	SETZM MAXJBN
	SETZM MAXRSZ
	SETZM MAXRJB
	SETZM MAXSSZ
	SETZM MAXSJB
	MOVE TAC,[XWD NJOBS,CJOBS]
	BLT TAC,CJOBS+JOBN-1	; MOVE OVER TABLE OF REFERENCE COUNTS
	MOVE DDB,FIT		;ENOUGH SEEN YET?
	LDB DSER,[POINT 6,JBTSTS(DDB),35]
	JUMPE DSER,FORCE3
	MOVE UCHN,JBTSTS(DSER)
	TLNE UCHN,SWP
	LDB DSER,[POINT 8,JBTSWP(DSER),35]
	TLNN UCHN,SWP		; OR IS HE SWAPPED IN?
	SETZ DSER,		; YES, HE DOESN'T COUNT INTO CORE WE HAVE TO GET
FORCE3:
	LDB DDB,IMGINT
	ADD DDB,DSER		; ADD IN SIZE OF UPPER
	MOVEM DDB,NEEDED	; AND STORE AS AMOUNT NEEDED
	MOVEI DAT,OSCAN		;NO--SCAN QS
	JSP PC,QSCAN
	JRST RESCNIN
	CAME J,FIT		; REACHED OURSELVES YET?
	JRST SCNOF1		; NO.
	SKIPN JBTSIN(J)		; GIVE HIGH PRIORITY TO GUYS IN SWAP IN LIST
	CAMN J,SEGWAIT		; IS THIS GUY WAITING FOR A SEGMENT?
	JRST (QR)		; YES, EXCEPT FOR US, SCAN BACK ALL THE WAY
	JRST RESCNIN		; NO, SCAN FOR MORE INPUT

SCNOF1:
	MOVE DDB,JBTSTS(J)	;GET JOB STATUS BITS
	TLNE	DDB,SWP		;NO, IS JOB ON DISK OR ON ITS WAY?
	JRST	CJOB		;YES,CONTINUE SCAN TO FIND ANOTHER JOB TO OUTPUT
	TLNE DDB,JHLDIN		;SOMEONE TRYING TO KEEP THIS GUY IN?
	JRST (QR)		;YES, SKIP HIM
	TLNE	DDB,JSEG	;SEGMENT?
	JRST	FRCE4A		;YES. CHECK NJOBS TO SEE IF IT SHOULD BE SWAPPED
	TRNE	DDB,JLOCK	;LOCKED JOB?
	JRST	(QR)		;YES. CAN'T BE SWAPPED.
	CAME	J,SEGWAIT	;DON'T SWAP OUT IF WAITING FOR A HIGH SEGMENT
	CAMN 	J,LOCKNO
	JRST	(QR)		;DON'T SWAP OUT THE GUY WE'RE TRYING TO LOCK IN.

REPEAT 0,<		;LET'S TRY NOT CLOGGING UP CORE WITH LOW PRIORITY LOSERS
	MOVM DDB,JOBQUE(J)	; PICK UP HIS QUEUE
	CAIE DDB,TQ		; IS HE IN A RUN QUEUE?
	CAIN DDB,RUNQ
	CAIA
	JRST FORCE4
	LDB DDB,PSEGN		; YES, DOES HE HAVE AN UPPER?
	JUMPE DDB,FORCE5	; NO
	MOVE DDB,JBTSTS(DDB)	; YES, IS IT IN CORE?
	TLNE DDB,SWP
	JRST FORCE4		; NO, DOESN'T MATTER
FORCE5:
	SKIPN STIME(J)		; HAS THIS JOB BEEN RUN?
	JRST (QR)		; NO, GO BACK AND LET IT RUN.
>

FORCE4:
	CAME J,SEGWAIT		; IF WAITING FOR SEGMENT, MUST STAY IN
	SKIPE JBTST2(J)		; DOES HE HAVE A SPACEWAR MODULE?
	JRST (QR)		;YES. CANT SWAP HIM OUT.
	HLRZ DDB,JBTDAT(J)	;PICK UP SIZE OF JOB
	JUMPE DDB,(QR)
	PUSHJ P,SIZCHK		;UPDATE SUMCOR AND CHECK IF ENOUGH YET
	JRST CJOB		;NO. LOOK FOR MORE
FORCE6:
	SKIPN J,MAXJBN		;YES, SWAP OUT LARGEST
	MOVE J,MAXRJB
	JUMPN J,FORCE0
	MOVE J,MAXSJB		;AS A LAST RESORT, SWAP SEGMENT
FORCE0:
	MOVSI DDB,SWP
	IORM DDB,JBTSTS(J)
	MOVEM J,FORCE		;ASSUME NOT SWAPPABLE--IS IT?

FORCE1:

IFN JDMPRG,<
	MOVE JDAT,JBTDAT(J)
>
	SKIPN PROG,JBTADR(J)	;LOC. IN PHYSICAL CORE, IS CORE
				;ASSIGNED IN MEMORY?
	JRST OUTJOB		;NO, CANNOT HAVE ACTIVE DEVICES
	CAME J,JOB(PID)		;IF THIS IS CURRENT JOB, WAIT UNTIL
				;PROTECTED AREA IS MOVED BACK TO JOB DATA AREA
	PUSHJ PDP,ANYACT	;ANY ACTIVE DEVICES?
	POPJ PDP,		;YES--RETURN AND WAIT FOR I/O TO STOP.
	SKIPN DDB,SEGWAIT	; IS ANYONE WAITING FOR A SEGMENT?
	JRST OUTJOB		; NO
	LDB TAC,[POINT 6,JBTSTS(DDB),35]
	CAIE TAC,(J)		; YES, IS IT US?
	JRST OUTJOB		; NO
	MOVSI TAC,SWP		; YES, WE ARE NO LONGER SWAPPABLE
	ANDCAM TAC,JBTSTS(J)
	SETZM FORCE
	SETZM SWPCNT		; BE SURE AND SCAN AGAIN NEXT TICK
	POPJ P,

FRCE4A:
	SKIPE	NJOBS(J)	;ANYONE LEFT USING THIS?
	JRST	(QR)		;YES. SEGMENT SWAP OUT WILL BE CONSIDERED W/LOWERS
	JRST	FORCE4		;THIS MAY BE A DETACHED SEGMENT. SWAP IT

;OUTPUT A JOB

OUTJOB:
	HGMAC(4)
	MOVNM J,FINISH		;SET FINISH FLAG FOR OUTJOB
	AOS NOUTSWPS
	SETZM FORCE		;CLEAR FORCE FLAG
	PUSHJ P,QNORUN		; REQUE HI SEGMENT IF NECESSARY
	SETZM FIRSTOUT#
	MOVSI DDB,INTSWW
	TDNN DDB,JBTIEN(J)
	JRST OUTJO1
	IORM DDB,JBTIRQ(J)
	PUSHJ P,INTRUN
	MOVM J,FINISH
OUTJO1:
	HLRZ	DDB,JBTADR(J)	;COMPUTE CORE IMAGE SIZE
	JUMPE	DDB,SWP5	;DONT OUTPUT IF 0 CORE
;HERE WE SAVE THE JOB DATA AREA OF A LOWER
	MOVE	TAC1,JBTSTS(J)	;GET STATUS
	SKIPE	JBTPDL(J)	;DON'T SAVE IF THERE'S NO PLACE.
	TLNE	TAC1,JSEG	;IS THIS A SEGMENT?
	JRST	OUTJO3		;YES. THERE IS NOTHING TO SAVE.
	HRLZ	TAC1,JBTDAT(J)	;SOURCE (SORT OF)
	HRR	TAC1,JBTPDL(J)	;DESTINATION (SORT OF)
	ADD	TAC1,[JOBPRT,,<JBTPLN+JOBPRT-JOBPFI>]
	HRRZ	DAT,JBTPDL(J)	;
	BLT	TAC1,JBTPLN(DAT);SAVE THE DATA.
	MOVEI	TAC1,SAVJDA
	IORM	TAC1,JBTSTS(J)	;DATA AREA IS NOW SAVED IN CORE.
OUTJO3:
	HRRZ	TAC1,JBTADR(J)	;LOCATION OF CORE IMAGE
	MOVNM	DDB,TAC		;*SAVE COUNT FOR CALL TO SQOUT. -(SIZE-1)
	ASH	DDB,-=10	;CONVERT TO 1K BLOCKS
	ADDI	DDB,1
	DPB	DDB,IMGOUT	;RECORD AS OUT IMAGE
	SKIPN	XPANDF		;DONT SET IMGIN IF FROM XPAND1
	DPB	DDB,IMGIN
	SKIPE	STIME(J)	;HAS HIS CORE IMAGE BEEN MODIFIED?
	JRST	OUTJ1		;YES.
	HLRZ	DDB,JBTSWP(J)	;SEE IF HE HAS BEEN SWAPPED OUT BEFORE
	JUMPN	DDB,OUTP1	;WAS SWAPPED OUT BEFORE.
	LDB	DDB,IMGOUT	;FIX DDB FOR CALL ON OUTJ1

; WE HAVE DECIDED THAT JOB IS REALLY TO BE SWAPPED
; CALL THE OUTPUT ROUTINE.
;DDB = IMGOUT SIZE. TAC1=LOCATION OF JOB. TAC = -(SIZE-1)

OUTJ1:
	SKIPN	BLTSWP		;ARE WE DOING BLT AFTER SWAPIN?
	JRST	OUTJ2		;NO. THEN NO BLT BEFORE SWAP OUT.
	HRL	TAC1,TAC1	;LOCATION,,LOCATION
	HLRZ	DAT,JBTADR(J)	;GET THE SIZE
	ADDI	DAT,(TAC1)	;COMPUTE ENDING ADDRESS
	BLT	TAC1,(DAT)	;BLT TO SELF.
	HRRZ	TAC1,JBTADR(J)	;RESTORE TAC1.
	
OUTJ2:
	HRLI	TAC1,-1(TAC)	;*BUILD AND SAVE IOWD FOR SQOUT
	PUSH	P,TAC1		;*
	MOVE	DAT,DDB		;*CONVERT CORE IMAGE TO 128 WD BLOCKS
	PUSHJ	P,GXSAT		;*GET DEVICE STORAGE
	JRST	FULL		;*NONE AVAILABLE
	SKIPN	FBACT
	HRLM	TAC,JBTSWP(J)	;*SAVE DEVICE ADDRESS
	POP	P,TAC1		;*GET IOWD
	JRST	SQOUT		;*START OUTPUT AND RETURN

SWP5:

	DPB DDB,IMGOUT		;SET OUTPUT IMAGE TO 0
	JRST SWAPSCAN		;GO LOOK FOR SOMETHING ELSE TO DO

NOFIT:
	SETZM FIT		;FORGET ABOUT FITTING IN A JOB ON DISK
	POPJ PDP,		;ALL JOBS IN CORE ARE HIGHER PRIORITY.

; ROUTINE TO ADD THIS JOB'S SIZE TO CURRENT TOTAL AND SEE IF WE
; HAVE MADE ENOUGH ROOM FOR THE JOB WE ARE TRYING TO FIT IN
; EXPECTS RELOCATION IN DDB, JOB NUMBER IN J

SIZCHK:
	ASH DDB,-12		;CONVERT TO 1K BLOCKS
	ADDI DDB,1
	MOVE TAC,JBTSTS(J)
	TLNE TAC,JSEG
	JRST SETMRS
	MOVM TAC,JOBQUE(J)	; IS HE RUNNABLE?
	CAIE TAC,TQ
	CAIN TAC,RUNQ
	JRST SETMRJ		; YES, GET SEPARATE MAXIMUM.
	CAMG DDB,MAXSIZ		;LARGEST SO FAR?
	JRST FORCE2		;NO
	MOVEM DDB,MAXSIZ	;YES, SAVE SIZE
	MOVEM J,MAXJBN		;AND JOB NUMBER
FORCE2:
	ADDB DDB,SUMCOR		;ADD TO TOTAL
	CAML DDB,NEEDED		;IS IT WHAT WE NEEDED
	AOS (P)			;YES
	POPJ P,

SETMRS:
	CAMG DDB,MAXSSZ
	JRST FORCE2
	MOVEM DDB,MAXSSZ
	MOVEM J,MAXSJB
	JRST FORCE2

SETMRJ:
	CAMG DDB,MAXRSZ
	JRST FORCE2
	MOVEM DDB,MAXRSZ
	MOVEM J,MAXRJB
	JRST FORCE2

; ROUTINE TO DECREMENT REFERENCE TO THIS JOB'S UPPER, IF ANY
; IF ALL REFERENCES HAVE BEEN SELECTED FOR SWAPOUT, THEN ADD
; IN THE UPPER SIZE TOO.

CJOB:
	LDB DDB,PSEGN		; PICK UP NUMBER OF UPPER
	JUMPE DDB,(QR)
	MOVE TAC,JBTSTS(DDB)	; IS UPPER IN CORE?
	SOSN CJOBS(DDB)		; DECREMENT REFERENCE COUNT
	TLNE TAC,SWP
	JRST (QR)
	PUSH P,J
	MOVE J,DDB
	HLRZ DDB,JBTADR(J)
	JUMPE DDB,CJBXIT
	PUSHJ P,SIZCHK		; UPDATE SUMCOR AND CHECK IF ENOUGH YET
	JRST CJBXIT		; NO, KEEP LOOKING
	SUB P,[XWD 1,1]		; YES, SWAP OUT LARGEST
	JRST FORCE6

CJBXIT:
	POP P,J
	JRST (QR)

; ALL SWAP RETURNS THROUGH HERE

SWPXIT:
	SKIPN FIT		; ARE WE FITTING SOMEBODY?
	SKIPE FORCE		; OR PERHAPS FORCING SOMEONE?
	SETZM SWPCNT		; IF SO, FIRE UP SWAPPER SOMETIME
	POPJ P,

FULL:
	POP PDP,TAC
	SOSL FULCNT		;PRINT MESSAGE EVERY 30 SECONDS
	POPJ PDP,
	MOVEI TAC,=30*JIFSEC
	MOVEM TAC,FULCNT
	JSP TAC,ERRPNT
	ASCIZ /SWAPPING DEVICE FULL/
	JRST EXCALP

;INPUT A JOB

INJOB:
	HGMAC(5)
	MOVEM J,FINISH		;SET FINISH FLAG TO INJOB
	AOS NINSWPS
	SETZM FIRSTOUT
	SETZM FIT		;CLEAR FIT FLAG
	LSH TAC,=10
	SUBI TAC,1
	SETZB JDAT,PROG		;NO CORE NOW
	PUSHJ PDP,CORGET
	JRST INJO3		; NOT AVAILABLE, FREE STORAGE SYSTEM MUST HAVE SNUK IN. RESCAN FOR INPUT.
INJO1:
	LDB DDB,IMGOUT		;GET OUTPUT IMAGE
	JUMPE DDB,FININ1	;DONT INPUT IF OUT IMAGE IS 0
	LDB TAC,IMGIN		;GET IN-CORE SIZE.
	CAML DDB,TAC		;SMALLER THAN OUT?
	MOVE DDB,TAC		;YES. READ ONLY WHAT WILL FIT.
	LSH DDB,=18+=10		;*BUILD IOWD FOR SQIN
	MOVN TAC1,DDB		;*
	HRR TAC1,JBTADR(J)	;*
	HLRZ TAC,JBTSWP(J)	;*GET DEVICE ADDRESS
	JRST SQIN		;*START INPUT

INJO3:
	SETZM FINISH
	SKIPN SHFWAT
	JRST SWP2
	SETZM SWPCNT
	POPJ P,

;XPAND SETS CONDITIONS TO GET MORE CORE FOR A JOB BY SWAPPING IT OUT
;THEN BACK IN TO DESIRED AMOUNT.
;JOBS POSITION IN QS NOT AFFECTED.
;CALL:
;	MOVE J,[JOB NO.]
;	MOVE TAC,[HIGHEST LEGAL ADDRESS DESIRED]
;	PUSHJ P,XPAND

↑XPAND:	PUSH P,DDB
	MOVE DDB,TAC		;ADDRESS TO 1K BLOCKS
	ROT DDB,-=10
	ADDI DDB,1
	DPB DDB,IMGIN
IFN FTSTAT,<
	EXCH TAC,DDB
	LSH TAC,6
	ANDI TAC,37700
	TRO TAC,CSZSTA
	PUSHJ P,STAPUT
	MOVE TAC,DDB
>;FTSTAT
	HLRZ DDB,JBTADR(J)
	JUMPE DDB,XPAND4	;ANY CORE IN MEMORY NOW? (NORMAL XPAND)
	SKIPE	XJOB(J)		;EXPAND FLAG ALREADY SET?
	JRST	XPAND3		;YES.  DONT INCREASE XJOB COUNT.
	SETOM	XJOB(J)		;SET EXPAND FLAG
	AOS	XJOB		;INCREASE COUNT OF JOBS TO EXPAND.
XPAND3:
	POP P,DDB
	SETZM SWPCNT
	POPJ P,

XPAND4:
	DPB DDB,IMGOUT		;CLEAR IMGOUT NOW
	MOVSI DDB,SWP
	IORM DDB,JBTSTS(J)	;AND MARK AS SWAPPED OUT
	JRST XPAND3

;XPAND1 COMPLETES ACTION REQUESTED BY XPAND.
;CALLED WHEN NO INPUT TO DO OR ON SEARCH FOR OUTPUT.

XPAND1:
	SKIPN	XJOB		;ANY JOBS TO EXPAND?
	POPJ	P,		;NO.
	MOVEI	J,JOBN		;SCAN FOR EXPANDING JOBS.
	SKIPN	XJOB(J)		;THIS JOB NEED TO EXPAND?
	SOJG	J,.-1
	SETZM	XJOB(J)		;CLEAR THIS JOB.
	JUMPE	J,XPAND2	;LOSE!
	SOS	XJOB		;REDUCE THE COUNT.
	SETOM XPANDF		;SET FLAG SO IMGIN WONT BE RESET
	SETZM	SWPCNT
	JRST FORCE0		;GO START OUTPUT

XPAND2:
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ /ππXJOB SET BUT NO JOB EXPANDING
/
	POPACS
	POPJ P,

SUBTTL	SWPSER	4 AUG 67

;PUT A REQUEST IN THE SWAPPING QUEUE. ENTER AT SQIN FOR
;	INPUT, SWOUT FOR OUTPUT
;CALL:	MOVE TAC1,XWD -NO. OF WORDS,FIRST CORE LOC.
;	HRRZ TAC,DISK BLOCK NO.
;	PUSHJ PDP,SQIN/SQOUT
;	RETURN HERE ALWAYS
;	CONTENTS OF TAC,TAC1 LOST

↑SQIN:
	SKIPE FBACT
	JRST FBIN
	TLO TAC,400000		;SET READ INDICATOR
↑SQOUT:
	SKIPE FBACT
	JRST FBOUT
	MOVEM TAC,SERA		;STORE THE BLOCK NUMBER
	MOVEM TAC1,SQREQ	;STORE THE IOWD
	MOVNI TAC,1		;IS THE DEVICE BUSY?
	EXCH TAC,DFBUSY
	JUMPN TAC,CPOPJ		;YES IF JUMP


ERATRY←←3	;NO. OF TIMES TO READ AND WRITE ON ERRORS

;START UP DEVICE WITH SWAPPING REQUEST.
;IF A SWAPPER REQUEST IS WAITING(SQREQ WILL BE NON-ZERO)

	MOVEI TAC1,ERATRY
	MOVEM TAC1,SERACT
	MOVE TAC1,SQREQ		;*PUT IOWD INTO TAC1
	MOVSI TAC,200000	;*SET "SWAPPER I/O GOING" FLAG ON
	ORB TAC,SERA		;*
	MOVM ITEM,FINISH	; PICK UP JOB NUMBER FOR OUTPUT
	HRROS ITEM		; MAKE LH NEG TO FLAG SWAP OPERATION
	TLZE TAC,400000		;*IS THIS JOB A READ?
	SOJA TAC1,DFRED		;*YES  -CALL DSKSER
	SOJA TAC1,DFWRT		;*NO, WRITE.

; FAST-BAND SWAPPER . .  .

FBOUT:
	MOVE DAT,[XWD J,JBTSWP]
	MOVEI DSER,MAXFB
FBOREQ:
	HLRZ UCHN,@DAT	; PICK UP SWAPPING BAND NUMBER
	JUMPN UCHN,FBOUT1
	MOVEI UCHN,(DSER)
	JRST FBOUT3
FBOUT1:
	HLRO DDB,TAC1
	MOVNS DDB
	SUBI DDB,1
	IDIVI DDB,=76*2000
	ADDI DDB,(DSER)
	CAMN DDB,UCHN
	JRST FBOUT6
	CAMG UCHN,DDB
	JRST FBOUT2
	PUSHJ P,FBGIVE		; TOO MANY BANDS. GIVE SURPLUS BACK.
	SUBI UCHN,1
	HRLM UCHN,@DAT
	JRST FBOUT1

FBOUT2:
	ADDI UCHN,1		; NOT ENOUGH. GET MORE BANDS.
FBOUT3:
	PUSHJ P,FBGET
	JRST FBOUT7
	HRLM UCHN,@DAT
	JRST FBOUT1

FBOUT7:
	MOVEM TAC1,DIOWD#
	MOVE TAC,[XWD FBCLK,1]
	CONO PI,PIOFF
	IDPB TAC,CLOCK
	CONO PI,PION
	POPJ P,

FBCLK:
	MOVM J,FINISH
	MOVE TAC1,DIOWD
	JRST FBOUT

; HERE WE HAVE ENOUGH BANDS, SET UP CALL

FBOUT6:
	MOVEI UCHN,(DSER)
	HRRZ TAC,TAC1
	HLRO AC2,TAC1
	MOVNS AC2
	SETZM TAC1
	SETOM SWPBSY#
	SETZM SERA
FBOUT4:
	CAIG AC2,=76*2000
	JRST FBOUT5
	PUSH P,TAC
	PUSH P,AC2
	PUSH P,DSER
	PUSH P,DAT
	MOVEI AC2,=76*2000
	MOVSI DAT,DONE1
	PUSHJ P,FBWRITE
	JRST FBERR1
	POP P,DAT
	POP P,DSER
	POP P,AC2
	POP P,TAC
	ADDI TAC,=76*2000
	SUBI AC2,=76*2000
	ADDI UCHN,1
	JRST FBOUT4

FBERR1:
	POP P,DAT
	POP P,DSER
	POP P,AC2
	POP P,TAC
	JRST FBERR

FBOUT5:
	MOVSI DAT,DONE
	PUSHJ P,FBWRITE
	JRST FBERR
	POPJ P,

DONE:
	SETZM SWPCNT
	SETZM SWPBSY
DONE1:
	HRRZM DAT,SERA
	POPJ P,

; LIBRASCOPE INPUT ROUTINE

FBIN:
	MOVE DAT,[XWD J,JBTSWP]
	MOVEI DSER,MAXFB
FBIREQ:
	HLRZ UCHN,@DAT
	HLRO DDB,TAC1
	MOVNS DDB
	SUBI DDB,1
	IDIVI DDB,=76*2000
	ADDI DDB,(DSER)
	CAMGE UCHN,DDB
	JRST FBINA
	MOVEI UCHN,(DSER)
	HRRZ TAC,TAC1
	HLRO AC2,TAC1
	MOVNS AC2
	SETZM TAC1
	SETOM SWPBSY
	SETZM SERA
FBIN2:
	CAIG AC2,=76*2000
	JRST FBIN1
	PUSH P,TAC
	PUSH P,AC2
	PUSH P,DSER
	PUSH P,DAT
	MOVEI AC2,=76*2000
	MOVSI DAT,DONE1
	PUSHJ P,FBREAD
	JRST FBERR1
	POP P,DAT
	POP P,DSER
	POP P,AC2
	POP P,TAC
	ADDI TAC,=76*2000
	SUBI AC2,=76*2000
	ADDI UCHN,1
	JRST FBIN2

FBIN1:
	MOVSI DAT,DONE
	PUSHJ P,FBREAD
	JRST FBERR
	POPJ P,

; LIBRASCOPE SWAPPING ERROR ROUTINES

FBERR:
	SETZM SWPCNT
	SETZM SWPBSY
	SETOM SERA
	JRST FINSWP

FBINA:
	JUMPE UCHN,FBINB
	SUBI UCHN,-1(DSER);;replaced;;SUBI UCHN,(DSER)-1
	MOVNI DDB,=76*2000
	IMULI DDB,(UCHN)
	HRL TAC1,DDB
	JRST FBIN

FBINB:
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/SWAP REQUEST WITH NO BANDS.
J=/]
	DISARG(DCP,<-20+J(P)>)
	[ASCIZ/
/]
	-1
	POPACS
	JRST FBERR	;ERROR OUT

;FIND A SERIES OF BLOCKS ON THE DISK TO SWAP ONTO. CALLED
;AT CLOCK LEVEL.
;CALL:	MOVEI DAT,NO. OF 1K BLOCKS DESIRED
;	PUSHJ PDP,GXSAT
;	ERROR EXIT	(DISK IS FULL)
;	NORMAL EXIT	;C(TAC) = BLOCK NO.

;CONTENTS OF ACS TAC,TAC1,DAT WILL BE LOST.



↑GXSAT:
	SETZM TAC
	SKIPE FBACT
	JRST CPOPJ1
	MOVE TAC,ITEM	;PUT IT ON BAND NUMBER;JS
	IMULI TAC,1140	;CORRESPONDING TO ITS JOB NUMBER
	AOS (PDP)	;ALWAYS GIVE OK RETURN
↑FXSAT:	POPJ PDP,	;DONT NEED FXSAT

SWPINI:
	SETZM SWPBSY
	SETZM SWPCNT
	SETZM FIT
	SETZM FORCE
	SETZM FINISH
	SETZM SERA
	POPJ PDP,

>
BEND SCHEDU
;: SCHEDU[J17,SYS] EOF.
;: CORE[J17,SYS]
COMMENT ⊗   VALID 00033 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	CORE ROUTINES FOR SWAPPING SYSTEM. 4 AUG 67 
 BEGIN CORE
C00007 00003	CORINI	INITIALIZE CORE TABLES
C00010 00004	CORE UUO
C00017 00005	SHUFFLER   CHKSHF
C00026 00006	ANYACT	ROUTINE TO TEST FOR ANY ACTIVE DEVICES
C00034 00007	CORE0
C00038 00008	ENTER HERE FROM CORE UUO OR RUN COMMAND WHEN IT REASSIGNS
C00043 00009	BAKOLD:
C00045 00010	MOVE OLD CORE TO NEW AREA
C00051 00011	DIDDLE
C00055 00012	CSTAT, STAPUT, STAPTT		STATISTICS SERVICE
C00058 00013	HOLSRC	
C00061 00014	CORCHK AND CORTCK  -- CHECK CORTAL AGAINST CORTAB AND CHECK CORTAB AGAINST WORLD
C00066 00015	CORSTG		ROUTINE TO SET AND CLEAR CORE USE TABLE
C00069 00016	CLRJOB
C00071 00017	GETPR
C00074 00018	RELOCA
C00079 00019	LOCK AND UNLOCK UUOS.
C00089 00020	FREE STORAGE	AND OTHER POLITICAL PRISONERS
C00090 00021	$	INITIALIZE FREE STORAGE
C00097 00022	$	FSGET:	GET FREE STORAGE AT ANY LEVEL.
C00108 00023	SWIPE 1K FROM AVAILABLE USER SPACE.
C00113 00024	$FSCLK:	CLOCK LEVEL (CHANNEL 7) ROUTINES TO KEEP FREE STORAGE HAPPY!
C00118 00025	$	FSGIVE:	RETURN FREE STORAGE TO SYSTEM.
C00128 00026	GET FREE STORAGE AT UUO LEVEL.
C00129 00027	 ROUTINES TO GET AND RELEASE THE PDL AT UUO LEVEL ONLY. - GETPDL
C00133 00028	SPARE LIST HANDLER FOR DPYSER & TTYSER
C00136 00029	VERSION OF FSGET TO USE SPARE LIST
C00139 00030	ARRRGH! PI LEVEL AND NO FAILURE POSSIBLE! HERE WE CURL UP AND DIE
C00140 00031	VERSION OF FSGIVE TO THINK ABOUT PUTTING RETURNED BLOCK INTO SPARE LIST
C00142 00032	YES FANS, IT'S THE INFAMOUS RELEX, FORMERLY SCATTERED THROUGH TTYSER & DPYSER
C00145 00033	BEND CORE
C00146 ENDMK
C⊗;

SUBTTL	CORE ROUTINES FOR SWAPPING SYSTEM. 4 AUG 67
BEGIN CORE

COMMENT $
	REVISED, MAY 1972 BY REG

	CORE IS ALLOCATED ON A 1K BLOCK BASIS.  A TABLE OF 257  9-BIT
BYTES  (CORTAB)  IS  KEPT.  EACH  BYTE  CORRESPONDS  TO A 1K BLOCK OF
ADDRESSABLE MEMORY (EXCEPT THE LAST WHICH IS ALWAYS NON-EXISTANT).  A
BYTE IS MARKED WITH THE FOLLOWING CODES:

	0	BLOCK IS AVAILABLE.
	1-77	BLOCK IS IN USE BY THE JOB NAMED IN THIS CODE
	101	BLOCK IS OCCUPIED BY THE SYSTEM
	103	BLOCK DOES NOT EXIST.
	105	BLOCK IS IN USE BY SYSTEM FREE STORAGE.

	WHEN THE SYSTEM IS LOADED OR  INITIALIZED,  CORINI  SETS  THE
CORTAB  TABLE TO REFLECT BLOCKS IN USE BY THE SYSTEM AND NON-EXISTANT
BLOCKS.  CORINI ALSO SETS  RMEMSIZ,  THE  SIZE  OF  PHYSICAL  MEMORY,
MEMSIZ,  THE  BOTTOM OF FREE STORAGE, AND LOCATION 37, SYSTEM JOBREL.
CORINI ALSO MAKES TWO BYTE POINTERS, CORLST IS  A  POINTER  PAST  THE
FIRST  NON-EX  BLOCK IN CORTAB; CORE2P IS A POINTER TO THE LAST BLOCK
USED  BY  SYSTEM  CODE.  CORTAL  IS  SET TO THE NUMBER OF FREE BLOCKS
AVAILABLE.

	CORE1  ASSIGNS  CORE TO A JOB, IF POSSIBLE, SETS THE USE CODE
IN CORTAB, AND MOVES THE JOB IF THIS ASSIGNMENT  IS  AT  A  DIFFERENT
PLACE THAN THE OLD.

THE TABLE, JBTADR, IS ALSO UPDATED BY THE CORE ROUTINES.
	JBTADR CONTAINS: PROTECTION,,RELOCATION OF A JOB.
	JBTADR  IS  MODIFIED  IF  CORE  FOR  CURRENT JOB THE HARDWARE
PROTECTION/RELOCATION REGISTER IS RESET IF THIS IS  THE  CURENT  JOB.
ALSO, JOBREL IN USER'S JOB DATA AREA IS ALWAYS UPDATED.

$

;LIST OF GLOBALS AFFECTED:
;JBTADR,CORTAL,CORTAB,HOLEF,SHFWAT,JOBADR

;ACS USED(BESIDES TAC,TAC1,JDAT,IOS,DEVDAT,AND P)
BLK←AC1		;HIGHEST REL. ADR. IN USER AREA
LOC←DSER	;ABS. LOC. OF FIRST BLOCK IN USER AREA

;CORINI	INITIALIZE CORE TABLES
;REG THIS PAGE. 1972: 22 FEB, 15 APRIL, 28 APRIL.

COREP:
	POINT	9,CORTAB
	POINT	9,CORTAB,8
	POINT	9,CORTAB,17
	POINT	9,CORTAB,26
↑CORINI:
	MOVE	TAC,[XWD CORBEG,CORBEG+1]
	SETZM	CORBEG
	BLT	TAC,COREND

	SETZM	LOCKNO		;NO JOB IS ATTEMPTING TO LOCK
	MOVE	TAC,SYSTOP
	MOVEM	TAC,LOKTOP	;TOP OF LOCKED CORE IS SAME AS SYSTEM TOP.

	MOVE	TEM,COREP	;BYTE POINTER TO CORTAB
	MOVEI	TAC,CORBLK	; =256, MAXIMUM MEM SIZE
	CONO	APR,NXM		;SHUT OFF NXM FLAG
	TDZA	TAC1,TAC1	;BEGIN ZERO AND SKIP INCREMENT
CORI1:
	ADDI	TAC1,2000	;INCREMENT ADDRESS
	HLLZ	DAT,(TAC1)	;REFERENCE MEMORY - ZERO RIGHT SIDE OF DAT
	CAMGE	TAC1,SYSSIZ	;SKIP IF ADDRESS IN SYSTEM
	TROA	DAT,2		;IN SYSTEM CODE WILL BE 103
	CONSZ	APR,NXM		;SKIP UNLESS NXM
	TRCA	DAT,103		;NXM CODE IS 103, IF SYSTEM, SET TO 101
	AOS	CORTAL		;THIS BLOCK OF CORE IS AVAILABLE.
	IDPB	DAT,TEM		;MARK THIS BLOCK IN CORTAB
	TRNE	DAT,2		;SKIP IF NO NXM
	JRST	CORI2		;NXM. QUIT NOW.
	TROE	DAT,103		;SET NXM CODE, SKIP IF BEYOND SYSTEM
	MOVEM	TEM,CORE2P	;SAVE CORE2P
	SOJG	TAC,CORI1	;LOOP IF STILL INSIDE POSSIBLE MEMORY
	ADDI	TAC1,2000	;FULL HOUSE.
	IDPB	DAT,TEM
CORI2:
	MOVEM	TAC1,RMEMSIZ	;SAVE FIRST PHYSICAL NON-EX ADDRESS 
	MOVEM	TAC1,MEMSIZ	;SETUP LOWEST ADDRESS IN FREE STORAGE
	SUBI	TAC1,1		;DECREMENT TO MAKE SYSTEM JOBREL
	MOVEM	TAC1,37		;SAVE SYSTEM JOBREL FOR EXEC DDT AND UEDDT
	IBP	TEM		;INCREMENT TO POINT TO 2ND NONEX DATA IN CORTAB
	MOVEM	TEM,CORLST	;SAVE AS POINTER PAST ALL REAL MEMORY,
IFN FTSWAP,<
	MOVE	TAC,CORTAL	;GET SIZE OF USER CORE
	LSH	TAC,=10		;TURN K INTO WORDS
	MOVEM	TAC,CORMAX	;SAVE AS MAX SIZE OF USER CORE
	MOVEI	TAC,%SWPL
	MOVEM	TAC,SWAPLI	;SET SYSTEM SWAPLIMIT.
>
	POPJ	P,

SUBTTL	CORE UUO

COMMENT $
CALL BY:
	MOVEI	AC,<HIGHEST RELATIVE ADDRESS DESIRED>
	CALL	AC,['CORE  ']	OR 	CALLI	AC,11
	<ERROR RETURN: CAN'T ASSIGN CORE>
	OK RETURN.  JOB MAY HAVE BEEN SHUFFLED OR SWAPPED.

THE NUMBER OF 1K BLOCKS THAT A JOB MAY HAVE IS RETURNED IN AC.
IF AC CONTAINS 0 THEN DO NOT CHANGE CORE ALLOCATION, JUST
RETURN NUMBER OF AVAILABLE BLOCKS IN AC (ERROR RETURN).

$


↑CORUUO:
	JUMPE	TAC,ZERCOR		;IS ARGUMENT ZERO?
	AOS	(P)			;ASSUME SUCCESS RETURN.
	PUSHJ	P,UNLOCK		;CORE UUO WILL FORCE UNLOCK.
	PUSHJ	P,UCORE			;DO IT!!
	SOS	(P)			;BAD ASSUMPTION. FAILURE RETURN.
ZERCOR:
	MOVE	TAC,CORMAX		;GET CURRENT FREE SPACE.
	CAMLE	TAC,SWAPLIMIT		;MORE THERE THAN HE CAN HAVE?
	MOVE	TAC,SWAPLIMIT		;YES. TELL HIM MAX WE'LL ALLOW.
	ASH	TAC,-12			;CONVERT TO BLOCKS!
	JRST	STOTAC			;RETURN CORMAX TO USER

↑UCORE:	IORI	TAC,1777		;ROUND UP TO A 1K BOUNDARY.
	MOVE	TAC1,JBTSTS(J)		;GET JOB STATUS
	TLNN	TAC1,JSEG		;AND SKIP IF THIS IS AN UPPER.
	JRST	CORCS2			;NOT AN UPPER.
	PUSH	P,J			;SAVE UPPER'S JOB NUMBER.
	MOVEI	J,JOBN-1		;LOOK THRU ALL JOBS...
CORCSO:
	LDB	TAC1,PSEGN		;DOES THIS GUY POINT TO ME?
	CAME	TAC1,(P)		;SKIP IF A USER OF THIS UPPER.
	JRST	CORCSL			;NO.
	MOVE	TAC1,J			;TAC ← JOB NUMBER OF THIS LOWER.
	PUSHJ	P,CORSGT		;GET THE SIZE OF THIS LOWER.
	ADDI	TAC1,1(TAC)		;LOWER SIZE + MY REQUEST SIZE.
CORCS3:
	CAMG	TAC1,CORMAX		;TOO BIG?
	JRST	CORCSL			;NOT TOO BIG. CHECK OTHER LOWERS.
	POP	P,J			;THIS LOWER AND ME WONT FIT
	POPJ	P,			;GIVE THE ERROR RETURN.

CORCSL:
	SOJG	J,CORCSO		;CONTINUE SCAN THRU ALL JOBS.
	POP	P,J			;RESTORE J
	JRST	CORXOK			;SO FAR, SO GOOD.

CORCS2:
	LDB	TAC1,PSEGN		;NOT A SEGMENT. HAS IT AN UPPER?
	SKIPE	DAT,TAC1		;SKIP IF NO UPPER. GET NUMBER IN DAT
	PUSHJ	P,CORSGT		;GET SIZE OF UPPER IN TAC1.
	ADDI	TAC1,1(TAC)		;UPPER'S SIZE + THIS REQUEST.
	CAMLE	TAC1,CORMAX		;DOES IT FIT?
	POPJ	P,			;NOPE.
CORXOK:
	PUSH	P,TAC			;SAVE SIZE WE WANT TO BE.
	PUSH	P,UUO			;SAVE
	PUSH	P,J			;SAVE J IF THIS IS A SEGMENT.
	PUSHJ	P,IOWAIT		;WAIT FOR ALL IO TO STOP.
	JRST	.+2
CORYOK:
	PUSHJ	P,WSCHED
	PUSHJ	P,ANYACT		;MAKE SURE WE CAN BE MOVED.
	JRST	CORYOK			;NO. WAIT UNTIL WE CAN.
	POP	P,J			;RESTORE J
	POP	P,UUO
	POP	P,TAC			;HIGHEST REL. LOC. DESIRED
	AOS	(P)			;SET SKIP RETURN.
CORUU1:
	SKIPE	PROG,JBTADR(J)		;PICK UP PROG 
					;COULD HAVE BEEN CLOBBERED IF IT'S AN UPPER.
	JRST	CORUU5			;JUMP IF WE HAVE CORE ALREADY.
	PUSHJ	P,CORGET		;NO: DON'T RELEASE PREVIOUS CORE
	SOS	(P)			;FAILURE RETURN.
	JRST	CORUU3

CORUU5:
	PUSHJ	P,CORE1			;TRY TO REASSIGN CORE
	SOS	(P)			;NOT AVAILABLE, ERROR RETURN

CORUU3:

IFN FTSWAP,<
	PUSHJ	P,WSCHED		;CALL SCHEDULER TO STOP JOB
					;IN CASE CORE NOW ON DISK.
>
	MOVE	TAC1,JBTSTS(J)
	TLNN	TAC1,JSEG		;SKIP IF THIS IS AN UPPER.
	JRST	SPWCNT			;CONTINUE SPACEWAR FOR THIS JOB
	JRST	NOTSH9			;CONTINUE SPACEWAR FOR ALL LOWERS.

;RUNCOR IS CALLED FROM SAVGET, (NOT CORUUO) (SINCE IT DOESN'T STORE ANYTHING?)

↑RUNCOR:
	AOS	(P)			;ASSUME SUCCESS.
	PUSHJ	P,CORE1			;TRY TO ASSIGN CORE.
	SOS	(P)			;WE SET FAILURE RETURN
	JRST	WSCHED			;HOLD UP IF CORE IS NOW ON DISK.

↑CORSGT:				;GET SIZE OF THIS JOB, WHETHER IN OR OUT.
	PUSH	P,TAC			;SAVE TAC
	MOVE	TAC,JBTSTS(TAC1)	;GET JOB STATUS
	TLNN	TAC,SWP			;SKIP IF ON DISK,
	JRST	CORSG1			;HE'S IN CORE.
	LDB	TAC1,[POINT 9,JBTSWP(TAC1),35]	;GET THE SIZE OF THE IMAGE
	LSH	TAC1,=10		;SHIFT TO MAKE WORDS.
	JRST	TPOPJ			;RESTORE TAC AND RETURN.
CORSG1:
	HLRZ	TAC1,JBTADR(TAC1)	;GET THE PROTECTION SIZE
	AOJA	TAC1,TPOPJ		;INCREMENT PROT, POP TAC AND RETURN

SUBTTL	SHUFFLER   CHKSHF

;ROUTINE TO CHECK JOBS TO SEE IF ANY JOB CAN BE SHUFFLED
;CALLED FROM THE SWAPPER WHEN THERE IS ENOUGH FREE CORE
;TO FIT A JOB, BUT THERE IS NO SINGLE HOLE BIG ENOUGH.
;
;A JOB MUST HAVE ALL DEVICES INACTIVE (SINCE SOME
;OF THEM USE ABSOLUTE ADDRESSES) BEFORE IT CAN BE MOVED.
;IF DEVICES ARE ACTIVE, JOB WILL BE STOPPED SO THAT IO WILL
;CEASE SOON SO JOB CAN BE SHUFFLED
;ALL DEVICES LOOK AT SHF BIT IN JBTSTS (ADVBFF OR ADVBFE)
;TO SEE IF MONITOR IS WAITING TO SHUFFLE JOB

;THIS VERSION OF THE CORE SHUFFLER WORKS AS FOLLOWS:
;EVERY CLOCK TICK FOR WHICH ALL JOBS ARE SHUFFLEABLE (NOT COUNTING ACTIVE
;IO DEVICES), THE JOB IMMEDIATELY ABOVE THE LOWEST HOLE
;(IF ANY) WILL BE MOVED DOWN INTO HOLE.  THE HOLEF IS SET NON-ZERO
;TO THE ADDRESS OF JOB IMMEDIATELY ABOVE THE LOWEST
;HOLE (0 IF NONE), EVERY TIME CORE IS REASSIGNED.

↑CHKSHF:
	HGMAC	(26)
	SKIPE	J,SHFWAT	;DID WE STOP A JOB TO WAIT FOR IO INACTIVE?
	JRST	SHFLOP		;YES, SEE IF IO HAS STOPPED YET
	SKIPN	TAC,HOLEF	;NO, DOES CORE HAVE A HOLE IN IT?
	JRST	CHKSHX
CHKSHZ:
	CAML	TAC,MEMSIZ
	JRST	CHKERR
	PUSHJ	P,CORGB1	;MAKE A BYTE POINTER FROM HOLEF
	ILDB	J,TAC		;GET A USE BYTE
	CAIGE	J,JOBN		;VALIDITY CHECK-SKIP IF ILLEGAL
	JUMPG	J,SHFLOA	;FOUND ONE?
SHFLOB:
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/HOLEF = /
	MOVE	TAC,HOLEF
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/  BUT NO HOLE PRESENT. CORTAB = /
	MOVE	LOC,HOLEF
	PUSHJ	P,CORGBP	;GET A BYTE POINTER.
	ILDB	J,TAC		;GET THE BYTE.
	CAIL	J,JOBN
	JRST	HOLHLP
	PUSH	P,J
	PUSHJ	P,DISJOB	;PRINT JOB NAME & NUMBER.
	PUSHJ	P,DISCRLF
	POP	P,TAC
	HRRZ	TAC1,JBTADR(TAC)	;TAC1←BOTTOM OF JOB
	HLRZ	TAC,JBTADR(TAC)
	ADDI	TAC,(TAC1)		;TAC← TOP OF JOB.
	CAMG	TAC1,HOLEF	;SKIP IF HOLEF BELOW THE BOTTOM
	CAMG	TAC,HOLEF	;SKIP IF HOLEF INSIDE THIS IMAGE.
	JRST	.+2		;WE CAN FIX THIS?
	JRST	HOLHLP		;WE NEED HELP.
	MOVE	LOC,HOLEF
	PUSHJ	P,CORGBP
	MOVEI	TAC1,0
	IDPB	TAC1,TAC
	JRST	HOLFIX

HOLHLP:
	PUSHJ	P,DISMES
	ASCIZ	/I CAN'T FIX IT.
/
	PUSHJ	P,DISFLU
	PUSHJ	P,DDTCAL
HOLFIX:
	POPACS
	JRST	CHKSHX

CHKERR:
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/ππHOLEF OUT OF BOUNDS
/
	POPACS
	SETZM	HOLEF
CHKSHX:
	SOS	(P)		;SET UP SWAPPER'S PARAMETERS AGAIN
	PSYNC	CORCSC
	JRST	DIDLE4

SHFLOA:
	HRRZ	TAC,JBTADR(J)
	CAME	TAC,HOLEF
	JRST	SHFLOB		;LOSER!

;THIS CODE DECIDES WHETHER TO SWAP INSTEAD OF SHUFFLE
	SKIPN	JBTST2(J)	;IS THERE SPACEWAR ACTIVE FOR THIS JOB?
	SKIPG	TAC,FIT		;NO.  AND SOMEONE BEING FITTED IN?
	JRST	SHFLOP		;SPACEWAR ACTIVE OR NO ONE BEING FITTED
	MOVE	TAC,JBTPRI(TAC)	;PRIORITY OF JOB BEING FITTED.
	CAMG	TAC,JBTPRI(J)	;SKIP IF SHUFFLED JOB HAS LOW PRIORITY.
	JRST	SHFLOP		;SHUFFLED JOB HAS HIGH PRIORITY, DON'T FORCE IT
	MOVE	TAC,SEGWAIT
	LDB	TAC,[POINT 6,JBTSTS(TAC),35]
	CAIN	TAC,(J)		;IS THIS THE SEGMENT THAT SOMEONE IS WAITING FOR?
	JRST	SHFLOP		;YES. DON'T SHOVE IT OUT!
	SKIPE	FORCE		;IF FORCE IS SET THEN WE CAN'T MAKE US SWAP
	JRST	SHFLOZ		;TELL PEOPLE THAT WE HAVE LOST.
SHFLOX:
	JRST	SHFLOP		;CLOBBER THIS TO JFCL TO MAKE IT SWAP INSTEAD

	MOVSI	TAC,SWP
	IORM	TAC,JBTSTS(J)	;ANNOUNCE THAT WE ARE SWAPPING THIS GUY.
	MOVEM	J,FORCE
	POPJ	P,		;TELL THEM WE WANT TO SWAP THIS USER

SHFLOZ:
	PUSH	P,J		;THIS MESSAGE IS FOR INFORMATION ONLY!
	PUSHJ	P,DISMES
	ASCIZ	/[FORCE SET AT SHFLOZ]
/
	POP	P,J

SHFLOP:
	JUMPL	J,CPOPJ		;JUMP IF A JOB IS ALREADY MOVING.
	SKIPN	PROG,JBTADR(J)	;SETUP PROG FOR CALL
	JRST	NOTSH1		;NO CORE. HE CAN'T BE SHUFFLED, SO CLEAR SHFWAT
IFN JDMPRG,<
	MOVE	JDAT,JBTDAT(J)	;JOB DATA AREA
>
	HLRZ	TAC,PROG	;REASSIGN SAME AMOUNT OF CORE.
	PUSHJ	P,SHFCOR	;IN A LOWER POSITION IN CORE
	JRST	NOTSHF		;CANNOT ONLY IF IO IS ACTIVE

IFN FTSHF1K,<
	SKIPE	SHFJOB		;IF FINISHED, CLEAN UP SHF BIT AND OTHER CELLS
	POPJ	P,		;OTHERWISE, RETURN, LETTING CLOCK DO THE MOVING
>
	JRST	NOTSH1		;FINISHED SHUFFLING, CLEAN UP

NOTSHF:
	SKIPN	HOLEF		;JOB CAN'T BE MOVED.  STILL ACTIVE IO.
	JRST	NOTSH1		;HOLE ISN'T THERE ANYMORE?
IFN FTSWAP,<
	MOVM	TAC,FORCE
	CAME	J,FIT
	CAMN	J,TAC
	JRST	NOTSH1		;IF THIS JOB IS BEING SWAPPED, DON'T SHUFFLE
>
	MOVEM	J,SHFWAT	;SET SHUFFLE WAIT FLAG WITH JOB NO.
	MOVSI	TAC,SHF		;SET SHF WAIT BIT IN JOB STATUS WORD
	SKIPN	JBTST2(J)	;IF SPW RUNNING, LET HIM RUN TOO
	IORM	TAC,JBTSTS(J)	;SO JOB WILL NOT BE RUN
	POPJ	P,		;AND IO WILL STOP SOON

↑NOTSH1:			;HERE WHEN JOB FINISHES MOVING
	PSYNC	CORCSC
	SETZM	SHFWAT		;JOB SHUFFLED, CLEAR FLAG
IFN FTSHF1K,<
	SETZM	SHFTAC		;CLEAR SHUFFLE FLAGS WHEN DONE
	SETZM	SHFEND
	SETZM	SHFJOB
>
	MOVSI	TAC,SHF		;CLEAR SHUFFLE WAIT BIT IN CASE IT WAS ON
	ANDCAB	TAC,JBTSTS(J)
	SKIPN	JBTADR(J)
	JRST	NOTSH4		;IF WE DON'T HAVE CORE, DON'T CONTINUE SPACEWAR
	TLNE	TAC,JSEG
	JRST	NOTSH6		;YES.
	PUSHJ	P,SPWCNT	;THIS IS A LOWER, CONTINUE SPACEWAR FOR HIM
	JRST	NOTSH4
 
NOTSH9:
	MOVEI	TAC1,(J)	;THIS IS AN UPPER, FIND OUR LOWERS.
				;(CALLED FROM CORE2 UUO, AND FROM NOTSH6)
	MOVEI	J,JOBN-1	;AND CONTINUE THEIR SPACEWAR.
NOTSH3:
	MOVE	TAC,JBTSTS(J)
	ANDI	TAC,77		;PSEGN BETTER POINT TO BITS 30-35.
	CAIN	TAC,(TAC1)	;IS THIS ONE OF MY LOWERS?
	PUSHJ	P,SPWCNT	;YES. CONTINUE HIS SPACEWAR.
	SOJG	J,NOTSH3	;LOOP LOOKING FOR ALL LOWER USERS OF THIS SEG.
	MOVEI	J,(TAC1)	;RESTORE J.
	POPJ	P,

NOTSH6:
	PUSHJ	P,NOTSH9	;CONTINUE SPACEWAR FOR LOWERS OF THIS UPPER.
NOTSH4:


IFN FTSHF1K,<
	SKIPN	SHFBLK		;ANY CORE TO RETURN?
	JRST	NOTSH2		;NO.
	HRRZ	LOC,SHFBLK
	HLRZ	BLK,SHFBLK
	SETZB	UCHN,SHFBLK
	PUSHJ	P,CORSTG	;YES. RETURN IT.
>

NOTSH2:
	SOS	(P)		;DIDLE SKIP RETURNS
	JRST	DIDLE4		;RE-FORM CORE AVAIL PARAMS.

↑SPWCNT:			;CONTINUE A SPW JOB
	SKIPN	JBTST2(J)	;IS THERE A SPW JOB HERE??
	POPJ	P,		;NO.
	PSYNC	SPWCSC
	MOVSI	TAC,SPWST1!SPWST2
	ANDCAM	TAC,JBTST2(J)
	XSYNC	SPWCSC
	POPJ	P,

SUBTTL	ANYACT	ROUTINE TO TEST FOR ANY ACTIVE DEVICES
COMMENT  $
CALLING
	MOVE	J,JOB NUMBER
	MOVE	JDAT,ADDRESS OF JOB DATA AREA
	PUSHJ	P,ANYACT
	<HERE IF DEVICES ACTIVE>
	<HERE IF NO DEVICE IS ACTIVE, EXCEPT POSSIBLY TTY>
$

↑ANYACT:
	MOVE	UCHN,JBTSTS(J)		;GET JOB STATUS
	TLNN	UCHN,JSEG		;SKIP IF THIS IS AN UPPER
	JRST	ANYAC3			;THIS IS A LOWER
	PUSH	P,PROG			;SAVE VITAL DATA.
	PUSH	P,J			;SAVE THIS JOB NUMBER.
	MOVEI	J,JOBN-1		;SEARCH THRU ALL JOBS.
ANYAC1:
	LDB	UCHN,PSEGN		;LOOKING FOR LOWERS THAT POINT HERE
	CAME	UCHN,(P)		;DOES THIS POINT TO ME.
ANYA1A:
	SOJG	J,ANYAC1		;NO. DECREMENT J AND LOOP
	JUMPLE	J,ANYAC2		;JUMP IF WE HAVE EXHAUSTED THE LOOP
	MOVE	PROG,JBTADR(J)		;YES. GET HIS ADDRESS
	PUSHJ	P,ANYAC3		;CALL ROUTINE FOR A LOWER SEGMENT
	CAIA				;LOSE. CANT MOVE THIS LOWER
	JRST	ANYA1A			;THIS LOWER DOESN'T CARE IF WE MOVE
	POP	P,J
	POP	P,PROG
	POPJ	P,			;FAILURE RETURN

ANYAC2:
	POP	P,J			;RESTORE JOB NUMBER
	POP	P,PROG
	JRST	CPOPJ1			;SUCCESS RETURN.

ANYAC3:
	SKIPN	JBTADR(J)		;ANY CORE THERE?
	JRST	CPOPJ1			;NO CORE MEANS NO IO ACTIVE.
	SKIPE	JBTGLU(J)		;IS SOMEONE GLUEING HIM?
	POPJ	P,			;YES. FAKE ACTIVE DEVICE.
	MOVEI	UCHN,JOBJDA(JDAT)	;ASSUME JOB IS NOT CURRENT JOB
	CAMN	J,JOB(PID)		;IS IT CURRENT JOB?
	MOVEI	UCHN,USRJDA(PID)	;YES. GET DATA FROM MONITOR.
	MOVEI	IOS,IOACT		;IO DEVICE ACTIVE BIT
	SKIPL	AC2,JOBJMH(UCHN)	;GET NO. OF USER IO CHANNELS IN USE
	CAILE	AC2,17			;IS HIGHEST CHANNEL LEGAL?
	JRST	ANY3			;SAVEGET IO ACTIVE  OR ILLEGAL CHANNEL.
	TLO	UCHN,AC2		;SET TO ADD UCHN TO AC2
	MOVSI	TAC1,DVTTY		;DEVICE IS A TTY BIT
ANY:
	HRRZ	DDB,@UCHN		;IS A DEVICE ASSIGNED TO THIS CHANNEL?
	JUMPE	DDB,ANY2		;NO.
	CAIL	DDB,CHKBEG		;CHECK ADDRESS. SKIP IF LOW CORE
	CAML	DDB,MEMSIZ		;SKIP IF BELOW F.S. (NO NO)
	CAML	DDB,RMEMSIZ		;BELOW REAL MEM? (REDUNDANT FOR LOW CORE)
	JRST	ANY7			;LOSING ADDRESS
	TDNN	IOS,DEVIOS(DDB)		;YES, IS IT ACTIVE?
ANY2:
	SOJGE	AC2,ANY			;NOT ACTIVE KEEP LOOKING
	JUMPL	AC2,ANY4A		;JUMP IF FINISHED LOOKING
	TDNN	TAC1,DEVMOD(DDB)	;NOT FINISHED, IS DEVICE TTY?
	POPJ	P,			;NOT TTY DEVICE ACTIVE. CANT MOVE THIS JOB
	JRST	ANY2			;DEVICE IS TTY.  LOOK AT OTHER DEVICES

ANY4A:
	SKIPL UCHN,JBTIOP(J)
	JRST ANY4
ANY4BA:
	SKIPN DDB,(UCHN)		;GET DDB POINTER (SKIP FLUSHED ONES)
	JRST ANY4C
	TDNE IOS,DEVIOS(DDB)		;IOACT ON?
	TDNE TAC1,DEVMOD(DDB)		;YES, TTY?
	CAIA				;YES (TTY) OR NO (IOACT)
	POPJ P,				;ACTIVE IO
ANY4C:
	ADD UCHN,[1,,1]			;ADVANCE TO CHANNEL NUM
	AOBJN UCHN,ANY4BA		;ADVANCE TO NEXT DDB AND TEST
	JRST ANY4

ANY7:
	PUSHACS				;DDB ADDRESS IS OUT OF BOUNDS.
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ANY7: ILLEGAL DDB ADDRESS = /
	HRRZ	TAC,DDB-17(P)		;PICK UP ADDRESS
	PUSHJ	P,DISLOC		;TYPE ADDRESS IN OCTAL
	PUSHJ	P,DISTAB
	MOVE	J,J-17(P)
	PUSHJ	P,DISJOB
	PUSHJ	P,DISMES
	ASCIZ	/ USER IO CHANNEL /
	MOVE	TAC,AC2-17(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	MOVE	J,J-17(P)
;	PUSHJ	P,DATERR		;FIX JOB DATA AREA.
	POPACS
	SETZM	@UCHN			;BLAST ILLEGAL DDB POINTER
	JRST	ANY2

ANYHCC:
	PUSHACS	
	PUSHJ	P,DISDAT
	PUSHJ	P,DISMES
	ASCIZ	/JOBHCU CLOBBERED AT ANYACT. /
	MOVE	J,J-17(P)
	PUSHJ	P,DISJOB
	PUSHJ	P,DISMES
	ASCIZ	/  JOBHCU = /
	MOVE	TAC,AC2-17(P)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
	MOVE	J,J-17(P)
;	PUSHJ	P,DATERR		;FIX JOB DATA AREA
	POPACS
	SETZM	JOBJMH(UCHN)		;SET ONLY USER CHANNEL 0 IN USE.
	SETZM	(UCHN)			;CLEAR USER CHANNEL 0.
	JRST	CPOPJ1			;FAKE SUCCESS RETURN.

ANY3:
	JUMPG	AC2,ANYHCC		;JOBHCU IS CLOBBERED.
	HRRZ	AC2,AC2			;ADDRESS ONLY, PLEASE!
	CAIL	AC2,CHKBEG		;SKIP IF IN SYSTEM LOW CORE.
	CAML	AC2,MEMSIZ		;NO. MUST BE IN FREE STORAGE.
	CAML	AC2,RMEMSIZ		;IF IN F.S.  MUST BE IN REAL MEM.
	JRST	ANYILM			;WE LOSE.
ANY3A:
	TDNN	IOS,DEVIOS(AC2)		;IS SAVEGET DEVICE STILL ACTIVE?
	AOS	(P)			;NO
	POPJ	P,			;YES

ANYILM:
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ANYILM: SAVGET JOBCHU - ILLEGAL DDB ADDRESS.
/
	POPACS
	JRST CPOPJ1			; PRETEND SUCCESSFUL

ANY4:
	SKIPE	JBTIIP(J)		; INTERRUPT IN PROGRESS
	POPJ	P,			;YES. CAN'T MOVE ME.
	SKIPN	SP2GO(J)		; IS A P2 SPACEWAR JOB RUNNING?
	SKIPE	SPWGO(J)		; OR IS A P1 SPACEWAR JOB RUNNING?
	AOSA	(P)			;SPACEWAR ACTIVE. ASSUME SKIP RETURN!
	JRST	CPOPJ1			;WE CAN BE MOVED.

	PSYNC	SPWCSC
	MOVE	IOS,JBTST2(J)
	TLC	IOS,SPWST1!SPWST2
	TLCN	IOS,SPWST1!SPWST2
	JRST	ANY4B			;SPW SUSPENDED. GIVE SKIP RETURN.
	MOVSI	IOS,SPWSUS		;NO. MARK IT FOR SUSPENSION
	TDNN	IOS,JBTST2(J)		;SKIP IF SUSPENSION REQUEST SET ALREADY.
	IORM	IOS,JBTST2(J)		;SET THE BIT THAT REQUESTS SPW SUSPENSION
	SOS	(P)			;NON-SKIP RETURN.
ANY4B:
	XSYNC	SPWCSC
	POPJ	P,			;CANT MOVE HIM UNTIL HE'S SEEN SUSPENSION.

SUBTTL	CORE0
;CORE0 IS CALLED BY THE CORE MONITOR COMMAND AND THE CORE SHUFFLER
;AND RUN COMMAND
;CORE SHUFFLER AND RUN COMMAND

;CALL:	MOVE TAC,HIGHEST LEGAL ADDRESSABLE LOC. DESIRED
;	MOVE J,JOB NUMBER
;	MOVE PROG,[XWD PROT.,RELOC.]=JBTADR(J)
;	PUSHJ P,CORE0
;	ERROR	;EITHER JOB HAS ACTIVE IO
		;OR NOT ENOUGH CORE
;	OK RETURN
;JOB IS MOVED IF NECESSARY TO SATISFY REQUEST
;PROG AND JDAT ARE SET TO NEW CORE ASSIGNMENT ON EITHER RETURN
;0 MEANS NONE ASSIGNED

;ENTER HERE FROM CORE CONSOLE COMMAND OR INITIAL CORE
;ASSIGNMENT OF JUST A JOB DATA AREA FOR RUN COMMAND
;IE ENTER WHEN DEVICES MAY BE ACTIVE OR JOB MAY HAVE NO PREVIOUS CORE


↑CORE0:
IFE FTSWAP,<
	JUMPE	PROG,CORGET	;IS JOB WITHOUT CORE IN MEMORY?
>
IFN FTSWAP,<
	CAML	TAC,SWAPLIMIT	;IS HE BEING TOO GREEDY.
	POPJ	P,		;FLUSH THE GREEDY BASTARD!	;JS
	JUMPN	PROG,CORE0A	;DOES JOB HAVE CORE IN MEMORY?
	MOVSI	TAC1,SWP	;NO, DOES IT HAVE CORE ON DISK?
	CAMGE	TAC,CORMAX	;WILL REQUEST FIT IN PHYSICAL CORE.
	TDNN	TAC1,JBTSTS(J)	;YES, IS JOB ON DISK?
	JRST	CORGET		;NO, TRY TO ASSIGN MEMORY IN CORE OR DISK.
	JUMPE	TAC,CORE0B	;YES, IS HE REQUESTING ANY?
	LSH	TAC,-12		;YES, CONVERT TO 1K BLOCKS
	AOSA	TAC
CORE0B:
	ANDCAM	TAC1,JBTSTS(J)	;NO, CLEAR CORE ON DISK BIT.
↑CORE0K:
	DPB	TAC,IMGIN	;STORE NEW CORE IMAGE BLOCK SIZE
IFN FTSTAT,<
	PUSH P,TAC
	LSH TAC,6
	ANDI TAC,37700
	TRO TAC,CSZSTA
	PUSHJ P,STAPUT
	POP P,TAC
>;FTSTAT
	PUSH	P,DAT
	LDB	DAT,IMGOUT	;SIZE ON DISC (1K BLOCKS)
	CAML	TAC,DAT		;NEW SIZE LESS THAN AMOUNT ON DISC?
	JRST	CORE0C		;NO, RETURN
	SETZM	SWPCNT		;WAKE UP SWAPPER NEXT TICK
	DPB	TAC,IMGOUT	;YES, REPLACE DISC SIZE
	SUB	DAT,TAC		;AMOUNT OF DISC TO FREE (1K BLOCKS)
	LSH	TAC,CONVMD	;CONVERT NEW SIZE TO DISC BLOCKS
	HLRZ	TAC1,JBTSWP(J)	;COMPUTE DISC BLOCK NUMBER FOR
	ADD	TAC,TAC1	;FIRST BLOCK TO FREE.
	PUSHJ	P,FXSAT		;FREE THE DISC BLOCKS.
CORE0C:
	POP	P,DAT		;RESTORE TTY OUTPUT BYTE POINTER
	JRST	CPOPJ1		;AND SKIP RETURN

CORE0A:

>
	PUSHJ	P,ANYACT	;NO,ANY ACTIVE DEVICE?
	POPJ	P,		;YES, CANNOT ASSIGN CORE
				;NO, FALL INTO CORE1

;ENTER HERE FROM CORE UUO OR RUN COMMAND WHEN IT REASSIGNS
;PROPER AMOUNT OF CORE AFTER READING DIRECTORY
;JOB MUST ALREADY HAVE CORE AND NO ACTIVE DEVICES
;FIRST OLD CORE IS RETURNED TO SYSTEM
;THEN NEW REQUEST IS ATTEMPTED TO BE SATISFIED IN LOWEST
;POSITION POSSIBLE.  THUS CORE TENDS TO BE PACKED
;IF NEW REQUEST CANNOT BE GRANTED, OLD AMOUNT IS RETAINED

↑CORE1:	CAML	TAC,SWAPLIMIT	;CAN HE HAVE THIS MUCH?
	POPJ	P,		;NO
	NOSCHEDULE		;PREVENT SCHEDULING
	PSYNC	CORCSC
	MOVE	LOC,JBTSTS(J)
	TRNE	LOC,JLOCK
	PUSHJ	P,UNLOCK	;DRD. REG 2-14-73
	ANDI	TAC,-1		;RIGHT SIDE ONLY
	HRRZ	LOC,PROG	;ABS. LOC. OF OLD CORE
	HLRZ	BLK,PROG	;HIGHEST LEGAL REL. ADR.
	JUMPE	TAC,CORG2
	CAILE	TAC,(BLK)	; IS HE EXPANDING?
	JRST	CORG2		; YES, LET HIM
	CAIN	TAC,(BLK)	; NO, IS HE THE SAME?
	JRST	DIDLEA		; YES, LEAVE NOW
	ADDI	LOC,1(TAC)	; OTHERWISE, SHRINK HIM IN PLACE
	SUBI	BLK,1(TAC)
	HRL	PROG,TAC
	MOVEI	UCHN,0
	PUSHJ	P,CORSTG
	JRST	DIDLEA

SHFCOR:
	PUSHJ	P,ANYACT
	POPJ	P,
	PSYNC	CORCSC
	ANDI	TAC,-1		;RIGHT SIDE ONLY
	HRRZ	LOC,PROG
	HLRZ	BLK,PROG
CORG2:
	MOVEI	UCHN,0		;CLEAR FOR CORSTG CALL
	PUSHJ	P,CORSTG	;RETURN OLD CORE TO FREE STORAGE
	JRST	CORG1

;CORGET IS CALLED BY SWAPPER WHEN JOB IS ON DISC AND IS WANTED IN CORE.

↑CORGET:
	CAML	TAC,SWAPLIMIT	;CAN HE HAVE THIS MUCH?
	POPJ	P,
	PSYNC	CORCSC
CORG1:
	SETZB	LOC,PROG	; SET NEW ASSIGNMENT TO 0 AND DIST. MOVED
	AOS	NCORCALLS
	JUMPE	TAC,DIDLE2	;IS ZERO CORE BEING REQUESTED?
	CAME	J,SHFWAT	;WAITING FOR CURRENT JOB?
	SKIPN	SHFWAT		;IF SHUFFLING, PRETEND NOT AVAIL.
	PUSHJ	P,HOLSRC	;NO, SEARCH FOR HOLE BIG ENOUGH
	JRST	BAKOLD		;NONE, GIVE BACK OLD AMOUNT
CORGT1:
	MOVEM	LOC,PROG	;SETUP NEW RELOC
	HRLM	TAC,PROG	;AND NEW PROTECT.
	MOVEI	BLK,(TAC)	;HIGHEST REL ADR. BEING REQUESTED
	MOVE	UCHN,J		;SET USE BITS IN CORE TABLE
	PUSHJ	P,CORSTG
	MOVE	BLK,JBTADR(J)	;OLD CORE ASSIGNMENT
	JUMPN	BLK,MOVCOR	;WAS THERE OLD MEMORY ASSIGNED?
	PUSHJ	P,CLRJB1	;CLEAR JOB DATA AREA
	MOVE	UCHN,JBTSTS(J)
	TLNE	UCHN,SWP	;IS JOB COMING IN FROM DISK?
	JRST	DIDLEA
	MOVSI	UCHN,JERR	; SET ERROR BIT IN JOB STATUS WORD
	ORM	UCHN,JBTSTS(J)
	MOVNI	UCHN,STOPQ	; PUT JOB IN STOP QUEUE
	MOVEM	UCHN,JOBQUE(J)
	PUSHJ	P,REQUE
	JRST	DIDLEA

BAKOLD:

IFN FTSWAP,<;IN SWAPPING SYSTEM STORAGE LIMIT INSTEAD OF CORE
;LIMIT USED TO DETERMINE IF REQUEST IS GRANTED.

	MOVSI	UCHN,SWP
	TDNN	UCHN,JBTSTS(J)	;GETTING CORE FOR SWAPPER?
	JRST	CORGT3
	SOS	(P)		;YES, SET FAILURE RETURN
	JRST	DIDLE4

CORGT3:
	JUMPL	TAC,CORGT2	; A NEGATIVE CORE AMOUNT IS AN ERROR?
	CAMGE	TAC,SWAPLIMIT	;GTR SWAP AREA?
	CAML	TAC,CORMAX	;WILL REQUEST FIT IN PHYSICAL CORE?
CORGT2:
	SOSA	(P)		;NO - GIVE ERROR RETURN
	PUSHJ	P,XPAND		;YES - TELL SWAPPER TO SWAP OUT
>
IFE FTSWAP,<	SOS	(P)	;SET FOR ERROR RETURN
>
	HLRZ	TAC,JBTADR(J)	;GIVE BACK OLD CORE.
	HRRZ	LOC,JBTADR(J)	;RETURN OLD CORE
	TRNN	LOC,-1		;ANY CORE TO RETURN?
	JRST	DIDLE4		;NO.  JUST EXIT.
	JRST	CORGT1

;MOVE OLD CORE TO NEW AREA

MOVCOR:
	CAIN	LOC,(BLK)	;IS NEW CORE IN SAME PLACE AS OLD?
	JRST	DIDLE		;YES, DO NOT MOVE IT
	MOVSI	TAC1,INTSHW	; DO WE INTERRUPT THIS GUY FIRST?
	TDNN	TAC1,JBTIEN(J)
	JRST	MOVCO1		; NO
	IORM	TAC1,JBTIRQ(J)	; YES
	PUSH	P,J
	PUSH	P,BLK
	PUSH	P,LOC
	PUSH	P,TAC
	PUSH	P,PROG
	PUSHJ	P,INTRUN	;MAKE INTERRUPT HAPPEN
	POP	P,PROG
	POP	P,TAC
	POP	P,LOC
	POP	P,BLK
	POP	P,J
MOVCO1:
	
IFN FTSHF1K,<
	SKIPN	SPWACT		; IS THERE A SPACEWAR JOB ACTIVE?
	JRST	ISET2		; NO, DO IT ALL IN ONE BIG BLT
;;; THE FOLLOWING J. SAUTER CODE (+ OTHER BITS AND PIECES AROUND
;;; AT NOTSH1 AND CLKSER) IS DE-ACTIVATED FOR EFFECIENCY'S SAKE

;CALC AMT TO GIVE BACK AFTER MOVING
;BLK = XWD LENGTH OF OLD CORE,BOTTOM OF OLD CORE
;TAC = LENGTH OF NEW CORE
;LOC = BOTTOM OF NEW CORE

	MOVEM	BLK,SHFBLK
	HLRZ	TAC1,BLK	;LENGTH OF OLD
	ADDI	TAC1,(BLK)	;TOP OF OLD
	CAIL	LOC,(TAC1)	;BOTTOM OF NEW ABOVE TOP OF OLD
	JRST	ISET		;YES. AREAS ARE DISJOINT
	MOVE	TAC1,TAC	;LENGTH OF NEW CORE
	ADD	TAC1,LOC	;TOP OF NEW CORE
	CAIG	TAC1,(BLK)	;ABOVE BOTTOM OF OLD?
	JRST	ISET		;NO. AREAS ARE DISJOINT
	HRRZM	TAC1,SHFBLK
	HLRZ	TAC1,BLK	;AREAS OVERLAP.
	ADDI	TAC1,(BLK)
	SUB	TAC1,SHFBLK
	JUMPLE	TAC1,ISET1	;AMOUNT LEQ 0.  RETURN NONE.
	SUBI	TAC1,1
	HRLM	TAC1,SHFBLK
	AOS	SHFBLK
ISET:
	PUSH	P,BLK		;GRAB THE OLD CORE UNTIL DONE
	PUSH	P,LOC
	HRRZ	LOC,SHFBLK
	HLRZ	BLK,SHFBLK
	MOVE	UCHN,J		;I HOPE J IS SET UP HERE
	PUSHJ	P,CORSTG	;GET BACK OLD CORE
	POP	P,LOC
	POP	P,BLK
	JRST	ISET2

ISET1:
	SETZM	SHFBLK		;DONT GIVE ANYTHING BACK.
>;END OF IFN FTSHF1K

ISET2:
	HLRZ	TAC1,BLK	;LENGTH OF OLD CORE
	CAILE	TAC1,(TAC)	;IS OLD CORE LESS THAN NEW?
	HRRZ	TAC1,TAC	;NO, MOVE THE SHORTENED NEW CORE
	ADDM	TAC1,SHFWRD	;INCREMENT TOTAL NO. WORDS SHUFFLED
	ADD	TAC1,LOC	;ADD IN NEW RELOC.
	MOVE	TAC,LOC		;DEST.=NEW RELOC.
	HRL	TAC,BLK		;SOURCE=OLD RELOC.
	MOVEM	BLK,PARBLK	;SAVE THIS FOR PARSER.
	SETZM	JBTADR(J)	;FLAG THAT CORE IS IN TRANSIT(TTY ROUTINES)

IFN FTSHF1K,<
	SKIPN	SPWACT		; IS THERE A SPACEWAR JOB ACTIVE?
	JRST	MOVC1		; NO, DO IT ALL IN ONE BLT
	ADDI	TAC1,1
	MOVEM	TAC1,SHFEND	;RECORD THE END OF THE BLT
	MOVE	TAC1,[XWD 2000,2000]
	ADD	TAC1,TAC	;BLT THE FIRST 1K NOW.
	MOVEM	TAC1,SHFTAC	;WHERE TO START NEXT TIME
	BLT	TAC,-1(TAC1)	;MOVE JOB DATA AREA.
	SETOM	SHFWAT		;NOTE THAT A JOB IS MOVING.
	MOVSI	TAC,SHF		;DONT RUN HIM UNTIL STOPPED
	IORM	TAC,JBTSTS(J)
	MOVEM	J,SHFJOB
	JRST	DIDLE
>;END OF IFN FTSHF1K

MOVC1:


IFN FTSHF1K,<
	SETZM	SHFTAC		; ZERO OUT CLKINT COMMUNICATION CELLS
	SETZM	SHFEND
	SETZM	SHFJOB		; MAKE SURE NOTSH1 IS CALLED!
>;IFN FTSHF1K

IFN FTHG,<PUSH	P,HGCODE
	HGMAC	(30)	>
	MOVEM	J,PARSJB	;FOR PARSER, THE JOB BEING SHUFFLED
↑SHFBLT:
	BLT	TAC,(TAC1)	;LABEL THIS FOR PARSER.
IFN FTHG,<POP	P,HGCODE>
	PUSHJ	P,DIDLE		; REFORM CORE PARAMETERS NOW
	JFCL
	AOS	(P)		;SET UP FOR SKIP RETURN
↑SHFDONE:
	MOVSI	TAC1,INTSHD
	TDNN	TAC1,JBTIEN(J)
	POPJ	P,
	IORM	TAC1,JBTIRQ(J)
	PUSH	P,J
	PUSH	P,BLK
	PUSH	P,LOC
	PUSH	P,PROG
	PUSHJ	P,INTRUN	;RUN USER I-LEVEL FOR END OF SHUFFLE
	POP	P,PROG
	POP	P,LOC
	POP	P,BLK
	POP	P,J
	POPJ	P,

SUBTTL	DIDDLE
;IF THE SHUFFLED JOB IS IN EXEC MODE, ITS DUMP ACS
;(P,PROG,JDAT SAVED IN JOB DATA AREA) MUST BE
;ALTERED BY DISTANCE CORE WAS MOVED

;IF THE SHUFFLED JOB IS CURRENT JOB, THE SOFTWARE STATE OF
;THE MONITOR(IE SOFTWARE OF JOB) NUST BE ALTERED BY AMOUNT
;CORE WAS MOVED

DIDLEA:
	MOVE	TAC,JBTSTS(J)
	TLNE	TAC,JSEG	;UPPER SEGMENTS TAKE 2 GIANT STEPS!
	JRST	DIDLE3
	JRST	DIDLE1


DIDLE:
	SUBI	LOC,(BLK)	;DISTANCE JOB WAS MOVED(DEST.-SOURCE)
	MOVE	TAC,JBTSTS(J)	; IS THIS A HIGH SEGMENT?
	TLNN	TAC,JSEG
	JRST	DIDLE6
	PUSH	P,J		;YES, RECALCULATE PROT-RELOC OF LOWER SEGMENT
	MOVE	J,JOB
	LDB	TAC,PSEGN
	CAME	TAC,(P)
	JRST	DIDLE5
	PUSHJ	P,GETPR
	DATAO	APR,TAC
DIDLE5:
	POP	P,J
	JRST	DIDLE3

DIDLE6:
	CAME	J,JOB(PID)	;IS THIS CURRENT JOB?
	SKIPA	TAC,JOBPC(JDAT)	;NO, GET PC IN JOB DATA AREA
	MOVE	TAC,USRPC(PID)	;YES, PC IN PROTECTED SYSTEM AREA
	TLNE	TAC,USRMOD	;IS JOB IN USER MODE?
	JRST	DIDLE1		;YES, DO NOT ALTER DUMP ACS
				;BECAUSE THEY ARE THE USERS
	HRRZ	TAC,JOBDAC+P(JDAT)
	CAMLE	TAC,SYSSIZ	; IS THIS PDL IN USER'S AREA?
	CAML	TAC,MEMSIZ
	JRST	.+2		; NO
	ADDM	LOC,JOBDAC+P(JDAT)
				; YES, RELOCATE PDL WITH JOB
	ADDM	LOC,JOBDPG(JDAT)	;AND ALTER PROG BY DIST. MOVED
DIDLE1:
	HLRZM	PROG,JOBREL(JDAT)	;ALWAYS SET JOB DATA AREA W/PROTECTION
DIDLE2:
	CAME	J,JOB(PID)	;IS THIS CURRENT JOB?
	JRST	DIDLE3		;NO, DO NOT ALTER STATE OF MONITOR
	HRRZI	TAC,(P)		; SEE IF THIS PDL IS IN USER'S AREA
	CAMLE	TAC,SYSSIZ	; IS IT ABOVE TOP OF SYSTEM
	CAML	TAC,MEMSIZ		; AND BELOW FREE STORAGE AREA?
	JRST	.+2		; NO
	ADDM	LOC,P		; YES, RELOCATE PDL
	MOVEM	PROG,JOBADR(PID)	;SET NEW JOB ADR. FOR CURRENT JOB
IFN FTSTAT,<
	CAME PROG,JBTADR(J)
	PUSHJ P,CSTAT
>
	MOVEM	PROG,JBTADR(J)
	HLRZM	PROG,USRREL(PID)	;SET NEW PROTECTION FOR CURRETN JOB
	PUSHJ	P,GETPR		; GET JOB'S PROT-RELOC IN TAC
	DATAO	APR,TAC		; AND PUT THAT OUT
DIDLE3:

IFN FTSTAT,<
	CAME PROG,JBTADR(J)
	PUSHJ P,CSTAT
>
	MOVEM	PROG,JBTADR(J)	;STORE NEW CORE ASSIGNMENT
DIDLE4:
	SETZB	TAC,HOLEF	;CLEAR HOLE FLAG
	PUSHJ	P,HOLSRC	;IS THERE A NON-ZERO HOLE?
	JRST	COROK		;NO
	ADDI	LOC,1(BLK)	;YES, FORM ADR. OF JOB JUST ABOVE HOLE
	CAMGE	LOC,MEMSIZ	;IS HOLE AT TOP OF MEMORY?
	MOVEM	LOC,HOLEF	;NO, FLAG WITH ADDRESS OF JOB ABOVE HOLE
COROK:

IFN FTSWAP,<
	MOVEI	TAC,-1		;FIND BIGGEST HOLE
	PUSHJ	P,HOLE		;ALWAYS GET ERROR RETURN
	ASH	AC2,-=10	;CONVERT TO 1K BLOCKS
	MOVEM	AC2,BIGHOLE
>
	SCHEDULE
	XSYNC	CORCSC
IFN FTCORBUG,<	PUSHJ	P,CORTCK >	;CHECK FOR CORTAB - JBTADR CONSISTENCY
	JRST	CPOPJ1		;SKIP RETURN(UNLESS ERROR)


;CSTAT, STAPUT, STAPTT		STATISTICS SERVICE
IFN FTSTAT,<
CSTAT:
	MOVE TAC,JBTSTS(J)
	TLNE TAC,SWP		;IF SWAPPER,
	JRST CSTAT0		;THEN IS ONLY POSITION CHANGE
	MOVE TAC,PROG
	XOR TAC,JBTADR(J)
	TLNN TAC,776000		;CHANGE IN PROT?
	JRST CSTAT1
	HLRZ TAC,PROG
	LSH TAC,-4
	TRZ TAC,77
	MOVEI TAC,CSZSTA+100(TAC);ADD CODE AND MAKE INTO K
	PUSHJ P,STAPUT
CSTAT1:
	JUMPE PROG,CPOPJ	;REPORT ONLY PROT IF CORE 0
	MOVE TAC,PROG
	XOR TAC,JBTADR(J)
	TRNN TAC,776000
	POPJ P,
CSTAT0:
	HRRZ TAC,PROG
	LSH TAC,-4
	TRO TAC,CPSSTA
↑STAPUT:IORI TAC,(J)
STAPTT:
	CONSO PI,77000	;ARE WE ON CHAN HIGHER THAN 7?
	JRST STAPOK	;NO, OK
	HRLI TAC,STACLK	;YES, SEND THIS DATA UP TO CH7
	CONO PI,PIOFF
	IDPB TAC,CLKQ
	CONO PI,PION
	POPJ P,

STACLK:
	HRRZ TAC,DAT
STAPOK:
	IDPB TAC,STATPTR
	MOVE TAC,STATPTR
	CAME TAC,[POINT 18,STATS+STATLEN-1,35]
	POPJ P,
	MOVE TAC,[POINT 18,STATS]
	MOVEM TAC,STATPTR
	AOS STATNUM
	POPJ P,

↑GLUSTT:PUSH P,TAC
	MOVE TAC,JBTGLU(J)
	ANDI TAC,77
	LSH TAC,6
	TRO TAC,GLUSTA
	PUSHJ P,STAPUT
	POP P,TAC
	POPJ P,

↑NAMSTT:PUSH P,TAC
	MOVEI TAC,NAMSTA(J)
;I HOPE WE DON'T GET INTERRUPTED BY SOMEONE ELSE STORING IN STATUS TABLE
	PUSHJ P,STAPTT
	HLRZ TAC,JOBNAM(J)
	PUSHJ P,STAPTT
	HRRZ TAC,JOBNAM(J)
	PUSHJ P,STAPTT
	POP P,TAC
	POPJ P,

↑SEGSTT:PUSH P,TAC
	LDB TAC,PSEGN
	LSH TAC,6
	TRO TAC,SEGSTA
	PUSHJ P,STAPUT
	POP P,TAC
	POPJ P,
>;FTSTAT

SUBTTL	HOLSRC	
;ROUTINE TO FIND HOLE BIG ENOUGH FOR REQUEST
;CALL:	MOVE TAC,HIGHEST REL. ADR. ASKING FOR
;	PUSHJ P,HOLSRC
;	RETURN1	;NO HOLES BIG ENOUGH
;	RETURN2	;UCHN BYTE SET TO LAST BLOCK+1 IN HOLE
;		;BLK SET TO HIGHEST REL. LOC. IN THAT HOLE
;		;LOC SET TO ADDRESS OF FIRST BLOCK IN HOLE
;		;AC2=LARGEST HOLE SEEN
;USES TAC1

HOLSRC:

IFN FTSWAP,<
	CAML	TAC,CORMAX	; IS IT A REASONABLE SIZE REQUEST?
>
IFE FTSWAP,<
	CAML	TAC,MEMSIZ
>
	POPJ	P,		; NO, GIVE UP NOW
HOLE:
	MOVE	UCHN,CORE2P	; BYTE POINTER TO FIRST BIT-1
	SETZ	AC2,		;LARGEST HOLE SIZE = 0
	MOVE	LOC,LOKTOP	;HOLE LOCATION = BOTTOM OF USER SPACE.
CORHOL:
	TDZA	BLK,BLK		;START BLK AT 0 AND SKIP

CORHO0:
	ADDI	BLK,2000	;INCREMENT HIGHEST REL LOC.
CORHO1:
	CAMN	UCHN,CORLST	;BYTE POINTER TO 1ST NON-EXISTANT BLOCK
	POPJ	P,		;NO MORE CORE TO SEARCH
	ILDB	TAC1,UCHN	;GET NEXT CORE USE BIT
	ADDI	LOC,2000	;INCREMENT ADDRESS OF BLOCK
	JUMPE	TAC1,CORHO0	;IS THIS BLOCK IN USE?
	JUMPE	BLK,CORHO1	;YES, HAVE ANY FREE BLOCKS BEEN SEEN YET?
IFN FTSWAP,<
	CAMLE	BLK,AC2		;YES, BIGGEST SO FAR?
	MOVEM	BLK,AC2		;YES, SAVE IN T1.
>
	CAMG	BLK,TAC
				;YES, IS THIS HOLE EQUAL TO OR GREATER
				;THAN THE REQUEST?
	JRST	CORHOL		;NO, KEEP LOOKING FOR HOLES
	SUBI	LOC,2000(BLK)	;YES, SET LOC TO FIRST BLOCK IN HOLE
	SUBI	BLK,1		;SET BLK TO HIGHEST REL. LOC.	;JS
IFN FTSWAP,<
	CAMGE	TAC,SWAPLIMIT	;DOES HE WANT MORE THAN 76K?
>
	AOS	(P)		;NO. GIVE IT TO HIM.	;JS
	POPJ	P,		;RETURN			;JS
				;AND RETURN

;CORCHK AND CORTCK  -- CHECK CORTAL AGAINST CORTAB AND CHECK CORTAB AGAINST WORLD
IFN FTCORBUG,<
CORCHK:
	PUSH	P,TAC		;MAKE SURE CORTAB AND CORTAL ARE CONSISTENT
	PUSH	P,AC2
	PUSH	P,AC1
	MOVE	AC1,CORE2P	;BYTE POINTER INTO CORE TABLE
	MOVEI	AC2,0		;COUNT OF FREE BLOCKS ABOVE LOKTOP
CORCH1:
	ILDB	TAC,AC1		;GET CORE TABLE ENTRY
	JUMPN	TAC,CORCH9	;IF IN USE FORGET IT
	ADDI	AC2,1		;YES.  FREE BLOCK!
CORCH9:
	CAME	AC1,CORLST	;OUT OF MEMORY RANGE YET?
	JRST	CORCH1		;NO. GO ON
	CAMN	AC2,CORTAL	;GET RIGHT ANSWER?
	JRST	CORCH8		;YES

	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/CORTAL = /
	MOVE	TAC,CORTAL
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/,ππππ SHOULD BE = /
	MOVE	TAC,AC2-17(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/;     CALLER'S ADDRESS = /
	HRRZ	TAC,-24(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/
GET A WIZARD!!  IF YOU CAN'T FIND ONE, TYPE POPJ 3,$X
/
	PUSHJ	P,DISFLU
	PUSHJ	P,DDTCALL
	POPACS
	MOVEM	AC2,CORTAL

CORCH8:
	POP	P,AC1
	POP	P,AC2
	POP	P,TAC
	POPJ	P,

CORTCK:
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,LOC
	PUSH P,J
	PUSH P,TAC
	PUSH P,TAC1
	MOVSI AC1,JNA
	MOVE J,JOBNM1
CORCKL:
	TDNE AC1,JBTSTS(J)
	SKIPN AC2,JBTADR(J)
	JRST CORCKN		;NO JOB OR ZERO JBTADR
	HRRZ LOC,AC2		;ADDRESS OF HIS FIRST BLOCK
	HLRZ AC2,AC2		;PROT
	ADDI AC2,1
	LSH AC2,-=10		;NUMBER OF 1K BLOCKS
	PUSHJ P,CORGBP		;SET UP TAC AS ILDB POINTER TO CORTAB
CORCK1:
	ILDB AC3,TAC
	CAIE AC3,(J)
	JRST CORCKC		;CORTAB AND JBTADR DISAGREE
	SOJG AC2,CORCK1
CORCKN:
	SOJG J,CORCKL

	MOVE LOC,SYSTOP
CORCK0:
	PUSHJ P,CORGBP		;NOW LOOK AT ALL USER STG CORTAB ENTRIES
CORCK2:
	ILDB J,TAC
	JUMPE J,CORCK3
	CAILE J,77
	JRST CORCK4		;SYS, NXM, OR FREE STG
	CAMLE J,JOBNM1
	JRST CORCKD		;JOB NUMBER OUT OF RANGE
	MOVE AC1,JBTADR(J)
	CAIE LOC,(AC1)
	JRST CORCKE		;NOT FIRST BLOCK OF THIS JOB!
	HLRZ AC2,AC1
	IORI AC2,1777
	ADDI LOC,1(AC2)
	JRST CORCK0

CORCK3:
	ADDI LOC,2000
	CAME TAC,CORLST
	JRST CORCK2
CORCKZ:
	POP P,TAC1
	POP P,TAC
	POP P,J
	POP P,LOC
	POP P,AC3
	POP P,AC2
	POP P,AC1
	JRST CORCHK		;NOW CHECK CORTAL

CORCK4:
	CAIN J,101		;SKIP IF NOT SYS BLOCK
	JRST CORCKF
CORCK5:
	CAIE J,105		;SKIP IF FS BLOCK
	JRST CORCK3
	CAMGE LOC,MEMSIZ
	JRST CORCKF		;NOT IN SYS AREA OR FS
	JRST CORCK3

CORCKC:
	JSP TAC1,CORCKX
CORCKD:
	JSP TAC1,CORCKX
CORCKE:
	JSP TAC1,CORCKX
CORCKF:
	JSP TAC1,CORCKX

CORCKX:
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /LOSSAGE AT CORCHK -- GET A WIZARD.  THE WINNING ENTRY IS /
	HRRZ TAC,TAC1-17(P)
	SUBI TAC,CORCKC+1
	PUSHJ P,DISOCT
	PUSHJ P,DISCRLF
	PUSHJ P,DISFLU
	PUSHJ P,DDTCAL
	POPACS
	JRST CORCKZ
>;IFN FTCORBUG

SUBTTL	CORSTG		;ROUTINE TO SET AND CLEAR CORE USE TABLE
;CALL:	MOVE UCHN,<JOB NUMBER, OR OTHER CODE>	;TO SET TABLE
;	MOVEI UCHN,0	;TO CLEAR TABLE
;	MOVE BLK,HIGHEST REL. LOC. IN USER AREA
;	MOVE LOC,ADDRESS OF FIRST BLOCK TO SET OR CLEAR



↑CORSTG:			;THE EXTERNAL CALL IS FROM REMAP IN UUOCON
	PUSH	P,TAC		;SAVE HIGHEST LOC. BEING REQUESTED
	ASH	BLK,-12		;CONVERT TO NO. OF BLOCKS-1
	ADDI	BLK,1		;NO. OF BLOCKS
	JUMPE	UCHN,.+2	;UPDATE NO OF FREE BLOCKS
	MOVNI	BLK,(BLK)	;DECREASE IF SETTING BITS
	CAML	LOC,LOKTOP	;IF THIS IS A CALL IN LOCKED CORE, LOCK AND
				;UNLOCK ARE RESPONSIBLE FOR DIDDLING CORTAL - REG
	ADDM	BLK,CORTAL	;INCREASE IF CLEARING,DECREASE IF SETTING BITS
	PUSHJ	P,CORGBP	;MAKE A BYTE POINTER
	MOVM	BLK,BLK		;GET MAG. OF NO. OF BLOCKS INVOLVED
CORST1:
	ILDB	TAC1,TAC	;GET OLD BIT.
	JUMPE	UCHN,CORST9	;LOOK FOR CONFLICTS
	JUMPN	TAC1,CORST2
	JRST	CORSTD
CORST9:
	JUMPN	TAC1,CORSTD
CORST2:
	PUSHACS			;LOSER.
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/CORTAB LOSES AT CORSTG. OLD CLAIM= /
	MOVE	TAC,TAC1-17(P)	;GET THE ARGUMENT
	PUSHJ	P,DISDCP	;TYPE DECIMAL WITH PERIOD
	PUSHJ	P,DISMES
	ASCIZ	/  NEW CLAIM = /
	MOVE	TAC,UCHN-17(P)	;GET NEW CLAIM
	PUSHJ	P,DISDCP	;TYPE DECIMAL W/PERIOD
	PUSHJ	P,DISCRLF
	POPACS
CORSTD:
	DPB	UCHN,TAC	;STORE NEW CORE USE BITS.
	SOJG	BLK,CORST1
IFN FTCORBUG,<	PUSHJ	P,CORCHK  >	;MAKE SURE CORTAB AND CORTAL ARE RIGHT
	JRST	TPOPJ		;RESTORE TAC, AND POPJ


↑CORGBP:			;(ALSO CALLED FROM PARSER)
				;MAKE A BYTE POINTER TO CORTAB
	MOVE	TAC,LOC		;ADDRESS OF FIRST BLOCK
CORGB1:
	MOVEI	TAC1,0		;ENTER HERE WITH TAC SET UP.
	LSHC	TAC,-14		;FORM BYTE POINTER TO BIT-1
	ROT	TAC1,2
	ADD	TAC,COREP(TAC1)	;FORM BYTE POINTER
	POPJ	P,

SUBTTL	CLRJOB
;ROUTINE TO CLEAR PART OF JOB DAT AREA(PART PROTECTED FROM USER IO)
;CALLED WHEN NEW CORE ASSIGNED AND AT SYSTEM RESTART(140)
;	MOVE J,JOB NO.
;CALL:	MOVE JDAT,ADR. OF JOB DATA AREA
;	PUSHJ	P,CLRJOB


↑CLRJB1:
	MOVE	UCHN,JBTSTS(J)	; CAN'T DO THIS IF NO JOB DATA AREA
	TLNE	UCHN,JSEG	; IS THIS AN UPPER SEGMENT
	POPJ	P,		; YES, JUST FORGET IT
	SETZM	JOBPRT(JDAT)	;FIRST LOC. PROTECTED FROM USER
	MOVSI	TAC,JOBPRT(JDAT)
	HRRI	TAC,JOBPR1(JDAT)
	BLT	TAC,JOBPFI(JDAT)
	SETZM	JOBENB(JDAT)	;ALSO CLEAR APR ENABLE WORD
	SETZM JOBINT(JDAT)	;AND MOORER RELOCATER
	MOVE	TAC,JBTSTS(J)
	TLNN	TAC,SWP!SHF	; FORGET THIS IF SWAPPING REQUEST
	HRRZS	UUOPC(J)	; AND UUO PC FLAGS
	POPJ	P,		;RETURN

↑CLRJOB:
	PUSHJ	P,CLRJB1	; CLEAR JOB DATA AREA
	JRST	ESTOP2		; GO SET JOB STATUS, SO CONT WILL
				;NOT WORK

↑CLRINI:
	PUSH	P,JOBDDT(JDAT)	; ON 200 RESTARTS, SAVE JOBDDT
	PUSHJ	P,CLRJB1
	POP	P,JOBDDT(JDAT)
	JRST	ESTOP2

SUBTTL	GETPR
; ROUTINE TO GET A JOB'S PROTECTION-RELOCATION

↑GETPR:
	PUSH	P,DAT		; SAVE SOME ACCUMULATORS
	PUSH	P,TAC1
	MOVE	TAC,JBTADR(J)	; START WITH THE MAIN PART
	ANDCM	TAC,[XWD 1777,1777]
	LDB	DAT,PSEGN
	JUMPE	DAT,GETPR4	; IF NO UPPER SEGMENT, WE ARE DONE
	MOVE	TAC1,JBTSTS(DAT)	; HE HAS AN UPPER, IS IT WRITE-PROTECTED?
	TLNE	TAC1,JWP
	TLO	TAC,1		; YES, SET WRITE-PROTECT BIT
	SKIPN	TAC1,JBTADR(DAT)
	JRST	GETPR1
GETPR5:
	HLRZ	DAT,JBTADR(J)
	CAIGE	DAT,400000
	JRST	GETPR3
	SUBI	TAC1,(DAT)	; FUDGE RELOCATION BY RIGHT AMOUNT
	HRLZ	DAT,DAT
	ADD	TAC1,DAT	; AND PROTECTION
	JRST	GETPR2
GETPR3:
	TRC	TAC1,400000
GETPR2:
	TLO	TAC1,400000
	LSH	TAC1,-11
	AND	TAC1,[XWD 776,776]
	OR	TAC,TAC1	; MERGE TWO RELOCATIONS
GETPR1:
	MOVEM	TAC,LASTPR(PID)	; SAVE THIS AS THE LAST PROT-RELOC ISSUED
	POP	P,TAC1
	POP	P,DAT
	POPJ	P,

GETPR4:
	SKIPN	TAC1,JBTPR2(J)	;IS DOING PEEK-POKE STUFF?
	JRST	GETPR1		;NO
	TLNE	TAC1,1		;IS IT TO BE WRITE PROTECTED?
	TLO	TAC,1		;YES
	TRZN	TAC1,1		;IS IT TO BE RELATIVE TO HIS CORE IMAGE?
	JRST	GETPR5
	PUSH	P,TAC		;YES, CHECK TOP OF HIS CORE IMAGE
	HLRZ	TAC,TAC1	;PROTECTION HE IS REQUESTING
	IORI	TAC,1777	;MAKE IT HONEST
	HLRZ	DAT,JBTADR(J)	;HIS JOBS PROTECTION
	CAIG	DAT,(TAC1)	;IS RELOC BELOW LOWERS PROT?
	JRST	GETPR6
	IORI	DAT,1777	;JUST TO BE SAFE
	SUBI	DAT,(TAC1)	;HOW FAR FROM NEW RELOCATION TO TOP OF CORE IMAGE.
	CAML	DAT,TAC		;IS HE REQUESTING TO MUCH?
	MOVE	DAT,TAC		;NO, USE WHAT HE GAVE US
	POP	P,TAC		;GET BACK LOWERS PROT. RELOC.
	HRL	TAC1,DAT	;SET NEW PROT. FOR PR2
	ADDI	TAC1,(TAC)	;AND RELOCATE IT
	JRST	GETPR5		;AND NOW IT LOOKS LIKE AN UPPER
GETPR6:
	POP	P,TAC
	TLZ	TAC,1
	JRST	GETPR1

SUBTTL	RELOCA
;THIS HERE IS A ROUTINE TO ADDRESS CHECK AND RELOCATE
;A USER ADDRESS. IT MAKES USE OF UPPER SEGMENTS AND
;THE PEEK-POKE FEATURE (JBTPR2).
;CALLING:
;	MOVE J,<NUMBER OF JOB IN QUESTION>
;	MOVE TAC1,<ADDRESS TO CHECK AND RELOCATE>
;	PUSHJ P,RELOCA
;	<ILLEGAL ADDRESS>
;	<LEGAL ADDRESS>
;UPON SUCCESS RETURN TAC1 CONTAINS THE ABSOLUTE ADDRESS
;THE SIGN BIT IS SET IF THIS ADDRESS IS WRITE PROTECTED
;FROM THE USER (THIS INCLUDES THE PROTECTED PART FROM 0-JOBPFI).
;AC1 IS NOW SET-UP FOR A CALL ON RELOCB.

↑↑RELOCA:
	TLZ TAC1,-1		;CLEAR CONFUSING BITS!
	CAIGE TAC1,JOBPFI	;BELOW PROTECTED PART?
	TLO TAC1,400000		;SET WRITE PROTECTED ACCESS
	PUSH P,TAC		;SAVE AN AC
	HLRZ TAC,JBTADR(J)	;GET PROT
	CAIGE TAC,(TAC1)	;IS IT OUTSIDE LOWER?
	JRST RELOC1		;YES, THIS IS HARDER
	MOVE AC1,JBTADR(J)	;SET-UP AC1 WITH PROT RELOC WE ARE USING
	ADDI TAC1,(AC1)		;DO RELOCATION THING
	JRST TPOPJ1		;PUT BACK TAC AND SKIP

RELOC1:
	LDB AC1,PSEGN		;CHECK FOR UPPER SEGMENT
	JUMPE AC1,RELOC2	;NONE, CHECK PEEK-POKE
	MOVSI TAC,JWP		;CHECK WRITE PROTECT
	TDNE TAC,JBTSTS(AC1)
	TLO TAC1,400000		;WRITE PROTECTED
	MOVE AC1,JBTADR(AC1)	;GET PROT RELOC INTO AC1
	JRST RELOC3

RELOC2:
	SKIPN AC1,JBTPR2(J)	;IS HE DOING PEEK-POKE
	JRST TPOPJ		;RESTORE TAC AND RETURN
	TLOE AC1,1		;IS HE WRITE PROTECTED(SET BIT FOR COMPARE)
	TLO TAC1,400000		;YES
	TRZN AC1,1		;IS THIS A RELATIVE MAPPING?
	JRST RELOC3		;NO, (WHEW)!
	PUSH P,DAT		;OH BOY, SAVE ANOTHER AC
	HLRZ TAC,AC1		;GET RELOC HE IS TRYING FOR
	IORI TAC,1777		;MAKE IT HONEST
	HLRZ DAT,JBTADR(J)	;GET PROT OF LOWER
	CAIG DAT,(AC1)		;IS THE RELATIVE RELOC HE WANTS TOO BIG?
	JRST RELOC4		;YES, LOSE
	SUBI DAT,(AC1)		;GET MAX PROT HE CAN HAVE
	CAML DAT,TAC		;IS HE ASKING FOR MORE THAN THAT?
	MOVE DAT,TAC		;NO, USE HIS
	ADD AC1,JBTADR(J)	;SET ABSOLUTE RELOCATION
	HRL AC1,DAT		;SET PROT.
	POP P,DAT		;GET BACK THE AC WE SAVED
RELOC3:
	HLRZ TAC,JBTADR(J)	;NOW WE CHECK TO SEE
	CAIGE TAC,400000	;IF HIS LOWER IS BIGGER THAN 400000
	MOVEI TAC,400000	;IT ISN'T, USE 400000
	SUB TAC1,TAC		;ADJUST REFERENCE
	TLNE TAC1,377777	;UNDERFLOW?
	JRST TPOPJ		;YES, BETWEEN UPPER AND LOWER!
	HLRZ TAC,AC1		;GET PROT.
	CAIL TAC,(TAC1)		;TOO BIG?
	AOS -1(P)		;NO, SKIP
	JRST TPOPJ		;RESTORE TAC AND RETURN

RELOC4:
	POP P,DAT
	JRST TPOPJ		;LOSE

;USE THIS ROUTINE AFTER CALLING RELOCA ONCE TO ASSURE
;THAT THE ADDRESS YOU ARE CHECKING IS IN THE SAME
;SEGMENT AS THE LAST ONE YOU CHECKED. DON'T CLOBBER
;AC1 BETWEEN CALLS ON RELOCA AND RELOCB
;CALLING:
;	MOVE J,<NUMBER OF JOB IN QUESTION>
;	MOVE TAC1,<ADDRESS YOU WISH CHECKED>
;	PUSHJ P,RELOCB
;	<ILLEGAL ADDRESS OR NOT IN SAME SEGMENT AS AC1>
;	<LEGAL ADDRESS AND IN RIGHT SEGMENT>

↑↑RELOCB:
	PUSH P,AC1		;SAVE PROT RELOC WE USED LAST!
	PUSHJ P,RELOCA		;DO THE RELOC THING
	JRST RELOC5
	POP P,(P)
	EXCH AC1,1(P)
	CAMN AC1,1(P)		;DID RELOCA USE PROT RELOC WE WANTED?
	AOS (P)			;YES, SUCCESS
	POPJ P,

RELOC5:
	POP P,AC1
	POPJ P,			;LOSE

SUBTTL	LOCK AND UNLOCK UUOS.
↑UNLOKC:MOVEI	J,(DAT)			;CALLED FROM CLOCK RQ AT ESTOP4
↑UNLOCK:
	PUSH	P,TAC
	MOVEI	TAC,JLOCK
	TDNN	TAC,JBTSTS(J)		;IS JOB LOCKED IN AT ALL?
	JRST	TPOPJ			;NO. THIS IS EASY.
	PUSH	P,PROG
	ANDCAM	TAC,JBTSTS(J)		;UNLOCK HIM.
IFN FTSTAT,<
	MOVEI TAC,LOKSTA
	PUSHJ P,STAPUT
>;FTSTAT
	MOVE	PROG,JBTADR(J)		;GET THE ADDRESS OF THIS JOB.
	HLRZ	TAC,PROG
	IORI	TAC,1777		;DEPT REDUNDANCY DEPT.
	ADDI	TAC,1(PROG)		;COMPUTE ADDRESS ABOVE THIS JOB.
	CAME	TAC,LOKTOP		;SAME AS LOKTOP?
	JRST	UNLOK4

UNLOK0:
	PUSH	P,TAC1
	MOVEI	PROG,(PROG)		;BOTTOM OF NEW UNLOCKED AREA.
UNLOK1:
	MOVEI	TAC,-2000(PROG)		;LOOK 1K FURTHER DOWN.
	PUSHJ	P,CORGB1		;GET A BYTE POINTER
	ILDB	TAC1,TAC		;LOAD CORE CODE.
	JUMPE	TAC1,UNLOK2		;CORE IS FREE. (GIVE BACK TO CORTAL)
	MOVEI	TAC,JLOCK
	CAIGE	TAC1,101		;CORE IN SYSTEM?
	TDNE	TAC,JBTSTS(TAC1)	;NO. CORE BELONGS TO UNLOCKED USER?
	JRST	UNLOK3			;SYSTEM CORE OR LOCKED USER.
	JRST	.+2
UNLOK2:
	AOS	CORTAL			;UNCLAIMED BLOCK: INCREMENT CORTAL
	SUBI	PROG,2000
	JRST	UNLOK1

UNLOK3:
	MOVEI	TAC,(PROG)
	PUSHJ	P,CORGB1
	MOVEM	TAC,CORE2P		;SET FOR HOLSRC.
	MOVEM	PROG,LOKTOP
IFN FTCORBUG,<	PUSHJ	P,CORCHK  >	;MAKE SURE CORTAB AND CORTAL ARE CONSISTENT
	POP	P,TAC1			;RESTORE AC'S
UNLOK4:
	POP	P,PROG
	JRST	TPOPJ

LOCK0:
	JSP	TAC,UUOMES
	ASCIZ	/CAN'T LOCK WITH SEGMENT
/

↑LOCK:	LDB	TAC1,PSEGN
	JUMPN	TAC1,LOCK0
	SKIPE	LOCKNO
	CAMN	J,LOCKNO
	JRST	LOCK1
	MOVEI	TAC,JIFSEC/2		;CODE CAN'T BE REENTERED, SO
	PUSHJ	P,SLEEPT		;LET THIS GUY WAIT.
	JRST	LOCK
LOCK0A:
	MOVEI	TAC,0
	PUSHJ	P,SLEEP
	JRST	LOCK

LOCK1:
					
	PUSHJ	P,ANYACT		;WAIT UNTIL IO STOPS.
	JRST	LOCK0A
					;NOW WE DECIDE WHERE TO PUT THIS TURKEY.
	MOVEI	AC2,JLOCK
	TDNE	AC2,JBTSTS(J)		;ARE WE LOCKED ALREADY?
	PUSHJ	P,UNLOCK		;YES. UNLOCK FIRST. (SHUFFLES IF POSSIBLE)
LOCK2A:
	MOVE	LOC,SYSTOP		;LOWEST POSSIBLE LOC OF HOLE.
	CAML	LOC,LOKTOP		;TOP OF LOCKED SPACE.
	JRST	LOCK2			;LOC CONTAINS ADDRESS.
	PUSHJ	P,CORGBP		;MAKE A BYTE POINTER
	MOVE	UCHN,TAC		;BYTE POINTER IN UCHN
	HLRZ	TAC,JBTADR(J)		;SIZE OF HOLE NEEDED.
LOCK1A:
	TDZA	BLK,BLK			;SIZE OF THIS HOLE.
LOCK1B:
	ADDI	BLK,2000		;INCREMENT SIZE OF THIS HOLE.
LOCK1C:
	CAML	LOC,LOKTOP		;PASSED THE LOCKED PART?
	JRST	LOCK1D			;YES. SEE IF IT WAS IN A HOLE.
	ILDB	TAC1,UCHN		;PICKUP CORE USE BITS
	ADDI	LOC,2000
	JUMPE	TAC1,LOCK1B		;JUMP IF STILL IN HOLE.
	CAIGE	TAC1,101		;SKIP IF THIS IS NOT A JOB
	TDNE	AC2,JBTSTS(TAC1)	;SKIP IF JOB IS UNLOCKED
	JRST	.+2			;IN SYSTEM OR IN LOCKED JOB.
	JRST	LOCK1B			;UNLOCKED JOB IS A LOGICAL HOLE.
	JUMPE	BLK,LOCK1C		;NOT IN HOLE. JUMP IF THERE WAS NO HOLE.
	CAIG	BLK,(TAC)		;SKIP IF HOLE IS BIG ENOUGH.
	JRST	LOCK1A			;NOT BIG ENOUGH.
	SUBI	LOC,2000(BLK)		;COMPUTE FIRST LOCATION OF HOLE.
	JRST	LOCK2
LOCK1D:
	SUBI	LOC,(BLK)		;DECREASE FOR HOLE AT TOP.
LOCK2:
	HLL	LOC,JBTADR(J)		;LOC HAS REL. OF IDEAL HOLE.
	MOVEM	LOC,LOKPOS		;SAVE ADDRESS OF THE HOLE.
	CAMN	LOC,JBTADR(J)		;SAME AS WHERE WE ARE NOW?
	JRST	LOCK4			;WE'RE IN LUCK. (LOCK)
	PUSHJ	P,LOCK5			;SEE IF WE CAN SHUFFLE TO THE RIGHT PLACE.
	JRST	LOCK3			;NO. LET THE CLOCK SWAP JOBS OUT.
					;HERE WE HAVE TO MOVE OURSELVES IN.
	PSYNC	CORCSC
	MOVE	PROG,JBTADR(J)
	HLRZ	TAC,PROG
	HRRZ	LOC,PROG
	HLRZ	BLK,PROG
	MOVEI	UCHN,0
	PUSHJ	P,CORSTG		;FREE OLD CORE.
	HRRZ	LOC,LOKPOS
	PUSHJ	P,CORGT1		;MAKE IT SHUFFLE
	JFCL				;COULD SKIP.
LOCK4:

IFN FTSTAT,<
	MOVEI TAC,LOKSTA+100
	PUSHJ P,STAPUT
>;FTSTAT
	MOVEI	TAC,JLOCK
	IORM	TAC,JBTSTS(J)		;TELL THEM WE'RE LOCKED IN.
	MOVE	PROG,JBTADR(J)		;JOB IS NOW IN THE RIGHT PLACE.
	HLRZ	TAC,PROG		;GET PROT
	IORI	TAC,1777
	ADDI	TAC,1(PROG)		;FIRST ADDRESS ABOVE THIS JOB
	CAMG	TAC,LOKTOP		;IS THIS GREATER THAN OLD LOKTOP?
	JRST	LOCK99			;NO.  THEN THERE'S NOTHING SPECIAL.
	MOVEM	TAC,LOKTOP
;CORTAL SHOULD BE OK. JOB WAS MOVED TO CORE WHICH WASN'T LOCKED CORE AT THAT TIME.
	MOVE	LOC,LOKTOP
	PUSHJ	P,CORGBP
	MOVEM	TAC,CORE2P
LOCK99:
	PUSHJ	P,SPWCNT		;CONTINUE HIS SPACEWARE JOB IF SUSPENDED
	SETZM	LOCKNO			;CLEAR THIS.
	MOVE	TAC,JBTADR(J)
	JRST	STOTAC

LOCK5:
	HRRZ	LOC,LOKPOS		;GET BASE LOCATION
	HLRZ	AC3,LOKPOS		;AND THE PROTECTION.
	PUSHJ	P,CORGBP		;MAKE A BYTE POINTER IN TAC.
LOCK5A:
	ILDB	TAC1,TAC		;GET CORE USE BITS
	CAIN	TAC1,(J)		;SAME AS OUR JOB
	JRST	CPOPJ1			;YES. THEN WE CAN MOVE IN.
	JUMPN	TAC1,CPOPJ		;SOME ONE IS THERE. WE HAVE TO WORK HARD.
	SUBI	AC3,2000
	JUMPG	AC3,LOCK5A		;LOOP.
	JRST	CPOPJ1			;WE'RE ALL FREE.


LOCK3:
	MOVEM	J,LOCKNO		;TELL THE SWAPPER TO FOREGO SWAPIN.
	PUSHJ	P,LOCKPL		;PLANT CLKRQ FOR LOCK.
	MOVNI	TAC,IOWQ		;REQUE THIS JOB TO IOWQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,WSCHED		;WAIT FOR REACTIVATION
	CAME	J,LOCKNO		;AVOID ↑C CONTINUE HANGUP
	JRST	LOCK			;REENTER THE LOCK RESOURCE
	MOVE	LOC,LOKPOS
	JRST	LOCK2A			;SEE IF ALL GOOD THINGS HAVE HAPPENED.
	
LOCK3A:
					;HERE AT CLOCK LEVEL.
	SKIPGE	FSCLKF			;FREE STORAGE DOING IT TOO?
	JRST	LOCKPL			;YES. WAIT FOR IT TOO.
	SKIPN	FINISH
	SKIPE	FORCE
	JRST	LOCKPL			;WAIT FOR SWAPPER TO BE IDLE.
	SKIPE	J,LOCKNO
	SKIPL	JBTSTS(J)
	JRST	LOCK3C			;FLUSH CLOCK RQ IF JOB NOT THERE.
	PUSHJ	P,LOCK5			;SEE IF THERE'S A HOLE YET.
	JRST	LOCK3B			;NOT YET.
	MOVNI	TAC,TQ
	MOVEM	TAC,JOBQUE(J)		;SET JOB TO RUN AGAIN
	JRST	REQUE			;REQUEUE AND DISMISS CLOCK LEVEL.

LOCK3B:
	MOVEI	J,(TAC1)		;GET JOB NUMBER OF THE GUY WE'RE FORCING
	MOVE	TAC,JBTSTS(J)
	TLNE	TAC,SHF!SWP		;SKIP IF HE'S NOT IN MOTION ALREADY
	JRST	LOCKPL			;WE'LL HAVE TO WAIT FOR HIM TO STOP MOVING
	HLRZ	TAC,JBTADR(J)
	SKIPN	XJOB(J)			;IS HE ALREADY EXPANDING?
	PUSHJ	P,XPAND			;NO. LET'S GIVE HIM A SHOVE
LOCKPL:
	MOVE	TAC,[LOCK3A,,1]		;PLANT A CLOCK REQUEST.
	CONO	PI,PIOFF
	IDPB	TAC,CLOCK
	CONO	PI,PION
	POPJ	P,

LOCK3C:
	SETZM	LOCKNO
	POPJ	P,

SUBTTL	FREE STORAGE	;AND OTHER POLITICAL PRISONERS
; "AND WHO DESERVES THE CREDIT?  AND WHO DESERVES THE BLAME?
; NIKCOLI IVANOVITCH LOBACHEVSKY IS HIS NAME."

;		JAM - ORIGINAL FREE STORAGE SYSTEM
;		REG - REVISED SYSTEM MARCH 1972

;	ACCUMULATOR DEFINITIONS

SIZE←AC3		;INPUT PARAMETER TO FSGET
BLOCK←AC1		;BLOCK ADDRESS OF FS BLOCK (BLK)

PICMSK←←37		;MASK TO SELECT CHANNELS 3,4,5,6,7 IN CONO/I PI
PICHON←←2000		;BIT TO TURN ON SELECTED CHANNELS: CONO PI
PICHOF←←1000		;BIT TO TURN OFF SELECTED CHANNELS

;THE FREE STORAGE SYSTEM ASSUMES THAT CHANNELS 1 AND 2 NEVER REQUEST
;FREE STORAGE.

COMMENT $	INITIALIZE FREE STORAGE

MEMSIZ:
			<LOWEST WORD OF FREE STORAGE AREA>
RMEMSIZ:
		<LOWEST NON-EX ADDRESS IN ALL CORE>

FREE STORAGE LOOKS LIKE:

BLOCK IN USE:			BLOCK THAT IS FREE

	(LOW ADDRESS)

---------------			---------------
| RS   |  *---|→→→*		|  U   |  *---|→→→*
---------------   ↓		---------------   ↓
|             |   ↓		|             |   ↓
|             |   ↓		|             |   ↓
|             |   ↓		|             |   ↓
| DATA AREA   |   ↓		|             |   ↓
|             |	  ↓		---------------   ↓
|             |	  ↓		|   0  | BLINK|   ↓
---------------   ↓		---------------   ↓
|⊗ SIZE| RS   |←←←*		| SIZE | FLINK|←←←*
---------------			---------------

	(HIGH ADDRESS)


WHERE SIZE IS THE TOTAL SIZE OF THE BLOCK IN WORDS.
THE DATA AREA HAS SIZE-2 WORDS. ⊗SIZE IS SIZE + 400000.
RS IS RESERVED FOR FUTURE USE BY THE FS SYSTEM.
U IS UNDEFINED.
FLINK IS A FORWARD LINK IN A CHAIN OF FREE BLOCKS.
LINKS WILL EVENTUALLY POINT BACK TO THE BASE OF THE CHAIN!
BLINK IS A BACKWARD LINK IN A CHAIN OF FREE BLOCKS.

THERE ARE "NFSB" CHAINS OF FREE BLOCK WITH FORWARD AND
BACKWARD POINTERS IN FSAVB TABLE.


ALL FREE STORAGE BLOCKS ARE SOME MULTIPLE OF THE "TRIVIAL" SIZE.
ALL REQUESTS ARE ROUNDED UP TO SUCH A MULTIPLE.
CHAINS OF FREE BLOCKS OF EACH SIZE ARE KEPT WITH BASE POINTERS IN FSAVB.
$

↑FSINIT:
	SETZM	FSBEG
	MOVE	TAC,[XWD FSBEG,FSBEG+1]
	BLT	TAC,FSEND
	SYNINI	CORCSC			;INITIALIZE INTERLOCK CELLS
	SYNINI	FSCSC
	MOVE	LOC,MEMSIZ		;GET THE SIZE OF USER SPACE
	CAMN	LOC,RMEMSIZ		;SKIP IF WE HAVE SOME STORAGE CLAIMED
	JRST	FSINI2			;NO. WE HAVE NOTHING TO GIVE BACK
	PUSHJ	P,CORGBP		;GET A POINTER TO OUR LOWEST BLOCK
	MOVEM	TAC,CORLST		;SAVE AS POINTER TO THE END OF ALL CORE
	MOVEI	AC2,2000
FSINI1:
	IDPB	AC2,CORLST		;CLEAR BLOCKS IN CORTAB
	ADDI	LOC,2000		;ADD TO BOTTOM OF FS.
	AOS	CORTAL			;INCREMENT CORE COUNT
IFN FTSWAP,<
	ADDM	AC2,CORMAX >		;INCREASE USER CORE
	CAME	LOC,RMEMSIZ		;AT THE TOP YET?
	JRST	FSINI1			;NO LOOP

FSINI2:
	MOVEM	LOC,MEMSIZ		;SAVE RMEMSIZ AS MEMSIZ
	MOVNI	UCHN,FSNINIT		;NUMBER OF BLOCKS TO CLAIM NOW
	ADDM	UCHN,CORTAL		;DECREASE USER'S SPACE
	MOVNI	LOC,2000*FSNINIT	;GET - NUMBER OF WORDS CLAIMED
IFN FTSWAP,<
	ADDM	LOC,CORMAX>		;DECREASE USER SPACE
	ADDB	LOC,MEMSIZ		;SET LOWER BOUND OF FS
	PUSHJ	P,CORGBP	
	MOVEI	UCHN,105
	IDPB	UCHN,TAC		;CLAIM BLOCK FROM CORTAB
	MOVE	AC2,TAC	
FSINI3:
	CAMN	AC2,CORLST		;ARE WE AT THE END YET?
	JRST	FSINI4	
	IDPB	UCHN,AC2
	JRST	FSINI3

FSINI4:
	MOVEM	TAC,CORLST		;SET UP NEW TOP OF CORE POINTER
	IBP	CORLST			;MAKE POINT TO 2ND UNAVAIL BLK.
	MOVE	UCHN,[XWD 2000*FSNINIT,FSAVB+2*NFSB-1]	;SIZE,,FLINK
	MOVE	AC2,RMEMSIZ		;FIRST NONEX ADDRESS
	SUBI	AC2,1			;ADDRESS OF HI END OF FIRST BLOCK
	MOVEM	UCHN,(AC2)		;SET SIZE,,FLINK IN TOP OF BLOCK
	HRRZM	UCHN,-1(AC2)		;SET BLINK
	MOVEM	AC2,(LOC)		;ADDRESS OF TOP GOES INTO BOTTOM
	SETZ	UCHN,
FSINI5:
	MOVEI	AC3,FSAVB+1(UCHN)	;GET ADDRESS OF SOMEONE
	MOVEM	AC3,FSAVB(UCHN)		;SAVE BACK POINTER
	MOVEM	AC3,FSAVB+1(UCHN)	;SAVE FORWARD POINTER
	ADDI	UCHN,2			;INCREMENT BY 2
	CAIGE	UCHN,2*NFSB-2		;ARE WE AT THE END YET?
	JRST	FSINI5			;NO KEEP LOOPING
	HRRZM	AC2,FSAVB+2*NFSB-2	;SAVE BACK POINTER TO ONLY BLOCK
	HRRZM	AC2,FSAVB+2*NFSB-1	;SAVE FORWARD POINTER TO ONLY BLOCK
	MOVEI	AC2,JIFSEC*=60		;NUMBER OF TICKS BETWEEN CHECKER CHECK
	MOVEM	AC2,FSCKCT		;SAVE
	MOVEI	UCHN,FSLIST		;GET THE START OF OUR Q SPACE
	MOVEM	UCHN,FSIPTR		;SAVE AS Q INPUT POINTER
	MOVEM	UCHN,FSOPTR		;AND Q OUTPUT POINTER
	JRST	SFSINI		;INITIALIZE FREE STORAGE SPARE LIST USERS


FSACSV:
	EXCH	DAT,(P)		;PUSHJ P,FSACSV TO SAVE AC'S.
	PUSH	P,TAC
	PUSH	P,TAC1
	PUSH	P,AC2
	PUSH	P,SIZE
	PUSH	P,TEM
	JRST	(DAT)


FSACRS:
	POP	P,TEM		;JSP DAT,FSACRS TO RESTORE AC'S
	POP	P,SIZE
	POP	P,AC2
	POP	P,TAC1
	POP	P,TAC
	EXCH	DAT,(P)
	POPJ	P,

COMMENT $	FSGET:	GET FREE STORAGE AT ANY LEVEL.
CALLING:

	MOVEI	SIZE,<BLOCK SIZE>
	PUSHJ	P,FSGET
	<NONE AVAILABLE>
	<OK - ADDRESS OF BLOCK IS IN BLOCK (AC1)>

	UUO LEVEL ALWAYS GETS SUCCESS EXIT

$

FSSBYP:
	POINT	17,(BLOCK),17		;POINTER TO SIZE FIELD OF BLOCK
FSSBP1:
	POINT	17,(AC2),17		;POINTER TO SIZE WHEN BLOCK TOP IN AC2

↑FSGET:	TDZA	BLOCK,BLOCK		;NORMAL CALL.
↑FSGETU:MOVNI	BLOCK,1			;CALL AT UUO LEVEL AND NEVER WAIT.
	CONSZ	PI,60000		;ARE WE BELOW CHANNEL 2?
	JRST	FSGLUZ			;NO. SOMEONE SHOULD KNOW BETTER.
	CONSO	PI,77400		;ANY PI'S IN PROGRESS?
	SKIPE	INTACT(PID)		;WE'RE AT UUO LEVEL? USER INTERRUPT?
	JRST	.+2			;EITHER PI IN PROGRESS OR USER I-LEVEL
	MOVEM	BLOCK,FSGTUF		;NORMAL UUO LEVEL. SET SPECIAL FLAG.
	AOS	NFSGETS			;COUNT FS GETS
	PUSHJ	P,FSACSV		;SAVE  DAT,TEM,SIZE,AC2,TAC,TAC1
	PSYNC	FSCSC			;SYNCHRONIZE WITH OTHER PROCESSOR
	MOVEI	SIZE,2(SIZE)		;GET SIZE OF REQUEST +2
	TRZE	SIZE,TRIVIAL-1		;IS THIS EXACT MULTIPLE OF TRIVIAL?
	ADDI	SIZE,TRIVIAL		;NO. ADD TRIVIAL
FSGETT:
	MOVEI	TAC,(SIZE)		;GET SIZE INTO TAC
	LSH	TAC,1-TSHF		;SHIFT TO MAKE INDEX
	SUBI	TAC,2			;NORMALIZE TO ZERO INDEX
	CAILE	TAC,2*NFSB-2		;ARE WE AT THE END OF THE TABLE?
	JRST	FSGTBX			;YES. LOOK FOR A BIG BLOCK
	LSH	TAC,-1
	AOS	FSRPQ(TAC)
	LSH	TAC,1
FSGT0:
	MOVE	TAC1,TAC		;INDEX TO FIRST BASE INSPECTED
	MOVE	BLOCK,MEMSIZ		;FIND BLOCK WITH A HIGHER ADDRESS
FSGT1:
	CAMGE	BLOCK,FSAVB+1(TAC1)	;ADDRESS BIGGER THAN OUR BEST?
	MOVE	BLOCK,FSAVB+1(TAC1)	;YES. REMEBER BEST ADDRESS
	ADDI	TAC1,2			;GO ON TO NEXT LIST BASE
	AOS	NFSLP1			;COUNT A LOOP OF TYPE1
	CAIGE	TAC1,2*NFSB		;STILL IN TABLE?
	JRST	FSGT1			;YES. LOOP
	CAMG	BLOCK,MEMSIZ		;FOUND ANY?
	JRST	FSGTW			;NO WE'LL HAVE TO WAIT...
	PUSHJ	P,FSGCL			;CALL ROUTINE TO CLAIM AND DELINK
	JRST	FSGT0			;THE CLAIM FAILED. LOOK AGAIN.
	JRST	FSGTC			;CLAIM OK

FSGTBX:
	AOS	FSRPQ+NFSB-1
FSGTB0:
	HRRZ	BLOCK,FSAVB+2*NFSB-1	;GET THE FIRST LINK
FSGTB1:
	AOS	NFSLP2			;COUNT A LOOP OF TYPE 2
	CAIG	BLOCK,FSAVB+2*NFSB-1	;FLINK > ADDRESS OF LIST BASE?
	JRST	FSGTW			;NO. WE'LL HAVE TO WAIT.
	SKIPG	AC2,(BLOCK)		;SKIP IF THIS BLOCK IS NOT CLAIMED
	JRST	FSGTB0			;HIGHER CHANNEL MUST HAVE GOT THIS ONE!
	HLRZ	TAC1,AC2		;GET THE SIZE FIELD
	CAIL	TAC1,(SIZE)		;SIZE BIG ENOUGH?
	JRST	FSGTB2			;YES. TRY TO CLAIM IT
	MOVEI	BLOCK,(AC2)		;LOAD NEXT FLINK
	JRST	FSGTB1			;LOOP

FSGTB2:
	PUSHJ	P,FSGCL			;CLAIM THE BLOCK AND DELINK IT
	JRST	FSGTB0			;CLAIM FAILED.
	JRST	FSGTC			;GOT IT

FSGCL:
	CONI	PI,AC2			;GET PI CHANNEL STATUS
	ANDI	AC2,PICMSK		;ONLY CHANNELS 3,4,5,6,7
	CONO	PI,PICHOF(AC2)		;TURN OFF CHANNELS 3-7
	SKIPG	TAC1,(BLOCK)		;FLINK INTO TAC1
	JRST	FSGCLX			;BLOCK IS ALREADY CLAIMED!
	HRRZ	TAC,-1(BLOCK)		;BLINK INTO TAC
	HRRM	TAC1,(TAC)		;GO BACK AND RESET FLINK
	HRRM	TAC,-1(TAC1)		;GO FORWARD AND RESET BLINK
	CONO	PI,PICHON(AC2)		;RESTORE CHANNELS THAT WERE ON
	MOVSI	AC2,400000
	IORM	AC2,(BLOCK)		;TURN ON THE SIGN BIT TO CLAIM BLOCK
	JRST	CPOPJ1			;GIVE THE SKIP RETURN

FSGCLX:
	CONO	PI,PICHON(AC2)		;RESTORE PI.
	POPJ	P,

FSGTC:
	LDB	AC2,FSSBYP		;GET THE SIZE OF THIS BLOCK
	SETZ	TEM,			;INITIALIZE EXCESS SIZE
	CAIGE	AC2,TRIVIAL(SIZE)	;IS BLOCK TOO BIG?
	JRST	FSGTC1			;NO
	MOVE	TEM,AC2			;GET THE SIZE
	SUBI	TEM,(SIZE)		;GET EXCESS SIZE
	MOVEI	AC2,(SIZE)		;GET THE SIZE TO USE
	DPB	AC2,FSSBYP		;SET SIZE
FSGTC1:
	HLLZS	(BLOCK)			;CLEAR RIGHT SIDE OF TOP MARK
	SUBM	BLOCK,AC2		;AC2 GETS ADDRESS BELOW LOWEST
	HRROM	BLOCK,1(AC2)		;SET UP POINTER IN THE LOW ADDRESS
	JUMPE	TEM,FSGTCR		;ALL DONE IF NO SPLIT
	HRLZM	TEM,(AC2)		;SET SIZE IN SPLIT BLOCK
	SUBM	AC2,TEM			;GET LOWEST ADDRESS OF THIS, -1
	HRRZM	AC2,1(TEM)		;SET UP FORWARD LINK
	HLRZ	TEM,(AC2)		;GET THE SIZE BACK
	CAIGE	TEM,NFSB*TRIVIAL	;IS BLOCK VERY BIG?
	JRST	FSGTC4			;NO. RETURN THE SPLIT BY THE CLOCK
	JRST	FSGTC5
FSGTC2:
	CONO	PI,PICHON(TEM)		;TURN CHANNELS ON AGAIN
FSGTC5:
	SKIPG	(TAC1)			;LOOK AHEAD
	JRST	FSGTC6			;LOSE
	MOVE	DAT,-1(TAC1)		;GET BLINK AHEAD
	HRRM	DAT,-1(AC2)		;SET BLINK HERE
	HRRM	TAC1,(AC2)		;SET FLINK HERE
	CONI	PI,TEM			;GET PI STATUS
	ANDI	TEM,PICMSK
	CONO	PI,PICHOF(TEM)		;TURN OFF CHANNELS
	SKIPLE	(TAC1)			;GRABBED FROM UNDER US?
	CAME	DAT,-1(TAC1)		;BE SURE
	JRST	FSGTC2			;TRY AGAIN
	HRRM	AC2,-1(TAC1)		;SET BLINK AHEAD
	HRRM	AC2,(DAT)		;SET FLINK BEHIND
	CONO	PI,PICHON(TEM)		;TURN ON PI'S AGAIN
	JRST	FSGTCR			;RETURN FREE STORAGE.

FSGTC3:
	CONO	PI,PICHON(TEM)
FSGTC6:
	SKIPG	DAT,(TAC)
	JRST	FSGTC4			;LINK'S HAVE MOVED
	HRRM	DAT,(AC2)		;SET FLINK HERE
	HRRM	TAC,-1(AC2)		;SET BLINK HERE
	CONI	PI,TEM
	ANDI	TEM,PICMSK
	CONO	PI,PICHOF(TEM)
	CAME	DAT,(TAC)		;THESE GUYS STILL THE SAME?
	JRST	FSGTC3			;LINKS HAVE MOVED. TRY AGAIN
	HRRM	AC2,-1(DAT)		;SET BLINK AHEAD
	HRRM	AC2,(TAC)		;SET FLINK BEHIND
	CONO	PI,PICHON(TEM)
	JRST	FSGTCR			;RETURN BLOCK

FSGTC4:
	MOVSI	TAC,400000
	IORM	TAC,(AC2)
	LDB	TAC,FSSBP1
	SUBM	AC2,TAC
	HRROM	AC2,1(TAC)
	PUSH	P,BLOCK
	MOVEI	BLOCK,2(TAC)
	PUSHJ	P,FSQUIK		;ADD BLOCK TO FSRTL.
	POP	P,BLOCK
FSGTCR:
	LDB	TAC,FSSBYP		;GET THE SIZE
	ADDM	TAC,FSBUSY		;ADD TO CLAIMED AMOUNT.
	SUBI	BLOCK,-2(TAC)		;COMPUTE LOWEST USABLE ADDRESS
	CONSO	PI,77000		;SKIP IF AT HI PI CHANNEL
	SKIPN	FSRTL			;LOW CHANNEL. SKIP IF ANY COMING BACK
	JRST	FSGRT1			;NOTHING TO DO OR MUST RETURN QUICK
	PUSH	P,BLOCK
	PUSHJ	P,FSCKX			;GIVE IT BACK TO THE INDIANS
	POP	P,BLOCK
FSGRT1:
	XSYNC	FSCSC
	JSP	DAT,FSACRS
	PUSH	P,[FSGET]		;IN CASE OF TROUBLE TRY AGAIN
	PUSHJ	P,FSECHK
	POP	P,(P)			;FLUSH STACK
	JRST	CPOPJ1			;AND GIVE SKIP RETURN

;HERE IF WE COULDN'T FIND ANY FREE STORAGE.
FSGTW:
	PUSHJ	P,FSGETK		;WE NEED ANOTHER K, GET IT
	JRST	FSGTW5			;CAN'T GET ANOTHER K
	PUSHJ	P,FSWAKE		;WAKE SOMEONE WHO WAITS
	JRST	FSGETT			;FSGET RETRY THIS ONE

FSGTW5:
	CONSO	PI,77400		;ARE WE AT I-LEVEL?
	SKIPE	FSGTUF			;NOT I-LEVEL, WANT TO RETURN QUICK?
	JRST	FSGFAI			;GIVE THE NON-SKIP RETURN
	SKIPE	INTACT(PID)		;IF YOU'RE AT USER I-LEVEL YOU'LL
	JRST	WSCHED			;BE KICKED OUT BY WSCHED....
	AOS	NFSWAITS		;COUNT A WAIT
	PUSH	P,J			;SAVE J ON THE STACK
	MOVE	J,JOB(PID)		;GET THE JOB NUMBER
	HRL	J,SIZE			;GET THE SIZE OF REQUEST
	MOVEM	J,@FSIPTR		;SAVE IN OUR QUEUE OF JOBS
	AOS	TAC,FSIPTR		;INCREMENT THE POINTER
	CAIL	TAC,FSLIST+JOBN
	MOVEI	TAC,FSLIST
	MOVEM	TAC,FSIPTR
	AOS	FSCNT
	XSYNC	FSCSC
	PUSHJ	P,WSCHED		;CALL CH7 TO RESCHEDULE JOB(PID)
	SETZM	FSGTUF			;ZERO THIS CELL SO IF WE FAIL AGAIN, WE WAIT
	PSYNC	FSCSC			;HERE EVENTUALLY AFTER FSWAKE
	PUSHJ	P,FSWAKE		;WAKE SOMEONE ELSE
	POP	P,J			;RESTORE J, FINALLY.
	JRST	FSGETT			;PLAY IT AGAIN, SAM.

FSGFAI:
	XSYNC	FSCSC
	JSP	DAT,FSACRS		;RESTORE AC'S
	AOS	NFSGFA			;COUNT A FAILURE
	POPJ	P,			;CRY

FSGLUZ:
	HRRZ	BLOCK,(P)		;GET RETURN ADDRESS
	PUSHACS
	PUSHJ	P,DISERR
	[ASCIZ/ FSGET CALLED ILLEGALLY FROM PI CHANNEL 1 OR 2
RETURN ADDRESS = /]
	DISARG ( LOC,<BLOCK-20(P)> )
	[ASCIZ/
/]
	-1
	POPACS
	JUMPE	PID,CPOPJ
	HALT	CPOPJ			;STOP THE PDP-6

;SWIPE 1K FROM AVAILABLE USER SPACE.
;THIS CAN BE DONE ONLY AT CLOCK OR UUO LEVEL.
;IT SETS THE FOLLOWING GLOBAL VALUES:
; CORLST		BYTE POINTER SET TO THE SECOND UNAVAILABLE 1K BLOCK.
; CORTAL		NUMBER OF 1K BLOCKS AVAILABLE TO USERS
; CORMAX		MAXIMUM NUMBER OF WORDS A JOB MAY HAVE.
; MEMSIZ		LOWEST LOCATION USED BY FREE STORAGE

FSGETK:
	JUMPN	PID,CPOPJ		;THE PDP-6 CAN'T DO THIS
	CONSZ	PI,77000		;ARE WE AT A HIGH CHANNEL?
	POPJ	P,			;YES. WE CAN'T DO THIS!
	PUSH	P,LOC
	MOVE	LOC,MEMSIZ		;GET THE CURRENT MEMORY SIZE
	SUBI	LOC,2000		;GET LOWEST ADDRESS WE WANT
	PUSHJ	P,CORGBP		;MAKE A BYTE POINTER TO CORTAB
	POP	P,LOC
	ILDB	TAC1,TAC		;PICK UP MARK BIT FOR THIS BLOCK
	JUMPN	TAC1,FSSWAP		;JUMP IF CLAIMED AND FORCE USER OUT
	MOVEI	TAC1,105		;CLAIM THIS BLOCK!
	DPB	TAC1,TAC		;STUFF OUR CLAIM BIT IN
	IBP	TAC
	MOVEM	TAC,CORLST		;SECOND UNAVAILABLE BYTE IN CORTAB
	MOVNI	TAC,2000		;UPDATE 4 GLOBAL CELLS
IFN FTSWAP,<
	ADDM	TAC,CORMAX >		;MAXIMUM CORE SIZE IN WORDS
	ADDM	TAC,MEMSIZ		;BOTTOM OF FREE STORAGE
	SOS	CORTAL			;NUMBER OF 1K BLOCKS FOR USERS
IFN FTCORBUG,<	PUSHJ	P,CORCHK >	;CHECK VALIDITY OF CORE TABLES.
	PUSH	P,LOC
	PUSH	P,UCHN
	PSYNC	CORCSC
	PUSHJ	P,DIDLE4		;SET UP HOLEF, BIGHOL, AND SKIP RETURN
	JFCL				;ALWAYS SKIP RETURNS
	POP	P,UCHN
	POP	P,LOC
	MOVE	BLOCK,MEMSIZ		;GET THE LOW BOUND OF FS.
	ADDI	BLOCK,1777		;POINTER TO HIGH SIDE OF THIS 1K
	MOVSI	TAC,402000		;SET UP SIZE AND USE BIT
	MOVEM	TAC,(BLOCK)		;STUFF IN BLOCK HEADER
	HRROM	BLOCK,@MEMSIZ		;STUFF IN LOWER MARKER
	MOVE	BLOCK,MEMSIZ
	ADDI	BLOCK,1
	PUSH	P,SIZE
	PUSHJ	P,FSGIVX		;GIVE BACK A 1K BLOCK (MERGES)
	POP	P,SIZE
	SETZM	FSGVKF			;FLUSH WARNING ABOUT BOTTOM K.
	JRST	CPOPJ1			;GIVE A SKIP RETURN FROM FSGETK

;ROUTINE TO FORCE THE JOB AT TOP OF CORE OUT.

FSSWAP:

IFN FTSWAP,<
	SKIPN	FORCE			;CAN WE DIDDLE THE SWAPPER NOW?
	SKIPE	FINISH			;?
	JRST	FSSWP3			;NO CAN'T BOTHER HIM JUST YET.
	PUSH	P,LOC			;SAVE LOC FOR A WHILE
	MOVE	LOC,MEMSIZ		;REMOVE 4 INSTRUCTIONS STARTING HERE.
	SUBI	LOC,2000			;D.RED.D.
	PUSHJ	P,CORGBP
	POP	P,LOC
	PUSH	P,J			;DON'T CLOBBER J
	ILDB	J,TAC			;GET JOB NUMBER OF THE GUY TO FORCE
	MOVE	TAC,JBTSTS(J)
	TLNE	TAC,SWP!SHF		;IS HE IN MOTION?
	JRST	FSWP3A			;CAN'T DO HIM NOW.
	HLRZ	TAC,JBTADR(J)
	SKIPN	XJOB(J)
	PUSHJ	P,XPAND			;MAKE HIM GET SHOVED OUT
FSWP3A:
	POP	P,J			;RESTORE J
>
FSSWP3:
	SETOM	FSCLKF			;TELL FSCLK TO THINK ABOUT GOBBLING
	SETOM	FSNCLK			;TELL CLKSER TO RUN FSCLK
	POPJ	P,			;AND RETURN


; THIS ROUTINE REQUEUES A JOB WHEN CORE IS AVAILABLE FOR HIM.

FSWAKE:
	CONO	PI,PIOFF
	SKIPLE	FSCNT			;ANYONE THERE?
	JRST	FSWAK1			;YES
	SETZM	FSCNT
	CONO	PI,PION
	POPJ	P,			;NO WORK FOR NO ONE

FSWAK1:
	SOS	FSCNT			;DECREASE NUMBER OF WAITERS
	CONO	PI,PION
	HRRZ	J,@FSOPTR		;GET JOB NUMBER TO REQUEUE
	AOS	TAC,FSOPTR
	CAIL	TAC,FSLIST+JOBN
	MOVEI	TAC,FSLIST
	MOVEM	TAC,FSOPTR
	SKIPL	JBTSTS(J)		;IS THIS GUY STILL RUNABLE?
	JRST	FSWAKE			;NO. TRY ANOTHER ONE.
	MOVNI	TAC,RUNQ
	MOVEM	TAC,JOBQUE(J)		;SET QUEUE FOR THIS JOB
	JRST	REQUE			;REQUEUE THIS JOB

COMMENT $FSCLK:	CLOCK LEVEL (CHANNEL 7) ROUTINES TO KEEP FREE STORAGE HAPPY!
CALLED FROM CLKSER, NEAR CALL ON DPYCLK
$

↑FSCLK:	SETZM	FSNCLK			;WE HAVE GOTTEN SERVICE. SHUT OFF FLAG.
	PSYNC	FSCSC			;SYNCRONIZE
	PUSHJ	P,FSCKX			;RETURN CONTENTS OF FSRTL.
FSCKY:
	SKIPN	FSCLKF			;ARE WE WAITING FOR THE SWAPPER?
	JRST	FSCLK1			;NO. SKIP THIS MESS
	SETZM	FSCLKF
	PUSHJ	P,FSGETK		;LOOK FOR THE 1K WE WANTED.
	JRST	FSCKZ			;THERE WASN'T ANY THERE FOR US
	PUSHJ	P,FSWAKE		;ATTEMPT TO WAKE A WAITER.
	JRST	FSCKZ			;AVOID ATTEMP TO GIVE BACK 1K

FSCLK1:
	SKIPN	FSGVKF			;MAYBE THERE'S A 1K BLOCK TO GIVE BACK?
	JRST	FSCKZ			;NOPE.
	SETZM	FSGVKF
	HRRZ	BLOCK,@MEMSIZ		;POINTER TO TOP OF BOTTOM BLOCK
	LDB	SIZE,FSSBYP		;GET THE SIZE FIELD
	CAIGE	SIZE,2000		;SKIP IF BIG ENOUGH
	JRST	FSCKZ
	PUSHJ	P,FSGCL			;ATTEMPT TO CLAIM THIS BLOCK
	JRST	FSCKZ			;LOSE
	LDB	SIZE,FSSBYP		;GET THE SIZE
	MOVEI	TEM,(BLOCK)		;GET THE BLOCK ADDRESS
	SUBI	TEM,-1(SIZE)		;GET THE BOTTOM ADDRESS
	HRROM	BLOCK,(TEM)		;CLAIM THE BOTTOM
	CAIL	SIZE,2000		;SKIP IF SMALLER THAN A BREADBOX
	CAME	TEM,MEMSIZ		;BIG ENOUGH. AT BOTTOM?
	JRST	FSGVK3			;NO. GIVE IT ALL BACK.
	SUBI	SIZE,2000		;FIGURE SIZE OF NEW BLOCK
	JUMPE	SIZE,FSGVK1		;THERE'S NOTHING TO SPLIT
	DPB	SIZE,FSSBYP		;SET SIZE FIELD IN BLOCK
	SUBM	BLOCK,SIZE		;GET THE BOTTOM ADDRESS
	HRROM	BLOCK,1(SIZE)		;SET THE BOTTOM MARK
	MOVEI	BLOCK,2(SIZE)		;GET THE ADDRESS FOR FSGIVE
	SETOM	(SIZE)			;MAKE HI END OF K LOOK CLAIMED.
	PUSHJ	P,FSGIVX		;GIVE BACK THIS PART OF THE BLOCK
FSGVK1:
	MOVEI	TAC,2000
	ADDM	TAC,MEMSIZ
IFN FTSWAP,<
	ADDM	TAC,CORMAX>
	AOS	CORTAL
	MOVE	LOC,MEMSIZ
	SUBI	LOC,2000
	PUSHJ	P,CORGBP
	SETZ	TAC1,
	IDPB	TAC1,TAC
	IBP	TAC
	MOVEM	TAC,CORLST
IFN FTCORBUG,<	PUSHJ	P,CORCHK  >	;MAKE SURE CORTAB AND CORTAL ARE CONSISTENT
	PSYNC	CORCSC
	PUSHJ	P,DIDLE4
	JFCL
	SETOM	FSGVKF			;FLAG FOR NEXT TICK JUST IN CASE 
	JRST	FSCKZ

FSGVK3:
	MOVEI	BLOCK,1(TEM)		;GET THE BOTTOM DATA WORD ADDRESS
	PUSHJ	P,FSGIVX		;GIVE BACK THIS BLOCK!
FSCKZ:
	SKIPLE	FSCKCT			;TIME TO DO CHECKERBOARD?
	JRST	FSCLK3			;NO.
	MOVE	BLOCK,RMEMSIZ
	SUB	BLOCK,MEMSIZ
	SUB	BLOCK,FSBUSY
	CAILE	BLOCK,5000		;SKIP IF LESS THAN 2.5 FREE
	JRST	FSCLK4			;TOO MUCH IS FREE.
	MOVEI	BLOCK,=30*JIFSEC	;LOOK AGAIN IN 30 SECONDS.
	MOVEM	BLOCK,FSCKCT
FSCLK3:
	XSYNC	FSCSC
	POPJ	P,

FSCLK4:
	XSYNC	FSCSC
	MOVEI	BLOCK,=10*JIFSEC
	MOVEM	BLOCK,FSCKCT
	JRST	RELEX			;RELEASE SPARES.


FSCKX:
	SKIPN	FSRTL			;ANY ONE ON THE RETURN LIST?
	POPJ	P,			;NO. RETURN
	CONO	PI,PIOFF		;DON'T INTERRUPT
	HRRZ	BLOCK,FSRTL		;GET THE FORWARD LINK
	MOVE	TAC,(BLOCK)		;GET THE NEXT FLINK
	HRRZM	TAC,FSRTL		;SAVE IT HERE
	CONO	PI,PION			;TURN ON THE PI'S
	LDB	TAC,FSSBYP		;GET THE SIZE FIELD
	SUBI	BLOCK,-2(TAC)		;GET THE ADDRESS OF LOWEST DATA WORD
	PUSHJ	P,FSGIVX		;ALL SET TO GIVE THE BLOCK BACK AGAIN
	JRST	FSCKX			;LOOK FOR MORE

COMMENT $	FSGIVE:	RETURN FREE STORAGE TO SYSTEM.
CALLING:

	MOVE	BLOCK,<ADDRESS OF BLOCK>
	PUSHJ	P,FSGIVE
	<RETURN HERE ALWAYS>

FSGIVX IS ROUTINE FOR FSGIVE THAT DOESN'T SAVE AC'S 
USE THIS ONLY INSIDE OF FS ROUTINES!

$

FSECHK:
	PUSH	P,BLOCK		;SAVE AC'S FOR A WHILE.
	PUSH	P,SIZE		;SAVE.
	CAMGE	BLOCK,RMEMSIZ
	CAMG	BLOCK,MEMSIZ
	JRST	FSECK1
	SUBI	BLOCK,1
	TRNE	BLOCK,TRIVIAL-1	;ALL THESE BITS MUST BE OFF!
	JRST	FSECK1
	HRRZ	BLOCK,(BLOCK)	;GET BOTTOM LINK
	CAMGE	BLOCK,RMEMSIZ
	CAMG	BLOCK,MEMSIZ
	JRST	FSECK1
	HLRZ	SIZE,(BLOCK)	;GET 400000+SIZE
	SUBI	BLOCK,-400002(SIZE)	;MAKE POINTER TO 1 ABOVE LOWEST ADR.
	CAME	BLOCK,-1(P)		;MAKE SURE THESE ARE THE SAME.
	JRST	FSECK1		;LOSE
	POP	P,SIZE
	POP	P,BLOCK
	POPJ	P,

FSECK1:
	
	PUSHACS	
	PUSHJ	P,DISMES
	ASCIZ	/RELEASE OF NON-EX FREE STORAGE BLOCK. BLOCK = /
	MOVE	TAC,-21(P)	;REACH BACK AND PULL UP STINKING MESS.
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/
CALLERS ADDRESS = /
	MOVE	TAC,-23(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/

/
	SKIPE	DEBMOD			;NO NEED TO DISFLUSH IF NOT DEBUGGING
	PUSHJ	P,DISFLUSH		;MAKE SURE WE CAN SEE MESSAGE.
	POPACS
	DEBCHECK
	POP	P,SIZE
	POP	P,BLOCK
	POP	P,(P)		;THROW OUT RETURN FROM FSCHEK
	POPJ	P,		;RETURN TO BASTARD WHO CALLED ME.

↑FSGIVE:MOVEI BLOCK,(BLOCK)		;SOME PEOPLE COME HERE WITH SHIT IN LEFT HALF
	PUSHJ	P,FSECHK		;CHECK FOR WINNING ADDRESSES
	AOS	NFSGIVES		;INCREMENT COUNT OF GIVES
	PUSH	P,BLOCK			;SAVE THIS FOR A WHILE.
	HRRZ	BLOCK,-1(BLOCK)		;GET THE TOP ADDRESS
	LDB	BLOCK,FSSBYP		;GET THE SIZE
	MOVN	BLOCK,BLOCK		;GET -SIZE
	ADDM	BLOCK,FSBUSY		;DECREASE BUSY COUNT
	POP	P,BLOCK			;RESTORE BLOCK.
	CONSZ	PI,77000		;SKIP IF WE'RE NOT IN CHANNELS 1-6
	JRST	FSQUK1			;DO THE QUICK STUFF!
	PUSHJ	P,FSACSV		;SAVE AC'S
	PUSHJ	P,FSGIVY		;NOW GO GIVE BACK FREE STORAGE
	JSP	DAT,FSACRS		;RESTORE AC'S
	POPJ	P,			;RETURN

FSGIVX:
	PUSHJ	P,FSECHK		;CHECK FOR ERROR.
	CONSZ	PI,77000		;SKIP IF AT LOW LEVEL
	JRST	FSQUK1			;AT HI CHANNEL GIVE BACK QUICK
FSGIVY:
	PUSH	P,BLOCK			;SAVE BLOCK
	PSYNC	FSCSC			;LOCK OUT OTHER PROCESSOR
	MOVEI	AC2,-2(BLOCK)		;AC2 ← HIGH ADDRESS OF LOWER BLOCK
	HRRZ	BLOCK,1(AC2)		;BLOCK SET TO TOP WORD OF THIS BLOCK
	CAMG	AC2,MEMSIZ		;NO MERGE IF WE'RE AT THE BOTTOM
	JRST	FSGV1			;NO. TRY A HIGH MERGE.
	PUSH	P,BLOCK			;SAVE BLOCK TOP!
	MOVE	BLOCK,AC2		;GET THE ADDRESS OF LOWER
	PUSHJ	P,FSGCL			;ATTEMPT TO CLAIM LOWER
	JRST	FSGV0			;POP BLOCK AND FORGET ABOUT LOW MERGE
	LDB	TEM,FSSBYP		;GET THE SIZE
	MOVEI	DAT,(BLOCK)
	SUBI	DAT,(TEM)		;GET THE BOTTOM ADDRESS - 1
	POP	P,BLOCK			;GET ADDRESS OF TOP OF BIG BLOCK
	LDB	TAC1,FSSBYP		;GET SIZE OF ORIGINAL
	ADD	TEM,TAC1		;SUM THEM
	DPB	TEM,FSSBYP		;STUFF THEM IN THE ORIGINAL
	HRROM	BLOCK,1(DAT)		;SAVE A BOUNDARY MARKER.
	JRST	FSGV1
FSGV0:
	POP	P,BLOCK			;GET THE TOP OF THIS BLOCK BACK.
FSGV1:
	MOVEI	TAC1,1(BLOCK)		;GET ADDRESS OF GUY ABOVE
	JUMPE	TAC1,FSGV2A		;MOVEI OVERFLOW IF BLOCK=777777.
	CAML	TAC1,RMEMSIZ		;SKIP IF NOT THE TOP OF ALL CORE
	JRST	FSGV2A			;THIS BLOCK IS AT THE VERY TOP!
	HRRZ	TAC1,1(BLOCK)		;GET BOTTOM POINTER OF GUY ABOVE
	CONI	PI,DAT
	ANDI	DAT,PICMSK
	CONO	PI,PICHOF(DAT)		;STOP CHANNELS 3-7
	HRRZ	AC2,1(BLOCK)		;GET THE BOTTOM POINTER
	SKIPG	TAC,(AC2)		;GET THE FLINK
	JRST	FSGV2			;ALL A BAD IDEA.
	MOVE	TAC1,-1(AC2)		;GET THE BLINK
	HRRM	TAC1,-1(TAC)		;GO FORWARD AND STUFF BLINK
	HRRM	TAC,(TAC1)		;GO BACK AND SET FLINK
	CONO	PI,PICHON(DAT)		;ALLOW INTERRUPTS AGAIN
	MOVSI	DAT,400000
	IORM	DAT,(AC2)		;CLAIM THIS BLOCK.
	LDB	TAC,FSSBP1		;GET THE SIZE OF THIS GUY
	LDB	SIZE,FSSBYP
	ADD	SIZE,TAC
	MOVE	DAT,AC2
	SUB	DAT,SIZE		;COMPUTE THE BOTTOM ADDRESS
	DPB	SIZE,FSSBP1
	HRROM	AC2,1(DAT)
	SKIPA	BLOCK,AC2
FSGV2:
	CONO	PI,PICHON(DAT)
FSGV2A:
	LDB	SIZE,FSSBYP
	LSH	SIZE,1-TSHF		;SHIFT SIZE TO MAKE INDEX.
	SUBI	SIZE,2			;FIX INDEX.
	CAIL	SIZE,NFSB*2		;REASONABLE INDEX?
	MOVEI	SIZE,NFSB*2-2		;NO. FIX INDEX.
	JRST	FSGV6
FSGV5:
	CONO	PI,PICHON(TAC1)		;MAKE SURE PI'S GET RESTORED
FSGV6:
	MOVEI	TAC,FSAVB+1(SIZE)	;GET THE LIST BASE
FSGV7:
	SKIPG	DAT,(TAC)		;DOES THIS POINT FREE?
	JRST	FSGV6			;NO TRY THIS LIST ALL OVER AGAIN
	HRRZ	TEM,(TAC)		;GET THE FLINK
	CAIGE	TEM,(BLOCK)		;HAVE WE FOUND THE RIGHT PLACE?
	JRST	FSGV8			;YES. PREPARE TO LINK IT IN
	CAME	DAT,(TAC)		;IS THIS STILL THE SAME?
	JRST	FSGV6			;NO. TRY ALL OVER
	MOVEI	TAC,(TEM)		;GET THE NEXT FLINK
	JRST	FSGV7			;CHASE DOWN THIS LIST

FSGV8:
	HRRZM	TAC,-1(BLOCK)		;SET THE BLINK
	HRRM	TEM,(BLOCK)		;SET THE FLINK
	LDB	AC2,FSSBYP		;GET THE SIZE OF BLOCK
	SUBM	BLOCK,AC2		;GET POINTER TO BOTTOM
	MOVSI	SIZE,400000
	ANDCAM	SIZE,(BLOCK)		;TURN OFF CLAIM BIT
	CONI	PI,TAC1
	ANDI	TAC1,PICMSK
	CONO	PI,PICHOF(TAC1)		;HOLD CHANNELS 3-7
	CAME	DAT,(TAC)		;STILL HERE?
	JRST	FSGV5			;WHAT A LOSS.
	HRRM	BLOCK,(TAC)		;STUFF IN NEW FLINK
	HRRM	BLOCK,-1(TEM)		;STUFF IN NEW BLINK
	HRRZM	BLOCK,1(AC2)		;AND TURN OFF BOTTOM MARK
	CONO	PI,PICHON(TAC1)		;ALLOW INTERRUPTS
	HRRZ	BLOCK,@MEMSIZ		;POINTER TO BOTTOM-MOST FS BLOCK
	LDB	SIZE,FSSBYP		;GET THE SIZE OF LOW BLOCK
	SKIPL	(BLOCK)			;SKIP IF BLOCK IS CLAIMED ALREADY
	CAIGE	SIZE,2000		;UNCLAIMED. SKIP IF BIGGER THAN 1K
	JRST	FSXPOP			;CLAIMED OR NOT BIG ENOUGH
	SKIPN	FSCNT			;SKIP IF ANYONE'S WAITING
	SETOM	FSGVKF			;SET FLAG TO LET CLOCK THINK ABOUT IT
	SETOM	FSNCLK			;MAKE CLKSER CALL FSCLK
FSXPOP:
	PUSH	P,J			;SAVE J, CLOBBERED BY FSWAKE
	PUSHJ	P,FSWAKE		;WAKE SOMEONE WHO WAITS.
	POP	P,J			;RESTORE J
FSPOP:
	POP	P,BLOCK
	XSYNC	FSCSC
	POPJ	P,


FSQUIK:
	PUSHJ	P,FSECHK		;CHECK ADDRESSES
FSQUK1:
	PUSH	P,BLOCK
	PUSH	P,TEM
	HRRZ	BLOCK,-1(BLOCK)		;LOAD TOP ADDRESS FROM BOTTOM
	PSYNC	FSCSC
	CONO	PI,PIOFF		;ADD THIS BLOCK TO THE FREE LIST
	HRRZ	TEM,FSRTL		;GET THE FLINK
	HRRM	TEM,(BLOCK)		;SAVE HERE
	HRRZM	BLOCK,FSRTL		;RESET LIST BASE
	CONO	PI,PION			;DONE
	SETOM	FSNCLK
	POP	P,TEM
	JRST	FSPOP

;GET FREE STORAGE AT UUO LEVEL.

↑UFSGET:
	PUSHJ	P,FSGET			;GET FREE STORAGE AT UUO LEVEL
	JRST	.+2			;FAILURE CANNOT HAPPEN (IT SAYS HERE)
	POPJ	P,			;EXPECTED RETURN
	PUSHACS				;STUFF EVERYTHING AWAY
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ/π
NO FREE STORAGE AT UFSGET. /
	CONSO	PI,77400		;ARE THERE ANY CHANNELS ACTIVE?
	JRST	UFSGT1			;NO.
	PUSHJ	P,DISMES
	ASCIZ	/NOT AT UUO LEVEL!  RETURN PC = /
	MOVE	TAC,P-17(P)
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/ PI = /
	CONI	PI,TAC
	PUSHJ	P,DISLOC
UFSGT1:
	PUSHJ	P,DISCRLF
	POPACS
	JSP	DAT,UERROR		;GIVE A UUO ERROR.

; ROUTINES TO GET AND RELEASE THE PDL AT UUO LEVEL ONLY. - GETPDL
; CALLING:
;	JSP TAC,GETPDL			;TO GET A PDL
;	PUSHJ P,RELPDL			;TO RELEASE A PDL
; NOTE FREE STORAGE BLOCK THAT THIS PDL USES WILL BE PLACED
; ON THE FREE STORAGE RETURN LIST. THE BLOCK WILL ACTUALLY
; BE RETURNED THE NEXT TIME CHANNEL 7 IS ACTIVATED BY THE CLOCK.
; YOU MUST FINISH USING THE PDL AT UUO LEVEL OR CHANNEL 7 LEVEL,
; WHICHEVER YOU'RE PRESENTLY IN.

; THE NUMBER IN J MUST BE THE CORRECT JOB NUMBER.
; AND PROG MUST POINT TO THE RIGHT JOB DATA AREA

;GETPDL SHOULD BE A NO-OP AFTER SYSTEM 6.09L

↑GETPDL:
	SKIPE	P,JBTPDL(J)
	JRST	(TAC)
	MOVEM	BLOCK,JOBTM1(JDAT)	;SAVE AC'S IN JOB DATA AREA
	MOVEM	SIZE,JOBTM2(JDAT)
	MOVEI	SIZE,JBTPLN		;GET ONE THIS SIZE
	MOVEI	P,JOBPDL-1(JDAT)	;MAKE A TEMPORARY PDL FOR FSGET
	HRLI	P,-JOBPLN		;THIS LONG
	PUSHJ	P,FSGET			;GET SOME FREE STORAGE
	JSP	DAT,ERROR		;IT CAN'T HAPPEN.
	PSYNC	PDLCSC			;SYNCHRONIZE
	SKIPN	P,JBTPDL(J)		;HAS HE GOT ONE SOME OTHER WAY?
	JRST	GETPD1			;NO. WE USE THE ONE WE JUST GOT
	XSYNC	PDLCSC			;DESYNCHRONIZE
	PUSHJ	P,FSGIVE		;RETURN THE PDL WE DON'T NEED IT.
	JRST	GETPD2			;AND RETURN IT.
GETPD1:
	MOVEI	P,-1(BLOCK)		;GET THE PDL BASE-1
	HRLI	P,1-<JBTPLN+JOBPRT-JOBPFI>	;AND THE PDL LENGTH
	MOVEM	P,JBTPDL(J)		;SAVE PDL POINTER
	XSYNC	PDLCSC			;RELEASE INTERLOCK
	SETZM	1(P)			;ZERO A CELL
	MOVSI	BLOCK,1(P)		;MAKE A BLT POINTER
	HRRI	BLOCK,2(P)
	BLT	BLOCK,JBTPLN(P)		;ZERO THE ENTIRE PDL
GETPD2:
	MOVE	BLOCK,JOBTM1(JDAT)	;RESTORE THE AC'S WE SAVED
	MOVE	SIZE,JOBTM2(JDAT)	
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/AT GETPDL WITHOUT A PDL /
	PUSHJ	P,DISJOB
	PUSHJ	P,DISCRLF
	POPACS
	SKIPE	DEBMOD
	PUSHJ	P,DDTCAL
	JRST	(TAC)			;RETURN TO CALLER.

↑RELPDL:
	HRRZ	BLOCK,JBTPDL(J)		;GET THE ADDRESS OF THE PDL
	JUMPE	BLOCK,CPOPJ		;NO PDL, CAN'T RELEASE
	HRRZ	TAC,JBTPDL(J)		;GET THE PDL ADDRESS
	ADDI	TAC,JBTPLN+JOBPRT-JOBPFI	;ADDRESS OF THE TOP IN TAC
	SKIPN	(TAC)			;LOOK FOR A NON-ZERO CELL
	SOJGE	TAC,.-1			;LOOP.
	SUB	TAC,BLOCK		;SUBTRACT THE BASE ADDRESS.
	CAMLE	TAC,NPUSHD		;BIGGER THAN OUR BIGGEST
	MOVEM	TAC,NPUSHD		;YES. SAVE THIS NUMBER
	SETZM	JBTPDL(J)		;CLEAR PDL CELL FOR NEXT JOB
	AOS	NFSGIVES		;COUNT THIS CELL HERE, SINCE FAKING IT
	MOVNI	TAC,JBTPLN+2		;GET THE SIZE OF THIS BLOCK
	ADDM	TAC,FSBUSY		;DECREASE BUSY COUNT TOO.
	AOJA	BLOCK,FSQUIK		;CHECK BLOCK, STUFF ON FSRTL, RETURN

;SPARE LIST HANDLER FOR DPYSER & TTYSER

;HERE WE SET UP THE INITIAL QUOTAS (QUOTAE?)
SFSINI:
	HRRZ DDB,SFHEAD		;THE SPARE LIST LIST
SFSIOL:
	LDB DAT,[331000,,SFSIZE(DDB)]	;HOW MANY DOES THIS ONE WANT?
	JUMPE DAT,SFSI2		;NONE?
	HRRZ AC3,SFSIZE(DDB)
	MOVEI AC2,(DDB)		;INIT PNTR FOR LINKING
SFSIIL:
	PUSHJ P,FSGETU
	JRST .+4		;LOSE - SET TO TRY LATER (SHOULDN'T HAPPEN)
	MOVEM AC1,(AC2)		;LINK IT IN
	MOVEI AC2,(AC1)
	SOJG DAT,SFSIIL
	SETZM (AC2)		;TERMINATE LIST
	MOVEM DAT,SPFSN(DDB)	;SET FROM DAT IN CASE WE LOST
	SKIPL SFSIZE(DDB)
	ADDM DAT,SPFSNT
SFSI2:
	HRRZ DDB,SFLINK(DDB)
	JUMPN DDB,SFSIOL
	POPJ P,

;WE GET HERE AT CLOCK LEVEL WHEN SPFSNT>0 TO REPLENISH OUR SPARES
↑SFSCLK:HRRZ DDB,SFHEAD
SFSCL1:
	SKIPLE SPFSN(DDB)	;IF THIS LIST DOESN'T NEED ANY
	SKIPGE SFSIZE(DDB)	;OR THIS ISN'T THE CLOCK-FILLED KIND
	JRST SFSCL2		;TRY NEXT LIST
SFSCLL:
	HRRZ AC3,SFSIZE(DDB)
	PUSHJ P,FSGET		;TRY TO GET ONE
	JRST SFSCL2		;LOSE - DON'T BOTHER WITH THIS LIST ANY MORE
	CONO PI,PIOFF
	EXCH AC1,(DDB)		;PUT IT IN THE LIST
	MOVEM AC1,@(DDB)
	CONO PI,PION
	SOS AC1,SPFSNT		;DECREMENT TOTAL
	SOSLE SPFSN(DDB)	;& # THIS LIST
	JRST SFSCLL		;STILL NEED MORE
	JUMPLE AC1,CPOPJ	;THIS LIST ALL SET, ANY OTHERS TO DO?
SFSCL2:
	HRRZ DDB,SFLINK(DDB)	;YES, TRY NEXT LIST
	JUMPN DDB,SFSCL1	;IF THERE IS ONE
	POPJ P,

;VERSION OF FSGET TO USE SPARE LIST
;LIKE FSGET EXCEPT AC3 HAS SPARE LIST HEADER POINTER INSTEAD OF SIZE
;SIGN BIT (AC3) MEANS NO SKIP (OR FAILURE) RETURN
;SFNWT BIT FORCES FAILURE RETURN EVEN AT UUO LEVEL
↑SFSGET:PUSH P,AC3
	SKIPGE SFSIZE(AC3)
	JRST SFGSF		;WANTS TO TRY SPARES FIRST
SFGFS:
	HRRZ AC3,SFSIZE(AC3)
	PUSHJ P,FSGETU
	JRST SFSGTS		;NO FS, TRY SPARE
SFSXIT:
	POP P,AC3
SFSWIN:
	JUMPGE AC3,CPOPJ1	;HERE WE HAVE WON, AND GIVE THE REQUESTED SUCCESS RETURN
	POPJ P,

SFSGTS:
	PUSHJ P,SFGTS		;TRY TO GET A SPARE
	JRST SFSLUZ		;OOPS - NO SPARE, EITHER
SFSGOK:
	POP P,AC3
	AOS SPFSN(AC3)		;NOW WE NEED ANOTHER
	SKIPL SFSIZE(AC3)	;AND UNLESS WE'RE KEEPING SFSCLK OUT
	AOS SPFSNT		;WE SHOULD REQUEST SERVICE FROM IT
	JRST SFSWIN

SFGSF:
	PUSHJ P,SFGTS		;HERE WE TRY THE SPARES FIRST
	SKIPA AC3,(P)		;LOSE - GET THE PNTR SO WE CAN GET THE SIZE FOR FSGET
	JRST SFSGOK		;WIN - UPDATE THINGS & EXIT
	JRST SFGFS		;NOW TRY FSGET

SFGTS:
	MOVEI AC3,		;PREPARE TO FLUSH LINK
	CONO PI,PIOFF		;GET SPARE FROM LIST AT @(P)
	SKIPN AC1,@-1(P)
	JRST PIONJ		;NONE
	EXCH AC3,(AC1)		;THIS ZEROES LINK TO TELL RELEX SOMETHING CHANGED
	MOVEM AC3,@-1(P)	;DELINK IT FROM THE LIST
	CONO PI,PION
	JRST CPOPJ1

SFSLUZ:
	POP P,AC3
	AOS SFLOSS(AC3)		;COUNT OUR TOTAL LOSSES
	CONSO PI,77400
	JRST SFULUZ		;UUO LEVEL - NOT TOO BAD
	JUMPL AC3,SFILUZ	;IF WE CAN'T GIVE A FAILURE RETURN WE ARE IN DEEP TROUBLE
	POPJ P,			;WHEW!

SFULUZ:
	TLNE AC3,SFNWT		;IF THE CALLER DOESN'T WANT TO WAIT
	JUMPGE AC3,CPOPJ	;AND HE ALLOWS FAILURE, JUST RETURN
	PUSH P,AC3
	HRRZ AC3,SFSIZE(AC3)
	PUSHJ P,UFSGET		;OTHERWISE OFF TO FSGET TO WAIT FOR IT
	JRST SFSXIT

;ARRRGH! PI LEVEL AND NO FAILURE POSSIBLE! HERE WE CURL UP AND DIE
SFILUZ:
	HLRZ AC2,SFLOSS(AC3)	;MAYBE THE CONDEMNED HAS A FEW LAST WORDS
	SKIPN AC2
	MOVEI AC2,[ASCIZ /SOMETHING/]	;NOPE
	PUSHACS
	PUSHJ P,DISDAT
	PUSHJ P,DISERR
	[ASCIZ /πππππππNO CORE FOR /]
	@AC2-20(P)
	[ASCIZ / AT SFSGET.

/]
	-1
	CONO PI,PIOFF
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	PUSHJ P,DDTCALL			;MAYBE SOMEONE WANTS TO KNOW WHY
	JRST AUTOLOAD		;AS THE SYSTEM SINKS SLOWLY INTO THE WEST

;VERSION OF FSGIVE TO THINK ABOUT PUTTING RETURNED BLOCK INTO SPARE LIST
;LIKE FSGIVE BUT CALL IS FOLLOWED BY LIST HEADER ADDRESS
↑SFSGIV:PUSH P,AC3
	AOS AC3,-1(P)		;SKIP OVER ARG
	MOVEI AC3,@-1(AC3)	;& GET IT
	SKIPGE SFSIZE(AC3)	;ONLY RETURN INTO LIST IF THIS BIT IS ON
	SKIPG SPFSN(AC3)	;AND WE NEED SOME
	JRST [POP P,AC3
JRST FSGIVE]	;OTHERWISE GIVE IT BACK TO FS
	PUSH P,AC1
	ANDI AC1,-1
	CONO PI,PIOFF
	EXCH AC1,(AC3)		;LINK IT IN
	MOVEM AC1,@(AC3)
	CONO PI,PION
	POP P,AC1
	SOS SPFSN(AC3)		;ONE FEWER NEEDED
	POP P,AC3
	POPJ P,

;ROUTINE TO DYNAMICALLY SHRINK SIZE OF SPARE LIST
;CALL WITH -# TO DECREASE IN AC2, HEADER POINTER IN AC3 (CLOBBERS AC1 & AC2)
↑SFSREL:SKIPL SFSIZE(AC3)	;AS USUAL, THIS TYPE LEAVES SPFSNT ALONE
	ADDM AC2,SPFSNT
	ADDB AC2,SPFSN(AC3)
	JUMPGE AC2,CPOPJ	;LEAVE IF WE DON'T HAVE TO GIVE ANY AWAY
SFSRLL:
	CONO PI,PIOFF
	SKIPN AC1,(AC3)		;GET ONE
	JRST PIONJ		;NONE
	HRRZ AC2,(AC1)
	MOVEM AC2,(AC3)		;LINK IT OUT
	CONO PI,PION
	PUSHJ P,FSGIVE		;AND GIVE IT BACK TO THE WORLD
	SKIPL SFSIZE(AC3)	;THE UBIQUITOUS TEST (SIGH)
	AOS SPFSNT
	AOSGE SPFSN(AC3)	;ONE MORE "NEEDED" (SHOULD BE GOING UP TO 0)
	JRST SFSRLL		;AND WE'LL KEEP AT IT UNTIL IT DOES
	POPJ P,

;YES FANS, IT'S THE INFAMOUS RELEX, FORMERLY SCATTERED THROUGH TTYSER & DPYSER
;THIS ONE TRIES TO SHUFFLE UP ALL THE SPARES IN THE BOTTOM 1K
;BY REPLACING THEM WITH NEW ONES FROM FREE STORAGE
;IT GIVES UP QUICKLY IF THE NEW ONES AREN'T ABOVE THE BOTTOM 1K
RELEX:
	MOVE AC2,MEMSIZ
	ADDI AC2,2000		;THIS WILL BE OUR THRESHOLD
	CAML AC2,RMEMSIZ	;BUT LEAVE THE TOP 1K ALONE
	POPJ P,		;IF THIS INSTRUCTION GETS EXECUTED SOMEONE DESERVES OUR WARMEST CONGRATULATIONS
	HLRZ DDB,SFHEAD		;THERE WAS ONCE A REASON FOR GOING THROUGH BACKWARDS
RELX1:
	MOVEI TAC,(DDB)		;START THE "PREVIOUS" POINTER HERE
RELX2:
	HRRZ TEM,(TAC)		;CONSIDER A BLOCK
	JUMPE TEM,RELXO		;GEE, WASN'T THAT EASY
	CAIL TEM,(AC2)
	JRST RELXI		;HE'S NOT IN THE BOTTOM 1K, SO WE WON'T WORRY ABOUT HIM NOW
	MOVE TAC1,(TEM)		;PICK UP HIS LINK
	HRRZ AC3,SFSIZE(DDB)	;HE MUST BE THIS BIG
	PUSHJ P,FSGET		;GET A SHINY NEW PIECE
	JRST RELXO		;OH WELL, SO MUCH FOR THIS LIST
	CAIGE AC1,(AC2)		;SEE IF THE NEW ONE IS ABOVE THE BOTTOM 1K
	JRST RELXL		;TIME TO SEE THE COMPLAINT DEPARTMENT
	MOVEM TAC1,(AC1)	;COPY THE LINK
	CONO PI,PIOFF		;NOW CLOSE OUR EYES
	CAMN TAC1,(TEM)		;AND IF THESE 2 POINTERS
	CAME TEM,(TAC)		;STILL AGREE
	JRST [CONO PI,PION
JRST RELXL]	;CURSES! FOILED AGAIN! GIVE BACK NEW BLOCK.
	MOVEM AC1,(TAC)		;QUICK! PULL THE SWITCH!
	CONO PI,PION		;DIDN'T SEE A THING
	EXCH AC1,TEM		;DON'T FORGET TO TELL FSGIVE ABOUT THE SWITCH
	PUSHJ P,FSGIVE		;NOW GET RID OF THE LOSER
RELXI:
	MOVE TAC,TEM		;THIS IS NOW THE PREVIOUS BLOCK
	JRST RELX2

RELXL:
	PUSHJ P,FSGIVE		;GIVE BACK THE NEW ONE
RELXO:
	HLRZ DDB,SFLINK(DDB)	;AND TRY A NEW LIST
	JUMPN DDB,RELX1		;IF THERE'S ONE TO BE FOUND
	POPJ P,

BEND CORE
;: CORE[J17,SYS] EOF.
;: DSKSER[J17,SYS]
COMMENT ⊗   VALID 00038 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	BEGIN DSKSER 
 	SUBTTL	DSKSER	DISK SERVICE ROUTINE
C00006 00003	IOS BITS,  DISPATCH TABLE
C00008 00004	DISKUP	DHUNG	BLAST DISK.  DISK HUNG ROUTINE
C00010 00005	SETDDB CLRDDB	CORE ALLOCATION ROUTINES
C00016 00006	REFRES		DISK REFRESHER (I. E., INITIALIZER)
C00021 00007	DSKINI, DSKSTP, DSKTM1 (TIME CONTROL)
C00030 00008	 BUFFERED I/O
C00039 00009	 DUMP MODE I/O
C00043 00010	DUMP MODE INPUT
C00049 00011	DUMP MODE OUTPUT
C00054 00012	BOTH INPUT & OUTPUT CLOSE ARE ALWAYS CALLED FROM UUOCON.
C00059 00013	RELEASE UUO, CALL RESET, AND CALL EXIT
C00063 00014	MTAPE UUO -- BY R. HELLIWELL -- 16 JAN 72
C00068 00015		GDWRIT, GDREAD
C00073 00016		SETSAT, CLRSAT
C00075 00017		SATWRT, SATRD, SATFRC
C00078 00018		FILINF, WRTINF
C00083 00019		WRTOFF, RDOFF
C00086 00020		DIAGL, DIAGW
C00089 00021		GETRTR
C00092 00022		INFCOM, ADDBLK, FILEUP, TKSFRE, DSKRES
C00097 00023	LOOKUP
C00105 00024	ENTER
C00113 00025	RENAME
C00124 00026	FILE ACCESS CONTROL.
C00130 00027	SEARCH MFD AND UFD FOR FILE.
C00141 00028	 RETRIEVAL SUBRS
C00150 00029	 SAT TABLE OPERATIONS
C00156 00030	IASNBK
C00163 00031	DELETE A FILE, FREE DISK BLOCKS
C00165 00032	 SWAPPER INTERFACE
C00169 00033	ENTER HERE FOR HIGH PRIORITY TRANSFER (CURRENTLY ONLY UDP IO).
C00173 00034	I-LEVEL SUBRS RETURN HERE WHEN DONE TO START ANOTHER REQUEST.
C00176 00035	I-LEVEL SUBRS PUSHJ HERE TO START A TRANSFER.
C00177 00036		ERROR HANDLING
C00181 00037	 USER DISK PACK SERVICE
C00187 00038	UDP PASS WORD STUFF
C00191 ENDMK
C⊗;

BEGIN DSKSER 
 	SUBTTL	DSKSER	DISK SERVICE ROUTINE
↑DEVBEG←←.			;START OF THE DEV SERVICES IN ENTIRE SYSTEM

	DEFINE	IOPCON <DIPCON>

; PRELIMINARIES, STORAGE CONTROL

;THIS CODE DEPENDS HEAVILY UPON:
; 1) NO RESCHEDULING AT UUO LEVEL
; 2) JOB NOT SHUFFLED OR SWAPPED WHEN IO ACTIVE.

TRIES←←1			;ASK DSKINT TO TRY A TRANSFER THIS MANY TIMES
ERRBOX←←1			;PLACE FOR ENTER, LOOKUP ERROR CODES
BUFIOW:
 XWD -BLKWDS,SYSBUF	;167 FORMAT
UFDEXT←←'UFD'			;SIXBIT UFD.

↑MFDENT:	'  1  1'	;'DIRECTORY ENTRY' FOR MFD
MFDEXT:
		'UFD   '
MFDPRO:
		155740,,0	;ANYONE CAN READ THE MFD
MFDLOC:
		1		;DISK LOC. OF MFD
↑BAND0:		0
↑SATLOC:	0

UNAM←←0
UEXT←←1
UPRO←←2
UPPN←←3

DWRITE←←100			;TELL 167 TO WRITE, ELSE READ.
IOPDCH←←IOPCHN			;HI PRIORITY CHANNEL FOR 167
MSGPPN:
	'  2  2'		;PPN OF MESSAGE AREA

;IOS BITS,  DISPATCH TABLE

;BITS IN LH IOS INDICATE FILE STATUS:

↑GOBIT←←400000
↑READB←←200000
↑WRITEB←←100000
↑ALTERB←←40000
RENAMB←←20000
DELETB←←10000
NTRUFD←←4000
PNTDIF←←2000
IOSET←←400		;CHEAT FOR USETI IN CLOSE
LOSBIG←←200
SATOP←←100
HDRDIF←←4		;HOPEFULLY WE CAN GET AWAY WITH THIS ONE, (SAME BIT AS IOFST!)
↑DSKFGS←←SATOP+GOBIT

;USER STATUS BITS IN RH IOS:

DMPBIT←←400
GARBIT←←200

;IDENTIFY DDB LOCATIONS FOR TVSER. LOCATIONS ARE SAME 
;AS IN BLACKINGTON, FOR NO GOOD REASON.

↑DSKBUF←←17
↑DSKCNT←←20

	JRST	CLRDDB		;GIVE BACK DDB
	JRST	SETDDB		;MAKE DDB
	JRST	DSKINI		;INITIALIZATION (SYSINI)
	JRST	DHUNG		;SHOULDN'T HANG
↑DSKDSP:JRST	DRELES		;RELEASE
	JRST	DCLOSO		;CLOSE OUTPUT
	JRST	DBUFO		;BUFFERED OUTPUT
	JRST	DBUFI		;BUFFERED INPUT
	JRST	DENTER		;ENTER
	JRST	DLOOK		;LOOKUP
	JRST	DDMPO		;DUMP OUTPUT
	JRST	DDMPI		;DUMP INPUT
	JRST	DSETO		;USETO
	JRST	DSETI		;USETI
	JRST	DGETF		;UGETF
	JRST	DRENAM		;RENAME
	JRST	DCLOSI		;CLOSE INPUT
	POPJ	P,		;UTPCLR
	JRST	DGETW		;MTAPE

;DISKUP	DHUNG	BLAST DISK.  DISK HUNG ROUTINE

DISKUP:
	CONO	IBM,CLRCHL
	MOVEI	TAC1,2				;MAY TAKE THIS MANY IF SCREWED UP.
DSKUP2:
	CONO	IBM,1				;.....
	CONO	IBM,2				;NOW RESET IBM.
	MOVEI	TAC,10000			;...WHICH MAY TAKE A WHILE.
	SOJG	TAC,.
	SOJGE	TAC1,DSKUP2
	CONO	PMP,460010!DSKCHN		;ENABLE FOR RANDOM INT'S
	POPJ	P,

;CALLED FROM DEVCHK BY SPECIAL CALL, DDB NOT SETUP
DHUNG:
	PUSHJ	P,DISKUP		;FLUSH THE WORLD.
	CONO	PMP,10			;MAKE SURE CHANNEL DOESN'T INTERRUPT ANYONE
	DATAO	IBM,NOPCMD		;NOW SEE IF HE IS LISTENING TO US
	MOVEI	TAC,100000		;WAIT THIS LONG
	CONSO	PMP,460000		;WAIT FOR NEW STATUS, UNEND, OR PARITY ERROR.
	SOJG	TAC,.-1			;WAIT FOR SOME STATUS
	CONI	PMP,TAC			;GET GOOD BITS
	TRC	TAC,600			;CHANNEL END, DEVICE END
	TRCN	TAC,600			;DID WE GET THEM BOTH?
	JRST	OKNOW			;YES.  PERHAPS THE DISK IS HAPPY NOW
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES	
	ASCIZ	/RESET DISK.  THEN PUSH CONTINUE.
/
	SETOM	DISFLAG
	PUSHJ	P,DISFLUSH		;MAKE SURE THEY SEE IT 
	POPACS
	HALT	.+1
	PUSHJ	P,DISKUP		;BLAST HIM AGAIN
OKNOW:
	CONO	PI,PIOFF		;MAKE SURE WE DON'T LOSE
	SETOM	HNGFLG			;TELL DSKINT WHY
	CONO	PMP,660010!DSKCHN	;MAKE AN INTERRUPT ON DISK CHANNEL
	CONO	PI,PION
	POPJ	P,

;SETDDB CLRDDB	CORE ALLOCATION ROUTINES


↑SETDDB:			;CALLED BY ASSASG IN IOCSS FOR INIT UUO.
	PUSHJ	P,GCOR1			;POINTER IN TAC
	PUSH	P,TAC1
	LDB	TAC1,PUNIT
	SKIPE	TAC1
	AOS	UDPCNT-1(TAC1)		;BUMP COUNT OF DDBS FOR THIS UDP
	MOVE	TAC1,DKDBML(TAC1)	;GET ADDRESS OF MODEL DDB
	HRRI	DDB,DDBSKW(TAC)		;SAVE GOOD BITS IN LH
	HRLI	TAC,-DDBSKW(TAC1)	;SOURCE ADDRESS IN LH
	BLT	TAC,DMPBUF(DDB)		;CLEAR, INITIALIZE DDB
	HRLM	DDB,DEVSER(TAC1)	;NEW LINK IN DUMMY
	POP	P,TAC1
	SETZM	DEVLOG(DDB)		;CLEAR LOGICAL NAME.
	SETZM UFDPPN(DDB)
	SETZM UFDADR(DDB)
	JRST	DCLSDD			;CLEAR CRUD AND RETURN

↑CLRDDB:			;CALLED BY RELEASE IN UUOCON FOR RELEASE UUO.
	PUSHJ	P,DCLSDD
	SETZB	IOS,DEVIOS(DDB)			;HEAR NO EVIL
	LDB	TAC1,PUNIT			;GET UNIT NUMBER
	JUMPE	TAC1,CLRDD3			;JUMP IF MAIN DISK
	SOSE	TAC,UDPCNT-1(TAC1)
	JRST	CLRD99

;THERE ARE NO OTHER DDBS.  GIVE AWAY THE FS FOR THE SAT TABLE
	SETOM	UDPOWN-1(TAC1)			;MAKE PUBLIC FOR NEXT INIT OR ASSIGN
	MOVE	AC3,DKDBML(TAC1)
	MOVSI	TAC,DVDSK
	IORM	TAC,DEVMOD(AC3)
	MOVEI	TAC,DSKDSP
	HRRM	TAC,DEVSER(AC3)
	SKIPE	TAC,SATADR(TAC1)
	PUSHJ	P,RCOR1				;GIVE AWAY THE FS BLOCK FOR SAT
	SETZB	TAC,SATADR(TAC1)
	TROA	TAC,DMES1
CLRD99:
	MOVEI	TAC,DMES2
	PUSH	P,DDB
	PUSH	P,TAC				;SAVE MESSAGE
	CONSO	PI,400				;IN PROG ON 7?
	JRST	CLRDD1
	PUSHJ	P,TTYFND			;J SET UP FROM COMMAND DECODER WE HOPE
	PUSH	P,-1(P)				;GET UDP DDB TO (P) FOR ERNAM
	PUSHJ	P,ERNAM				;TYPE "DEVICE UDPN"
	POP	P,(P)
	POP	P,TAC				;SETUP MESSAGE
	PUSHJ	P,CONMES
	JRST	CLRDD2				;RELEASE DDB

DMES1:
	ASCIZ	/ MAY BE UNLOADED
/
DMES2:
	ASCIZ	/ STILL IN USE - DON'T UNLOAD
/

CLRDD1:
	SKIPN	UDPCNT-1(TAC1)			;RELEASE BY UUO:
	JRST	CLRD19				;ALWAYS GIVE DMES1 IF APPROPRIATE,
	MOVE	TAC,DKDBML(TAC1)		;BUT DON'T GIVE DMES2 IF THIS JOB HAS
CLRD11:
	HLRZ	TAC,DEVSER(TAC)			; OTHER DDBS FOR THIS UDP
	JUMPE	TAC,CLRD19			;THIS CAN'T HAPPEN
	MOVE	TAC1,DEVNAM(TAC)
	CAME	TAC1,DEVNAM(DDB)
	JRST	CLRD19				;NO MORE DDBS, GIVE THE MESSAGE
	LDB	TAC1,[POINT 6,DEVCHR(TAC),5]	;PJOBN
	CAIE	TAC,(DDB)			;THE DDB WE'RE FLUSHING DOESN'T COUNT
	CAME	TAC1,JOB(PID)
	JRST	CLRD11				;NOT OUR DDB, KEEP LOOKING
	POP	P,TAC				;OUR DDB, DON'T DO THE MESSAGE
	JRST	CLRDD2

CLRD19:
	JUMPE	PROG,CLRDD2			;NO CORE, NO MESSAGE
	PUSHJ	P,TTYFUW
	PUSH	P,-1(P)				;UDP DDB TO (P) FOR ERNAM
	PUSHJ	P,ERNAM				;TYPE "DEVICE UDPN"
	POP	P,(P)
	POP	P,TAC
	PUSHJ	P,CONMES
	PUSHJ	P,TYPGO
CLRDD2:
	POP	P,DDB
	LDB	TAC1,PUNIT
CLRDD3:
	MOVE	TAC,DKDBML(TAC1)		;SEARCH FOR THIS DDB - START AT MODEL
CLRDD4:
	MOVEI	TAC1,(TAC)
	HLRZ	TAC,DEVSER(TAC1)
	JUMPE	TAC,CPOPJ			;SHOULDN'T HAPPEN
	CAIE	TAC,(DDB)			;RIGHT ONE YET?
	JRST	CLRDD4				;NO. KEEP SEARCHING
	MOVE	DDB,DEVSER(TAC)			;LINK TO ONE AFTER LOSER
	HLLM	DDB,DEVSER(TAC1)		;SPLICE AROUND IT
	SUBI	TAC,DDBSKW			;CALC ADDRESS OF FREE STG BLOCK
	JRST	RCOR1				;RETURN TO DISK FREE STG. AND POPJ

;CORE ALLOCATION ROUTINES

GETCOR:
	PUSHJ	P,GCOR1				;GET DUMP MODE COMMAND BUFFER.
	MOVSM	TAC,DMPBUF(DDB)
	POPJ	P,

GCOR1:
	MOVEI	AC3,DDBSIZ			;SET SIZE
	PUSHJ	P,FSGET				;GET FREE STORAGE
	JRST	GCOR2				;HAVE TO WAIT
	MOVEI	TAC,(AC1)			;RETURN ADDRESS IN TAC
	POPJ	P,

GCOR2:
	SUB	P,[XWD 4,4]			;CALLED FROM COMMAND DECODER
	JRST	DLYCM1

RTNCOR:
	HLRZ	TAC,DMPBUF(DDB)			;RELEASE DUMP MODE CMD BUFFER.
	SETZM	DMPBUF(DDB)
	JUMPE	TAC,CPOPJ			;IF NONE, LEAVE QUICK
RCOR1:
	HRRZ	AC1,TAC				;GET ADDRESS OF BLOCK
	JRST	FSGIVE				;RETURN IT

;REFRES		DISK REFRESHER (I. E., INITIALIZER)

COMMENT ∩
↑REFRESH:
	PUSHJ	P,DQINI			;INITIALIZE SUBR QUEUE, ETC.
	CONO	PI,PION
	MOVEI	DDB,DSKDDB
	MOVEI	IOS,0
	MOVEI	DAT,SATIN		;READ IN OLD SAT TABLE.
	PUSHJ	P,DDOIT			;SEE TO IT.
	SKIPLE	TAC,BADCNT+SATTAB	;SEE IF ITS BAD TRACK TABLE IS BELIEVABLE.
	CAILE	TAC,BADMAX
	JRST	REF3			;IGNORE OLD TABLE.
	MOVEI	TAC1,0			;CHECKSUM OLD TABLE.
	ADD	TAC1,BADTRK-1+SATTAB(TAC)
	SOJG	TAC,.-1
	CAMN	TAC1,BADCHK+SATTAB
	JRST	REF4			;IT CHECKS. USE IT.
REF3:
	SETZM	BADCNT+SATTAB		;FLUSH OLD TABLE.
	SETZM	BADCHK+SATTAB
REF4:
	MOVE	TAC1,TIME		;GET CURRENT TIME,
	DATAI	DSK,TAC			;AND CURRENT POSITION OF LIBRASCOPE..
	XOR	TAC,TAC1		;..AND MAKE SHINY NEW SATID.
	MOVMM	TAC,SATID+SATTAB	;MAKE SATID ALWAYS POSITIVE.
	MOVMM	TAC,SATID1		;MAKE BACKUP SATID'S RIGHT
	MOVMM	TAC,SATID2
	SETZM	LSTBLK+SATTAB
	SETZM	SATBIT+SATTAB
	MOVE	TAC,[SATBIT+SATTAB,,SATBIT+1+SATTAB]
	BLT	TAC,SATBIT+SATWCT+SATTAB	;CLEAR THE REST
	MOVE	TAC,MFDLOC		;PROTECT MFD IN SAT
	SUBI	TAC,1
	IDIVI	TAC,=36			;DO THE MAPPING OURSELVES
	MOVEI	DAT,1			;TO ACHIEVE UNCONDITIONLITY
	MOVEM	DAT,DSKUSE+SATTAB	;ECONOMY!
	ROT	DAT,(TAC1)
	IORM	DAT,SATBIT+SATTAB(TAC)
	MOVEM	DAT,SATCHK+SATTAB	;OK FOR SAT TABLE.
	MOVEI	DAT,SATOUT		;WRITE IT.
	PUSHJ	P,QENTER
	PUSHACS
	PUSHJ	P,DISINIT		;HERE FROM ONCE, WE NEED TO INITIALIZE THIS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/SATID=/
	MOVE	TAC,SATID+SATTAB
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ	/  BADCNT=/
	MOVE	TAC,BADCNT+SATTAB
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	SETOM	DISFLAG
	PUSHJ	P,DISFLUSH		;FORCE ALL MESSAGES OUT
	POPACS
REF2:
	MOVEI	TEM,SYSRTV		;CONSTRUCT EMPTY MFD IN SYSBUF
	HRLI	TAC,MFDENT
	HRRI	TAC,DSKDAT(TEM)
	BLT	TAC,DDPRO(TEM)		;COPY NAME, EXT, PROT
	MOVE	TAC,SYSPPN
	MOVEM	TAC,DDPPN(TEM)
	SETZM	DDLNG(TEM)
	HRLI	TAC,DDLNG(TEM)
	HRRI	TAC,DDLNG+1(TEM)
	BLT	TAC,BKDSIZ+SECSIZ-1+DSKDAT(TEM)		;CLEAR THE REST
	MOVE	TAC,MFDLOC		;SET UP RTVL PTRS
	MOVEM	TAC,DDLOC(TEM)
	HRLM	TAC,DPTR(TEM)
	AOS	DGRP1R(TEM)
	MOVE	TAC,SATID+SATTAB
	MOVEM	TAC,DSATID(TEM)		;GIVE MFD THE SAT ID TOO
	MOVE	TAC,THSDAT		;DATE CREATED
	HRRM	TAC,DDEXT(TEM)
	PUSHJ	P,DSKTM1
	DPB	TAC,[POINT 3,DDEXT(TEM),20];RPH/DATE75
	ORM	TAC1,DDPRO(TEM)		;TIME LAST WRITTEN
	PUSHJ	P,XWSYNC		;WAIT FOR SATOUT
	MOVE	TAC,BUFIOW
	MOVEM	TAC,TFRIOW(DDB)
	MOVE 	TAC,MFDLOC
	PUSHJ	P,BK2SEC
	MOVEM	TAC,TFRSEC(DDB)
	MOVEI	DAT,TSTART
∩;END OF COMMENTED OUT REFRESH CODE

DDOIT:
	PUSHJ	P,QENTER		;MAKE REQUEST AND

XWSYNC:
	MOVE	TAC,[XWD DEVSBB,IOACT]	; SPIN TILL DONE
	TDNE	TAC,DEVIOS(DDB)
	JRST	.-1
	POPJ	P,

;DSKINI, DSKSTP, DSKTM1 (TIME CONTROL)
;TIME CONTROL. INFORMATION KEPT AS FOLLOWS:
;DATE CREATED IN UFD (FILEXT) [DEC - DATE LAST WRITTEN]
;TIME LAST WRITTEN IN UFD (FILPRO) [DEC - TIME CREATED]
;TIME LAST REFERENCED IN FILE - DREFTM
;TIME LAST DUMPED IN FILE - DDMPTM
;LATTER TWO ARE ACCESSED THRU 6-WORD ENTER-LOOKUP BLOCKS IF
;DMPBIT SET BY INIT.

↑DSKTM1:			;CALLED ALSO FROM UUOCON -DSKTIM UUO
	MOVE	TAC,TIME
	IDIVI	TAC,=3600			;JIFFIES/MIN.
	HRRZ	TAC1,THSDAT
	DPB	TAC,[POINT 11,TAC1,23]
	LDB	TAC,[POINT 3,THSDAT,35-12]	;EXTRA BITS IN TAC - RPH/DATE75
	POPJ	P,				;RETURN RESULT IN TAC1.

;DSKSTP CALLED FROM AUTORELOAD CODE IN OUTER TO PRESERVE THE SAT TABLE
↑DSKSTP:
	PUSHJ	P,DQINI		; CLEAR QUEUE
	CONO	PI,2202		; TURN ON PI AND CH6
OSAT:
	MOVEI	DDB,DSKDDB
	PUSHJ	P,CUSATO
	JRST	XWSYNC

ISAT:
	MOVEI	DDB,DSKDDB	;HERE FROM ACISAT
	MOVEI	DAT,SATIN
	PUSHJ	P,NENTER
	JRST	XWSYNC		;WAIT FOR DISK AND RETURN

;DSKINI CALLED VIA DISPATCH FROM IOGO IN SYSINI FOR 200 RESTART.

DSKINI:
	PUSHJ	P,DQINI
	SETZM	CUSLOC			;FORGET CUSLOC ON RESTARTS
	PUSHJ	P,ACISAT		;READ SAT TABLE
	MOVE	TAC,DSKDDB+DEVIOS	;GET IOS BITS
	TRNE	TAC,IODERR!IODTER	;DID IT WORK?
	JRST	NOSAT			;NO
	MOVEI	DDB,UDP1DD		;LINK OUT CRUFTY OLD DISK DDB'S
	HRLM	DDB,DSKDDB+DEVSER
	SETZM	SATADR+1
IFG UPACKS-1,<	MOVE	TAC,[SATADR+1,,SATADR+2]
		BLT	TAC,SATADR+UPACKS>
	SETOM	UDPOWN
IFG UPACKS-1,<	MOVE	TAC,[UDPOWN,,UDPOWN+1]
		BLT	TAC,UDPOWN+UPACKS-1>
	SETZM	UDPCNT
IFG UPACKS-1,<	MOVE	TAC,[UDPCNT,,UDPCNT+1]
		BLT	TAC,SATMOD+UPACKS>

	MOVEI	DDB,DSKDDB		;MAKE SURE WE LINK TO UDPINI
	SKIPE	FBACT			;SWAPPING WHERE?
	POPJ	P,			;ON FASTBANDS, SKIP SWAPPING PACK CRUD
PASCHK:
	MOVEI	DDB,UDP1DD;CAT(CAT(UDP,\<UPACKS>),DD)	;THE LAST UDP
	MOVEI	TAC,ASSCON!ASSPRG
	IORM	TAC,DEVMOD(DDB)		;ASSIGN THIS UDP
	MOVE	TAC,['*SWAP*']
	MOVEM	TAC,DEVLOG(DDB)		;ANNOUNCE THAT UDP IS USED FOR SWAPPING
	SETZB	TAC,DEVIOS(DDB)
	DPB	TAC,PJOBN		;TO JOB 0
	SETZM	UDPOWN-1+UPACKS		;RESERVE PRIVATE UDP FOR JOB ZERO
	SETZM	SWPDDB			;THIS IS THE UDP WE ARE SWAPPING ON
	MOVEI	DAT,PASSIN		;READ PASSWORD BLOCK
	PUSHJ	P,NENTER
	PUSHJ	P,XWSYNC		;WAIT FOR IT
	MOVE	TAC,DEVIOS(DDB)
	TRNE	TAC,IODERR!IODTER!IOIMPM
	JRST	PASERR			;IO ERRORS OCCURED
	MOVE	TAC,['PASS  ']		;IS IT INITIALIZED
	CAMN	TAC,DSKDAT(DDB)
	CAME	TAC,DSKDAT+1(DDB)
	JRST	PASOK			;NO. IT IS GRUNGY
	SKIPE	TAC,DSKDAT+2(DDB)	;PASSWORD MUST BE NULL FOR SWAPPING
	CAMN	TAC,['*SWAP*']		;SWAPPING PACK?
	JRST	PASOK			;YES.
	JRST	PAKERR			;BARF
PASOK:
	MOVEI	DAT,PASOUT		;NOW TRY WRITING
	PUSHJ	P,NENTER
	PUSHJ	P,XWSYNC
	MOVE	TAC,DEVIOS(DDB)
	TRNE	TAC,IODERR!IODTER!IOIMPM
	JRST	PASERR			;POSSIBLY WRITE-LOCKED
	MOVEM	DDB,SWPDDB		;SAVE DDB ADDRESS FOR SWAP OPS
	MOVEI	DDB,DSKDDB		;SET UP DDB FOR SYSINI?
	POPJ	P,

	DEFINE	SWPMES $(XXX) <	ASCIZ	/SWAPPING DRIVE (UDP$XXX$) / >

PAKERR:
	PUSHACS
	PUSHJ	P,DISMES
	SWPMES	(\<UPACKS>)
	PUSHJ	P,DISMES
	ASCIZ	/WRONG PACK MOUNTED.
/
PASTRY:
	PUSHJ	P,DISMES
	ASCIZ	/FIX IT.  PUSH CONTINUE TO TRY AGAIN
/
	SETOM	DISFLAG
	PUSHJ	P,DISFLUSH
	POPACS
	HALT	PASCHK			;TRY ALL OVER AGAIN


PASERR:
	PUSHACS
	PUSH	P,TAC
	PUSHJ	P,DISMES
	SWPMES	(\<UPACKS>)		;TELL SOMEONE WHICH UDP WE'RE USING.
	POP	P,TAC
	TRNN	TAC,IOIMPM		;OFFLINE OR WRITE-LOCK?
	JRST	PASIOE			;NO.  REAL IO ERROR
	PUSHJ	P,DISMES
	ASCIZ	/OFF LINE OR WRITE LOCKED
/
	JRST	PASTRY

PASIOE:
	PUSHJ	P,DISMES
	ASCIZ	/IO ERROR
/
	JRST	PASTRY

NOSAT:
	PUSHACS
	MOVE	TAC,[JRST AUTOLOAD]	;MAKE THEM START FROM THE FRONT
	MOVEM	TAC,SYSDSP
	MOVEM	TAC,SYSDSP+2
	MOVE	TAC,[XWD SYSDSP+2,SYSDSP+3]
	BLT	TAC,SYSDSP+7
	MOVE	TAC,UPTIME
	MOVEM	TAC,LASTRESTART		;DON'T DO A 200 RESTART
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/FAILED TO GET SAT TABLE READ IN.  CHECK DISK, THEN RELOAD.
/
	SETOM	DISFLAG
	PUSHJ	P,DISFLUSH
	POPACS
	HALT	AUTOLOAD

DQINI:
	SETZM	QBEGIN			;INITIALIZE DISK SUBR QUEUE.
	MOVSI	TAC,QUBEG		;START OF THE UDP QUEUE
	HLRZM	TAC,MIPTR+1
	HLRZM	TAC,MOPTR+1
	MOVSI	TAC,QBEGIN		;START OF THE DISK QUEUE
	HLRZM	TAC,MIPTR
	HLRZM	TAC,MOPTR
	SETZM	DQCNT			;NUMBER OF TASKS IN DISK QUEUE
	HRRI	TAC,QBEGIN+1
	BLT	TAC,QUEND		;CLEAR OUT REQUEST QUEUE
	PUSHJ	P,DISKUP		;MAKE IBM LISTEN TO US

IJOB:
	SETZM	DFBUSY
	SETZM	SQREQ
	HLLZS	IOPCON
	SETZM	DXB
	SETZM	DSKEDD
	SETZM	ERRBIT
	SETZM	DSKERB
	SETZM	BKIN
	POPJ	P,

ACISAT:
	CONO	PI,PION			;CERTAINLY ISN'T ON YET
	SKIPN	SATDIR			;READ IF -1.(FIRST TIME ONLY)
	JRST	OSAT			;ELSE WRITE (POPJ FROM OSAT)
	MOVE	TAC,SATID+SATTAB	;MAKE SURE COPIES OF SATID AGREE
	MOVEM	TAC,SATID1
	MOVEM	TAC,SATID2
	PUSHJ	P,ISAT			;GET SAT IN
	MOVE	TAC,SATID+SATTAB	;NOW COPY GOOD SATID
	MOVEM	TAC,SATID1
	MOVEM	TAC,SATID2
	SETZM	SATDIR			;FROM NOW ON, WRITE THE SAT TABLE

;ENTER HERE FROM SATGET AT UUO LEVEL FOR NEW STYLE UDP SERVICE
ACISTT:
	LDB	AC3,PUNIT		;GET THE DISK UNIT NUMBER
	MOVE	TAC,LSTBTB(AC3)		;NUMBER OF BITS IN THIS SAT TABLE
	ADDI	TAC,43
	IDIVI	TAC,44
	IMULI	TAC,44			;CALC NUMBER OF WORDS IN SAT TABLE
	MOVE	AC3,SATADR(AC3)		;ADDRESS OF SAT TABLE
	MOVE	TAC1,[POINT 1,SATBIT(AC3)]	;PREPARE TO COUNT SAT BITS!
	SETZB	AC1,BADCHK(AC3)		;BIT COUNT, BAD TRACK CHECKSUM
	ILDB 	AC2,TAC1		;LOAD A BIT
	ADDI	AC1,(AC2)		;SEE THE CLEVER PROGRAMMER COUNT BITS
	SOJGE	TAC,.-2			;COUNT THEM ALL
	MOVEM	AC1,DSKUSE(AC3)		;SET HONEST DSKUSE
	SKIPG	AC2,BADCNT(AC3)		;ANY BAD TRACKS TO TURN ON?
	POPJ	P,			;NO.
	CAILE	AC2,BADMAX
	MOVEI	AC2,BADMAX
	HRLOI	AC2,-1(AC2)
	EQVI	AC2,BADTRK(AC3)		;FORM AOBJN POINTER
MRKITB:
	MOVE	TAC,(AC2)
	ADDM	TAC,BADCHK(AC3)		;ACCUMULATE CHECKSUM
	PUSHJ	P,MRKBLK		;MARK BAD TRACK SO IT WON'T GET USED
	AOBJN	AC2,MRKITB
	POPJ	P,

; BUFFERED I/O

;BUFFERED INPUT

DBUFI:
	TLNN	IOS,READB!WRITEB!ALTERB	
	JRST	ENOLUK				;NO LOOKUP
	TRNE	IOS,IODERR!IODTER		;ERROR LAST TIME?
	POPJ	P,				;YES
	TLNE	IOS,LOSBIG			;BAD RETRIEVAL?
	JRST	EGARB				;YES PRINT MESSAGE
	MOVSI	IOS,IO
	ANDCAB	IOS,DEVIOS(DDB)			;MARK AS READING
	JSP	AC1,TSTEOF			;RETURN NOW IF PAST EOF
	JRST	DIEOF
	MOVEI	DAT,DIBUFI
	PUSHJ	P,QENTER			;QUEUE TASK. USER PGM CAN PROCEED
	POPJ	P,

TSTEOF:
	MOVE	TAC,USETP(DDB)			;GET USET POINTER
	SUBI	TAC,1
	ASH	TAC,RECWSH			;RECORD NUMBER * 200 = WORD NUMBER
	CAMGE	TAC,FILLNG(DDB)			;PAST EOF?
	JRST	1(AC1)				;NO.  OK TO READ MORE
	JRST	(AC1)				;PAST EOF

;***INTERRUPT SUBR***

DIBUFI:
	PUSHJ	P,GETBLK			;GET BLOCK INTO SYSBUF
	JUMPE	TAC,SETLOS			;NON EX = BAD RETRIEVAL
	PUSHJ	P,AUDCHK			;DID WE GET THE RIGHT FILE?

DIBFI1:
	MOVE	TAC,USETP(DDB)
	SUB	TAC,DGRP1R(DDB)
	IDIVI	TAC,RCPBLK
	ASH	TAC1,RECWSH			;7
	HRRZ	TAC,DEVIAD(DDB)			;GET REL. ADDR. OF USER BUFFER
	HLRZ	DAT,PROG
	CAIG	TAC,(DAT)			;ILL. ADR.?
	JRST	DIBFI3				;NO, RELOCATE BY PROG
	LDB	DAT,PSEGN			;YES, CHECK FOR UPPER SEGMENT
	HRRZ	DAT,JBTADR(DAT)
	ADDI	TAC,-400000(DAT)
	JRST	DIBFI4

DIBFI3:
	ADDI	TAC,(PROG)			;RELOCATE INTO LOWER
DIBFI4:
	HRLI	DAT,SYSDTA(TAC1)
	HRRI	DAT,2(TAC)
	BLT	DAT,RECSIZ+1(TAC)		;INTO USER'S BUFF
	AOS	TAC1,USETP(DDB)
	SUBI	TAC1,1
	ASH	TAC1,RECWSH
	SUB	TAC1,FILLNG(DDB)
	MOVEI	DAT,RECSIZ			;SET UP WORD COUNT
	JUMPL	TAC1,DIBFI2			;IF NOT PAST EOF
	TLO	IOS,IOEND			;EOF; TELL USER
	SUB	DAT,TAC1			;ADJUST WORD COUNT
DIBFI2:
	HRRM	DAT,1(TAC)			;GIVE WD CT TO USER.
	PUSHJ	P,ADVBFF
	POPJ	P,				;NO MORE BUFFERS EMPTY.
	TLNE	IOS,IOEND			;QUIT IF END OF FILE
	POPJ	P,
	MOVE	TAC,USETP(DDB)
	SUB	TAC,DGRP1R(DDB)
	IDIVI	TAC,RCPBLK
	JUMPN	TAC1,DIBFI1			;DO MORE IF BLK NOT DONE
	POPJ	P,				;QUIT.

DIEOF:
	TLO	IOS,IOEND
	JRST	DSIOS				;STORE IOS, AND POPJ.

;BUFFERED OUTPUT

DBUFO:
	TLNN	IOS,WRITEB!ALTERB
	JRST	ENOENT
	MOVSI	IOS,IO
	IORB	IOS,DEVIOS(DDB)			;FLAG OUTPUT FOR UUOCON
	TLNE	DDB,OCLOSB			;CALLED BY CLOSE?
	JRST	DBUFO1				;YES, DO OUTPUT NOW
DBUFOA:
	TRNE	IOS,IODERR!IODTER		;ERROR RECENTLY
	POPJ	P,				;YES, TELL HIM
	TLNE	IOS,LOSBIG			;OR BAD RETRIEVAL
	JRST	EGARB				;YES
	HLR	TAC,DEVBUF(DDB)			;PTR TO OBUFF HDR
	XCTR	XR,[HRR TAC,(TAC)]		;GET PTR TO NEXT FREE BFR
	XCTR	XR,[SKIPL TAC1,(TAC)]
	JRST	DBFOGO				;NEXT BUFFER IS FREE.
	TRNN	IOS,IOACT			;NEXT BUFFER IS FULL.
	PUSHJ	P,DBUFO1			;IF NOT ACTIVE, START OUTPUT.
	PUSHJ	P,WSYNC				;WAIT FOR OUTPUT TO HAPPEN.
	JRST	DBUFOA				;RETURN OR START NEXT OUTPUT.

DBFOGO:
	XCTR	XR,[SKIPGE (TAC1)]		;CHECK ONE AFTER.
	TRNE	IOS,IOACT			;IT'S FULL, OUTPUT ALREADY GOING?
	POPJ	P,				;YES, LET USER RUN.

DBUFO1:
	PUSHJ	P,MAKBLK			;ENTER A TRANSFER IN QUEUE.
	MOVEI	DAT,DIBUFO			;CALL INT LEVEL SUBR
	PUSHJ	P,QENTER			;USER PGM CAN PROCEED
	POPJ	P,

;*** INTERRUPT SUBR ***

DIBUFO:
	MOVE	TAC,USETP(DDB)			;LOAD SYSBUF & OUTPUT
	MOVEM	TAC,DSKFAD(DDB)
	SUB	TAC,DGRP1R(DDB)
	IDIVI	TAC,RCPBLK
	ASH	TAC1,RECWSH
	MOVEI	TAC,SYSDTA(TAC1)		;DATA AREA OF SYSBUF
	MOVEM	TAC,CORFAD(DDB)
	MOVEM	TAC,CORLAD(DDB)

DIBFO1:
	HRRZ	TAC,DEVOAD(DDB)
	HLRZ	TAC1,PROG
	CAIG	TAC,(TAC1)
	JRST	DIBFO2
	LDB	TAC1,PSEGN
	HRRZ	TAC1,JBTADR(TAC1)
	ADDI	TAC,-400000+2(TAC1)
	JRST	DIBFO3

DIBFO2:
	ADDI	TAC,2(PROG)
DIBFO3:
	SKIPG	AC1,-1(TAC)			;ANY WORDS IN THIS BUFFER
	JRST	DIBFO4				;NO, SKIP OVER IT
	MOVSS	TAC
	HRR	TAC,CORLAD(DDB)
	MOVEI	TAC1,RECSIZ(TAC)
	MOVEM	TAC1,CORLAD(DDB)
	BLT	TAC,-1(TAC1)			;COPY USRBUF TO SYSBUF
	AOS	USETP(DDB)
	PUSHJ	P,ADVBFE
	JRST	DIBOFT				;NO MORE BUFFERS READY
	MOVE	TAC,USETP(DDB)
	SUB	TAC,DGRP1R(DDB)
	IDIVI	TAC,RCPBLK
	JUMPN	TAC1,DIBFO1			;BLOCK NOT DONE, DO MORE

DIBOFT:
	MOVE	TAC,CORFAD(DDB)			;PICK UP STARTING ADDRESS
	CAML	TAC,CORLAD(DDB)			;BEFORE FINISHING ADDRESS
	POPJ	P,				;NO, NOTHING TO DO.
	MOVE	TAC,USETP(DDB)			;DID FILE GROW?
	SUBI	TAC,1+1				;-1 FOR AOS ABOVE, -1 FOR LAST RECORD,
	ASH	TAC,RECWSH			;WHICH WILL BE COUNTED BY WC BELOW
	CAILE	AC1,RECSIZ
	MOVEI	AC1,RECSIZ			;AVOID BUMPING WC BY TOO MUCH
	ADDI	TAC,(AC1)			;ADD WC FROM LAST RECORD WRITTEN
	CAMG	TAC,FILLNG(DDB)
	JRST	DIBOFW				;NO, GO DO OUTPUT.
	MOVEM	TAC,FILLNG(DDB)			;YES, MARK IT SO
;	MOVEI TAC,1
;	CAME TAC,DGRP1R(DEVDAT)	;IF BEYOND FIRST GROUP,
;	TLOA IOS,HDRDIF!PNTDIF		;UPDATE RTVL AT CLOSE.
	TLO	IOS,PNTDIF!HDRDIF
DIBOFW:
	MOVE	TAC,CORFAD(DDB)			;IF RTVL NOT CONTIGUOUS,
	CAIN	TAC,SYSDTA			;CAN'T WRITE IT NOW.
	TLNN	IOS,PNTDIF
	JRST	DIBOFN				;UPDATING RTVL NOT RQD
	PUSHJ	P,AUDINF
	HRLI	TAC,DSKDAT(DDB)			;BLT RTVL FROM DDB...
	HRRI	TAC,SYSBUF			;TO SYSBUF
	BLT	TAC,SYSDTA-1
;	PUSHJ P,SPREDT		;FIRST UPDATE PRIOR RTVL.
	MOVE	TAC,DSKFAD(DDB)			;SET UP TRANSFER
	PUSHJ	P,LR2BLK
	JUMPE	TAC,SETLOS			;NON EX = BAD RETRIEVAL
	PUSHJ	P,BK2SEC
	LDB	AC3,PUNIT
	ADD	TAC,BFSETS(AC3)			;ADD IN OFFSET
	MOVEM	TAC,TFRSEC(DDB)
	MOVE	TAC,CORFAD(DDB)
	SUB	TAC,CORLAD(DDB)
	ADD	TAC,[SYSBUF,,-40]
	MOVSM	TAC,TFRIOW(DDB)			;WRITE ONLY THE RETRIEVAL AND VALID DATA
	JRST	RERITE				;GO DO OUTPUT.

DIBOFN:
	MOVE	TAC,CORFAD(DDB)			;HERE IF RTVL IS OUT
	SUB	TAC,CORLAD(DDB)			;GET -WORD COUNT
	HRL	TAC,CORFAD(DDB)
	MOVSM	TAC,TFRIOW(DDB)
	MOVE	TAC,DSKFAD(DDB)			;STARTING RECORD NO.
	PUSHJ	P,LR2BLK
	JUMPE	TAC,SETLOS			;NON EX = BAD RETRIEVAL
	PUSHJ	P,BKMAP
	LDB	AC1,PUNIT
	ADD	TAC,BFSETS(AC1)
	MOVEM	TAC,TFRSEC(DDB)

RERITE:
	MOVEI	TAC,DWRITE!IOPCHN
	MOVSM	TAC,TFRCTL(DDB)
	JRST	TSTART				;WRITE OUT DATA

SETLOS:
	TDO	IOS,[LOSBIG!IOEND,,IODEND]	;SCREW THE BASTARD
	JRST	DSIOS				;STO IOS AND GO UP ONE LEVEL

DIBFO4:
	PUSHJ	P,ADVBFE			;ADVANCE THE BUFFERS
	JRST	DIBOFT				;NONE LEFT, DO TRANSFER IF ANY WORDS TO TRANSFER
	JRST	DIBFO1				;LOOK AT ANOTHER BUFFER

; DUMP MODE I/O

;COMMAND LIST IN IOWD FORMAT: (-WDCT)SA-1
;GETS CONVERTED TO 167 FORMAT: (-WDCT)SA
; RETURNS STARTING ADDRESS IN TAC1 AND -WD CT IN TAC

↑DMPCMD:
	MOVEI	AC1,JOBPFI			;LOWER LIMIT
	MOVE	TAC,UUOPC(J)
	TLNN	TAC,USRMOD			;MONITOR OP?
	MOVEI	AC1,JOBSAV			;YES
	HLRZ	AC2,PROG			;UPPER LIMIT=PROTECTION
	LDB	AC3,PSEGN
	JUMPE	AC3,DMPGET			;AC3 ← HIGH SEGEMENT PROTECT ADDR
	HLRZ	AC3,JBTADR(AC3)
	ADDI	AC3,400000			;UPPER SEGMENT ADDRESSES ARE O.K.

DMPGET:

DMPGT1:
	XCTR	XR,[SKIPN TAC1,(UUO)]	;GET NEXT COMMAND WORD
	JRST	TPOPJ			;ZERO TERMINATES
DMPGT2:
	HLRE	TAC,TAC1		;NEGATIVE WORD COUNT
	ANDI	TAC1,-1			;FIRST ADDRESS-1
	JUMPE	TAC,DMPTCH		;JUMP IF THIS IS A JUMP COMMAND
	ADDI	TAC1,1			;REAL STARTING ADDRESS
	CAIGE	TAC1,(AC1)		;ABOVE MINUMUM PROTECT ADDRESS?
	JSP	DAT,ADRERR		;NO. LOSE.
	PUSH	P,TAC1			;SAVE STARTING ADDRESS
	HRRO	TAC,TAC			;IN CASE HUGE WD CT
	SUB	TAC1,TAC		;CALCULATE LAST ADDR
	CAIG	TAC1,1(AC2)		;IS IT WITHIN LOWER?
	JRST	T1POPJ			;YES.  WIN.
	CAIG	TAC1,1(AC3)		;BENEATH TOP OF UPPER?
	TRNN	TAC1,400000		;YES. IN UPPER AT ALL.
	JSP	DAT,ADRERR		;NO TO ONE OF ABOVE
T1POPJ:
	POP	P,TAC1			;GET STARTING ADDRESS BACK
	POPJ	P,			;WIN

DMPTCH:
	HRR	UUO,TAC1		;SET ADDRESS OF NEXT COMMAND
	CAIG	TAC1,(AC1)		;ABOVE PROTECTED AREA?
	JSP	DAT,ADRERR		;NO. LOSE
	CAIG	TAC1,(AC2)		;ADDRESS OK?
	JRST	DMPGET			;YES.
	CAIG	TAC1,1(AC3)		;BENEATH TOP OF UPPER?
	TRNN	TAC1,400000		;YES. IN UPPER AT ALL?
	JSP	DAT,ADRERR		;NO TO ONE OF ABOVE
	JRST	DMPGET

DDCALC:
	MOVE	AC1,USETP(DDB)		;LOCATE END OF BLOCK
	ADDI	AC1,RCPBLK-1		;CONTAINING USETP
	MOVEI	DAT,RCPBLK
	IDIVM	AC1,DAT			;SEE US CLEVERLY AVOID A REMAINDER !
	IMULI	DAT,RCPBLK
	LSH	DAT,RECWSH		;CONVERT TO WORD COUNT.
	POPJ	P,

;DUMP MODE INPUT

DDMPI:
	TLNN	IOS,READB!WRITEB!ALTERB
	JRST	ENOLUK
	JSP	AC1,TSTEOF		;SEE IF IMMEDIATE EOF
	JRST	DDMIEF			;YES. TELL LOSER.
	TLZ	IOS,IO			;FLAG INPUT
	TLO	IOS,GOBIT		;MAKE US UNSTOPPABLE.
	MOVEM	IOS,DEVIOS(DDB)
	PUSHJ	P,DDICOM

DDXIT:
	PUSHJ	P,RTNCOR		;RETURN COMMAND BUFFER TO FREE STG
	TRNN	IOS,IODERR!IODTER	;IF DATA OR DEVICE ERROR, LET USER SEE IT!
	TLNN	IOS,LOSBIG		;ELSE IF BAD RETRIEVAL PRINT MESSAGE
	JRST	DPOPJ
	JRST	EGARB

DDICOM:
	PUSHJ	P,GETCOR		;GET CORE FOR COMMAND LIST NOW
	PUSHJ	P,GETRET		;GET GROUP DIRECTORY
	JRST	SETLOS			;BAD RETRIEVAL
DDICO2:
	PUSHJ	P,DMPCMD		;GET AN IOWD
	MOVEM	TAC1,CORFAD(DDB)	;SAVE STARTING ADDRESS
	MOVE	AC1,USETP(DDB)
	SUBI	AC1,1
	ASH	AC1,RECWSH		;7
	MOVEM	AC1,DSKFAD(DDB)
	SUB	AC1,TAC			;CALC DISK LAST ADDR
	CAMG	AC1,FILLNG(DDB)
	JRST	DDICO3
	TLO	IOS,IOEND
	MOVE	AC1,FILLNG(DDB)		;STOP AT EOF
DDICO3:
	MOVEM	AC1,DSKLAD(DDB)

DDIC0:
	HLRS	DMPBUF(DDB)
DDIC1:
	PUSHJ	P,DDCALC		;FIND BLOCK END.
	CAMLE	DAT,DSKLAD(DDB)		;COMPARE WORD COUNTS.
	MOVE	DAT,DSKLAD(DDB)
	SUB	DAT,DSKFAD(DDB)		;THIS GIVES TFR WORD COUNT.
	MOVN	TAC,DAT
	HRR	TAC1,CORFAD(DDB)
	HLRZ	TEM,PROG
	CAIG	TAC1,(TEM)
	JRST	DDIC2
	LDB	TEM,PSEGN
	HRRZ	TEM,JBTADR(TEM)
	TRZ	TAC1,400000		;FOR 256K IT MUST BE DONE-RPH 4-17-72
	ADDI	TAC1,(TEM)
	JRST	DDIC3

DDIC2:
	ADDI	TAC1,(PROG)		;RELOCATE
DDIC3:
	HRL	TAC1,TAC		;PUT IN -WD COUNT
	AOS	TEM,DMPBUF(DDB)
	MOVEM	TAC1,-1(TEM)		;ENTER IN COMMAND LIST
	ADDM	DAT,CORFAD(DDB)		;BUMP FIRST ADDR BY WD CT
	ADDB	DAT,DSKFAD(DDB)
	ADDI	DAT,RECSIZ+RECSIZ-1	;ROUND UP TO RECORD
	ASH	DAT,-RECWSH
	MOVE	TAC,USETP(DDB)
	MOVEM	DAT,USETP(DDB)
	PUSHJ	P,LR2BLK
	JUMPE	TAC,SETLOS		;NON EX = BAD RETRIEVAL
	PUSHJ	P,BKMAP
	MOVEM	TAC,(TEM)
	AOS	TEM,DMPBUF(DDB)		;BUMP COMMAND POINTER
	HLRZ	TAC,TEM			;END CHECK COMMAND LIST
	CAIGE	TAC,-100(TEM)
	JRST	EDMPLS			;ILL FMT COMMAND LIST.
	MOVE	TAC,DSKFAD(DDB)
	CAME	TAC,DSKLAD(DDB)		;SEE IF REQUEST COMPLETED
	PUSHJ	P,TSTRET		;START XFER IF GRP OFLOW
	JRST	DDIGO			;RTVL NOT IN MEANS GRP OFLOW
	JRST	DDIC1			;NO OFLOW YET, DO MORE

DDIGO:
	MOVEI	DAT,DIDMPI		;START I-LEVEL SUBR
	PUSHJ	P,QEWAIT
	TRNE	IOS,IODERR!IODTER	;IF DEVICE SCREW-UP
	POPJ	P,			;QUIT NOW!
	MOVE	TAC,DSKFAD(DDB)
	CAME	TAC,DSKLAD(DDB)
	JRST	DDIC0			;WORDS LEFT; DO ANOTHER GROUP
	TLNN	IOS,IOEND		;END FILE?
	AOJA	UUO,DDICO2		;NO, DO NEXT IOWD

DDMIEF:
	IOR	IOS,[XWD IOEND,IODEND]
	JRST	DSIOS			;STORE IOS, AND POPJ.

;*** INTERRUPT SUBR ***

DIDMPI:
	MOVE	TEM,DMPBUF(DDB)
	HLRS	TEM
	MOVEI	TAC1,IOPCHN
	MOVSM	TAC1,TFRCTL(DDB)
	LDB	AC1,PUNIT
DIDMI1:
	MOVE	TAC1,(TEM)		;WCMA FROM COMMAND LIST
	MOVEM	TAC1,TFRIOW(DDB)
	MOVE	TAC1,1(TEM)
	ADD	TAC1,BFSETS(AC1)
	MOVEM	TAC1,TFRSEC(DDB)
	PUSHJ	P,TSTART
	ADDI	TEM,2
	CAMGE	TEM,DMPBUF(DDB)
	JRST	DIDMI1

DIDMI2:
	MOVE	TAC,DSKFAD(DDB)
	CAMN	TAC,DSKLAD(DDB)		;IF LAST TFR,JUST RETURN
	POPJ	P,
	SKIPN	TAC,DNXTGP(DDB)		;ELSE GET RTVL FOR NEXT GRP.
	JRST	DMIEF1			;FLAG END
	PUSHJ	P,BK2SEC
	LDB	TAC1,PUNIT
	ADD	TAC,BFSETS(TAC1)
	MOVEM	TAC,TFRSEC(DDB)
	MOVEI	TAC,DSKDAT(DDB)		;READ RIGHT INTO DDB
	HRLI	TAC,-SECSIZ
	MOVEM	TAC,TFRIOW(DDB)
	PUSHJ	P,TSTART
	PUSHJ	P,AUDCHK
	POPJ	P,

DMIEF1:
	TLO	IOS,IOEND
	POPJ	P,

;DUMP MODE OUTPUT

DDMPO:
	TLNN	IOS,WRITEB!ALTERB
	JRST	ENOENT
	TLO	IOS,IO!GOBIT		;FLAG OUTPUT
	MOVEM	IOS,DEVIOS(DDB)
	PUSHJ	P,DDOCOM
	JRST	DDXIT

DDOCOM:
	PUSHJ	P,GETCOR		;GET BUFFER FOR COMMAND LIST
DDOCO2:
	PUSHJ	P,DMPCMD		;GET IOWD
	MOVEM	TAC1,CORFAD(DDB)
	MOVE	AC1,USETP(DDB)
	SUBI	AC1,1
	ASH	AC1,RECWSH
	MOVEM	AC1,DSKFAD(DDB)
	SUB	AC1,TAC			;TAC: -WD CT
	MOVEM	AC1,DSKLAD(DDB)
	CAMG	AC1,FILLNG(DDB)		;DID FILE GROW?
	JRST	DDOC0
	MOVEM	AC1,FILLNG(DDB)
	TLO	IOS,HDRDIF		;INDICATE NEW FILLNG TO SPREAD.
	MOVEM	IOS,DEVIOS(DDB)		;GET IT INTO THE DDB

DDOC0:
	HLRS	DMPBUF(DDB)
DDOC1:
	PUSHJ	P,MAKBLK
	JUMPE	TAC,SETLOS		;NON EX = BAD RETRIEVAL
	PUSHJ	P,DDCALC		;LOCATE BLOCK'S END.
	CAMLE	DAT,DSKLAD(DDB)		;COMPARE WORD COUNTS.
	MOVE	DAT,DSKLAD(DDB)
	SUB	DAT,DSKFAD(DDB)		;THIS GIVES TFR WORD COUNT.
	MOVN	TAC,DAT
	HRR	TAC1,CORFAD(DDB)
	HRL	TAC1,TAC		;PUT IN -WD COUNT
	AOS	TEM,DMPBUF(DDB)
	MOVEM	TAC1,-1(TEM)		;ENTER IN COMMAND LIST
	ADDM	DAT,CORFAD(DDB)		;UPDATE STARTING ADDRESSES
	ADDB	DAT,DSKFAD(DDB)
	ADDI	DAT,RECSIZ+RECSIZ-1
	ASH	DAT,-RECWSH
	MOVE	TAC,USETP(DDB)
	MOVEM	DAT,USETP(DDB)
	PUSHJ	P,LR2BLK
	JUMPE	TAC,SETLOS		;NON EX = BAD RETRIEVAL
	PUSHJ	P,BKMAP
	MOVEM	TAC,(TEM)
	AOS	TEM,DMPBUF(DDB)
	HLRZ	TAC,TEM
	CAIGE	TAC,-100(TEM)		;END CHK COMND LIST
	JRST	EDMPLS			;ILL FMT COMMAND LIST.
	MOVE	TAC,DSKFAD(DDB)
	CAMN	TAC,DSKLAD(DDB)		;ALL WORDS ACCOUNTED FOR?
	JRST	DDMPO4			;YES, DO OUTPUT
	PUSHJ	P,TSTRET		;RTVL NOT IN MEANS GRP OFLOW
	JRST	DDMPO3			;GRP OFLOW, DO OUTPUT
	JRST	DDOC1			;NO OFLOW, DO NEXT BLOCK

DDMPO3:
	SKIPE	DNXTGP(DDB)		;NEXT GROUP EXIST?
	JRST	DDMPO4			;YES, OUTPUT THIS BLOCK.
	PUSHJ	P,ASNGRP		;NO, SET IT UP.

DDMPO4:
	MOVEI	DAT,DIDMPO		;WRITE THIS GROUP OUT.
	PUSHJ	P,QEWAIT
	TRNE	IOS,IODERR!IODTER
	POPJ	P,			;QUIT NOW IF ERROR!
	MOVE	TAC,DSKFAD(DDB)
	CAME	TAC,DSKLAD(DDB)
	JRST	DDOC0			;WORDS LEFT, DO ANOTHER GROUP
	AOJA	UUO,DDOCO2		;GET NEXT IOWD

;***INTERRUPT SUBR***

DIDMPO:
	TLZE	IOS,PNTDIF
	PUSHJ	P,SPREAD
	MOVE	TEM,DMPBUF(DDB)
	HLRS	TEM
	MOVEI	TAC1,DWRITE!IOPCHN
	MOVSM	TAC1,TFRCTL(DDB)
DIDMO1:
	MOVE	TAC1,(TEM)
	HLRZ	DAT,PROG
	CAIL	DAT,(TAC1)
	JRST	DIDMO2
	LDB	DAT,PSEGN
	TRZ	TAC1,400000		;BELIEVE ME FRED THIS IS THE ONLY WAY!
	HRRZ	DAT,JBTADR(DAT)		;RPH 4-17-72
 	ADDI	TAC1,(DAT)		;RELOCATE TO UPPER
	JRST	DIDMO3

DIDMO2:
	ADDI	TAC1,(PROG)
DIDMO3:
	MOVEM	TAC1,TFRIOW(DDB)
	MOVE	TAC1,1(TEM)
	LDB	DAT,PUNIT
	ADD	TAC1,BFSETS(DAT)
	MOVEM	TAC1,TFRSEC(DDB)
	PUSHJ	P,TSTART
	ADDI	TEM,2
	CAMGE	TEM,DMPBUF(DDB)
	JRST	DIDMO1
	POPJ	P,

;BOTH INPUT & OUTPUT CLOSE ARE ALWAYS CALLED FROM UUOCON.
;CLOSE INPUT.

DCLOSI:
	TLNE	IOS,IOSET
	JRST	DSIOS			;FAKE FOR USETI, RETURN.
	TLZE	IOS,READB
	TLZN	IOS,DELETB		;DELETE FILE (SUBSEQUENT ENTER)?
	JRST	DSIOS			;NO, JUST RETURN.
	JSP	AC1,ACCESS		;IS ANYONE ELSE READING?
	JRST	DSIOS			;YES, DON'T DELETE.
	JFCL				;IRRELEVANT
	PUSHJ	P,GOSET			;MAKE US UNSTOPPABLE.
	MOVE	TAC,FILLOC(DDB)		;NO ONE ELSE LOOKING, SO...
	PUSHJ	P,DELETE		;DELETE FILE.
	PUSHJ	P,CUSATO		;OUT SAT IF NEEDED.
	PUSHJ	P,WSYNC			;WAIT FOR IT
	JRST	DPOPJ


;CLOSE OUTPUT

DCLOSO:
	TLNN	IOS,WRITEB!ALTERB
	JRST	DCLSDD			;NO ENTER, BLAST DDB
	PUSHJ	P,GOSET
	TLNN	DDB,OUTBFB+OUTPB	;ANY OUTPUT BUFFERS SET UP?
	JRST	DCLSO3			;NO.  NOTHING TO FLUSH  --ME
	LDB	TAC,PIOMOD		;#-EATING APRSER SHOULD DO THIS
	CAIGE	TAC,DR
	PUSHJ	P,OUT			;LAST OUTPUT FOR BUFFERED MODES
DCLSO3:
	PUSHJ	P,WAIT1			;FINISH IT 
	TLNE	IOS,IOSET		;WERE WE CALLED FROM USETO?
	JRST	DPOPJ			;YES. CLEAR GOBIT AND RETURN.
	MOVEI	DAT,DCLOI
	TLNE	IOS,PNTDIF!HDRDIF	;RTVL CORRECT?
	PUSHJ	P,NEWAIT		;NO, GO FIX
	PUSHJ	P,RTNCOR		;IF OUTPUT ABORTED

;FILE & POINTERS NOW OUT; FIX UP UFD

DCLSO1:
	TLNN	IOS,NTRUFD		;CHANGE UFD?
	JRST	DCLSO2			;NO, NEW FILE; UFD POINTS TO IT
DCLSO9:
	TLZ	IOS,DELETB		;NEW VERSION OF OLD FILE.
	MOVSI	AC2,DELETB
	JSP	AC1,ACCESS		;MARK READERS OF OLD FILE...
	JRST	DCLSOR			;TO DELETE IT WHEN THRU
	JRST	ELOSE			;SHOULD BE JUST US WRITING
	PUSHJ	P,UFDSRC		;GET UFD RTVL
	MOVEI	DAT,DRAUFD		;USE RENAME CODE TO...
	PUSHJ	P,QEWAIT		;CHANGE UFD TO NEW FILE
	TLZE	IOS,DELETB		;WAS ANYONE READING?
	JRST	DCLSO2			;YES, DON'T DELETE NOW
DCLSOC:
	MOVE	TAC,SRCLOC(DDB)		;OLD FILE LOCATION
DCLSOD:
	PUSHJ	P,DELETE		;DELETE IT
	LDB	TAC,PUNIT
	TRNE	IOS,IOIMPM!IODERR
	JUMPN	TAC,SATGLZ		;WRITE LOCKED UDP
DCLSO2:
	PUSHJ	P,CUSATO		;OUT SAT IF NEEDED
	PUSHJ	P,WSYNC			;WAIT FOR IT

DCLSDD:
	TDNE	IOS,[XWD DEVSBB,IOACT]
	SETZB	IOS,DEVIOS(DDB)		;THIS SHOULDN'T HAPPEN, BUT IT DOES.
	MOVSI	TAC,DEVIBF
	ANDCAM	TAC,DEVCMR(DDB)
	PUSHJ	P,RTNCOR
	SETZM	ACCNAM(DDB)
	HRLI	TAC,ACCNAM(DDB)
	HRRI	TAC,ACCNAM+1(DDB)
	BLT	TAC,DDEND-1(DDB)
	ANDI	IOS,GARBIT!DMPBIT!17
	JRST	DPOPJ

DCLSOR:
	IORM	AC2,DEVIOS(TAC)		;FOUND READER, MARK TO DELETE
	TLO	IOS,DELETB		;FLAG FILE STILL IN USE
	JRST	ACCES1			;KEEP LOOKING


; *** INTERRUPT LEVEL ROUTINE ***
; UPDATE FIRST RTVL (LENGTH) &∨ LAST (PTRS).

DCLOI:
	TLZN	IOS,HDRDIF		;HEADER PTRS OK?
	JRST	DCLSO5			;YES, FIX LAST PTRS
	MOVEI	TAC,1			;HEADER IS WRONG
	CAMN	TAC,DGRP1R(DDB)		;LOOKING AT HEADER?
	JRST	DCLSO5			;YES, GO FIX IT
;	TLNN IOS,PNTDIF		;LAST POINTERS OK?
	PUSHJ	P,DCLSO5		;NO, FIX THEM TOO
	MOVEI	TAC,1
	MOVEM	TAC,USETP(DDB)
	PUSHJ	P,GGRETI		;GET HEADER POINTERS
DCLSO5:
	PUSHJ	P,AUDINF		;FIX UP
DCLSO4:
	PUSHJ	P,SPREAD		;OUTPUT POINTERS
	TLNE	IOS,HDRDIF		;WERE BLOCKS REASSIGNED AT INTERRUPT LEVEL?
	JRST	DCLOI			;YES.
	POPJ	P,

;RELEASE UUO, CALL RESET, AND CALL EXIT

DRELES:
	PUSHJ	P,WAIT1			;MAKE SURE RESET WAITS FOR DISK TO STOP
	PUSHJ	P,DCLOSI		;MAYBE DELETE FILE WE READ.
	TLNN	IOS,WRITEB		;IS A PARTIALLY WRITTEN FILE?
	JRST	DCLSDD			;NO, CLEAR DDB.
	PUSHJ	P,GOSET			;WE GET HERE ON RESET ONLY.
	MOVEI	DAT,DCLOI		;MAKE SURE RETRIEVAL IS OUT.
	PUSHJ	P,QEWAIT
	MOVE	TAC,FILLOC(DDB)
	TLNE	IOS,NTRUFD
	JRST	DCLSOD			;OLD FILE EXISTS, DELETE NEW
	PUSHJ	P,UFDSRC		;NEW FILE, DELETE NAME
	SETZM	ACCNAM(DDB)
	MOVEI	DAT,DRAUFD
	PUSHJ	P,QEWAIT
	JRST	DCLSOC			;THEN DELETE FILE.

;USETI, USETO, UGETF.

DSETI:
	TLNN	IOS,READB
	JRST	ENOLUK
	PUSH	P,UUO			;SAVE THIS FOR LATER
	HRRI	UUO,CLSOUT		;DON'T AFFECT OUTPUT
DSETC0:
	PUSHJ	P,DSETC			;FLUSH BUFFERS, FINISH IO
	POP	P,TAC1
	HRRE	TAC1,TAC1
	ADD	TAC1,DOFFST(DDB)	;ADD OFFSET
	SKIPG	TAC1			;IF LESS THAN 1
	MOVEI	TAC1,1			;MAKE IT 1 (LOSERS)
	PUSHJ	P,DGETL			;GET RECORD EOF+1
	CAMLE	TAC,TAC1		;SET TO END IF NOT IN FILE
	SKIPA	TAC,TAC1		;IT'S OK - USE IT
DSETC1:
	TDOA	IOS,[XWD IOEND,IODEND]	;OFF END
	TDZ	IOS,[XWD IOEND,IODEND]	;INSIDE FILE, NO EOF
	MOVEM	TAC,USETP(DDB)		;STORE NEW POINTER
	TLNE	IOS,WRITEB!ALTERB	;COULD HE BE WRITING?
	SKIPN	TAC1,DGRP1R(DDB)	;AND DO WE HAVE ANY RETRIEVAL?
	JRST	DSIOS			;NOTHING TO DO
	CAIGE	TAC,RCPGRP(TAC1)
	CAIGE	TAC,(TAC1)		;IS NEW RECORD IN CURRENT RETRIEVAL?
	TLZN	IOS,PNTDIF		;NO, POINTERS NEED UPDATE?
	JRST	DSIOS			;NO UPDATE!
	MOVEI	DAT,DCLSO5
	PUSHJ	P,NEWAIT		;GO
	JRST	DSIOS			;STO IOS AND RETURN


DSETO:
	TLNN	IOS,WRITEB!ALTERB
	JRST	ENOENT
	PUSH	P,UUO
	HRRI	UUO,CLSIN		;LEAVE INPUT ALONE
	JRST	DSETC0

DGETF:
	PUSH	P,UUO
	MOVEI	UUO,CLSIN!CLSOUT
	TLNE	IOS,READB
	TRZ	UUO,CLSIN
	TLNE	IOS,WRITEB!ALTERB
	TRZ	UUO,CLSOUT
	PUSHJ	P,DSETC			;FLUSH BUFFERS, FINISH IO
	POP	P,UUO
	PUSHJ	P,DGETL			;NOW GET END OF FILE
	MOVE	TAC1,TAC		;SAVE COPY
	SUB	TAC1,DOFFST(DDB)	;UN-OFFSET FOR LOSER
	XCTR	XRW,[HRRM TAC1,(UUO)]	;GIVE TO USER
	JRST	DSETC1			;AND USETP TO THERE

DGETL:
	MOVE	TAC,FILLNG(DDB)		;FIND NEXT FREE RECORD
↑DGETL1:ADDI	TAC,RECSIZ-1		;ROUND UP TO NEXT FULL RECORD
	ANDCMI	TAC,RECSIZ-1
	ASH	TAC,-RECWSH
	ADDI	TAC,1
	POPJ	P,

DSETC:
	MOVSI	IOS,IOSET		;FLAG FOR CLOSE
	IORB	IOS,DEVIOS(DDB)		;FOR WAIT1 AT CLSOUT (UUOCON)
	PUSH	P,DDB
	PUSHJ	P,CLOSE1		;TO FLAG BUFFERS EMPTY.
	POP	P,DDB			;RE-OPEN
	TLZ	IOS,IOSET		;MAKE SURE THIS IS OFF!
	MOVEM	IOS,DEVIOS(DDB)
	HLLM	DDB,USRJDA(UCHN)	;AND REPLACE IN USER TABLE
	POPJ	P,

;MTAPE UUO -- BY R. HELLIWELL -- 16 JAN 72

;	IF FIRST WORD = SIXBIT/GODMOD/	:
;		THEN SECOND WORD IS DISPATCH INTO GODDIS
;		SEE ROUTINE FOR FURTHER DESCRIPTION
;
;	ANYTHING ELSE IN FIRST WORD GETS THE USET POINTER!

DGETW:
	PUSHJ	P,WAIT1			;FINISH ANYTHING IN PROGRESS
	XCTR	XR,[MOVE TAC,(UUO)]	;PICK UP FIRST ARG!!!
	CAMN	TAC,[-1]		;OLD MTAPE?
	JRST	UUOERR			;YES: OLD FORM OF MTAPE NO LONGER EXISTS
	CAME	TAC,['GODMOD']		;REQUESTING NEW GOD MODE
	JRST	GETPNT			;NO. GET THE USET POINTER
	ADDI	UUO,1
	XCTR	XR,[MOVE TAC,(UUO)]
	CAIL	TAC,GODLEN		;OFF END OF TABLE?
	JRST	UUOERR			;YES, TELL HIM HE LOST
	SKIPL	GODDIS(TAC)		;PROTECTED MTAPE?
	JRST	DGETW1			;NO, DISPATCH
	MOVE	TAC1,JBTPRV(J)		;YES, CHECK PRIV.
	TLNN	TAC1,INFPRV		;USE THIS PRIVILEGE
	JRST	UUOERR			;LOSER
DGETW1:
	MOVE TAC1,GODDIS(TAC)		;IN CASE UDP, SEE IF WE NEED SAT IN
	TLNN TAC1,200000		;DEPENDS ON WHICH MTAPE
	JRST	@GODDIS(TAC)		;NO, JUST DISPATCH
	PUSH P,TAC			;YES, DO IT
	PUSHJ P,SATGET
	POP P,TAC
	JRST	@GODDIS(TAC)

;IF SIGN BIT ON IN TABLE, MUST HAVE INFPRV TO DO THIS UUO!!!!!!!!
;200000,,0 BIT MEANS UDP SAT TABLE MUST BE IN CORE

GODDIS:
		GETPNT			;0	GET USET POINTER
	400000,,GDREAD			;1	READ DISK BLOCK
		GDWRIT			;2	WRITE DISK BLOCK
	200000,,SETSAT			;3	SET SAT BIT
	200000,,CLRSAT			;4	CLEAR SAT BIT
	200000,,SATRD			;5	READ WORDS FROM SAT TABLE
	200000,,SATWRT			;6	WRITE WORDS IN SAT TABLE
	200000,,SATFRC			;7	FORCE OUT SAT
	400000,,FILINF			;10	READ 5 WORDS OF FILE INFO
		WRTINF			;11	WRITE 5 WORDS OF FILE INFO
		DIAGL			;12	DIAGNOSTIC LOAD
		DIAGW			;13	DIAGNOSTIC WRITE
		GETRTR			;14	GET FILE RETRIEVAL DATA
		INFCOM			;15	COMPARE A WORD IN DQINFO
		ADDBLK			;16	FIX RETRIEVAL TO INCLUDE AN EXISTING BLOCK
		FILEUP			;17	UPDATE ALL POINTERS AND HEADER INFO
		RDOFF			;20	READ FILE RECORD OFFSET
		WRTOFF			;21	SET FILE RECORD OFFSET
	200000,,TKSFRE			;22	HOW MANY FREE TRACKS LEFT
	200000,,VOLID			;23	TELL USER THE SATID
GODLEN←←.-GODDIS

;	MTAPE CHN,[	≠-1 ∧ ≠SIXBIT/GODMOD/	]
;  OR
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			0		];POINTER COMES BACK HERE

GETPNT:
	MOVE	TAC,USETP(DDB)		;GET USET POINTER
	SUB	TAC,DOFFST(DDB)		;DO OFFSET
	XCTR	XW,[MOVEM TAC,(UUO)]	;AND GIVE IT TO USER
	POPJ	P,

;CHECK DISK ABSOLUTE WRITE PRIVILEGE
DGODZ:
	MOVSI	AC1,DAWPRV
	TDNN	AC1,JBTPRV(J)		;SKIP IF DISK ABSOLUTE WRITE PRIV
	JRST	UUOERR			;LOSER
	POPJ	P,

;	GDWRIT, GDREAD
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			1=READ 2=WRITE
;			IOWD WC,MA
;			XWD S <RECORD #>,<DISK BLOCK ADDRESS>	]
;	IO ERROR RETURN
;	SUCCESS RETURN
;IF THE SIGN BIT (S) IS ON IN THE 4TH WORD THEN THIS TRANSFER WILL BE
;TO ONE OF THE EXTRA TRACKS AT THE END OF PACK 0.  THE BLOCK ADDRESS
;SHOULD BE RELATIVE TO THE END OF THE PACK.

GDWRIT:
	XCTR	XR,[HRRZ TAC,2(UUO)]	;MUST NOT WRITE SAT DIRECTLY
	XCTR XR,[SKIPL 2(UUO)]		;DON'T BE FAKED OUT BY XTRA CYL WRITE
	JUMPE	TAC,UADRER		;(DON'T BE FOOLED BT A RECORD # - REG)
	PUSHJ	P,DGODZ			;IS HE LEGAL?
	SKIPA	TAC,[DWRITE!IOPCHN]	;MAKE IT A WRITE
GDREAD:
	MOVEI	TAC,IOPCHN		;READ
	MOVSM	TAC,TFRCTL(DDB)		;WHICH DIRECTION
	XCTR	XR,[HLRZ TAC,1(UUO)]	;MAKE SURE ITS NOT TIC
	JUMPE	TAC,UADRER		;LOSE?
	PUSHJ	P,MTPACK		;CHECK AND RELOCATE IOWD!
	LDB	TAC1,PUNIT		;GET UNIT (DSK OR UDP?)
	XCTR	XR,[SKIPGE TAC,2(UUO)]	;PICK UP DISK ADDRESS
	JRST	GDRD1			;XTRA CYL TRANSFER
	ANDI	TAC,-1
	CAMLE	TAC,LSTRKT(TAC1)	;MUST BE IN RANGE FOR THIS DEVICE
	POPJ	P,			;LET THE USER FIGURE OUT WHAT'S WRONG. (REG)
GDRD2:
	LSH	TAC,6			;POSITION FOR TRACK ADDRESS
	ADD	TAC,BFSETS(TAC1)
	XCTR	XLB,[LDB TAC1,[POINT 6,2(UUO),17]]	;GET RECORD #
	CAILE	TAC1,RCPBLK		;LEGAL RECORD?
	JRST	UADRER
	IOR	TAC,TAC1		;MERGE ADDRESS
	XCTR	XR,[SKIPGE 2(UUO)]
	TLO	TAC,200000		;MARK AS XTRA CYL PACK 0 OP
	MOVEM	TAC,TFRSEC(DDB)		;STUFF INTO DDB
	XCTR	XR,[HLRO TAC,1(UUO)]	;GET WC AGAIN
	IMULI	TAC1,RECSIZ
	SKIPE	TAC1
	SUBI	TAC1,RECSIZ-SECSIZ
	SUB	TAC1,TAC		;AND "ADD" WC
	CAILE	TAC1,BLKWDS		;RUN OFF END OF BLOCK?
	JRST	UADRER
	PUSHJ	P,GOSET			;MAKE US UNSTOPPABLE
	SETOM	DDLOC(DDB)		;DISABLE DSKQCK
	MOVEI	DAT,TSTART		;JUST DO OP
	PUSHJ	P,QEWAIT		;DO IT
	SETZM	DDLOC(DDB)
DEPOPJ:
	TRNE	IOS,IODERR!IODTER	;ANY ERRORS?
	JRST	DPOPJ			;YES, NO SKIP
	JRST	DPOPJ1			;NO, SKIP RETURN

MTPACK:
	XCTR	XR,[HRRZ TAC1,1(UUO)]	;PICK UP ADDRESS
	ADDI	TAC1,1			;MAKE IT HONEST
	PUSHJ	P,RELOCA		;ADDRESS CHECK AND RELOCATE
	JRST	UADRER
	HRRM	TAC1,TFRIOW(DDB)	;SAVE IN DDB
	MOVE	TAC,TFRCTL(DDB)		;GET MAGIC BIT
	TLNN	TAC,DWRITE		;IS IT WRITE?
	JUMPL	TAC1,UADRER		;NO, MUST HAVE WRITE (IN CORE) PERMISSION
	XCTR	XR,[HRRZ TAC1,1(UUO)]
	XCTR	XR,[HLRO TAC,1(UUO)]
	SUB	TAC1,TAC		;COMPUTE LAST ADDRESS OF TRANSFER
	PUSHJ	P,RELOCB		;ADDRESS CHECK, RELOCATE AND TEST SAME SEGMENT
	JRST	UADRER
	XCTR	XR,[HLLZ TAC1,1(UUO)]
	HLLM	TAC1,TFRIOW(DDB)	;SAVE IN DDB
	POPJ	P,			;OK

GDRD1:
	ANDI	TAC,-1
	CAIGE	TAC,NXTRA0*TRKCYL*BKPTRK
	JUMPE	TAC1,GDRD2		;LEGAL, BUT NOT FOR UDPS
	JRST	UADRER

;	SETSAT, CLRSAT
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			3=SET BIT	4=CLEAR BIT
;			DISK ADDRESS]
;
;	CLEAR OR SET SAT BIT CORRESPONDING TO DISK ADDRESS

SETSAT:
	SKIPA	AC2,[MRKBLK]
CLRSAT:
	MOVEI	AC2,RTNBLK
	PUSHJ	P,DGODZ				;MUST BE GOD TO TWIDDLE BITS
	LDB	TAC1,PUNIT
	XCTR	XR,[SKIPLE TAC,1(UUO)]		;GET BLOCK ADDRESS
	CAMLE	TAC,LSTBTB(TAC1)		;IN SAT TABLE?
	JRST	UADRER				;NO
	JRST	(AC2)				;SET OR CLEAR A BIT, AND POPJ

;	SATWRT, SATRD, SATFRC
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			5=READ  6=WRITE
;			IOWD WC,MA
;			RELATIVE ADDRESS IN SAT TABLE]
;
; ADDRESS IS RELATIVE TO SATTAB, NOT SATBIT!!!!!
; READ OR WRITE PORTIONS OF SAT TABLE IN CORE!

SATWRT:
	PUSHJ	P,DGODZ			;CHECK FOR GOD
	PUSHJ	P,SATSUP		;SAT SET UP
	JFCL				;DON'T CARE, JUST  READING
	MOVSS	TAC			;SWAP POINTERS TO BLT INTO SYSTEM
	ADDI	TAC1,-1(TAC)		;GET LAST LOC
	BLT	TAC,(TAC1)		;AND DO BLT
	POPJ	P,

SATRD:
	PUSHJ	P,SATSUP		;SAT SET UP
	JRST	UADRER			;WRITE PROT, LOSE
	ADDI	TAC1,-1(TAC)		;GET LAST LOC
	BLT	TAC,(TAC1)		;GIVE INFO TO LOSER!
	POPJ	P,

SATSUP:
	XCTR	XR,[HRRZ TAC1,1(UUO)]	;PICKUP USER ADDRESS
	ADDI	TAC1,1			;MAKE IT HONEST
	PUSHJ	P,RELOCA		;ADDRESS CHECK AND RELOCATE
	JRST	UADRER
	JUMPL	TAC1,.+2		;SKIP AOS IF WRITE PROT
	AOS	(P)			;SKIP RETURN
	MOVE	TAC,TAC1		;SAVE IN TAC
	XCTR	XR,[HLRE AC2,1(UUO)]	;GET WC
	MOVNS	AC2			;MAKE IT POS!
	JUMPLE	AC2,UADRER		;MUST NOW BE POS!
	XCTR	XR,[HRRZ TAC1,1(UUO)]	;GET MA AGAIN
	ADD	TAC1,AC2		;COMPUTE LAST ADDRESS
	PUSHJ	P,RELOCB		;ADDRESS CHECK AND RELOCATE
	JRST	UADRER
	XCTR	XR,[SKIPGE AC1,2(UUO)]	;GET RELATIVE SAT ADDRESS
	JRST	UADRER
	MOVE	TAC1,AC2
	ADD	AC2,AC1			;GET RELATIVE END OF SAT
	LDB	AC3,PUNIT		;GET UNIT AS INDEX TO SAT TAB TABLES
	CAMLE	AC2,TSATSZ(AC3)		;INSIDE SAT?
	JRST	UADRER			;NO
	MOVE	AC3,SATADR(AC3)		;ORIGIN OF SAT FOR THIS DEVICE
	ADDI	AC3,(AC1)		;FIRST WORD TO TRANSFER
	HRLI	TAC,(AC3)		;PUT CORE ADDRESS OF FIRST WORD IN TAC
	POPJ	P,			;RETURN TO DO BLT

;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			7		]
;
;FORCE SAT TABLE TO BE WRITTEN OUT!

SATFRC:
	LDB TAC,PUNIT
	SETOM	SATMOD(TAC)		;LET ANYBODY FORCE SAT OUT
	PUSHJ P,CUSATO			;PUTS OUT THE RIGHT SAT TABLE
	JRST WSYNC			;WAIT FOR IT

;	FILINF, WRTINF
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD
;			10
;			ADDRESS TO PUT INFO (5 WORDS)	]
;	ERROR RETURN, NO LOOKUP DONE
;	SUCCESS RETURN

FILINF:
	TLNN	IOS,READB			;LOOKUP DONE?
	POPJ	P,				;NO
	XCTR	XR,[MOVE TAC1,1(UUO)]
	ADDI	TAC1,DQLEN-1			;CHECK END OF TRANSFER FIRST
	PUSHJ	P,RELOCA
	JRST	UADRER
	JUMPL	TAC1,UADRER
	XCTR	XR,[MOVE TAC1,1(UUO)]
	PUSHJ	P,RELOCB
	JRST	UADRER
	JUMPL	TAC1,UADRER
	HRLI	TAC1,DQINFO(DDB)		;GET INFO FROM HERE
	HRRZ	TAC,TAC1
	BLT	TAC1,DQLEN-1(TAC)
	JRST	CPOPJ1

;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			11
;			ADDRESS OF 5 WORDS TO WRITE INTO RETRIEVAL	]
;	ERROR RETURN
;	SUCCESS RETURN

WRTINF:
	PUSHJ	P,DGODZ
	TDNE	IOS,[XWD DEVSBB,IOACT]
	PUSHJ	P,WAIT1
	SKIPE	FILNAM(DDB)		;NO FILE TO RENAME?
	TLNE	IOS,DELETB		;OR GOING AWAY?
	POPJ	P,			;LOSSAGE RETURN
	XCTR	XR,[MOVE TAC1,1(UUO)]
	ADDI	TAC1,DQLEN-1
	PUSHJ	P,RELOCA
	JRST	UADRER
	XCTR	XR,[MOVE TAC1,1(UUO)]
	PUSHJ	P,RELOCB
	JRST	UADRER
	HRLM	TAC1,(P)		;SAVE USER ADDRESS FOR BLT'S
	MOVE	TAC1,JBTSTS(J)
	TLNE	TAC1,JACCT		;DON'T PRINT THIS FOR LOGIN/OUT
	JRST	LINOUT
	LDB TAC1,PUNIT
	JUMPN TAC1,LINOUT		;NOR FOR UDP
	PUSHJ	P,DISDATE
	PUSHJ	P,DISERR
	[ASCIZ/WRITE INFO, USER = /]
	DISARG SIX,<PRJPRG(J)>
	[ASCIZ/  PROGRAM = /]
	DISARG SIX,<JOBNAM(J)>
	[ASCIZ/  TTY/]
	DISARG LOC,<JBTLIN(J)>
	[ASCIZ/
FILE = /]
	DISARG SIX,<FILNAM(DDB)>
	[ASCIZ/./]
	DISARG SIX,<FILEXT(DDB)>
	[0133B6];;replaced;;[ASCIZ/[/]
	DISARG SIX,<FILPPN(DDB)>
;;replaced	[ASCIZ/]
;;replaced
;;replaced /] with
[0135B6 + 015B13 + 012B20 + 015B27 + 012B34 
 0] ;; ASCIZ right-square-bracket CRLF CRLF
;;`2013-02-21 bgbaumgart@mac.com'
	-1
LINOUT:
	MOVEI	AC3,DQLEN		;GET BLOCK OF FREE STORAGE
	PUSHJ	P,UFSGET		;GET IT
	PUSH	P,AC1
	HLLZ	TAC1,-1(P)		;GET SAVED USER ADDR
	HRR	TAC1,AC1		;SYSTEM ADDR
	BLT	TAC1,DQLEN(AC1)		;SAVE WORDS IN FREE STORAGE
	PUSHJ	P,FILEUP		;FORCE OUT POINTERS IF NECESSARY
	POP	P,SRCTMP(DDB)		;SAVE ADDRESS
	TRZ	IOS,IODERR!IODTER	;NO ERRORS YET!
	TLO	IOS,RENAMB		;LOCK UP FILE WHILE WE'RE IN IT
	PUSHJ	P,GOSET			;LEST WE GET STOPPED
	PUSH	P,USETP(DDB)		;SAVE CURRENT USET
	MOVEI	DAT,WRTINS		;I SUBR
	PUSHJ	P,NEWAIT
	POP	P,USETP(DDB)		;RESTORE USET
	MOVE	AC1,SRCTMP(DDB)
	PUSHJ	P,FSGIVE		;RETURN BLOCK
	TLZ	IOS,RENAMB		;UNLOCK FILE
	JRST	DEPOPJ

;***** I-SUBR FOR SMEARING OUT 5 WORD CHANGE TO DQINFO *****
WRTINS:
	MOVE	TAC,FILLOC(DDB)		;HERE IS WHERE WE START
	PUSHJ	P,NEWFIL		;INITIALIZE FILE
WRTIN1:
	PUSHJ	P,GGRETI		;GET RETRIEVAL IN
	HRLZ	TAC1,SRCTMP(DDB)	;GET FREE STORAGE ADDRESS
	HRRI	TAC1,DQINFO(DDB)	;AND DDB ADDRESS
	BLT	TAC1,DQINFO+DQLEN-1(DDB);BLT IN 5 WORDS
	PUSHJ	P,SPREAD		;SPREAD RET. OVER GROUP
	SKIPN	DNXTGP(DDB)		;ANOTHER TO GO?
	POPJ	P,
	MOVEI	TAC,RCPGRP		;INC USET TO NEXT GROUP
	ADDM	TAC,USETP(DDB)
	JRST	WRTIN1			;AND LOOP

;	WRTOFF, RDOFF
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			21
;			NEW FIRST RECORD	]
;	ERROR RETURN
;	SUCCESS RETURN

WRTOFF:
	TDNE	IOS,[XWD DEVSBB,IOACT]
	PUSHJ	P,WAIT1
	SKIPE	FILNAM(DDB)		;NO FILE TO RENAME?
	TLNE	IOS,DELETB		;OR GOING AWAY?
	POPJ	P,			;LOSSAGE RETURN
	TLNE	IOS,WRITEB		;ALREADY WRITING?
	JRST	WOFFOK			;YES, OK
	MOVSI	DAT,100000		;CHANGE; IS IT LEGAL?
	MOVE	AC2,FILPPN(DDB)
	MOVE	AC3,FILPRO(DDB)
	JSP	AC1,PROTEK
WOFFOK:
	XCTR	XR,[MOVE TAC1,1(UUO)]	;GET USER OFFSET REQUEST
	SOJL	TAC1,CPOPJ		;NORMALIZE AND TEST FOR TO SMALL
	PUSH	P,TAC1
	PUSHJ	P,FILEUP		;MAKE SURE POINTERS ARE OK
					;BEFORE DIDLING THEM
	POP	P,SRCTMP(DDB)
	TRZ	IOS,IODERR!IODTER	;NO ERRORS YET!
	TLO	IOS,RENAMB		;LOCK UP FILE WHILE WE'RE IN IT
	PUSHJ	P,GOSET			;LEST WE GET STOPPED
	PUSH	P,USETP(DDB)		;SAVE CURRENT USET
	MOVEI	DAT,WRTOFS		;I SUBR
	PUSHJ	P,NEWAIT
	POP	P,USETP(DDB)		;RESTORE USET
	TLZ	IOS,RENAMB		;UNLOCK FILE
	JRST	DEPOPJ

;***** I-SUBR FOR SMEARING OUT DOFFST CHANGE *****
WRTOFS:
	MOVE	TAC,FILLOC(DDB)		;HERE IS WHERE WE START
	PUSHJ	P,NEWFIL		;INITIALIZE FILE
WRTOF1:
	PUSHJ	P,GGRETI		;GET RETRIEVAL IN
	MOVE	TAC1,SRCTMP(DDB)	;GET NEW OFFSET
	MOVEM	TAC1,DOFFST(DDB)	;SET INTO RETRIEVAL
	PUSHJ	P,SPREAD		;SPREAD RET. OVER GROUP
	SKIPN	DNXTGP(DDB)		;ANOTHER TO GO?
	POPJ	P,
	MOVEI	TAC,RCPGRP		;INC USET TO NEXT GROUP
	ADDM	TAC,USETP(DDB)
	JRST	WRTOF1			;AND LOOP
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			20
;			RECORD OFFSET STORED HERE
;			ACTUAL FILE LENGTH	]
;	ERROR RETURN
;	SUCCESS RETURN
RDOFF:
	MOVE	TAC,DOFFST(DDB)
	ADDI	TAC,1
	XCTR	XW,[MOVEM TAC,1(UUO)]	;REPORT STARTING RECORD #
	MOVE	TAC,FILLNG(DDB)
	XCTR	XW,[MOVEM TAC,2(UUO)]	;REPORT ACTUAL FILE LENGTH
	POPJ	P,

;	DIAGL, DIAGW
;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			12
;			ADDRESS TO PUT DIAGNOSTIC (MUST BE 200 WORDS)
;			FLOPPY DISK ADDRESS	]
;	IO ERROR RETURN
;	SUCCESS RETURN

DIAGL:
	XCTR	XR,[MOVE TAC1,1(UUO)]		;PICK UP ADDRESS OF 200 WORD BUFFER
	PUSHJ	P,RELOCA
	JRST	UADRER
	JUMPL	TAC1,UADRER			;MUST HAVE WRITE PERMISSION
	HRRZM	TAC1,TFRIOW(DDB)
	XCTR	XR,[HRRZ TAC1,1(UUO)]
	ADDI	TAC1,177
	PUSHJ	P,RELOCB
	JRST	UADRER
	XCTR	XR,[MOVE TAC,2(UUO)]		;PICK UP FLOPPY DISK ADDRESS
	CAILE	TAC,377				;MUST BE ONE BYTE
	JRST	UADRER
	DPB	TAC,[POINT 8,TFRSEC(DDB),7]	;PUT IN PLACE FOR PICK UP BY CHANNEL
	MOVSI	TAC,IOPCHN			;KLUDGE TO INDICATE READ
LWMERG:
	MOVEM	TAC,TFRCTL(DDB)
	PUSHJ	P,GOSET				;LOCK HIM IN FOR THIS
	MOVEI	DAT,LWSTRT
	PUSHJ	P,QEWAIT			;START OP AND WAIT FOR IT
	JRST	DEPOPJ				;CHECK ERRORS AND UNLOCK

;CALL:
;	MTAPE CHN,[	SIXBIT/GODMOD/
;			13
;			ADDRESS TO GET DIAGNOSTIC FROM (MUST BE 200 WORDS)
;			ADDRESS TO PUT ERROR CODE (4 WORDS)	]
;	IO ERROR RETURN
;	SUCCESS RETURN

DIAGW:
	PUSHJ	P,DGODZ
	XCTR	XR,[MOVE TAC1,1(UUO)]
	PUSHJ	P,RELOCA
	JRST	UADRER
	HRRZM	TAC1,TFRSEC(DDB)
	XCTR	XR,[MOVE TAC1,1(UUO)]
	ADDI	TAC,177
	PUSHJ	P,RELOCB
	JRST	UADRER
	XCTR	XR,[MOVE TAC1,2(UUO)]
	PUSHJ	P,RELOCA
	JRST	UADRER
	JUMPL	TAC1,UADRER		;LOSE IF WRITE PROTECTED
	HRRZM	TAC1,TFRIOW(DDB)
	XCTR	XR,[MOVE TAC1,2(UUO)]
	ADDI	TAC,3
	PUSHJ	P,RELOCB
	JRST	UADRER
	MOVSI	TAC,DWRITE!IOPCHN
	JRST	LWMERG

;DIAGNOSTIC I-SUBR ************
LWSTRT:
	MOVEM	DDB,DXB
	MOVEM	J,DXJ
	MOVEM	P,DXP
	TRZ	IOS,IODERR!IODTER
	MOVE	TAC,TFRSEC(DDB)
	MOVEM	TAC,DXS
	MOVE	TAC,TFRIOW(DDB)
	MOVEM	TAC,DXW
	HLRZ	TAC,TFRCTL(DDB)
	MOVEM	TAC,DXC
	JRST	WLDIAG			;DISPATCH TO DEVICE DEPENDENT SUBR

;	GETRTR
;CALL:	
;	MTAPE	CHN,['GODMOD'
;			14
;		     IOWD WC,MA]	;WC≤40
;	<ERROR - NO LOOKUP OR ENTER>
;PLACE UP TO 40 WORDS OF FILE RETRIEVAL AT USER'S ADR.
;RETRIEVAL IS COPIED FROM THE DDB FOR THIS CHANNEL.
;USER MUST HAVE A FILE LOOKED UP SUCESSFULLY ALREADY.

;REG THIS PAGE

GETRTR:
	TLNN	IOS,READB+WRITEB+ALTERB	;LOOKUP OR ENTER DONE?
	POPJ	P,			;NO
	XCTR	XR,[HRRZ TAC1,1(UUO)]	;GET HIS ADDRESS
	XCTR	XR,[HLRO TAC,1(UUO)]	;AND THE WC
	CAMGE	TAC,[-40]
	JRST	UADRER
	SUB	TAC1,TAC		;COMPUTE LAST ADDRESS OF TRANSFER
	PUSHJ	P,RELOCA		;
	JRST	UADRER
	JUMPL	TAC1,UADRER
	XCTR	XR,[HRRZ TAC1,1(UUO)]	;GET THE ADDRESS HE SAID
	ADDI	TAC1,1			;MAKE IT HONEST
	PUSHJ	P,RELOCB
	JRST	UADRER
	JUMPL	TAC1,UADRER
	HRLI	TAC1,DDNAM(DDB)		;GET INFO FROM HERE
	XCTR	XR,[HLRO TAC,1(UUO)]	;GET -WC
	MOVN	TAC,TAC			;+WC
	MOVE	AC2,TAC			;REMEMBER THE WC
	ADDI	TAC,(TAC1)		;ADD BEGINNING ADDRESS
	MOVEI	AC1,(TAC1)		;SAVE USER'S ADDRESS
	BLT	TAC1,-1(TAC)		;MOVE DATA
	MOVE	TAC,JBTPRV(J)		;GET THIS GUY'S PRIVILEGES
	CAILE	AC2,DQINFO-DDNAM	;DID THIS USER READ SPECIAL STUFF?
	TLNE	TAC,INFPRV		;IS HE ALLOWED TO SEE ALL RETRIEVAL?
	JRST	CPOPJ1			;PRIVILEGED OR DIDN'T ATTEMPT TO READ DQINFO
	SETZM	DQINFO-DDNAM(AC1)	;ZERO DQINFO
	MOVSI	TAC1,DQINFO-DDNAM(AC1)	;SOURCE
	HRRI	TAC1,DQINFO-DDNAM+1(AC1)	;DESTINATION OF BLT
	CAILE	AC2,DQINFO+DQLEN-DDNAM	;DOES WC EXCEED SPECIAL AREA?
	MOVEI	AC2,DQINFO+DQLEN-DDNAM	;YES. MAKE IT SMALLER.
	ADDI	AC2,-1(AC1)		;ADD TO MAKE LAST ADDRESS TO ZERO
	CAIL	AC2,(TAC1)		;IS THIS A NULL BLT?
	BLT	TAC1,(AC2)		;REAL BLT TO ZERO CORE.
	JRST	CPOPJ1			;RETURN.

;	INFCOM, ADDBLK, FILEUP, TKSFRE, DSKRES
;CALL:	
;	MTAPE	CHN,['GODMOD'
;			15
;			0-4		;WHICH WORD TO COMPARE WITH
;		       DATA  ]		;DATA TO BE COMPARED
;	<NO LOOKUP OR ENTER OR COMPARE NOT EQUAL>
;THIS IS A UUO TO COMPARE A WORD FROM THE USER WITH ONE FROM
;THE SPECIAL 5 WORD RETRIEVAL BLOCK IN A FILE

INFCOM:
	TLNN	IOS,READB!WRITEB!ALTERB
	POPJ	P,
	XCTR	XR,[MOVE TAC,1(UUO)]	;PICK UP INDEX INTO 5 WORD RETRIEVAL BLOCK
	JUMPL	TAC,UADRER		;CHECK IT
	CAIL	TAC,DQLEN
	JRST	UADRER
	ADDI	TAC,DQINFO(DDB)		;CALC ADDR OF WORD
	MOVE	TAC,(TAC)		;PICK IT UP
	XCTR	XR,[CAMN TAC,2(UUO)]	;EQUAL TO LOSERS WORD?
	AOS	(P)			;YES, SKIP
	POPJ	P,

;CALL:
;	MTAPE	CHN,['GODMOD'
;			16
;		     RECORD # (REAL, NOT OFFSET)]
;	<NO LOOKUP OR ENTER OR NON-EX BLOCK>
;THIS UUO ALLOWS THE USER(LOSER) TO INCLUDE AN
;EXISTING BLOCK IN HIS WORD COUNT!

ADDBLK:
	TLNN	IOS,ALTERB!WRITEB!READB	;FILE OPEN SOMEHOW?
	POPJ	P,
	XCTR	XR,[SKIPG TAC,1(UUO)]	;PICK UP LOSERS REC. NO.
	POPJ	P,			;AVOID CONFUSION
	PUSH	P,USETP(DDB)		;SAVE OLD USET POINTER IN CASE HE LOSES
	ADD	TAC,DOFFST(DDB)		;DO OFFSET
	MOVEM	TAC,USETP(DDB)
	PUSHJ	P,GOSET			;MAKE US UNSTOPPABLE IN CASE BAD POINTER
	PUSHJ	P,GETRET		;GET RETRIEVAL FOR RECORD
	JRST	ADDLOS			;NO SUCH GROUP
	PUSHJ	P,LR2BLK		;THE GROUP EXISTS, DOES THE BLOCK?
	JUMPE	TAC,ADDLOS		;0 MEANS NO SUCH BLOCK
	SUB	P,[1,,1]		;BLOCK EXISTS, LOSE OLD USETP
	MOVE	TAC,USETP(DDB)		;NOW INCLUDE THIS BLOCK IN WC
	LSH	TAC,RECWSH		;MAKE IT WORDS
	CAMG	TAC,FILLNG(DDB)
	JRST	DPOPJ1			;ALREADY IN WC
	MOVEM	TAC,FILLNG(DDB)		;UPDATE FILE LENGTH
	TLNE	IOS,ALTERB!WRITEB	;WRITING?
	TLO	IOS,HDRDIF		;YES, MAKE SURE IT GETS WRITTEN OUT LATER
	TDZ	IOS,[IOEND,,IODEND]	;CAN'T BE EOF ANY MORE
	JRST	DPOPJ1

ADDLOS:
	POP	P,USETP(DDB)		;NO SUCH RECORD, GET BACK OLD ONE
	JRST	DPOPJ			;AND GIVE ERROR RETURN

;CALL
;	MTAPE	CHN,['GODMOD'
;			17   ]
FILEUP:
	TLNE	IOS,ALTERB!WRITEB	;FILE OPEN?
	TLNN	IOS,PNTDIF!HDRDIF	;YES, ANYTHING TO DO?
	POPJ	P,			;NO, NO-OP
	MOVEI	DAT,DCLOI
	JRST	NENTER			;ENTER REQUEST AND RETURN TO USER

;MTAPE TO FIND OUT NUMBER OF FREE TRACKS ON A STRUCTURE
;CALL
;	MTAPE	CHN,['GODMOD'
;			22
;			ADDRESS	TO STORE RESULT]

TKSFRE:
	LDB TAC1,PUNIT			;FIND OUT THE ANSWER
	PUSHJ P,DSKRES			;RESULT IN TAC
	XCTR XEW,[MOVEM TAC,@1(UUO)]	;RETURN RESULT TO THE USER
	POPJ P,

↑DSKRES:MOVE TAC,LSTBTB(TAC1)			;CALC RESOURCES FOR UNIT IN TAC1
	SKIPN TAC1,SATADR(TAC1)			;(CLOBBERS TAC1!)
	JRST DKRES1				;NO SAT, NO TRACKS!
	MOVE TAC1,DSKUSE(TAC1)			;THIS IS THE NUMBER IN USE
	SUBI TAC,=200(TAC1)			;MINUS MAGIC BUFFER
	JUMPGE TAC,CPOPJ
DKRES1:
	MOVEI TAC,0
	POPJ P,

;MTAPE TO FIND OUT SATID OF A STRUCTURE
;CALL
;	MTAPE	CHN,['GODMOD'
;			23
;			ADDRESS	TO STORE RESULT]

VOLID:
	LDB TAC1,PUNIT			;TELL USER THE SATID
	SKIPE TAC,SATADR(TAC1)
	MOVE TAC,SATID(TAC)		;IT SAYS HERE THERE HAS TO BE A SAT
	XCTR XEW,[MOVEM TAC,@1(UUO)]
	POPJ P,

;LOOKUP

DLOOK:
	TLZ	IOS,IO!READB
	TLNE	IOS,WRITEB
	JRST	EXFIL				;THIS DDB IS ALREADY WRITING
	SETZM	FILNAM(DDB)			;DISABLE RENAME.
	JSP	AC1,ACCENT
	SKIPN	ACCNAM(DDB)			;WAS THE SPECIFIED NAME BLANK?
	JRST	ENOFIL				;YES. LOSE.
	PUSHJ	P,GOSET
	PUSHJ	P,SATGET			;MAKE SURE SAT TABLE IS IN (FOR UDP)
	JSP	AC1,ACCESS			;CHECK WHO'S DIDDLING FILE
	JRST	DLK1				;READ ENTRY - BORROW DATA
	JRST	DLK2				;WRITE ENTRY
	PUSHJ	P,FILSRC			;SEARCH DIRECTORY FOR FILE
	SKIPG	SRCTMP(DDB)
	JRST	ENOFIL				;NOT FOUND, LOSE
	MOVE	TAC,SRCEXT(DDB)
	MOVEM	TAC,ACCEXT(DDB)
	MOVE	TAC,SRCPRO(DDB)
	MOVEM	TAC,ACCPRO(DDB)
	JRST	DLK3				;GO CHECK PROTECTION.

DLK2:
	TLNN	TAC1,NTRUFD			;WRITING; IS THERE AN OLD FILE?
	JRST	ENOFIL				;JUST NEW ONE, REPORT NON EX
	JRST	ACCES1				;THERE IS AN OLD ONE, SEEK IT

DLK1:
	MOVE	TAC1,FILEXT(TAC)		;READ ENTRY FOUND. - BORROW DATA
	MOVEM	TAC1,SRCEXT(DDB)
	MOVEM	TAC1,ACCEXT(DDB)
	MOVE	TAC1,FILPRO(TAC)		;STEAL DATA
	MOVEM	TAC1,SRCPRO(DDB)
	MOVEM	TAC1,ACCPRO(DDB)
	SKIPN	TAC1,FILLOC(TAC)
	MOVE	TAC1,SRCLOC(TAC)
	MOVEM	TAC1,SRCLOC(DDB)
	MOVE	TAC1,UFDPRO(TAC)
	MOVEM	TAC1,UFDPRO(DDB)
DLK3:
	MOVSI	DAT,200000
	JSP	AC1,UPROTC			;CHECK READ ACCESS TO UFD
	MOVSI	DAT,200000			;CHECK READ PROTECTION.
	JSP	AC1,PROTEC
	TLO	IOS,READB
	PUSHJ	P,ACCEST			;OK, ACCESS ESTABLISHED
	LDB	DAT,PUNIT
	SKIPLE	TAC,SRCLOC(DDB)			;REASONABLE ADDRESS?
	CAMLE	TAC,LSTBTB(DAT)			;IF NOT,
	JRST	EGARB1				;UFD HAS BAD POINTER IN IT.
	MOVEI	DAT,LOOKI
	PUSHJ	P,QEWAIT			;UPDATE TIMES, GET LENTGH
	TLNE	IOS,LOSBIG
	JRST	EGARB2				;WRONG FILE FOUND AT LOC.
DRPT:
	MOVEI	AC1,3(UUO)			;END ADDRESS
	TRNE	IOS,DMPBIT			;UNLESS DMPBIT SET
	ADDI	AC1,2				;THEN 2 LONGER
	HLRZ	TAC,PROG
	CAIL	TAC,(AC1)			;ADDRESS IN LOWER?
	JRST	DRPT2				;ENDS IN LOWER
	TRNN	UUO,400000			;UPPER STARTING ADDRESS?
	JRST	ADRERR				;NO
	LDB	TAC1,PSEGN
	JUMPE	TAC1,ADRERR
	MOVE	TAC,JBTSTS(TAC1)
	TLNE	TAC,JWP				;WRITE PROTECTED?
	JRST	ADRERR				;YES, LOSE
	HLRZ	TAC,JBTADR(TAC1)
	CAIGE	TAC,-400000(AC1)		;END IN UPPER?
	JRST	ADRERR				;NO, LOSE
	HRRZ	TAC,JBTADR(TAC1)
	SUBI	TAC,400000
	JRST	DRPT1

DRPT2:
	HRRZ	TAC,PROG
DRPT1:
	ADDI	TAC,(UUO)			;REPORT DATA TO USER
	PUSH	TAC,FILEXT(DDB)
	PUSH	TAC,FILPRO(DDB)
	MOVN	TAC1,DDLNG(DDB)
	TLNE	IOS,ALTERB			;ARE WE GETTING INTO ALTER MODE?
	MOVN	TAC1,FILLNG(DDB)		;YES, USE HONEST FILE LENGTH!
	MOVNM	TAC1,FILLNG(DDB)
	MOVE	AC1,DOFFST(DDB)
	LSH	AC1,RECWSH			;MAKE IT WORDS
	ADD	TAC1,AC1			;REPORT ADJUSTED SIZE TO USER
	SKIPLE	TAC1
	SETZ	TAC1,				;ACCOUNT FOR DOFFST BEING EOF
	MOVSS	TAC1
	PUSH	TAC,TAC1
	MOVE	TAC1,DREFTM(DDB)		;BEGIN RPH 3-8-73
	MOVEM	TAC1,REFTIM(DDB)		;UPDATE THIS CRUFT
	TRNE	IOS,DMPBIT
	PUSH	TAC,TAC1
	MOVE	TAC1,DDMPTM(DDB)
	MOVEM	TAC1,DMPTIM(DDB)
	TRNE	IOS,DMPBIT
	PUSH	TAC,TAC1			;END RPH

DLOK:
	PUSHJ	P,DGETL
	MOVE	TAC1,DOFFST(DDB)
	ADDI	TAC1,1				;INIT USETP POINTER TO OFFSET
	CAMLE	TAC,TAC1			;DOFFST INSIDE FILE?
	MOVE	TAC,TAC1			;OK, USE DOFFST
	MOVEM	TAC,USETP(DDB)

DPOPJ1:
	AOS	(P)
DPOPJ:
	TLZ	IOS,GOBIT
	MOVEM	IOS,DEVIOS(DDB)
	CONSZ	PI,177B27			;ARE WE AT UUO LEVEL?
	POPJ	P,				;NO, CAN'T DO ANYTHING HERE!
	PUSH	P,AC3
	MOVE	J,JOB(PID)
	MOVE	AC3,JBTLIN(J)
	CAMN	AC3,[-1]			;DETACHED?
	JRST	DPJRA3
	PUSH	P,AC2
	PUSH	P,AC1

	MOVSI	AC1,DLYBIT
	MOVSI	AC2,COMBIT
	CONO	PI,SCNOFF			;KEEP SCANNER OUT.
	TDNN	AC1,TTYTAB(AC3)			;SKIP IF COMMAND DELAYED
	JRST	DPJRSC				;NO DELAYED COMMAND
	ANDCAM	AC1,TTYTAB(AC3)			;TURN OFF DELAY BIT
	TDNE	AC2,TTYTAB(AC3)			;ANOTHER COMMAND ALREADY IN?
	JRST	DPJRSC				;YES.
	AOS	COMCNT				;COUNT ANOTHER TTY NEED SCANNING
	IORM	AC2,TTYTAB(AC3)			;TURN ON COMMAND BIT
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM			;MAKE SURE ALL IS WELL
>
	CONO	PI,SCNON

	PUSHJ	P,WSCHED
DPJRST:
	POP	P,AC1
	POP	P,AC2
DPJRA3:
	POP	P,AC3
	POPJ	P,

DPJRSC:
	CONO	PI,SCNON
	JRST	DPJRST

GOSET:
	TLO	IOS,GOBIT
DSIOS:
	MOVEM	IOS,DEVIOS(DDB)
	POPJ	P,

;*** INTERRUPT SUBR ***

LOOKI:
	MOVE	TAC,SRCLOC(DDB)			;GET RTVL INTO DDB
	MOVEM	TAC,FILLOC(DDB)
	PUSHJ	P,NEWFIL
	PUSHJ	P,GETBLK
	PUSHJ	P,AUDCHK
	TRNE	IOS,DMPBIT			;MAKE THIS TRNE IF REFTIM REQUIRED
	POPJ	P,
	MOVE	TAC1,THSDAT			;USE DATE ONLY FOR REFERENCE TIME
	CAMG	TAC1,DREFTM(DDB)		;DON'T UPDATE MORE THAN ONCE A DAY
	POPJ	P,
	SKIPN	TTYLOK				;IN MAINTMODE, DON'T WRITE 
	SKIPE	MAINTM
	POPJ	P,
	MOVEM	TAC1,REFTIM(DDB)
	MOVEM	TAC1,DREFTM(DDB)
	MOVEM	TAC1,DREFTM+SYSRTV
	MOVE	TAC,[XWD -40,SYSBUF]
	MOVEM	TAC,TFRIOW(DDB)			;DON'T REWRITE WHOLE BLK.
	LDB	TAC1,PUNIT			;UDP?
	JUMPE	TAC1,RERITE			;NO.
	TRNE	IOS,IOIMPM!IODERR
	POPJ	P,				;ERRORS ALREADY. DON'T REWRITE
	PUSHJ	P,RERITE
	TDZ	IOS,[LOSBIG,,IOIMPM!IODERR]	;DON'T REPORT WRITE LOCK.
	POPJ	P,

;ENTER

DENTER:
	JSP	AC1,ACCENT
	SKIPN	ACCNAM(DDB)
	JRST	ENOFIL				;BLANK NAME LOSES
	TLNE	IOS,READB			;HAS LOOKUP BEEN DONE?
	JRST	DALTER				;YES, IS ALTER
	SETZM	FILNAM(DDB)			;DISABLE RENAME.
	SETOM	SRCTMP(DDB)			;INITIALIZE FLAG
	JSP	AC1,ACCESS			;SEE WHO'S LOOKING
	JRST	DENT0				;READ - SAVE DATA (XCTED IN ACCESS)
	JRST	EFWRIT				;WRITE - LOSE (XCTED IN ACCESS)
	TLO	IOS,IO!WRITEB!GOBIT
	PUSHJ	P,ACCEST			;ACCESS OURS (ACCXXX → FILXXX)
	PUSHJ	P,SATGET			;MAKE SURE SAT TABLE IN (FOR UDP)
	SKIPG	SRCTMP(DDB)			;WAS SOMEONE READING?
	PUSHJ	P,FILSRC			;NO, GET DATA
	TLZ	IOS,WRITEB!NTRUFD		;TURN OFF IN CASE PROTECTION CHECK
	MOVEM	IOS,DEVIOS(DDB)			;   FAILS
	MOVSI	DAT,100000
	JSP	AC1,UPROTC
	SKIPG	SRCTMP(DDB)			;THIS NAME IN USE?
	JRST	DENT1				;NO FILE FOUND
	MOVSI	DAT,100000			;FOUND, CHECK PROTECTION.
	JSP	AC1,PROTEC			;WRITE ACCESS REQUIRED.
	LDB	AC1,[POINT 9,FILPRO(DDB),8]
	JUMPN	AC1,DENT1A			;JUMP IF USER SPECIFIED PROTECTION
	LDB	AC1,[POINT 9,SRCPRO(DDB),8]	;USE OLD FILE'S PROT
	DPB	AC1,[POINT 9,FILPRO(DDB),8]	;...AS NEW FILE'S PROTECTION
DENT1A:
	TLOA	IOS,NTRUFD!WRITEB		;INDICATE CHANGE UFD AT CLOSE.
DENT1:
	TLOA	IOS,WRITEB			;NEW NAME. PUT IN UFD NOW.
	SKIPA	TAC1,SRCEXT(DDB)		;USE OLD CREATION DATE AS DEFAULT
	MOVE	TAC1,THSDAT			;USE CURRENT DATE AS DEFAULT
	LDB	TAC,[POINT 15,ACCEXT(DDB),35]	;BELIEVE ANY CREATE DATE
	JUMPN	TAC,DENT4			;USER TELLS US.
	MOVE	TAC,TAC1
	DPB	TAC,[POINT 15,ACCEXT(DDB),35]
DENT4:
	DPB	TAC,[POINT 15,FILEXT(DDB),35]
DENT2:
	MOVEM	IOS,DEVIOS(DDB)
	TRNE	IOS,DMPBIT
	JRST	DENT3				;DON'T INIT TIME IF DUMPER
	SETZM	DDMPTM(DDB)			;NEW FILE NEVER DUMPED.
	SETZM	DMPTIM(DDB)
	MOVE	TAC1,THSDAT			;REFERENCE DATE
	MOVEM	TAC1,REFTIM(DDB)
	MOVEM	TAC1,DREFTM(DDB)
	PUSHJ	P,DSKTM1			;GET DATE AND TIME LAST WRITTEN
	DPB	TAC,[POINT 3,ACCEXT(DDB),20]	;STORE EXTRA BITS
	DPB	TAC,[POINT 3,FILEXT(DDB),20]
	MOVSI	TAC,777000			;USE SPECIFIED PROTECTION
	AND	TAC,FILPRO(DDB)			;GET PROTECTION THUS FAR
	JUMPN	TAC,DENT2A			;JUMP IF THERE'S NON-ZERO ALREADY
	TLNE	IOS,NTRUFD			;SKIP IF NEW FILE.
	JRST	DENT2A				;REPLACING OLD FILE - KEEP 0 PROT
;HERE WE USE UFD'S DEFAULT PROTECTION WORD FOR PROTECTION OF THIS NEW FILE
	MOVEI	TAC,777000
	AND	TAC,UFDPR1(DDB)			;DEFAULT PROTECTION VALUE FROM UFD
	MOVSI	TAC,(TAC)
DENT2A:
	OR	TAC1,TAC
	DPB	IOS,[POINT 4,TAC1,12]		;DATA MODE
	MOVEM	TAC1,FILPRO(DDB)
	MOVEM	TAC1,ACCPRO(DDB)
	MOVSI	IOS,HDRDIF
	IORB	IOS,DEVIOS(DDB)			;MAKE SURE DATE GOES OUT EVENTUALLY
DENT3:
	TLNE	IOS,ALTERB
	JRST	ENTREN				;PUT OUT DATE IF ALTER MODE
	LDB	TAC,PUNIT
	JUMPN	TAC,DENT3A
	MOVE	TAC,DSKUSE+SATTAB		;SEE IF ANY SPACE LEFT
	CAILE	TAC,LSTBIT-=200			;SOFT STOP WITH 200K DISK LEFT.
	JRST	ENTFUL				;GIVE NO ROOM MESSAGE. ERROR RETURN
DENT3A:
	PUSHJ	P,ASNBLK			;GET SPACE FOR NEW FILE
	MOVEM	TAC,FILLOC(DDB)
	MOVE	TAC,DDLOC(DDB)			;UFD LOCN FOR DIRINS
	MOVEM	TAC,SRCLOC(DDB)
	TLNN	IOS,NTRUFD
	PUSHJ	P,DIRINS			;NEW FILE TO UFD NOW.
	SETZM	FILLNG(DDB)
	SETZM	DQINFO(DDB)			;INITIALIZE MAGIC FILE INFO
	SETZM	DQINFO+1(DDB)
	HLRZ	TAC,FILEXT(DDB)
	CAIE	TAC,UFDEXT
	JRST	NENUFD				;NOT ENTERING A UFD
	MOVE	TAC,FILPPN(DDB)
	CAME	TAC,SYSPPN
	JRST	NENUFD
	SETZM	DQINFO+2(DDB)			;CLEAR WORDS WHEN ENTERING A UFD
	SETZM	DQINFO+3(DDB)
	JRST	WENUFD

NENUFD:
	MOVE	TAC,JOBNAM(J)			;UPDATE PPN AND JOB OF WRITER
	MOVEM	TAC,DQINFO+2(DDB)
	MOVE	TAC,PRJPRG(J)
	MOVEM	TAC,DQINFO+3(DDB)
WENUFD:
	SETZM	DOFFST(DDB)			;INIT OFFSET
	PUSHJ	P,AUDINF
	MOVE	TAC,FILLOC(DDB)
	PUSHJ	P,NEWFI1
	PUSHJ	P,ASNGR1			;SET UP RTVL
	MOVEI	DAT,SPREAD
	TLNN	IOS,NTRUFD			;IF NEW FILE,
	PUSHJ	P,QEWAIT			;PUT RTVL OUT.
	LDB	TAC,PUNIT
	TRNE	IOS,IODERR!IOIMPM		;UDP IN WRITE LOCK?
	JUMPN	TAC,SATGLZ			;REPORT DATA TO USER.
	JRST	DRPT

DENT0:
	MOVE	TAC1,FILPRO(TAC)		;READER FOUND, SAVE PROTECTION.
	MOVEM	TAC1,SRCPRO(DDB)
	MOVE	TAC1,FILEXT(TAC)
	HRRM	TAC1,SRCEXT(DDB)
	MOVE	TAC1,UFDPRO(TAC)
	MOVEM	TAC1,UFDPRO(DDB)
	MOVEI	TAC1,1				;SET FLAG: ITEM FOUND
	MOVEM	TAC1,SRCTMP(DDB)
	JRST	ACCES1				;KEEP LOOKING FOR WRITERS

ENTREN:
	PUSHJ	P,ALTREN			;WRITE DATE INTO UFD
	JFCL					;CAN'T GET ERROR RETURN???
	JRST	DRPT				;RETURN LOOKUP INFO

DALTER:
	TLOE	IOS,ALTERB
	JRST	EFWRIT				;ALREADY ALTERING
	MOVE	TAC,FILNAM(DDB)			;SAME FILE?
	CAME	TAC,ACCNAM(DDB)
	JRST	EANAME
	HLLZ	TAC,FILEXT(DDB)
	HLLZ	TAC1,ACCEXT(DDB)
	CAME	TAC,TAC1
	JRST	EANAME
	MOVE	AC2,FILPPN(DDB)
	CAME	AC2,ACCPPN(DDB)
	JRST	EANAME
	MOVSI	DAT,100000
	JSP	AC1,UPROTC			;SEE IF UFD ALLOWS THIS ACCESS
	MOVSI	DAT,100000			;NEEDS WRITE ACCESS
	MOVE	AC3,FILPRO(DDB)
	JSP	AC1,PROTEK
	JSP	AC1,ACCESS			;IS ANYONE USING FILE?
	JRST	EFWRIT				;IF SO, LOSE
	JRST	EFWRIT
	JRST	DENT2				;STORE IOS & SKIP RETURN.

;RENAME

DRENAM:
	TDNE	IOS,[XWD DEVSBB,IOACT]
	PUSHJ	P,WAIT1				;FINISH CURRENT BUSINESS
	SKIPN	FILNAM(DDB)
	JRST	EXFIL				;LOSE IF NO ACCESSED FILE.
	TLNE	IOS,NTRUFD!DELETB		;IF FILE TO BE DELETED,
						;OR OVERWRITING AND NO CLOSE
	JRST	ENOFIL				;CAN'T RENAME.
	TLNN	IOS,READB			;IF READING, TEST UNIQUE ACCESS.
	JRST	DRE0				;OTHERWISE, ALREADY UNIQUE.
	XCTR	XR,[MOVE AC2,(UUO)]		;NEW FILE NAME
	JSP	AC1,ACCESS			;IS ANYONE ELSE RENAMING FILE?
	JUMPN	AC2,EFWRIT			;LOSE UNLESS DELETING
	JFCL					;CAN'T AFFECT FOREIGN WRITER
DRE0:
	PUSHJ	P,FILEUP			;FORCE RETRIEVAL SO WE DON'T MUNG IT
	PUSHJ	P,GOSET
	TRNE	IOS,DMPBIT
	JRST	DRE0A				;DON'T INIT TIME IF DUMPER
	MOVE	TAC1,THSDAT			;GET REFERENCE DATE
	MOVEM	TAC1,REFTIM(DDB)		;UPDATE REFTIM FOR RANDOM LOSER
DRE0A:
	JSP	AC1,ACCENT			;JUST US. PICK UP UUO ARGS.
	SKIPN	TAC,ACCNAM(DDB)
	JRST	DRNMC				;DELETING, CHECK WRITE PROT
	MOVE	TAC,ACCPRO(DDB)
	XOR	TAC,FILPRO(DDB)			;PROTECTION CHANGE?
	TLNN	TAC,777000
	JRST	DRE1				;NO CHANGE
	MOVE	AC2,FILPPN(DDB)
	CAME	AC2,SYSPPN
	JRST	DRE0B				;NOT ACCESS TO A UFD
	MOVE	AC2,FILNAM(DDB)			;UFD ACCESS.  TO MFD?
	CAMN	AC2,SYSPPN
	JRST	EPROT				;CHANGE PROT OF MFD NOT ALLOWED
	MOVE	AC1,JBTPRV(J)
	TLNN	AC1,PROPRV			;PRIVILEGED?
	CAMN	AC2,PRJPRG(J)			;NO. BUT ACCESS TO OWN UFD OK
	JRST	DRE1
	JRST	EPROT

DRE0B:
	MOVSI	DAT,400000
	JSP	AC1,UPROTK			;LEGAL TO CHANGE IN THIS UFD?
	MOVSI	DAT,400000
	MOVE	AC3,FILPRO(DDB)
	JSP	AC1,PROTEK			;LEGAL TO CHANGE THIS FILE?

DRE1:
	MOVE	TAC,FILNAM(DDB)
	CAME	TAC,ACCNAM(DDB)
	JRST	DRNMC				;NAME CHANGE.
	HLLZ	TAC1,FILEXT(DDB)
	XOR	TAC1,ACCEXT(DDB)
	TLNE	TAC1,777777			;EXT CHANGE?
	JRST	DRNMC
	MOVE	TAC1,FILPPN(DDB)
	CAME	TAC1,ACCPPN(DDB)		;NEW PROJ.-PROG?
	JRST	DRNMC				;YES, NEW PPN
ALTREN:
	PUSHJ	P,FILSRC			;LITTLE OR NO CHANGE. GET RTVL IN.
	JRST	DRE2

DRNMC:
	MOVSI	DAT,100000			;NAME CHANGE REQUIRES WRITE ACCESS
	MOVE	AC2,FILPPN(DDB)
	JSP	AC1,UPROTK			;UFD ALLOWS WRITE ACCESS?
	MOVSI	DAT,100000
	MOVE	AC3,FILPRO(DDB)
	JSP	AC1,PROTEK			;FILE ALLOWS WRITE ACCESS?
	JUMPE	TAC,DRDEL			;0 = DELETE.
	JSP	AC1,ACCESS			;NEW NAME; SEE IF IN USE.
	JRST	EDNAME
	JRST	EDNAME				;YES, LOSE.
	TLO	IOS,RENAMB			;ESTABLISH UNIQUE ACCESS NOW!
	MOVEM	IOS,DEVIOS(DDB)
	MOVE	AC3,UFDPRO(DDB)			;THIS GETS CLOBBERED BY FILSRC
	MOVEM	AC3,UFDPR1(DDB)
	PUSHJ	P,FILSRC			;SEE IF IN DIRECTORY.
	TLZ	IOS,RENAMB			;IN CASE OF ACCIDENT, RELEASE ACCESS
	MOVE	AC3,UFDPR1(DDB)			;GET BACK PROTECTION OF SOURCE UFD
	EXCH	AC3,UFDPRO(DDB)			;DESTINATION UFD PROTECTION IN AC3
	SKIPLE	TAC,SRCTMP(DDB)			;DOES FILE NAME EXIST?
	JRST	EDNAME				;FILE NAME IS IN USE. (STORES IOS)
	TRNN	IOS,DMPBIT
	SETZM	DMPTIM(DDB)			;CLEAR DUMP DATE, UNLESS DUMPER

DRE2:
	TLO	IOS,RENAMB			;KEEP HACKERS OUT WHILE...
	MOVEM	IOS,DEVIOS(DDB)			;CHANGING THINGS.
	MOVE	TAC,DDLOC(DDB)			;POINTS TO DESTINATION UFD ALWAYS
	MOVEM	TAC,SRCLOC(DDB)			;TELL DIRSRC WHERE TO LOOK.
	MOVE	TAC,ACCPPN(DDB)			;COMPARE PPN
	CAMN	TAC,FILPPN(DDB)
	JRST	DREC1				;SAME PPN, CHANGE 1 UFD
	MOVSI	DAT,100000			;REQUIRES WRITE ACCESS TO OTHER UFD
	MOVE	AC2,ACCPPN(DDB)			;GET PPN OF DESTINATION. AC3 SETUP
	JSP	AC1,PROT0			;SEE IF ACCESS ALLOWED.
	MOVE	TAC,FILEXT(DDB)			;COPY CREATION DATE FROM RETRIEVAL
	DPB	TAC,[POINT 15,ACCEXT(DDB),35]	;INTO USERS VARIABLES
						;(WILL BE COPIED BACK LATER)
	TRNE	TAC,700000			;CHECK THIS PART OF DATE
	JRST	DRE3				;USER IS SPECIFYING DATE & TIME
	MOVE	TAC,ACCPRO(DDB)
	TDNE	TAC,[777,,777777]		;ANY DATE AND TIME?
	JRST	DRE3				;YES, USE IT
	MOVE	TAC,FILPRO(DDB)			;NO, USE THOSE FROM RETRIEVAL
	TLZ	TAC,777000			;CLEAR PROT.
	IORM	TAC,ACCPRO(DDB)
	LDB	TAC,[POINT 3,FILEXT(DDB),20]
	DPB	TAC,[POINT 3,ACCEXT(DDB),20]
DRE3:
	PUSHJ	P,DIRINS			;CHANGE 2 UFD'S. INSERT NEW
	MOVEI	TEM,FILNAM(DDB)
	PUSHJ	P,SRCH1				;FIND OLD UFD
	SKIPA	DAT,[DR2INT]			;AND REMOVE OUR ENTRY
DREC1:
	MOVEI	DAT,DRINT			;CHANGE 1 UFD ONLY
	MOVE	AC1,FILLNG(DDB)
	CAILE	AC1,=50*2000
	JRST	DRE8
	PUSHJ	P,QEWAIT
	JRST	DRE7

DRE8:
	PUSHJ	P,NEWAIT
DRE7:
	TLZA	IOS,RENAMB			;SEE US SAVE A WORD OF CODE.
DRDEL:
	PUSHJ	P,DCLSO9			;ARRANGE TO DELETE FILE.
	LDB	TAC,PUNIT
	TRNE	IOS,IODERR!IOIMPM		;WRITE ERROR?
	JUMPN	TAC,SATGLZ			;LOSE. WRITE LOCKED UDP
	JRST	DPOPJ1				;RETURN TO USER

;***INTERRUPT LEVEL SUBRS***

DRAUFX:
	AOS	DRAUFO
	POPJ	P,

DRAUFD:
	SKIPN	TAC,FILNAM(DDB)			;FIND ENTRY FOR OLD NAME
	JRST	DRAUFX				;NULL NAME? RETURN NO FILE FOUND.
	MOVEM	TAC,SRCNAM(DDB)			;(UFD WAS FOUND BY FILSRC)
	MOVE	TAC,FILEXT(DDB)
	HLLZM	TAC,SRCEXT(DDB)
	PUSHJ	P,DIRSRC			;FIND UFD ENTRY
	SKIPG	SRCTMP(DDB)
	JRST	DRAUFX				;NO OLD FILE FOUND!
	MOVE	TAC,ACCNAM(DDB)			;CHANGE IT
	MOVEM	TAC,SYSDTA+UNAM(TAC1)		;(ALSO USED FOR DELETE)
	MOVE	TAC,ACCEXT(DDB)
	HLLM	TAC,SYSDTA+UEXT(TAC1)
	MOVE	TAC,SYSDTA+UEXT(TAC1)		;NOW COPY CREATION DATE BACK
	DPB	TAC,[POINT 15,ACCEXT(DDB),35]	;RPH/DATE75
	LDB	TEM,[POINT 3,ACCEXT(DDB),20]	;GET DATE
	MOVE	TAC,ACCPRO(DDB)			;AND TIME
	TDNN	TAC,[777,,777777]		;DID HE SPECIFY ANY?
	JUMPE	TEM,UOLDAT			;CHECK IT ALL
	JRST	UNEWDA				;USER SPECIFYING DATE AND TIME

UOLDAT:
	LDB	TEM,[POINT 3,FILEXT(DDB),20]	;COPY 3 EXTRA BITS
	DPB	TEM,[POINT 3,ACCEXT(DDB),20]
	MOVE	TAC,FILPRO(DDB)			;NOW REST OF DATE AND TIME
	DPB	TAC,[POINT 23,ACCPRO(DDB),35]
	MOVE	TAC,ACCPRO(DDB)
UNEWDA:
	DPB	TEM,[POINT 3,SYSDTA+UEXT(TAC1),20]	;STORE BITS IN UFD ENTRY
	MOVEM	TAC,SYSDTA+UPRO(TAC1)			;AND THE REST TOO
	MOVE	TAC,FILLOC(DDB)				;NEW FILE LOCATION.
	EXCH	TAC,SYSDTA+UPPN(TAC1)		;OLD ONE USED BY CLOSE OUTPUT.
	MOVEM	TAC,SRCLOC(DDB)

REWRIT:
	MOVEI	TAC,IOPCHN!DWRITE
	MOVSM	TAC,TFRCTL(DDB)
	PUSHJ	P,TSTART			;WRITE IT BACK OUT.
	POPJ	P,

DRINT:
	PUSHJ	P,DRAUFD
DRINT1:
	MOVE	TAC,FILEXT(DDB)
	PUSHJ	P,ACCST1			;UPDATE NAME.
	HRRM	TAC,FILEXT(DDB)			;RESTORE TIME
	MOVE	TAC,FILLOC(DDB)			;PREPARE TO SPREAD IT
	PUSHJ	P,NEWFIL

DRINL:
	PUSHJ	P,GGRETI			;WRITE NEW NAME OVER FILE
	TLNN	IOS,ALTERB			;ARE WE ENTERING R-A MODE,
	JRST	DRINL2				;UPDATE JOB AND PPN OF CULPRIT
	HLRZ	TAC,FILEXT(DDB)			;EXCEPT FOR UFDS
	CAIE	TAC,UFDEXT
	JRST	DRINL1
	MOVE	TAC,FILPPN(DDB)
	CAMN	TAC,SYSPPN
	JRST	DRINL2
DRINL1:
	MOVE	TAC,JOBNAM(J)
	MOVEM	TAC,DQINFO+2(DDB)
	MOVE	TAC,PRJPRG(J)
	MOVEM	TAC,DQINFO+3(DDB)
DRINL2:
	PUSHJ	P,AUDINF			;COPY NEW INFO IN RETRIEVAL AREA
	PUSHJ	P,SPREAD
	SKIPN	DNXTGP(DDB)
	POPJ	P,				;END FILE, RETURN
	MOVEI	TAC,RCPGRP
	ADDM	TAC,USETP(DDB)
	JRST	DRINL

; WE GET HERE TO DELETE ENTRY IN OLD UFD
; PPN CHANGE ONLY
; ENTRY HAS ALREADY (SUPPOSEDLY) BEEN INSERTED IN NEW UFD

DR2INT:
	PUSHJ	P,DIRSRC			;FIND ENTRY IN OLD UFD
	SKIPG	SRCTMP(DDB)			;IS IT REALLY THERE?
	JRST	DRAUFX				;NO, LOSE LOSE
	SETZM	SYSDTA+UNAM(TAC1)		;DELETE ENTRY IN UFD
	SETZM	SYSDTA+UEXT(TAC1)
	PUSHJ	P,REWRIT
	JRST	DRINT1				;SPREAD RETRIEVAL

;FILE ACCESS CONTROL.

ACCENT:
	MOVE	J,JOB(PID)
	XCTR	XR,[MOVE TAC,UNAM(UUO)]		;NAME
	MOVEM	TAC,ACCNAM(DDB)
	XCTR	XR,[MOVE TAC,UEXT(UUO)]		;EXT
	MOVEM	TAC,ACCEXT(DDB)
	XCTR	XR,[MOVE TAC,UPRO(UUO)]		;PROT
	MOVEM	TAC,ACCPRO(DDB)
	XCTR	XR,[SKIPN TAC,UPPN(UUO)]	;PPN
IFN FTDSKPPN,<	SKIPE	TAC,DSKPPN(J)		;PICK UP DISK ALIAS PPN IF ANY
		CAIA			>;FTDSKPPN
	MOVE	TAC,PRJPRG(J)			;USE USER'S PPN IF BLANK
	TLNE	DDB,SYSDEV			;SYS?
	MOVE	TAC,CUSPPN			;YES, USE CUSP PPN
	MOVEM	TAC,ACCPPN(DDB)
	TRNN	IOS,DMPBIT
	JRST	(AC1)
	XCTR	XR,[MOVE TAC,4(UUO)]
	MOVEM	TAC,REFTIM(DDB)
	XCTR	XR,[MOVE TAC,5(UUO)]
	MOVEM	TAC,DMPTIM(DDB)
	JRST	(AC1)

ACCESS:
	LDB	TAC,PUNIT
	MOVE	TAC,DKDBML(TAC)		;FIRST DDB IS DUMMY
	HLLZ	DAT,ACCEXT(DDB)		;IN CASE RH NOT 0.
ACCES1:
	HLRZ	TAC,DEVSER(TAC)		;GET NEXT DDB
	MOVE	TAC1,DEVNAM(TAC)	;GET DEVICE NAME
	CAME	TAC1,DEVNAM(DDB)	;IS IT SAME AS US
	JRST	2(AC1)			;NO, ALL DONE, RETURN
	CAIN	TAC,(DDB)		;DON'T LOOK AT OWN DDB
	JRST	ACCES1
	MOVE	TAC1,FILNAM(TAC)	;COMPARE NAME
	CAME	TAC1,ACCNAM(DDB)
	JRST	ACCES1
	HLLZ	TAC1,FILEXT(TAC)
	CAME	TAC1,DAT
	JRST	ACCES1
	MOVE	TAC1,FILPPN(TAC)
	CAME	TAC1,ACCPPN(DDB)
	JRST	ACCES1
	MOVE	TAC1,DEVIOS(TAC)	;FOUND ONE, SEE WHAT IT'S DOING
	TLNE	TAC1,DELETB
	JRST	ACCES1			;IGNORE IF TO BE DELETED.
	TLNE	TAC1,ALTERB!RENAMB	;ALTERING?
	JRST	EFWRIT			;YES, LOSE
	TLNE	TAC1,READB		;READING?
	XCT	0(AC1)			;YES
	TLNE	TAC1,WRITEB		;WRITING?
	XCT	1(AC1)			;YES
	JRST	ACCES1			;OK, LOOK FOR MORE.

ACCEST:
	MOVEM	IOS,DEVIOS(DDB)			;ACCESS ESTABLISHED
ACCST1:
	MOVE	TAC1,ACCNAM(DDB)
	MOVEM	TAC1,FILNAM(DDB)
	MOVE	TAC1,ACCEXT(DDB)
	MOVEM	TAC1,FILEXT(DDB)
	MOVE	TAC1,ACCPRO(DDB)
	MOVEM	TAC1,FILPRO(DDB)
	MOVE	TAC1,ACCPPN(DDB)
	MOVEM	TAC1,FILPPN(DDB)
	POPJ	P,

PROTEC:
	MOVE	AC2,ACCPPN(DDB)
	MOVE	AC3,SRCPRO(DDB)
PROTEK:
	CAMN	AC2,SYSPPN		;ACCESS TO A UFD?
	JRST	PROT3			;YES.
PROT0:
	CAMN	AC2,PRJPRG(J)		;OWNER ACCESS TO FILE?
	JRST	PROT1			;YES.  DO OWNER ACCESS TESTS
	LSH	AC3,3			;NOT OWNER. SHIFT TO LOCAL-USER BITS
	MOVE	TAC1,JBTPRV(J)		;
	TLNN	TAC1,LUPPRV		;LOCAL USER?
	LSH	AC3,3			;NO. SHIFT TO REMOTE-USER FIELD
	LSH	TAC1,2			;SHIFT PRIVILEGE BITS TO CHECK PRIV ACCESS
	TDNE	TAC1,DAT		;IS ACCESS ALLOWED BY PRIVILEGE?
	JRST	(AC1)			;YES. PRIV. ACCESS TO FILE
	JRST	PROT2			;CHECK NON-OWNER ACCESS
PROT1:
	TLZ	DAT,600000		;OWNER CAN READ OR RENAME
PROT2:
	TDNN	DAT,AC3
	JRST	(AC1)			;OK
	JRST	EPROT			;LOSE

PROT3:
	TLNE	DAT,500000		;WRITE OR RENAME ACCESS TO UFD?
	JRST	PROT4			;YES. THIS IS USUALLY ILLEGAL
	MOVE	AC2,ACCNAM(DDB)		;USE THE NAME INSTEAD OF PPN FOR LEGALITY
	JRST	PROT0			;OTHERWISE, CONSIDER OTHER CLASS OF USERS

PROT4:
	JUMPGE	DAT,PROT5		;JUMP UNLESS 400000 ACCESS REQUESTED
	MOVE	TAC1,FILNAM(DDB)	;GET NAME OF THIS UFD
	CAMN	TAC1,PRJPRG(J)		;BELONGS TO US?
	JRST	(AC1)			;YES.  PROTECTION CHANGE IS OK.
PROT5:
	MOVE	TAC1,JBTPRV(J)		;WRITE OR RENAME ACCESS TO UFD
	LSH	TAC1,2
	TDNN	TAC1,DAT
	JRST	EPROT
	JUMPL	DAT,(AC1)		;LEGAL FOR PRIV' USER TO CHANGE PROT
	SKIPN	ACCNAM(DDB)		;WRITE IS LEGAL ONLY IF DELETING
	JRST	(AC1)
	JRST	EPROT

;HERE TO CHECK ACCESS TO A UFD
UPROTC:
	MOVE	AC2,ACCPPN(DDB)
UPROTK:
	SKIPE	AC3,UFDPRO(DDB)
	JRST	PROT0
	JRST	(AC1)			;AVOID WORK IF THIS IS A UFD ACCESS

;SEARCH MFD AND UFD FOR FILE.
;PUT DIRECTORY DATA IN SRCNAM,SRCEXT,SRCPRO,SRCLOC.
;FLAG IS LEFT IN SRCTMP.

; MFD, UFD FORMAT:
;	NAME
;	EXT, DATE CREATED
;	PROT, MODE, TIME LAST WRITTEN
;	LOCATION (LOGICAL BLOCK NO.)

FILSRC:
	PUSHJ	P,SRCH
	SKIPE	DAT				;WANT MFD?
	PUSHJ	P,QEWAIT			;NO, READ DIRECTORY
	TLNE	IOS,LOSBIG
	JRST	EGARPJ
	POPJ	P,

UFDSRC:
	PUSHJ	P,SRCH
	JUMPN	DAT,CPOPJ			;RETURN
	JRST	EACMFD				;ILLEG MFD OP.

SRCH:
	MOVEI	TEM,ACCNAM(DDB)
SRCH1:
	MOVE	DAT,MFDLOC
	MOVEM	DAT,SRCLOC(DDB)
	MOVE	TAC,UPPN(TEM)
	MOVSI	TAC1,UFDEXT
	HLLZ	AC3,UEXT(TEM)
	CAME	TAC,SYSPPN			;LOOKING FOR [1,1] FILE?
	JRST	SRCHM				;NO, GO SEARCH MFD FOR UFD
	CAMN	TAC1,AC3			;IT IS [1,1], IS IT UFD?
	CAME	TAC,UNAM(TEM)			;IS UFD, IS IT MFD?
	JRST	SRCHU				;NO, SEARCH MFD FOR IT
	MOVEM	DAT,SRCTMP(DDB)			;YES, PLUG IN MFD STUFF
	MOVE	DAT,MFDEXT
	MOVEM	DAT,SRCEXT(DDB)
	MOVE	DAT,MFDPRO
	MOVEM	DAT,SRCPRO(DDB)
	MOVEM	DAT,UFDPRO(DDB)			;DEFINE ACCESS ALLOWED TO MFD
	MOVEI	DAT,0				;MFD FLAG
	POPJ	P,

SRCHM:
	MOVEM	TAC,SRCNAM(DDB)
	MOVEM	TAC1,SRCEXT(DDB)
	CAMN TAC,UFDPPN(DDB)			;IS PTR TO THIS UFD IN THE DDB?
	SKIPN TAC1,UFDADR(DDB)			;YES, JUST GOBBLE IT
	JRST .+2
	JRST CUSSRC
	LDB	TAC1,PUNIT
	JUMPN	TAC1,SRCHM1			;DON'T KNOW WHERE ANYTHING IS IF UDP
	CAMN	TAC,CUSPPN			;IS THIS THE BLOODY CUSP?
	SKIPN	TAC1,CUSLOC			;YES, DO WE REMEMBER WHERE IT IS?
	CAIA					;NO TO ONE OF THESE
	JRST	CUSSRC				;YES, GO SEARCH IT
IFN FTDSKPPN,<
	SKIPN	TAC1,DSKPPN(J)
	MOVE	TAC1,PRJPRG(J)
	CAMN	TAC,TAC1			;HIS OWN UFD?
>;FTDSKPPN
IFE FTDSKPPN,<	CAMN	TAC,PRJPRG(J) >
	SKIPN	TAC1,JBTUFD(J)			;DO WE KNOW WHERE IT IS?
	JRST	SRCHM1				;NO. LOOK IN MFD FOR ITS LOC.
CUSSRC:
	HRRZM	TAC1,SRCLOC(DDB)		;TRY HERE.
	JRST	SRCHU				;GO GET UFD (BYPASS MFD SEARCH)

SRCHM1:
	MOVEI	DAT,DIRSRC			;LOOK IN MFD FOR USER'S UFD
	PUSHJ	P,QEWAIT
	TLNE	IOS,LOSBIG
	JRST	EGARJ2
	SKIPG	SRCTMP(DDB)			;FOUND IT?
	JRST	ENOUFD				;NO, LOSE
	MOVE	TAC1,SRCLOC(DDB)		;SAVE MOST RECENT UFD ADDR IN DDB
	LDB TAC,PUNIT
	JUMPN TAC,SRCHM2			;IF DSK, DON'T SAVE IF IN JBTUFD
	CAME TAC1,JBTUFD(J)
	CAMN TAC1,CUSLOC
	JRST SRCHM3
SRCHM2:
	MOVE	TAC,SRCNAM(DDB)
	MOVEM TAC,UFDPPN(DDB)
	MOVEM TAC1,UFDADR(DDB)
SRCHM3:
	LDB	TAC,PUNIT
	JUMPN	TAC,SRCHU			;SKIP THIS STUFF IF UDP
	MOVE	TAC,SRCNAM(DDB)			;DID WE JUST LOOK AT GUY'S OWN UFD?
IFN FTDSKPPN,<	SKIPN	DAT,DSKPPN(J)
		MOVE	DAT,PRJPRG(J)
		CAMN	TAC,DAT		>;FTDSKPPN
IFE FTDSKPPN,<	CAMN	TAC,PRJPRG(J)	>
	MOVEM	TAC1,JBTUFD(J)
	CAMN	TAC,CUSPPN
	MOVEM	TAC1,CUSLOC
SRCHU:
	HLLZ	TAC1,UEXT(TEM)
	MOVEM	TAC1,SRCEXT(DDB)
	MOVE	TAC,UNAM(TEM)			;LOOK IN UFD FOR FILE
	MOVEM	TAC,SRCNAM(DDB)
	MOVEI	DAT,DIRSRC
	POPJ	P,

;INSERT A FILE NAME IN UFD.
;UFD RTVL MUST BE IN DDB.

DIRINS:
	MOVEI	DAT,DIRI1			;TRY TO PUT NEW NAME IN
	PUSHJ	P,QEWAIT			;WITHOUT EXTENDING UFD.
	SKIPN	SRCTMP(DDB)			;SUCCESSFUL?
	POPJ	P,				;YES, RETURN
	PUSHJ	P,MAKBLK			;NO ROOM, GET NEW BLOCK
	MOVEI	DAT,DIRI2
	PUSHJ	P,QEWAIT			;WRITE NEW NAME IN IT
	POPJ	P,

;*** INTERRUPT SUBRS ***

DIRI1:
	SETZM	SRCNAM(DDB)
	PUSHJ	P,DIRSRC			;LOOK FOR A HOLE.
	SKIPL	SRCTMP(DDB)			;FOUND ONE?
	JRST	DIRIHF				;YES, GO USE IT.
	SKIPN	AC1,DDLNG+SYSRTV		;UFD WD CT
	JRST	DIRI1W				;ZERO LENGTH FILE MUST HAVE ROOM
	IDIVI	AC1,BKDSIZ			;ROOM IN THIS BLOCK?
	CAIG	AC2,BKDSIZ-4
	JUMPN	AC2,DIRI1W			;YES, GO FIX UNLESS INTEGRAL
						;NUMBER OF BLOCKS
	SETOM	SRCTMP(DDB)			;FLAG MORE SPACE NEEDED
	MOVEI	DAT,RCPBLK
	ADDM	DAT,USETP(DDB)
	POPJ	P,				;BACK TO UUO LVL TO GET IT.

DIRIHF:
	MOVEI	TAC1,SYSDTA-1(TAC1)
	PUSH	TAC1,ACCNAM(DDB)
	PUSH	TAC1,ACCEXT(DDB)
	PUSH	TAC1,ACCPRO(DDB)
	PUSH	TAC1,FILLOC(DDB)
	SETZM	SRCTMP(DDB)			;FLAG SUCCESSFUL.
	JRST	REWRIT				;SPIT IT BACK OUT

DIRI2:
	MOVEI	TAC1,0
DIRI1W:
	PUSH	P,TAC1
	MOVEI	DAT,4
	ADDM	DAT,DDLNG(DDB)			; EXTEND UFD
	PUSHJ	P,SPREAD
	MOVE	TAC,[XWD -BKDSIZ,SYSDTA]	;RTVL OUT, JUST WRITE DATA!
	MOVEM	TAC,TFRIOW(DDB)
	MOVE	TAC,USETP(DDB)
	PUSHJ	P,LR2BLK
	JUMPE	TAC,[	POP	P,TAC1		;0 MEANS BAD RETRIEVAL!
			JRST	SETLOS]
	PUSHJ	P,BKMAP				;FINISH MAPPING
	LDB	AC3,PUNIT
	ADD	TAC,BFSETS(AC3)
	MOVEM	TAC,TFRSEC(DDB)
	POP	P,TAC1
	JRST	DIRIHF

;*** I-SUBR TO READ DIRECTORY INTO SYSBUF & SEARCH.
;RETURNS FLAG IN SRCTMP: -1 IF NOT FOUND
;	0 IF DIFFERS IN EXT AND SPECIFIED EXT WAS 0
;	+N IF EXACT MATCH FOUND

DIRSRC:
	MOVE	TAC,SRCLOC(DDB)			;LOCATION OF UFD FILE
	PUSHJ	P,NEWFIL
	SETZM	SRCTMP(DDB)
	PUSHJ	P,GETBLK
	MOVE	TAC,DDPPN+SYSRTV		;BLOCK SHOULD LOOK LIKE UFD.
	HLLZ	TAC1,DDEXT+SYSRTV
	CAMN	TAC,SYSPPN
	CAME	TAC1,MFDEXT
	PUSHJ	P,AUDHAK			;IT DOESN'T.
	MOVE	TAC,MFDLOC
	MOVE	TAC1,SYSRTV+DSATID		;GET SATID OF CURRENT UFD.
	LDB	DAT,PUNIT
	MOVE	DAT,SATADR(DAT)
	CAMN	TAC,SRCLOC(DDB)			;IS THIS THE MFD ?
	CAMN	TAC1,SATID(DAT)			;YES. AGREES WITH MASTER COPY?
	JRST	DIRSA				;YES
	CAME	DAT,SATADR			;IS THIS THE MAIN DISK?
	JRST	AUDHAK				;NO. SOMEONE SWAPPED PACKS!
	EXCH	TAC1,SATID(DAT)			;MAKE IT GOOD, WE HOPE
	MOVE	TAC,SATID(DAT)			;MAKE LIFE EASIER IN TYPEOUT
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISERR
	[ASCIZ/SATID CLOBBERED!
SATID IN CORE=/]
	DISARG(OCT,<-20+TAC1(P)>)		;SATID IN CORE
	[ASCIZ/
SATID ON DISK=/]
	DISARG(OCT,<-20+TAC(P)>)
	[ASCIZ/
DON'T CONTINUE UNTIL YOU GET A WIZARD.
/]
	-1
	MOVE	TAC,SATID+SATTAB		;MAKE SURE ALL THE SATID'S AGREE
	MOVEM	TAC,SATID1
	MOVEM	TAC,SATID2
	CONO	PI,PIOFF
	SETOM	DISFLAG				;FORCE TYPEOUT
	PUSHJ	P,DISFLUSH
	POPACS
	CONO	PI,PION
	PUSHJ	P,DDTCALL			;MAKE HIM DO A CPOPJ$G
DIRSA:
	MOVE	TAC1,SYSRTV+DQINFO+3		;GET DEFAULT FILE PROTECTION
	HLRM	TAC1,UFDPR1(DDB)		;ICK!
	MOVSI	TAC1,777000
	AND	TAC1,SYSRTV+DDPRO
	MOVEM	TAC1,UFDPRO(DDB)		;SAVE PROTECTION OF THIS UFD
	SETZ	TAC1,
	MOVN	TEM,DDLNG+SYSRTV		;GET -WORD COUNT
	JUMPE	TEM,DIRSN			;EMPTY DIRECTORY
DIRS1:
	MOVEI	TAC1,0
DIRS2:
	MOVE	DAT,SYSDTA(TAC1)
	CAME	DAT,SRCNAM(DDB)
	JRST	DIRSX				;NOT THIS ONE
	JUMPE	DAT,DIRSRZ			;LOOKING FOR HOLE, FOUND ONE
	MOVE	DAT,SYSDTA+1(TAC1)		;NAME SAME, SAVE STUFF ...
	MOVEM	DAT,SRCTMP(DDB)			;FOR EXT CHECK.
	MOVE	TAC,SYSDTA+2(TAC1)
	MOVEM	TAC,SRCPRO(DDB)
	MOVE	TAC,SYSDTA+3(TAC1)		;FILE LOCN (MUST BE +)
	MOVEM	TAC,SRCLOC(DDB)
	XOR	DAT,SRCEXT(DDB)			;COMPARE EXTENSION
	TLNN	DAT,-1
	JRST	DIRSE				;MATCHES, THIS IS IT.
DIRSX:
	ADDI	TEM,4				;INDEXING.
	ADDI	TAC1,4
	JUMPGE	TEM,DIRSF			;OUT OF ENTRIES, RETURN FAIL.
	CAIGE	TAC1,BKDSIZ
	JRST	DIRS2
	MOVEI	TAC1,RCPBLK
	ADDM	TAC1,USETP(DDB)
	PUSHJ	P,GETBLK			;GET NEXT BLOCK OF DIRECTORY FILE
	JRST	DIRS1

DIRSF:
	SKIPN	SRCTMP(DDB)			;ANY PARTIAL MATCH?
	JRST	DIRSN				;NO, RETURN FAIL
	SKIPN	SRCEXT(DDB)			;BLANK EXT SPECIFIED?
DIRSRZ:
	TDZA	TAC,TAC				;RETURN MAYBE, IF SO.
DIRSN:
	SETOM	TAC				;NO, RETURN FAILURE

DIRSE:
	EXCH	TAC,SRCTMP(DDB)			;ENDFILE OR ENTRY FOUND
	MOVEM	TAC,SRCEXT(DDB)			;RETURN BEST BET
	POPJ	P,

; RETRIEVAL SUBRS

GETRET:
	MOVEI	DAT,GGRETI			;GET RTVL IN IF IT IS NOT
	PUSHJ	P,TSTRET			;IS IT?
	PUSHJ	P,QEWAIT			;NO, GO GET IT
	PUSHJ	P,TSTRET			;IS IT REALLY HERE?
	POPJ	P,				;NO, GIVE ERROR RETURN
	JRST	CPOPJ1				;YES, SUCCESS.

TSTRET:
	MOVE	TAC,USETP(DDB)			;SKIP IF RTVL IS IN.
	SKIPN	TAC1,DGRP1R(DDB)
	POPJ	P,				;NOT IN, RETURN
	CAIGE	TAC,RCPGRP(TAC1)
	CAIGE	TAC,(TAC1)
	POPJ	P,				;LOSE, WRONG GROUP IN
	JRST	CPOPJ1				;IN, SKIP

MAKBLK:
	PUSHJ	P,GETRET			;GET GROUP RETRIEVAL IN!
	PUSHJ	P,ASNGRP			;NO SUCH GROUP, MAKE ONE
	MOVE	TAC,USETP(DDB)
	PUSHJ	P,LR2BLK			;LOOK UP BLOCK IN RTVL.
	JUMPN	TAC,CPOPJ			;IT EXISTS, RETURN
	PUSHJ	P,ASNBLK			;IT DOESN'T, GET ONE FROM SAT
	TLO	IOS,PNTDIF			;NOTE RTVL NOT OUT!!!
	MOVE	AC1,USETP(DDB)			;MAKE RTVL ENTRY
	SUB	AC1,DGRP1R(DDB)			;PUT ABS BLK PTR IN CORR HALFWD.
	IDIVI	AC1,RCPBLK
	LSHC	AC1,-1
	ADDI	AC1,DPTR(DDB)
	JUMPL	AC2,MAKB3
	HRLM	TAC,(AC1)			;EVEN IN LEFT HALF
	POPJ	P,

MAKB3:
	HRRM	TAC,(AC1)			;ODD IN RIGHT HALF
	POPJ	P,

;ASSIGN A BLOCK FOR A NEW GROUP.

ASNGRP:
	PUSHJ	P,ASNBLK			;GET BLOCK FROM SAT
ASNGR1:
	MOVEM	TAC,DNXTGP(DDB)			;PUT INTO LINK
	MOVEI	DAT,SPREAD			;SMEAR EXISTING RTVL OUT...
	SKIPE	DGRP1R(DDB)			;IF THERE IS A CURRENT GROUP.
	PUSHJ	P,QEWAIT
	SETZM	TAC
	EXCH	TAC,DNXTGP(DDB)			;NEW BLOCK...
	HRLZM	TAC,DPTR(DDB)			;IS FIRST OF NEW GRP.
	SETZM	DPTR+1(DDB)			;CLEAR OUT REST OF RTVL.
	HRLI	TAC1,DPTR+1(DDB)
	HRRI	TAC1,DPTR+2(DDB)
	BLT	TAC1,DDEND-1(DDB)
	MOVE	TAC,USETP(DDB)
	MOVEM	TAC,DGRP1R(DDB)
	TLO	IOS,PNTDIF			;NOTE NEW RTVL NOT OUT.
	POPJ	P,

;SPREAD UPDATED RTVL OVER BLOCKS IN CURRENT GROUP.
;NORMALLY WRITES FROM DDB

SPREDT:
	MOVE	AC2,USETP(DDB)			;OUT RTVL UP TO CURR BLOCK.
	SUBI	AC2,RCPBLK
	JRST	SPREDF

SPREAD:
	MOVE	AC2,DGRP1R(DDB)			;OUT RTVL OVER WHOLE GROUP
	ADDI	AC2,RCPGRP-RCPBLK

SPREDF:
	MOVEI	TAC1,DSKDAT(DDB)
SPREDD:
	HRLI	TAC1,-SECSIZ
	SKIPN	TEM,DGRP1R(DDB)
	POPJ	P,				;NO RTVL TO SPREAD.
	MOVEM	TAC1,TFRIOW(DDB)
	MOVEI	TAC1,DWRITE!IOPDCH
	MOVSM	TAC1,TFRCTL(DDB)
SPREDL:
	CAMLE	TEM,AC2
	POPJ	P,				;DONE WITH GROUP
SPREDR:
	MOVE	TAC,TEM		
	PUSHJ	P,LR2BLK
	JUMPE	TAC,SPREDI			;NON EX BLOCK
	PUSHJ	P,BK2SEC
	LDB	AC3,PUNIT
	ADD	TAC,BFSETS(AC3)
	MOVEM	TAC,TFRSEC(DDB)
	PUSHJ	P,TSTART
SPREDI:
	ADDI	TEM,RCPBLK
	JRST	SPREDL


AUDINF:
	MOVSI	TAC1,FILNAM(DDB)
	HRRI	TAC1,DSKDAT(DDB)		;BLT AUDIT INFO INTO RTVL
	BLT	TAC1,DSKDAT+7(DDB)
	LDB	TAC1,PUNIT
	MOVE	TAC1,SATADR(TAC1)
	MOVE	TAC1,SATID(TAC1)
	MOVEM	TAC1,DSATID(DDB)
	POPJ	P,

AUDCHK:
	MOVE	TAC,FILNAM(DDB)
	CAME	TAC,DDNAM(DDB)
	TLO	IOS,LOSBIG
	HLLZ	TAC,FILEXT(DDB)
	HLLZ	TAC1,DDEXT(DDB)
	CAME	TAC,TAC1
	TLO	IOS,LOSBIG
	MOVE	TAC,FILPPN(DDB)
	CAME	TAC,DDPPN(DDB)
AUDHAK:
	TLO	IOS,LOSBIG
	TLNE	IOS,LOSBIG
	MOVEM	DDB,ACDDB			;SAVE LOSER FOR DEBUGGING
	POPJ	P,

;SET UP GGRETI TO READ A NEW FILE, WHOSE RTVL ISN'T IN.

NEWFIL:
	CAME	TAC,DDLOC(DDB)			;IS RIGHT RTVL IN?
NEWFI1:
	SETZM	DGRP1R(DDB)			;NO, FORCE IT TO BE READ
	MOVEM	TAC,DDLOC(DDB)
	MOVEI	TAC1,1
	MOVEM	TAC1,USETP(DDB)
	POPJ	P,

; GET BLOCK CONTAINING USETP INTO SYSBUF. 

GETBLK:
	PUSHJ	P,GGRETI			;GET RTVL IN
	JUMPE	TAC,CPOPJ			;NON EX=EOF
	MOVE	TAC,USETP(DDB)
	SKIPN	TFRIOW(DDB)			;DID GGRETI READ?
	JRST	GETBK1				;NO, GO READ BLOCK
	MOVE	TAC1,DGRP1R(DDB)		;FIRST GROUP OF BLOCK
	CAIGE	TAC,RCPBLK(TAC1)		;IS ONE WE WANT IN IN THIS BLOCK?
	POPJ	P,				;YES, RETURN.
GETBK1:
	PUSHJ	P,LR2BLK
	JUMPE	TAC,CPOPJ			;NON EX = EOF
	PUSHJ	P,BK2SEC
	LDB	AC3,PUNIT
	ADD	TAC,BFSETS(AC3)
	MOVEM	TAC,TFRSEC(DDB)			;READ IT INTO SYSBUF
	MOVE	TAC,BUFIOW
	MOVEM	TAC,TFRIOW(DDB)
	MOVEI	TAC,IOPCHN
	MOVSM	TAC,TFRCTL(DDB)
	PUSHJ	P,TSTART
	POPJ	P,

; GET RTVL FOR GROUP INTO DDB IF NOT ALREADY THERE. 

GGRETI:
	SETZM	TFRIOW(DDB)			;FLAG FOR GETBLK.
	SKIPN	TAC1,DGRP1R(DDB)		;IF NO RTVL IN,
	JRST	GGBLK1				;GET BLOCK 1.
	MOVE	TAC,USETP(DDB)
	CAIL	TAC,RCPGRP(TAC1)		;USETP IN CURRENT GROUP?
	JRST	GGNXT				;BEYOND, TRY SUCCESSOR
	CAIL	TAC,(TAC1)
	POPJ	P,				;IN THIS ONE.

GGBLK1:
	SKIPA	TAC,DDLOC(DDB)			;START AT BEGINNING.
GGNXT:
	MOVE	TAC,DNXTGP(DDB)			;GO ON TO NEXT GROUP
	JUMPE	TAC,CPOPJ			;RETURN IF EOF
	PUSHJ	P,BK2SEC
	LDB	AC3,PUNIT
	ADD	TAC,BFSETS(AC3)
	MOVEM	TAC,TFRSEC(DDB)
	MOVE	TAC,BUFIOW			;READ ENTIRE BLOCK...
	MOVEM	TAC,TFRIOW(DDB)
	MOVEI	TAC,IOPCHN
	MOVSM	TAC,TFRCTL(DDB)
	PUSHJ	P,TSTART			;IN CASE SOMEONE WANTS IT.
	HRLI	TAC,SYSBUF			;GOT CORRECT GRP. BLT RTVL
	HRRI	TAC,DSKDAT(DDB)			;AND AUDIT TO DDB.
	BLT	TAC,DSKDAT+SECSIZ-1(DDB)
	MOVE	TAC,USETP(DDB)
	MOVE	TAC1,DGRP1R+SYSRTV
	CAIL	TAC,RCPGRP(TAC1)		;IN THIS GROUP?
	JRST	GGNXT
	POPJ	P,

;LOGICAL RECORD TO BLOCK. CORRECT GROUP IS ASSUMED.

LR2BLK:
	SUB	TAC,DGRP1R(DDB)
	CAIL	TAC,0
	CAIL	TAC,RCPGRP
	MOVEI	TAC,1				;WRONG GROUP.DEFAULT SELECT REC1.
	IDIVI	TAC,RCPBLK
	MOVEI	AC3,1(TAC1)		;PHYSICAL RECORD WITHIN BLOCK (INCL RTRVL)
	LSHC	TAC,-1
	ADDI	TAC,DPTR(DDB)
	MOVE	TAC,(TAC)
	SKIPL	TAC1
	HLRS	TAC
	HRRZS	TAC
	POPJ	P,


;CONVERT BLOCK NO. TO DISK ADDRESS OF FIRST RECORD OF BLOCK
BK2SEC:
	SETZ	AC3,
;MAPPING BLOCK NO. AND RECORD NO. TO DISK ADDRESS
BKMAP:
	LSH	TAC,6				;TO STOP LATER.
	ANDI	AC3,77				;IGNORE IMPOSSIBLE RECORD NOS.
	IOR	TAC,AC3
	POPJ	P,

; SAT TABLE OPERATIONS

CUSATO:
	LDB	TAC,PUNIT
	SKIPE	SATMOD(TAC)		;SAT OUT FROM UUO LEVEL, IF CHANGED.
	SKIPG	TAC1,SATADR(TAC)		;ADDRESS OF SAT TABLE
	POPJ	P,			;NO CHANGE, RETURN
	MOVE	DAT,TIME		;GET CURRENT TIME
	MOVEM	DAT,DTIME(TAC1)		;SAVE IN SAT TABLE
	MOVE	DAT,THSDAT
	MOVEM	DAT,DDATE(TAC1)		;AND CURRENT DATE
	MOVEI	DAT,SATOUT
	JUMPE	TAC,NENTER		;IF MAIN DISK, QUEUE THIS AND POPJ
	HRLI	TAC1,-USATSZ
	MOVEM	TAC1,TFRIOW(DDB)	;SET THIS FOR USATOUT
	MOVEI	DAT,USATOUT
	PUSHJ	P,NENTER
	TRNN	IOS,IODERR!IOIMPM
	POPJ	P,
SATGLZ:
	PUSHJ	P,ERZIOS			;UN-INITIALIZED UDP.
	JSP	TAC,ERRPTU
	ASCIZ	/UDP OFFLINE OR WRITE LOCKED/
	JRST	EXCALP

;*** I-SUBR
SATOUT:
	SKIPA	TAC,[DWRITE!IOPCHN]	;WRITE SAT
SATIN:
	MOVEI	TAC,IOPCHN		;READ SAT
	TLO	IOS,SATOP
	MOVSM	TAC,TFRCTL(DDB)
	MOVE	TAC,[XWD -SATSIZ,SATTAB]
	MOVEM	TAC,TFRIOW(DDB)		;IOWD FOR THIS TRANSFER
	SETZM	TFRSEC(DDB)
	PUSHJ	P,TSTART
	SETZM	SATMOD
	TLZ	IOS,SATOP
	POPJ	P,

ASNBLK:
	PUSHJ	P,IASNBK		;ASSIGN SUITABLE BLOCK
	PUSH	P,TAC
	MOVEM	TAC,TFRSEC(DDB)		;SAVE HERE FOR I SUBR
	MOVEI	DAT,RB4WCK		;READ BEFORE WRITE CHECKER
	PUSHJ	P,QEWAIT
	POP	P,TAC
	SKIPN	TFRIOW(DDB)		;SUCCESS?
	JRST	ASNBLK			;NO, ASSIGN ANOTHER BLOCK
	POPJ	P,

; READ BEFORE WRITE CHECKER ** I SUBR
RB4WCK:
	SKIPN	TAC,TFRSEC(DDB)		;GET LOGICAL DISK ADDRESS
	JRST	RB4WLS			;LOSE IF ADDRESS IS 0
	PUSHJ	P,BK2SEC		;CONVERT TO PHYSICAL ADDRESS
	LDB	AC3,PUNIT
	ADD	TAC,BFSETS(AC3)
	MOVEM	TAC,TFRSEC(DDB)		;AND PUT IT BACK
	MOVE	TAC,[XWD -SECSIZ,QBUF]
	MOVEM	TAC,TFRIOW(DDB)
	MOVEI	TAC,IOPCHN
	MOVSM	TAC,TFRCTL(DDB)		;READ OP
	PUSHJ	P,TSTART
	MOVE	IOS,DEVIOS(DDB)
	TRNE	IOS,IODERR!IODTER	;LOSE ON READ?
	JRST	RB4WER			;YES, USE ANOTHER
	SKIPE	QBUF+DDNAM-DSKDAT	;NULL FILE NAME?
	SKIPN	QBUF+DDPPN-DSKDAT	;OR PPN?
	POPJ	P,			;YES, OK TO WRITE HERE
	LDB	TAC,PUNIT
	MOVE	TAC,SATADR(TAC)
	MOVE	TAC,SATID(TAC)		;GET SATID FROM CORE
	CAME	TAC,QBUF+DSATID-DSKDAT	;SAME AS ON DISK?
	POPJ	P,			;NO. INVALID SATID MEANS WE CAN WRITE HERE
RB4WLS:
	AOS	DSKOVC			;COUNT OVERWRITE CHECK
RB4WER:
	SETZM	TFRIOW(DDB)		;FLAG ILLEGAL BLOCK
	POPJ	P,


;MANIPULATE THE UDP SAT TABLE

SATGT0:
	MOVEI	DAT,CPOPJ			;WAIT IN DISK QUEUE AND DO NOTHING!
	PUSHJ	P,NEWAIT
SATGET:
	LDB	TAC1,PUNIT
	SKIPLE	AC3,SATADR(TAC1)		;IS THE SAT IN FOR THIS DEVICE?
	POPJ	P,				;YES.
	JUMPL	AC3,SATGT0			;JUMP IF SOMEONE ELSE BRINGING IT IN
	SETOM	SATADR(TAC1)			;FLAG WE SHALL BRING IT IN.
	MOVEI	AC3,USATSZ			;SIZE OF SAT TABLE
	PUSHJ	P,UFSGET			;GET FS. WAIT IF NEEDED
	HRLI	AC1,-USATSZ			;FORM WCMA
	MOVEM	AC1,TFRIOW(DDB)			;SET IT IN THE DDB
	MOVEI	DAT,USATIN
	PUSHJ	P,NEWAIT			;CAUSE SAT TO BE READ AND WAIT FOR IT.
	TRNE	IOS,IOIMPM!IODERR		;ERROR?
	JRST	SATGL1				;YES.  GIVE BACK FREE STG
	LDB	TAC,PUNIT
	MOVE	TAC1,SATADR(TAC)
	MOVE	AC1,IDSAT(TAC1)
	CAMN	AC1,['SATID ']
	JRST	ACISTT				;FORM DSKUSE, BADCHK, ETC,
	PUSHJ	P,ERZIOS			;UN-INITIALIZED UDP.
	JSP	TAC,ERRPTU
	ASCIZ	/NOT A NEW FORMAT UDP/
	JRST	EXCALP

;LOST TRYING TO READ IN SATTAB.  PROBABLY NO PACK MOUNTED
;GIVE BACK FREE STORAGE AND GIVE OFFLINE COMPLAINT
SATGL1:
	HRRZ AC1,TFRIOW(DDB)			;ADDRESS OF WOULD BE SATTAB
	PUSHJ P,FSGIVE				;RETURN THE BLOCK
	JRST SATGLZ

;*** I-LEVEL SUBR
;TFRIOW SETUP BY CALLER!
USATOUT:
SKIPA	TAC,[DWRITE!IOPCHN]
USATIN:
	MOVEI	TAC,IOPCHN
	MOVSM	TAC,TFRCTL(DDB)			;SET READ/WRITE MODE
	TLO	IOS,SATOP
	LDB	TAC,PUNIT
	MOVE	TAC,BFSET(TAC)			;DISK ADDRESS OF SAT TABLE
	PUSHJ	P,BK2SEC			;CONVERT BLOCK TO SECTOR
	MOVEM	TAC,TFRSEC(DDB)
	PUSHJ	P,TSTART
	TLZ	IOS,SATOP
	LDB	TAC,PUNIT
	SETZM	SATMOD(TAC)
	TRNE	IOS,IODERR!IODTER!IOIMPM
	TDZA	TAC1,TAC1			;SATTAB DIDN'T MAKE IT IN
	HRRZ	TAC1,TFRIOW(DDB)
	MOVEM	TAC1,SATADR(TAC)		;SET SATADR - RACE FREE!
	POPJ	P,

;IASNBK
;THIS CODE BLOWS HORNY TOADS, SOMEONE OUGHT TO FIX IT. - REG

ASNST1:
	CONO	PI,IOPON		;TURN IOP BACK ON
	PUSHJ	P,EDFULL		;"DISK IS FULL" MESSAGE
					;LET HIM TRY AGAIN, IF HE SAYS CONTINUE
IASNBK:
	LDB	AC3,PUNIT
	MOVE	AC3,SATADR(AC3)		;ADDRESS OF SAT TABLE FOR THIS DEV
	MOVE	AC2,LSTBLK(AC3)		;LAST PLACE WE ASSIGNED BLOCK
	AOJA	AC2,ASNSL2		;START BEYOND THAT
ASNSL1:
	CONO	PI,IOPON		;LET THE IOP IN FOR A QUICK LOOK.
ASNSL2:
	CONO	PI,IOPOFF
	LDB	TAC,PUNIT
	CAML	AC2,LSTBTB(TAC)		;OFF THE END YET?
	MOVEI	AC2,1			;YES. START OVER.
	CAMN	AC2,LSTBLK(AC3)		;WRAP TO WHERE WE STARTED?
	JRST	ASNST1			;YES. ICK. THERE'S NO DISK LEFT
	MOVE	TAC,AC2			;CONVERT BLOCK NUMBER TO BIT AND WORD #
	IDIVI	TAC,44			;WORD NUMBER IN TAC, BIT NUMBER IN TAC1
	MOVEI	AC1,1			;MAKE A BIT MASK
	ROT	AC1,(TAC1)
	ADDI	TAC,(AC3)
	TDNE	AC1,SATBIT(TAC)		;THIS BLOCK IN USE?
	AOJA	AC2,ASNSL1		;YES, KEEP LOOKING
	IORM	AC1,SATBIT(TAC)		;MARK IN USE
	LDB	TAC,PUNIT
	SETOM	SATMOD(TAC)		;FLAG SAT TABLE IS BEING CHANGED
	XORM	AC1,SATCHK(AC3)		;UPDATE CHECKSUM.
	CONO	PI,IOPON		;LET THEM BACK IN
	MOVEM	AC2,LSTBLK(AC3)		;REMEMBER THE LAST BLOCK THAT WAS USED
	AOS	TAC,AC2			;RETURN EXCESS 1 IN TAC.  (AVOID 0)
	AOS	DSKUSE(AC3)		;COUNT ANOTHER BLOCK IN USE
	SKIPG	AC1,BADCNT(AC3)
	POPJ	P,
	CAILE	AC1,BADMAX
	MOVEI	AC1,BADMAX
	HRLOI	AC1,-1(AC1)
	EQVI	AC1,(AC3)		;-BADCNT,,ADDRESS OF SAT TABLE
	CAMN	TAC,BADTRK(AC1)		;SKIP UNLESS THIS BLOCK IS BAD
	JRST	IASNBK			;ASSIGN SOME OTHER BLOCK.
	AOBJN	AC1,.-2
	POPJ	P,


RTNBLK:
	LDB	AC1,PUNIT
	CAMG	TAC,LSTBTB(AC1)		;SKIP IF INVALID BLOCK.
	SOJGE	TAC,.+2			;REMOVE EXCESS 1 AND JUMP IF VALID
	POPJ	P,			;INVALID BLOCK
	IDIVI	TAC,44
	ADD	TAC,SATADR(AC1)
	MOVEI	AC1,1
	ROT	AC1,(TAC1)
	TDNN	AC1,SATBIT(TAC)
	POPJ	P,			;ALREADY OFF!
	ANDCAM	AC1,SATBIT(TAC)
	LDB	TAC,PUNIT
	SETOM	SATMOD(TAC)		;FLAG SAT TABLE NEEDS OUTPUT
	MOVE	TAC,SATADR(TAC)
	XORM	AC1,SATCHK(TAC)	;UPDATE CHECKSUM.
	SOS	DSKUSE(TAC)		;DECREASE COUNT
	POPJ	P,

↓MRKBLK:LDB	AC1,PUNIT
	CAMG	TAC,LSTBTB(AC1)		;SKIP IF INVALID BLOCK.
	SOJGE	TAC,.+2			;REMOVE EXCESS 1 AND JUMP IF VALID
	POPJ	P,			;INVALID BLOCK
	IDIVI	TAC,44
	ADD	TAC,SATADR(AC1)
	MOVEI	AC1,1
	ROT	AC1,(TAC1)
	TDNE	AC1,SATBIT(TAC)
	POPJ	P,			;ALREADY OFF!
	IORM	AC1,SATBIT(TAC)
	LDB	TAC,PUNIT
	SETOM	SATMOD(TAC)		;FLAG SAT TABLE NEEDS OUTPUT
	MOVE	TAC,SATADR(TAC)
	XORM	AC1,SATCHK(TAC)	;UPDATE CHECKSUM.
	AOS	DSKUSE(TAC)		;DECREASE COUNT
	POPJ	P,

CSATID:
	LDB	TAC,PUNIT
	JUMPN	TAC,CPOPJ		;DON'T BOTHER CHECKING SATID FOR UDPS
	MOVE	TAC,SATID+SATTAB
	CAMN	TAC,SATID1
	CAME	TAC,SATID2
	CAIA
	POPJ	P,
	PUSHACS
	PUSHJ	P,DISDAT
	PUSHJ	P,DISERR
	[ASCIZ/BACKUP SATID'S DISAGREE.
SATID = /]
	DISARG	OCT,SATID+SATTAB
	[ASCIZ/
SATID1 = /]
	DISARG OCT,SATID1
	[ASCIZ/
SATID2 = /]
	DISARG OCT,SATID2
	[ASCIZ/
DON'T DO ANYTHING 'TILL YOU GET A WIZARD!
/]
	-1
	SETOM	DISFLAG
	PUSHJ	P,DISFLUSH
	POPACS
	PUSHJ	P,DDTCAL
	JRST	CSATID

;CALLED FROM ERROR2 IN DSKERR INSIDE PUSHACS
MRKBAD:
	SKIPGE	TAC,DSKLRN		;LOGICAL NO. OF THIS TRACK
;	CAILE	TAC,LSTBIT		;DON'T BAD TRACK UDP!!(NOT ANYMORE)
	POPJ	P,			;IF SAT OR SWAP IGNORE.
;GUARANTEED FILE SYSTEM OP IF DSKLRN < 0 (I THINK THEY MEAN > --BH)
	MOVE DDB,DSKACS+DDB
	LDB AC1,PUNIT
	SKIPN AC1,SATADR(AC1)		;DOUBLE CHECK THAT THERE'S A SAT
	POPJ P,				;ELSE RESTORE ACS
	SKIPN	TAC1,BADCNT(AC1)	;GET NUMBER OF ENTRIES IN TABLE
	JRST	MRKBD1			;NONE YET
	CAILE	TAC1,BADMAX		;ONLY CHECK EXISTING TABLE
	MOVEI	TAC1,BADMAX
MRKBD0:
	MOVEI AC2,(AC1)
	ADDI AC2,(TAC1)
	CAMN	TAC,BADTRK-1(AC2)	;IS THIS BAND ALREADY IN TBL ?
	POPJ P,				;YES. DON'T ENTER IT AGAIN.
	SOJG	TAC1,MRKBD0
MRKBD1:
	AOS	TAC1,BADCNT(AC1)	;INC. NO. OF BAD TRACKS IN TABLE.
	CAIGE	TAC1,BADMAX		;TOO MANY FOR ONE UNIVERSE ?
	JRST	MRKBD2			;NO, GO ON
	PUSHJ	P,DISMES
	ASCIZ	/TOO MANY BAD DISK TRACKS.  GET A WIZARD, OR PUSH CONTINUE
/
	SETOM	DISFLAG
	PUSHJ	P,DISFLUSH
	HALT	CPOPJ

MRKBD2:
	ADDI TAC1,(AC1)
	MOVEM	TAC,BADTRK-1(TAC1)	;ADD CURRENT TRACK TO BAD TRACK TABLE.
	ADDM	TAC,BADCHK(AC1)		;UPDATE THE CHECKSUM.
	PUSH P,BADCNT(AC1)		;(MRKBLK CLOBBERS AC1)
	PUSHJ	P,MRKBLK		;MARK TRACK IN SAT TABLE, SO IT WON'T GET USED
	PUSHJ	P,DISMES
	ASCIZ	/NEW BAD DISK TRACK.  BADCNT=/
	POP P,TAC
	PUSHJ	P,DISDCP
	PUSHJ	P,DISMES
	ASCIZ	/	BADMAX=/
	MOVEI	TAC,BADMAX
	PUSHJ	P,DISDCP
	JRST DISCRLF

;DELETE A FILE, FREE DISK BLOCKS

DELETE:
	PUSHJ	P,NEWFIL		;SET UP RTVL FETCH
	MOVEI	DAT,DELFIL
	MOVE	AC1,FILLNG(DDB)
	CAILE	AC1,=50*2000
	JRST	NEWAIT			;MARK ALL BLOCKS EMPTY, CLEAR RTVL
	JRST	QEWAIT

;*** INTERRUPT SUBR ***

DELFIL:
	PUSHJ	P,DELBLK
	TRZE	IOS,IODTER		;WAS THERE AN ERROR ?
	JRST	DSIOS
	MOVE	TAC,USETP(DDB)
DELF2:
	PUSHJ	P,LR2BLK		;RETURN BLOCKS TO SAT
	JUMPE	TAC,.+2			;NO SUCH BLOCK
	PUSHJ	P,RTNBLK
	MOVEI	TAC,RCPBLK
	ADDB	TAC,USETP(DDB)
	MOVE	TAC1,DGRP1R(DDB)
	CAIGE	TAC,RCPGRP(TAC1)	;HAVE WE GOT TO NXT GRP?
	JRST	DELF2			;STILL IN THIS ONE, CONTINUE
DELF3:
	SKIPE	DNXTGP(DDB)		;IS THERE A NEXT GROUP?
	JRST	DELFIL			;YES, DO IT
	POPJ	P,

DELBLK:
	PUSHJ	P,GGRETI		;GET INTO CORE
	PUSHJ	P,AUDCHK
	TLZE	IOS,LOSBIG
	JRST	DELBK1
	LDB	AC2,PJOBN		;GET JOB # OF LOSER DELETING FILE
	MOVE	AC1,JOBNAM(AC2)		;NOW REMEMBER SOMETHING ABOUT HIM
	MOVEM	AC1,DQINFO+2(DDB)
	MOVE	AC1,PRJPRG(AC2)
	MOVEM	AC1,DQINFO+3(DDB)
	SETZM	DSATID(DDB)		;JUST CLEAR SATID TO FREE THIS BLOCK
	JRST	SPREAD			;AND POOT IT BACK OUT

DELBK1:
	TRO	IOS,IODTER
	JRST	DSIOS

; SWAPPER INTERFACE

;	EXTERNAL SERACT,JOBDAC,MJOBCK,FINISH,JBTCHK,SERA
;	INTERNAL DFWRT,DFRED

;ENTER HERE FROM SWAPPER TO START SWAP (DISK IDLE.)
;TAC=DISK ADDR=SERA; TAC1=IOWD=SQREQ.

↑DFWRT:
↑DFRED:	CONO	PI,IOPOFF		;JUST FOR SAFETY.
	PUSHJ	P,DSSTRT
	MOVSI	17,UUOACS		;RETURN HERE AFTER STARTING XFER
	BLT	17,17			;RELOAD CH7 AC'S (ESP. P)
	CONO	PI,IOPON		;SAFE NOW
	POPJ	P,			;GO TO SWPXIT

DSSTRT:
	POP	P,INTRTN
	JSR	DSKSV			;SET UP CH6 PDL.
	PUSHJ	P,SQGOX1		;RETURNS HERE WHEN XFER DONE
	JRST	DNSTR1			;GO DO NEXT I-SUBR.

;ENTER HERE FROM DISK QUEUE SERVICE AFTER FINISHING I-SUBR.

SQGOA:
	MOVEI	TAC1,TRIES
	MOVEM	TAC1,SERACT
	MOVSI	TAC,200000		;PUT IN A BIT...
	ORB	TAC,SERA		;TO INDICATE SWAP OP.
	MOVE	TAC1,SQREQ
	MOVM	J,FINISH
	HRRO	J,J			;NEG TO INDICATE SWAPPER
	PUSHJ	P,SQGOX			;DO SWAP OP.
	JRST	DNSTR1			;GO DO NEXT I-SUBR.

;SET UP SWAP OPERATION AND EXECUTE IT.
;ENTER WITH TAC=DISK ADDR=SERA; +1B0 IF INCOMING.
;TAC1=IOWD=SQREQ.

SQGOX1:
	ADDI	TAC1,1			;CONVERT IOWD TO 167 FORMAT
SQGOX:
	MOVE	DDB,SWPDDB		;GET THE RIGHT DDB
	MOVEM	TAC1,TFRIOW(DDB)
	MOVEI	DAT,IOPCHN
	SKIPL	SERA
	TRO	DAT,DWRITE
	MOVSM	DAT,TFRCTL(DDB)
	PUSHJ	P,SBK2SC		;SPECIAL BLOCK TO SECTOR
	MOVEM	TAC,TFRSEC(DDB)
SQGO2:
	SETZB	IOS,DEVIOS(DDB)		;MAKE SURE THERE ARE NO ERROR BITS ON!
	PUSHJ	P,SETACT
	PUSHJ	P,TGO			;ZORCH
	MOVEI	IOS,IOACT
	ANDCAB	IOS,DEVIOS(DDB)
	TRNE	IOS,IOIMPM		;IMMEDIATE ERROR?
	JRST	SWPLUZ
	TRNE	IOS,IODERR!IODTER
	JRST	SWPERR
	JRST	SNOERR			;NO ERRORS

SWPLUZ:
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/SWAPPING PACK OFF LINE OR IN WRITE LOCK!
PLEASE FIX IT AND CONTINUE.
/
	SETOM	DISFLAG
	PUSHJ	P,DISFLUSH
	POPACS
	HALT	SQGO2

SWPERR:
	SOSLE	SERACT			;COUNT DOWN
	JRST	SQGO2			;TRY AGAIN
	TRO	IOS,IODERR		;TRIED ENOUGH, DIE

SNOERR:
	MOVE	TAC,IOS
	ANDI	TAC,IODERR!IODTER	;GET ERROR BITS, IF ANY.
	MOVEM	TAC,SERA		;GIVE TO SWAPPER.
	SETZM	SQREQ
	SETZM	SWPCNT			;WAKE UP SWAPPER.
	POPJ	P,

;MORE MISC: CONVERT SWPSER BLOCK ADDRESS TO DISC ADDRESS.
;COURTESY J. SAUTER

SBK2SC:
	HRRZ	TAC,TAC
	IDIVI	TAC,1140		;↑D1216/2
	LSH	TAC,14			;MAKE BAND NO.
	TLO	TAC,400000		;INDICATE SWAP OP
	POPJ	P,

;ENTER HERE FOR HIGH PRIORITY TRANSFER (CURRENTLY ONLY UDP IO).
UEWAIT:
	TDZE	IOS,[XWD DEVSBB,IOACT]
	PUSHJ	P,WSYNC
	MOVSI	AC1,DEVIBF
	ANDCAM	AC1,DEVCMR(DDB)
	PUSHJ	P,SETACT
	PUSHJ	P,QUE1			;MERGE WITH Q-ENTER CODE
	JRST	WSYNC			;AND WAIT FOR FINISH

;ENTER I-SUBR CALL IN QUEUE FROM UUO LEVEL.

QEWAIT:
	PUSH	P,PWSYNC		;QUEUE REQUEST. RETURN TO WSYNC TO WAIT
QENTER:
	TDZE	IOS,[XWD DEVSBB,IOACT]
	PUSHJ	P,WSYNC			;JUST IN CASE SOMEBODY GOOFED.
	MOVSI	AC1,DEVIBF
	ANDCAM	AC1,DEVCMR(DDB)
	PUSHJ	P,SETACT		;STORES IOS
QE1:
	TDZA	AC1,AC1			;SELECT NORMAL DISK QUEUE
QUE1:
	MOVEI	AC1,1			;SELECT UDP QUEUE
	SKIPE	@MIPTR(AC1)
	JRST	.-1			;CRASH IF QUEUE FULL
	CONO	PI,IOPOFF		;INTS OFF UNTIL IACTIV:
	HRLM	DDB,@MIPTR(AC1)		;DDB ADDR...
	HRRM	DAT,@MIPTR(AC1)		;AND SUBROUTINE ADDR.
	AOS	DAT,MIPTR(AC1)		;BUMP QUEUE POINTER
	AOS	DQCNT			;ANOTHER LOSER INTO QUEUE
	CAML	DAT,MQEND(AC1)
	MOVE	DAT,MQBEG(AC1)
	MOVEM	DAT,MIPTR(AC1)
	MOVNI	DAT,1
	EXCH	DAT,DFBUSY
	JUMPN	DAT,IACTIV		;RETURN IF INT PGM RUNNING.
	PUSHJ	P,DIGO			;SAVE UUO AC'S, START I-LEVEL
INSRTN:
	MOVSI	17,UUOACS		;RELOAD UUO AC'S FROM INT. SAVE.
	BLT	17,17			;CH6 INTS INHIBITED UNTIL THIS DONE.
IACTIV:
	CONO	PI,IOPON
PWSYNC:
	POPJ	P,WSYNC			;RETURN TO UUO CALLER.


NEWAIT:
	PUSH	P,PWSYNC		;RETURN FROM NENTER TO WSYNC
NENTER:
	TDZE	IOS,[XWD DEVSBB,IOACT]
	PUSHJ	P,WSYNC
	MOVSI	AC1,DEVIBF
	ORM	AC1,DEVCMR(DDB)
	TLO	IOS,DEVSBB
	MOVEM	IOS,DEVIOS(DDB)
	JRST	QE1

					;RETURN HERE FROM TSTART WITH I-AC'S SAVED.
DIGO:
	POP	P,INTRTN		;ARRANGE I-LEVEL DISMISS
	JSR	DSKSV			;SAVE UUO AC'S IN CH6 AREA.  MUST NOT HAVE
					;CH6 INTERRUPT UNTIL THESE ARE RESTORED.
					;SET UP I-LEVEL PDL (OTHER AC'S NOT NEEDED)
	JRST	DNSTRT			;GO CALL SUBR

;I-LEVEL SUBRS RETURN HERE WHEN DONE TO START ANOTHER REQUEST.


DNXTRQ:
	MOVE	AC1,QALT
	SETZM	@MOPTR+1(AC1)		;WIPE OUT RQ JUST FINISHED
	AOS	TAC,MOPTR+1(AC1)	;ADVANCE POINTER
	SOS	DQCNT			;ONE LESS LOSER IN QUEUE
	CAML	TAC,MQEND+1(AC1)
	MOVE	TAC,MQBEG+1(AC1)
	MOVEM	TAC,MOPTR+1(AC1)

DNSTRT:
	SKIPE	SQREQ			;IF SWAPPER WANTS SOMETHING,
	JRST	SQGOA			;GO SEE ABOUT IT.
DNSTR1:
	SETCMB	AC1,QALT		;SELECT A QUEUE
	SKIPN	TAC,@MOPTR+1(AC1)	;GET NEXT REQUEST.
	JRST	DFSTOP			;NONE PENDING, FLAG IDLE
	PUSHJ	P,DSETUP		;COMMON SETUP AND DISPATCH
ISRTN:
	JRST	DNXTRQ

DFSTOP:
	SETCA	AC1,AC1
	SKIPE	@MOPTR+1(AC1)
	JRST	DNSTRT			;OTHER QUEUE HAS SOMETHING.  DO IT
	SETZM	DFBUSY
	JRST	@INTRTN			;RESTORE USER AC'S, DISMISS

DSETUP:
	HLRZ	DDB,TAC
	SETZB	PROG,BKIN		;FLAG SYSBUF EMPTY
	MOVE	IOS,DEVIOS(DDB)
	LDB	J,PJOBN
	MOVSI	AC1,DEVIBF
	TDNE	AC1,DEVCMR(DDB)
	JRST	DNSTR2
	TLZE	IOS,DEVSBB
	PUSHJ	P,MESS2
	SKIPE	J
	SKIPE	PROG,JBTADR(J)
	TRON	IOS,IOACT
	PUSHJ	P,MESS3
	JRST	DNSTR3

DNSTR2:
	TRZE	IOS,IOACT
	PUSHJ	P,MESS4
	TLON	IOS,DEVSBB
	PUSHJ	P,MESS5
DNSTR3:
	PUSHJ	P,(TAC)			;CALL SUBR
DRQDN:
	MOVSI	AC1,DEVIBF
	ANDCAM	AC1,DEVCMR(DDB)
	TDZN	IOS,[XWD DEVSBB,IOACT]	;MOST SUBRS POPJ, THEN
	PUSHJ	P,MESS1			;IOACT OFF AT....
	TLZE	IOS,IOW			;DO THIS RITUAL TO...
	PUSHJ	P,SETIOD		;GET OUT OF IO WAIT
	JRST	DSIOS			;STORE IOS!

MESS1:
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ/IOACT OFF AT DRQDN.
/
	POPACS
	JRST	DSIOS

MESS2:
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ/DEVIBF OFF BUT DEVSBB ON AT DNSTRT.
/
	POPACS
	JRST	DSIOS

MESS3:
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ/IOACT OFF AT DNSTRT.
/
	POPACS
	JRST	DSIOS

MESS4:
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ/DEVIBF AND IOACT ON AT DNSTRT.
/
	POPACS
	JRST	DSIOS

MESS5:
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ/DEVIBF ON BUT DEVSSB OFF.
/
	POPACS
	JRST	DSIOS

;I-LEVEL SUBRS PUSHJ HERE TO START A TRANSFER.

TSTART:
	MOVEI	TAC,TRIES
	HRRM	TAC,TFRCTL(DDB)
TREDO:
	PUSHJ	P,TGO
TFSRTN:
	TRNN	IOS,IODERR!IODTER	;ANY ERRORS?
	POPJ	P,			;NO, OK RETURN.
	SOS	TAC,TFRCTL(DDB)		;COUNT DOWN
	TRNE	TAC,-1			;TRIED ENOUGH?
	JRST	TREDO			;NO, TRY AGAIN.
	TLO	IOS,LOSBIG		;INFORM THE HIGHER-UPS.
	POPJ	P,			;RETURN LOSSAGE.

TGO:
	MOVEM	DDB,DXB
	MOVEM	J,DXJ
	MOVEM	P,DXP
	TRZ	IOS,IODERR!IODTER	;WE HAVEN'T LOST YET.
	MOVE	TAC,TFRSEC(DDB)
	MOVEM	TAC,DXS
	MOVE	TAC,TFRIOW(DDB)
	MOVEM	TAC,DXW
	HLRZ	TAC,TFRCTL(DDB)
	MOVEM	TAC,DXC
	JRST	GO2314

;	ERROR HANDLING

;ERRORS, CLASS 1. ENTER, ETC. RETURN CODES IN E+1

ENOUFD:
	POP	P,TAC			;ADJUST STACK
	POP	P,TAC
	JRST	ENOUF1

ENOFIL:
	JSP	TAC,ERRC1		;0 - ZERO FILE NAME
ENOUF1:
	JSP	TAC,ERRC1		;1 - NO UFD
EPROT:
	JSP	TAC,ERRC1		;2 - PROTECT VIOLATION
EFWRIT:
	JSP	TAC,ERRC1		;3 - FILE BEING WRITTEN
EDNAME:
	JSP	TAC,ERRC1		;4 - NAME IN USE
EXFIL:
	JSP	TAC,ERRC1		;5 - NO LOOKUP OR ENTER - RENAME
EANAME:
	JSP	TAC,ERRC1		;6 - ENTER (ALTER) NAME DISAGREES
ENODEV:
	JSP	TAC,ERRC1		;7 - NO DEVICE (NO INIT)
EGARB1:
	JSP	TAC,ERRC2		;10 - GARBAGED UFD (POINTER OUT OF RANGE)
					; - AND OLD UDPS ACCESSED BY NEW UDPSER
EGARB2:
 JSP	TAC,ERRC2		;11 - GARBAGED FILE (POINTER WRONG)
EFULLZ:
	JSP	TAC,ERRC1		;12 - DISK IS FULL, TRY AGAIN LATER

ERRC2:
	TRNN	IOS,GARBIT		;SUPPRESS "BAD RTVL" MESSAGE??
	JRST	EGARB			;NO. NOT A SPECIAL PERSON.
	PUSHJ	P,ERZIOS		;HOLD ALL FURTHER I/O.
ERRC1:
	SUBI	TAC,ENOFIL+1		;GET ERROR CODE
	XCTR	XRW,[HRRM TAC,ERRBOX(UUO)]	;STUFF ERROR CODE
	ANDI	TAC,-1
	CAIE	TAC,11			;ALLOW RENAME OF FILE WITH BAD RETRIEVAL
	SETZM	FILNAM(DDB)		;DISABLE RENAME.
	JRST	ERZIOS			;DISABLE I/O. DOES NOT RETURN.

;ERRORS, CLASS 2. FLUSH USER, GO TO SYSTEM.

ENTFUL:
	PUSHJ	P,EFULLZ		;GIVE FUNNY ERROR CODE
	TRNE	IOS,GARBIT		;IS HE ENABLED FOR DIRECT RETURN?
	POPJ	P,			;YES. DO IT
EDFULL:
	PUSH	P,IOS			;SAVE THE RELEVANT ACS
	PUSHJ	P,DPOPJ			;CLEAR GOBIT IF SET AND SAVE ITS STATE
	PUSH	P,DDB
	PUSHJ	P,TTYFUW		;FIND TTY
	PUSHJ	P,INLMES
ASCIZ /
DISK IS FULL!/
	PUSHJ	P,PRCRCC		;TYPE CRLF ↑C
	PUSHJ	P,TTYSTC		;SET TTY INTO COMMAND MODE.
	PUSHJ	P,STOP1			;STOP THE JOB
	POP	P,DDB
	POP	P,IOS			; RESTORE THE ACCUMULATORS
	POPJ	P,			; AND RETURN TO SENDER.

ENOENT:
	JSP	TAC,ERRPTU
	ASCIZ	/NEED ENTER BEFORE OUTPUT/
	JRST	EXCALP

ENOLUK:
	JSP	TAC,ERRPTU
	ASCIZ	/NEED LOOKUP BEFORE INPUT/
	JRST	EXCALP

ELOSE:
	JSP	TAC,ERRPTU
	ASCIZ	/ERROR IN DSKSER/
	JRST	EXCALP

EGARJ2:
	POP	P,TAC
EGARPJ:
	POP	P,TAC			;FIX UP STACK
EGARB:
	PUSHJ	P,ERZIOS		;HOLD ALL I/O.
	TRNE	IOS,IODTER!IODERR	;MACHINE OR DATA ERRORS?
	JRST	EGARC			;2314 SCREW-UP
	JSP	TAC,ERRPTU
	ASCIZ	/BAD RETRIEVAL/
	JRST	EXCALP

EGARC:
	JSP	TAC,ERRPTU
	ASCIZ	/DISK TRANSMISSION ERROR/
	JRST	EXCALP

EACMFD:
	JSP	TAC,ERRPTU
	ASCIZ	/CAN'T ENTER-RENAME MFD/
	JRST	EXCALP

EDMPLS:
	JSP	TAC,ERRPTU
	ASCIZ	/ILLEGAL FORMAT DUMP MODE COMMAND LIST/
	JRST	EXCALP

ERZIOS:
	TLZ	IOS,GOBIT!LOSBIG!READB!WRITEB!ALTERB
	JRST	DPOPJ			;TUCK IOS AWAY. DON'T LET USER DO ANYTHING.

; USER DISK PACK SERVICE

;SYSTEM INITIALIZATION:
; CLEAR DEVIOS FOR EACH UDP
; SET DVDSK IN DEVMOD - DEFAULT NEW STYLE
; LINK MODEL DDBS TOGETHER, LINKING OUT COPIED DDBS THAT WERE IN FREE STG

UDPINI:
	MOVSI	TAC1,DVDSK
	MOVEI	TAC,DSKDSP
FOR @$ UNUM←1,UPACKS
<	SETZM	UDP$UNUM$DD+DEVIOS
	IORM	TAC1,UDP$UNUM$DD+DEVMOD		;INITIALLY DVDSK IN UDP DDBS
IFN UNUM-1,<
	HRLI	TAC,UDP$UNUM$DD
	MOVEM	TAC,DEVSER+CAT(CAT(UDP,\<UNUM-1>),DD)
>>
	HRLI	TAC,PTRDDB
	MOVEM TAC,DEVSER+UDP1DD;;replaced;;MOVEM TAC,DEVSER+CAT(CAT(UDP,\UPACKS),DD)
	POPJ	P,


	JRST	CLRDDB		;GIVE BACK DDB
	JRST	SETDDB		;MAKE DDB
	JRST	UDPINI		;INITIALIZE
	JRST	DHUNG		;HUNG TIMEOUT
↑UDPDSP:JRST	ERZIOS		;RELEASE, DISABLE WRITE
	JRST	ERZIOS		;CLOSE OUTPUT, SAME
	JRST	UUOERR		;BUFFERED OUTPUT
	JRST	UUOERR		;BUFFERED INPUT
	JRST	PASSIT		;ENTER, CHECK PASS WORD
	JRST	UUOERR		;LOOKUP
	JRST	UDPOUT		;DUMP OUTPUT
	JRST	UDPIN		;DUMP INPUT
	JRST	UUOERR		;USETO
	JRST	UUOERR		;USETI
	JRST	UUOERR		;UGETF
	JRST	PASSET		;RENAME, SET PASS WORD
	POPJ	P,		;CLOSE INPUT
	POPJ	P,		;UTPCLR
	JRST	UUOERR		;MTAPE

UDPIN:
	MOVEI	TAC1,IOPCHN
	JRST	UDPSER

UDPOUT:
	TLNN	IOS,WRITEB		;ENTER DONE?
	JRST	ENOENT			;NO
	MOVEI	TAC1,DWRITE!IOPCHN

UDPSER:
	MOVSM	TAC1,TFRCTL(DDB)
	HRRZ	AC1,UUO			;CHECK EVERY ADDRESS IN SIGHT.
	PUSHJ	P,UADCK1		;FOR LEGAL ADDRESS RANGE.
	ADDI	AC1,1
	PUSHJ	P,UADCK1		;CHECK LAST CL WORD TOO.
	XCTR	XR,[SKIPL (UUO)]	;THIS IS BECAUSE DMPCMD DOES BRANCHING!
	JRST	ADRERR			;ONLY IOWD'S ALLOWED
	PUSHJ	P,DMPCMD		;CHECK FOR LEGAL IOWD
	MOVEM	TAC1,CORFAD(DDB)
	XCTR	XR,[MOVE TAC1,(UUO)]	;GET IOWD
	LDB	DAT,PSEGN		;UPPER (IF ANY)
	JUMPE	DAT,UDPS1		;NONE, MUST BE IN LOWER
	HRRZ	DAT,JBTADR(DAT)		;RELOC OF UPPER
	TRZN	TAC1,400000		;IN UPPER?
UDPS1:
	HRRZ	DAT,PROG		;AFTER ALL THAT ITS IN THE LOWER
	ADDI	TAC1,1(DAT)		;RELOCATE AND MAKE IT XWD -WC,ADDRESS
	MOVEM	TAC1,TFRIOW(DDB)	;GOD ONLY KNOWS WHAT MCGUIRE WILL DO WITH THIS
	XCTR	XR,[HRRZ TAC1,1(UUO)]	;GET UDP BLOCK ADDR.
	LDB	DAT,PUNIT
	LDB	DAT,[POINT 32,NCYLSH+FPACKS-1(DAT),31]	;NUMBER OF CYLS ON THIS PACK
	IMULI	DAT,BKPTRK*TRKCYL	;MULTIPLY TO GET TOTAL NUMBER OF BLOCKS
	CAIL	TAC1,(DAT)		;TOO BIG?
	JRST	UADRER			;NO GOOD.
	MOVE	TAC,JBTPRV(J)
	TLNN	TAC,UDPPRV		;LET DUMPER(1,2) GET AT LAST BLOCK
	CAIE	TAC1,-1(DAT)		;LAST LOGICAL BLOCK
	CAIA
	JRST	UADRER
	LDB	TAC,PUNIT		;GET UNIT NUMBER
	ADD	TAC1,BFSET(TAC)		;KLUGE UP START ADDR OF UDP.
	LSH	TAC1,6			;PRETEND RECORD ZERO.
	XCTR	XR,[HLRZ TAC,1(UUO)]
	CAILE	TAC,RCPBLK		;LEGAL RECORD NUMBER?
	JRST	UADRER
	IOR	TAC1,TAC		;OR IT IN
	MOVEM	TAC1,TFRSEC(DDB)
	PUSHJ	P,GOSET
	SETOM	DDLOC(DDB)
	MOVEI	DAT,TSTART
	PUSHJ	P,UEWAIT
	SETZM	DDLOC(DDB)
	JRST	DPOPJ

;UDP PASS WORD STUFF

GPASIN:
	MOVEI	DAT,PASSIN		;READ PASSWORD BLOCK
	PUSHJ	P,NEWAIT
	TRNE	IOS,IODERR!IODTER	;ERRORS?
	JRST	EGARB1			;YES
	MOVE	TAC,['PASS  ']		;CHECK FOR INITIALIZATION
	CAMN	TAC,DSKDAT(DDB)
	CAME	TAC,DSKDAT+1(DDB)
	JRST	CPOPJ1			;NOT INITIALIZED. LET HIM IN
;HERE WE SHOULD VERIFY THAT IDSAT IN BLOCK 0 ISN'T USED
	LDB	TAC,PUNIT
	MOVE	AC1,BUFIOW		;USE SYSBUF
	MOVEM	AC1,TFRIOW(DDB)			;SET IT IN THE DDB
	MOVEI	DAT,CHKSAT
	PUSHJ	P,NEWAIT			;CAUSE SAT TO BE READ AND WAIT FOR IT.
	MOVE	TAC,SYSBUF+IDSAT
	CAME	TAC,['SATID ']
	POPJ	P,
	JSP	TAC,UUOMES
	ASCIZ	/Illegal old-style access to new format UDP. UUO /

PASSIT:
	MOVE	TAC,JBTPRV(J)
	TLNE	TAC,UDPPRV		;LET DUMPER THROUGH (1,2)
	JRST	PASSI1
	TLZ	IOS,WRITEB		;LOSE FOR NOW
	PUSHJ	P,GPASIN		;READ PASSWORD BLOCK. SKIP IF NONE THERE
	SKIPN	TAC,DSKDAT+2(DDB)	;MAY NOT BE NECESSARY
	JRST	PASSI1			;BLANK PASSWORD, OR NO PASS BLOCK
	CAME	TAC,['*SWAP*']		;ALLOW WRITE ACCESS TO SCRATCH PACK
	XCTR	XR,[CAMN TAC,(UUO)]	;GET PASSWORD FROM USER
PASSI1:
	TLOA	IOS,WRITEB		;ALLOW WRITE ACCESS
	JRST	EPROT			;PROTECTION FAILURE
	JRST	DPOPJ1

PASSET:
	MOVE	TAC,JBTPRV(J)
	TLNE	TAC,UDPPRV		;LET DUMPER IN ALWAYS(1,2)
	JRST	PASSE1
	TLZN	IOS,WRITEB		;CAN HE DO THIS?
	JRST	ENOENT			;NO
	PUSHJ	P,GPASIN
	SKIPA	TAC,DSKDAT+2(DDB)
	JRST	PASSE1			;NO PASSBLOCK - LET'S MAKE ONE
	CAMN	TAC,['*SWAP*']
	JRST	EPROT			;CAN'T CHANGE PASSWORD OF SWAPPING PACK
PASSE1:
	MOVE	TAC,['PASS  ']
	MOVEM	TAC,DSKDAT(DDB)
	MOVEM	TAC,DSKDAT+1(DDB)
	XCTR	XR,[MOVE TAC,(UUO)]	;GET NEW PASS WORD!
	MOVEM	TAC,DSKDAT+2(DDB)
	SETZM	DSKDAT+3(DDB)
	HRRI	TAC,DSKDAT+3(DDB)
	HRL	TAC,TAC
	ADDI	TAC,1
	BLT	TAC,DSKDAT+SECSIZ-1(DDB)	;CLEAR THE REST
	MOVEI	DAT,PASOUT			;WRITE IN PASS WORD BLOCK
	PUSHJ	P,NEWAIT
	TRNE	IOS,IODERR!IODTER		;ERRORS?
	JRST	EGARB1
	JRST	PASSI1				;OK

;****** I-LEVEL SUBR ******
PASOUT:
	SKIPA	TAC,[DWRITE!IOPCHN]		;WRITE
PASSIN:
	MOVEI	TAC,IOPCHN			;READ
	MOVSM	TAC,TFRCTL(DDB)
	MOVE	TAC,[XWD -SECSIZ,DSKDAT]
	ADDI	TAC,(DDB)
	MOVEM	TAC,TFRIOW(DDB)
	LDB	TAC1,PUNIT
	LDB	TAC,[POINT 32,NCYLSH+FPACKS-1(TAC1),31]
	IMULI	TAC,BKPTRK*TRKCYL
	SUBI	TAC,1
	ADD	TAC,BFSET(TAC1)			;ADD BASE ADDRESS
	LSH	TAC,6				;RECORD 0
	MOVEM	TAC,TFRSEC(DDB)
	JRST	TSTART				;DO IT

CHKSAT:
	MOVEI	TAC,IOPCHN			;READ
	MOVSM	TAC,TFRCTL(DDB)
	TLO	IOS,SATOP
	LDB	TAC,PUNIT
	MOVE	TAC,BFSET(TAC)			;DISK ADDRESS OF SAT TABLE
	PUSHJ	P,BK2SEC			;CONVERT BLOCK TO SECTOR
	MOVEM	TAC,TFRSEC(DDB)
	PUSHJ	P,TSTART
	TLZ	IOS,SATOP
	POPJ	P,
;: DSKSER[J17,SYS] EOF.
;: DSKINT[J17,SYS]
COMMENT ⊗   VALID 00017 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	BEGIN DSKINT
C00006 00003	HERE IS THE 3330 CODE FOR DIAGNOSTIC LOAD AND WRITE
C00009 00004	ENTER HERE TO DO A TRANSFER.
C00013 00005	DOCHK:	PUSH P,DXW		SAVE A COUPLE OF THINGS
C00020 00006	CADDR	CASWAP
C00027 00007	ICALLA:	SKIPGE TAC,LSTREC		NEED BACKUP?
C00030 00008	ICALLC:	SKIPE D2LUZ
C00032 00009	ESYNC:	MOVEM P,INTPDL
C00037 00010	DSKERR		INTERFACE ERRORS
C00043 00011			DISK ERRORS
C00046 00012			ERROR/USAGE STATISTICS
C00049 00013			ERROR PRINT
C00055 00014	ERROR CLASS DESCRIPTIONS
C00057 00015	ERROR CLASS HANDLERS
C00064 00016	HIGH PRIORITY INTERRUPT CODE (HPIC)
C00067 00017	MORE HPIC
C00069 ENDMK
C⊗;

BEGIN DSKINT
; DEVICE DEPENDENT ROUTINE FOR THE 3330
;THIS ONE RECOVERS FROM ERRORS AS MUCH AS POSSIBLE.

;HUNG COUNT FOR DISK IN SECONDS
↑DHNGCT←←=5		;LETS TRY 5 SECONDS FOR NOW
↑DLHNGCT←←=60		;DIAG LOAD TAKES PRETTY LONG

;BITS FOR CONO/CONI 500: CONDITION MASKS.

;LEFT HALF
DSKNXM←←200000		;NON-EX-MEM
DCHNER←←100000		;DATA CHAIN ERROR
SELERR←←40000		;SELECT ERROR
CPARER←←20		;CORE PARITY ERROR

;RIGHT HALF
PARERR←←400000		;FOR SEPARATE PAR ERR CHECK
↑↑CHDEMP←←200000	;COMMAND HOLD BUFFER EMPTY
IDLE←←100000		;PMP IN IDLE STATE
↑↑UNEND←←40000+PARERR	;UNEND OR PARITY ERROR
↑↑NEWST←←20000		;NEW STATUS BIT FROM PETIT.
CPIACT←←20		;CONI: PI REQUEST UP.

;BITS FOR CONO 504.

CLREND←←4000		;CLEAR UNUSUAL END
↑↑ACTCLR←←400		;CLEAR PI REQUEST
↑↑CNEWST←←200		;CLEAR NEW STATUS FLAG
CLRSTS←←40		;CLEAR STATUS.
↑CLRCHL←←20		;CLEAR COMMAND HOLD LOADED
CRESET←←1		;RESET EVERYTHING.

;STATUS BITS IN CONI PMP (500)

↑↑ATTN←←10000
↑↑STMOD←←4000
↑↑CUEND←←2000
↑↑BUSY←←1000
↑↑CHNEND←←400
↑↑DEVEND←←200
↑↑UCHK←←100
↑↑UXCPTN←←40

;THE FOLLOWING BITS ARE FOUND IN THE FIRST 2 SENSE BYTES
BITCL0←←155		;CLASS 0 BITS
CMDRJT←←100000		;COMMAND REJECT IS SPECIAL
BITCL1←←20000		;CLASS 1 BITS
BITCL2←←4000		;CLASS 2 BITS
BITCL4←←2000		;CLASS 4 BITS
BITCL5←←40002		;CLASS 5 BITS
WRTINH←←2		;WRITE INHIBITED
PERM←←200		;PERMANENT ERROR
BITEQU←←10000		;EQUIPMENT CHECK

ERRUSE←←20		;SENSE BYTE 2, ERROR-USAGE DATA PRESENT

;THESE ARE FOUND IN SENSE BYTE 7
SKCHK←←32		;SEEK CHECK
SKINCP←←33		;SEEK INCOMPLETE
RTYABT←←6		;RETRY ABORTED
DWERR←←320		;DIAGNOSTIC WRITE CONTROL BIT ERROR
DVERR←←100		;INVALID DATA ARG (PROBABLY DIAG. LOAD)

;HERE IS THE 3330 CODE FOR DIAGNOSTIC LOAD AND WRITE
↑WLDIAG:MOVEM 17,DSKACS+17
	MOVEI 17,DSKACS
	BLT 17,DSKACS+16
	MOVEM IOS,DEVIOS(DDB)
	SETZ TAC,
	DPB TAC,[POINT 3,TSTXOR,11]		;SO WE DON'T GET ASYNC INT'S
	MOVE TAC,DXC
	MOVEI TAC,DLHNGCT			;DIAGS TAKE QUITE A WHILE
	MOVEM TAC,DHNGST
	MOVEM TAC,DSKHNG
	SETOM DSKACT				;FLAG DISK ACTIVE!
	SETOM ERRCMD				;TELL THEM WHO IT IS
	PUSHJ P,ERRCLR				;CLEAR ERROR COUNTS
WLRTRY:
	CONO PMP,NEWST!UNEND!10!DSKCHN
	CONO IBM,CNEWST!CLREND!ACTCLR		;COME HERE TO TRY AGAIN
	MOVE TAC,DXC
	TRNN TAC,DWRITE				;THIS TELLS US IF THIS IS
	JRST LDIAG1				;A LOAD OR WRITE
	DATAO PMP,[FILMSK]
	DATAO IBM,MSKCMD			;SET FILE MASK COMMAND
	PUSHJ P,ISYNC
	JRST WLRTRY
	JRST WLERR
	DATAO PMP,DXS				;WRITE, ADDRESS OF DIAGNOSTIC
	DATAO IBM,DWCMD				;IS IN DXS
	JRST WLWAIT

LDIAG1:
	CONO IBM,ACTCLR				;CLEAR ACTIVE
	DATAO PMP,[DXS]				;POINT TO ADDRESS BYTE
	DATAO IBM,DLCMD
WLWAIT:
	PUSHJ P,ISYNC
	JRST WLRTRY
	JRST WLERR
	MOVE TAC,PMPCNI
	TRNN TAC,DEVEND
	JRST WLWAIT
	CONO IBM,ACTCLR
	DATAO PMP,DXW
	DATAO IBM,RD1CMD
	PUSHJ P,ISYNC
	JRST WLRTRY
	JRST WLERR
	JRST NOLUZ				;RETORE ACS, AND LEAVE

WLERR:
	PUSHJ P,DSKERR
	JRST WLRTRY
	JRST NOLUZ

;ENTER HERE TO DO A TRANSFER.

↑GO2314:MOVEM 17,DSKACS+17
	MOVEI 17,DSKACS
	BLT 17,DSKACS+16
	MOVEM IOS,DEVIOS(DEVDAT)
	AOS DSKOPS		;COUNT TOTAL DSK OPS.
	SKIPLE TAC,DXJ		;GET JOB NUMBER OF USER
	AOS DSKOPS(TAC)		;COUNT A DISK ACCESS FOR THIS USER
	SKIPE DXS		;NOT ON SATOP
	PUSHJ P,CSATID		;CHECK SATID (ROUTINE IS IN DSKSER)
	SETOM DSKACT		;FLAG DISK ACTIVE NOW!
	MOVEI TAC,DHNGCT
	MOVEM TAC,DHNGST
	MOVEM TAC,DSKHNG	;ENABLE HANG CODE
	MOVE TAC,DXC
	TRNE TAC,100		;WRITE OP?
	SKIPG TAC,DXS		;AND FILE OP
	JRST NOCHK		;NO
	MOVE TAC1,DSKACS+DDB
	TRNN TAC,77		;RECORD 0?
	SKIPGE DDLOC(TAC1)	;AND NOT GOD?
	JRST NOCHK		;NO
	PUSHJ P,DOCHK		;YES, TO ALL OF THESE, DO OVERWRITE CHECK!
	JRST NOLUZ		;BLEW UP COMPLETELY!
NOCHK:
	PUSHJ P,CADDR		;DO ALL THE SETUP CRUD
	JRST NOLUZ		;ILL ADDR
	SETOM DSKACT		;SET DISK ACTIVE FLAG
	MOVEI TAC,DHNGCT
	MOVEM TAC,DHNGST
	MOVEM TAC,DSKHNG
	PUSHJ P,ICALL		;CALL D2CHN
	SKIPN D2LUZ
	JRST NOLUZ
	MOVE TAC,DSKACS+DDB		;GET DDB ADDRESS
	MOVEI TAC1,IODERR	;GIVE ERROR BIT FOR ILLEGAL WRAP
	IORM TAC1,DEVIOS(TAC)
NOLUZ:
	SETZM DSKACT		;CLEAR DISK ACTIVE FLAG
	SETZM DSKHNG		;TELL DEVCHK NOT ACTIVE
	CONO PMP,NEWST!UNEND!10!DSKCHN
	CONO IBM,CNEWST!CLREND!ACTCLR
	CONO PI,D2OFF		;DEACTIVATE HIGH PRIORITY CHANNEL
	SKIPE DXS		;IF NOT SAT TABLE,
	PUSHJ P,CSATID		;CHECK SATID AGAIN (ROUTINE IS IN DSKSER)
	MOVE TAC,STAC		;RESTORE THE SAVED ACS.
	MOVE TAC1,STAC1
	MOVE P,SAVP
	MOVE AC3,SAC3
	MOVE DAT,SDAT
	JSR DSKSV		;NOW SAVE THEM ALL.
	POP P,INTRTN		;SET DISMISS ADDR.
	MOVSI 17,DSKACS		;NOW RESTORE RAS'S ACS.
	BLT 17,17
	MOVE IOS,DEVIOS(DEVDAT)	;GET CURRENT STATUS.
	POPJ P,


DOCHK:
	PUSH P,DXW		;SAVE A COUPLE OF THINGS
	PUSH P,DXC
	MOVE TAC,[XWD -SECSIZ,QBUF]
	MOVEM TAC,DXW
	MOVEI TAC,DSKCHN
	MOVEM TAC,DXC
	PUSHJ P,CADDR		;SETUP OVERWRITE CHECK ADDRESS
	JRST [	POP P,DXC
		POP P,DXW
		POPJ P,]	;LOSE BIG, ILLEGAL ADDRESS
	POP P,DXC
	POP P,DXW
	SKIPG DSKLRN		;MAKE SURE WE MUST CHECK
	JRST CPOPJ1		;NOT FILE OP AFTER ALL, SAY CHECK DONE!
	PUSHJ P,ICALL		;READ RETRIEVAL IN
	MOVE TAC1,DSKACS+DDB
	MOVEI TAC,IODERR!IODTER
	SKIPE D2LUZ		;ANY GROSS ERRORS?
	IORM TAC,DEVIOS(TAC1)	;YES, SET ERROR BITS
	TDNE TAC,DEVIOS(TAC1)	;NOW TEST FOR ERRORS
	POPJ P,			;YES, GO AWAY NOW
	LDB TAC,[POINT PUNITS,DEVCHR(TAC1),35-PUNITP]
	MOVE TAC,SATADR(TAC)	;GET POINTER TO SAT FOR THIS DEVICE
	MOVE TAC,SATID(TAC)	;GET NAME OF CURRENT GENERATION OF FILES.
	CAMN TAC,QBUF+DSATID-DSKDAT	;IS BLOCK WE'RE WRITING ON CURRENT ?
	SKIPN AC3,QBUF		;FILENAME OF 0 MEANS NOT IN USE.
	JRST CPOPJ1		;THE BLOCK WE'RE WRITING ON IS NOT IN USE.
	MOVE TAC,QBUF+1		;GET EXTENSION.
	XOR TAC,FILEXT(TAC1)	;TAC1 POINTS AT DDB FOR CURRENT OP.
	CAMN AC3,FILNAM(TAC1)
	TLNE TAC,-1
	SKIPN QBUF+3		;IF PPN IS 0, OR IF
	JRST CPOPJ1		;SAME FILENAME AND EXTENSION. WRITE IS OK.
DSKQK1:
	PUSH P,TEM
	HRRZ TEM,DXW		;THIS POINTS TO THE RETRIEVAL WE ARE REWRITING
	MOVE TAC,QBUF+3		;CHECK PPN
	CAMN AC3,(TEM)		;SAME FILNAME?
	CAME TAC,3(TEM)		;AND PPN?
	JRST DSKQKP		;NO
	MOVE TAC,QBUF+1		;EXT
	XOR TAC,1(TEM)
	TLNE TAC,-1
	JRST DSKQKP
	POP P,TEM
	JRST CPOPJ1

DSKQKP:
	POP P,TEM
DSKQK2:
	CAMN AC3,SRCNAM(TAC1)	;OR PERHAPS RENAMING THE FILE ?
	JRST CPOPJ1		;NOTHING CAN GO WRONGWRONGWRONGWRON
	HRRZ TAC,DXW		;GET STARTING ADDR. OF XFER.
	PUSH P,TAC		;SIGH.  NO ACS FOR VARIABLE SATTAB LOCATION...
	LDB TAC,[POINT PUNITS,DEVCHR(TAC1),35-PUNITP]
	MOVE TAC,SATADR(TAC)
	SKIPL DDLOC(TAC1)	;IS IT (A) GOD ?
	CAMN TAC,(P)		;IF WE ARE WRITING OUT THE SAT TABLE,
	JRST TPOPJ1		;...THEN ALL IS WELL (?)
	POP P,TAC
	PUSHACS
	PUSHJ P,DISDATE
	MOVE UUO,DSKACS+DDB
	PUSHJ P,DISERR
	[ASCIZ/OVERWRITE CHECK,  LR = /]
	DISARG LOC,DSKLRN
	[ASCIZ/
WRITING FILE   /]
	DISARG SIX,FILNAM(UUO)
	[ASCIZ/./]
	DISARG SIX,FILEXT(UUO)
	[0133B6];;replaced;;[ASCIZ/[/]
	DISARG SIX,FILPPN(UUO)
	[ASCIZ/   DDLOC = /]
	DISARG LOC,DDLOC(UUO)
	[ASCIZ/)
ON TOP OF FILE /]
	DISARG SIX,QBUF-DSKDAT+DDNAM
	[ASCIZ/./]
	DISARG SIX,QBUF-DSKDAT+DDEXT
	[0133B6];;replaced;;[ASCIZ/[/]
	DISARG SIX,QBUF-DSKDAT+DDPPN
	[ASCIZ/)  DDLOC = /]
	DISARG LOC,QBUF-DSKDAT+DDLOC
	[ASCIZ/


/]
	-1
	SKIPN DEBMOD
	JRST .+3
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	POPACS
	SKIPE DEBMOD
	PUSHJ P,DDTCALL
NOOSTP:
	AOS DSKOVC		;COUNT OVERWRITE ATTEMPTS.
	MOVSI TAC,HDRDIF!PNTDIF	;INDICATE THAT RETRIEVAL MUST BE SPREAD AGAIN.
	IORM TAC,DEVIOS(TAC1)
	MOVE AC3,TAC1		;SAVE PTR. TO TABLE OF BLOCK LOCATIONS IN DDB.
	PUSH P,AC1
	PUSH P,AC2
	PUSHJ P,IASNBK		;ASSIGN A NEW BLOCK TO REPLACE THE ONE WE DON'T
				; WANT TO CLOBBER.
	MOVE TAC1,[POINT 18,DPTR(AC3)]	;BYTE PTR. TO TABLE OF BLOCKS IN FILE.
	MOVEI AC2,40		;LENGTH OF TABLE FOR ONE 32K GROUP OF FILE.
	ILDB AC1,TAC1		;SEARCH FOR BLOCK WE WERE WRITING ON.
	CAME AC1,DSKLRN		;DSKLRN IS BLOCK WE WERE WRITING ON.
	SOJG AC2,.-2

	JUMPG AC2,DSKQK3	;DID WE FIND BLOCK IN TABLE ?
	POP P,AC2
	POP P,AC1
	JRST DSKQY
DSKQK3:
	DPB TAC,TAC1		;REPLACE OLD BLOCK WITH NEW ONE IN TABLE.
	POP P,AC2
	POP P,AC1
	CAME TAC1,[POINT 18,DPTR(AC3),17]	;WAS IT FIRST BLOCK OF THIS GROUP ?
	JRST DSKQZ		;NO.
	MOVSI TAC1,NTRUFD	;YES. MAKE CLOSE UPDATE UFD ENTRY.
	IORM TAC1,DEVIOS(AC3)
	MOVEI TAC1,1		;YES. IS THIS GROUP 1 OF THE FILE ?
	CAME TAC1,DGRP1R(AC3)
	JRST DSKQY	
	HRRZM TAC,FILLOC(AC3)	;YES. NEW BLOCK IS NEW LOCATION OF FILE.
	HRRZM TAC,DDLOC(AC3)	;ALSO PUT IT HERE.
	JRST DSKQZ
DSKQY:
	MOVEI TAC1,IODERR	;NO. THERE IS NOTHING REASONABLE WE CAN DO.
	IORM TAC1,DEVIOS(AC3)	;GIVE THE LOSER LOSSAGE BIT.
	POPJ P,			;SKIP RETURN TO DSKINT.
DSKQZ:
	PUSHJ P,BK2SEC		;NOW UPDATE DISK ADDR. OF CURRENT XFER TO BE NEW BLOCK.
	MOVEM TAC,DXS
	JRST DOCHK

;CADDR	CASWAP

CASWAP:
	TLZ	TAC,400000				;CLEAR SWAP OP BIT!
	LSH	TAC,-14					;GET JOB NUMBER(WE HOPE)!
	IMULI	TAC,<CAT(NTRK,\<NPACKS-1>)/LJOBN>	;DIVIDE SWAPPING PACK AMONG
						;ALL POSSIBLE JOBS
	MOVE	TAC1,SWPDDB
	LDB	TAC1,[POINT PUNITS,DEVCHR(TAC1),35-PUNITP]	;UNIT NUMBER
	ADD	TAC,BFSET(TAC1)			;ADD OFFSET TO MAKE DISK ADDRESS
	HRROM	TAC,DSKLRN			;DISABLE MRKBAD
	MOVSI	TAC1,(<BYTE(8)1>)		;WRAP TO RECORD 1 ON 3330
	MOVEM	TAC1,XWRAP
	MOVEI	TAC1,1				;AND START AT RECORD 1
	JRST	CDX3			;TAC=TRACK NUMBER, TAC1= RECORD NUMBER = 1

CADDR1:
	MOVE AC3,DXC
	TRNE AC3,100		;SAT TABLE, IS IT WRITE?
	JUMPN TAC1,CDX4		;YES, BETTER BE RECORD 0
	SETOM DSKLRN		;DISABLE MRKBAD
	JRST CDX3S		;TAC=0, TAC1=RECORD NUMBER (=0 FOR WRITE)

;TAC HAS RELATIVE BLOCK NUMBER
CAXTRA:
	IDIVI TAC,100		;TAC ← REL BLOCK #, TAC1 ← REC
	CAIL TAC,NXTRA0*TRKCYL*BKPTRK
	JRST CDX4		;WE DON'T HAVE THAT MANY EXTRA TRACKS
IFG BKPTRK-1,<
	MOVEI AC3,(TAC1)
	IDIVI TAC,BKPTRK
	IMULI TAC1,CRMAX
	ADDI TAC1,(AC3)
>
	CAIL TAC1,RCPTRK
	JRST CDX4		;RECORD NUMBER TOO BIG
	SETZB AC3,XWRAP		;PACK 0, WRAP AROUND TO RECORD 0
	SETOM DSKLRN		;DISABLE MRKBAD
	ADDI TAC,NTRK0		;OFFSET TO END OF PACK 0
	JRST CDXE

CADDR:
	MOVE TAC,DXW
	HRLZ TAC1,DXC
	TLNN TAC1,100		;READ OR RIGHT?
	TROA TAC1,-1		;FLAG READ
	SUB TAC,[1,,0]		;CAUSES CHNL TO NOT STOP XFER TOO SOON
	MOVEM TAC,XWCMA
	MOVE TAC,WCMD(TAC1)	;PICKUP COMMAND
	MOVEM TAC,XCMD
	MOVE TAC,ENDTAB(TAC1)	;PICKUP INSTRUCTION FOR ENDING TEST ON WC
	MOVEM TAC,ENDTST	;AND STUFF IT AWAY
	MOVE TAC,[JSR D2INT]	;MAKE SURE D2CHN KNOWS WHERE TO GO
	MOVEM TAC,140+2*D2CHN
	SKIPGE TAC,DXS
	JRST CASWAP		;SIGN BIT MEANS SWAP OP, WITH SHIFTED JOB NUMBER
	TLZE TAC,200000
	JRST CAXTRA		;200000 BIT MEANS XTRA CYL PACK 0 OP
	IDIVI TAC,100			;TRACK INTO TAC, RECORD INTO TAC1
	JUMPE TAC,CADDR1		;JUMP IF SAT TABLE OPERATION
	MOVEM TAC,DSKLRN		;SAVE LOGICAL BLOCK NUMBER IN CASE OF ERROR
	MOVE AC3,DSKACS+DDB		;FIND OUT IF IT'S A FILE OP OR OLD UDP OP
	MOVE AC3,DEVMOD(AC3)
	TLNN AC3,DVDSK			;FILE OP?
;	CAILE TAC,LSTBIT		;FILE OP? (HOW IT USED TO CHECK--;ED OUT!)
	HRROS DSKLRN			;NO, DISABLE MRKBAD
IFG BKPTRK*NSATBK-1,<
	ADDI TAC,BKPTRK*NSATBK-1	;LEAVE ENOUGH ROOM FOR SAT TABLE
>
IFG BKPTRK-1,<				;ASSEMBLE CODE FOR MULTIPLE BLOCKS/TRACK
	MOVEI AC3,(TAC1)
	IDIVI TAC,BKPTRK		;DIVIDE BY BLOCKS/TRACKS
	IMULI TAC1,CRMAX		;TIMES RECORDS/BLOCK (INCL RETRIEVAL)
	ADDI TAC1,(AC3)			;CALC REAL DISK RECORD NUMBER
>
CDX3S:
	SETZM XWRAP			;WRAP TO RECORD ZERO ON OVERFLOW
CDX3:
	CAIGE TAC1,RCPTRK		;RECORD OK?
	CAILE TAC,LSTTRK		;OFF END OF WORLD?
	JRST CDX4			;LOSER

	MOVSI AC3,-NPACKS		;SEARCH FOR THE PACK CONTAINING THIS TRACK
CDXL:
	CAMLE TAC,PACKAD(AC3)
	AOBJN AC3,CDXL
	JUMPGE AC3,CDX4			;THIS IS TOO HORRIBLE TO THINK ABOUT.
	SUB TAC,PACKAD-1(AC3)
	SUBI TAC,1			;AC3=PACK, TAC=TRACK NUMBER ON THAT PACK
CDXE:
	ROT TAC1,-8			;PUT RECORD BYTE IN LEFT BYTE
	MOVEM TAC1,SCDAT+1		;STUFF AWAY
	IDIVI TAC,TRKCYL		;STRIP OFF HEAD NUMBER
	DPB TAC1,[POINT 8,SKDAT+1,15]	;STUFF HEAD NUMBER
	DPB TAC1,[POINT 16,SCDAT,31]
	DPB TAC,[POINT 16,SKDAT,31]	;STUFF CYLINDER NUMBER
	DPB TAC,[POINT 16,SCDAT,15]
	DPB AC3,[POINT 3,SKCMD,21]	;STUFF PACK NUMBER
	DPB AC3,[POINT 3,SCCMD,21]
	DPB AC3,[POINT 3,XCMD,21]
	DPB AC3,[POINT 3,NOPCMD,21]
	DPB AC3,[POINT 3,SNSCMD,21]
	DPB AC3,[POINT 3,RDHACM,21]
	DPB AC3,[POINT 3,RCALCM,21]
	DPB AC3,[POINT 3,TSTXOR,11]
	SETZM LWCMA			;NO LAST ERROR YET!
	SETZM LSTOP
	SETOM LSTREC			;FOR SAFETY, FLAG XWCMA & SCDAT ARE NEXT OP TO DO
	JRST CPOPJ1

CDX4:
	MOVEM TAC,TYPANY	;STUFF AWAY HERE FOR NOW
	MOVEM TAC1,DSKFLG
	PUSHACS
	PUSHJ P,DISERR
	[ASCIZ/ILLEGAL DISK ADDRESS.  DXS = /]
	DISARG OCT,DXS
	[ASCIZ/
LR = /]
	DISARG LOC,TYPANY
	[ASCIZ/  REC = /]
	DISARG LOC,DSKFLG
	[ASCIZ/
JOB = /]
	-1
	HRRZ J,DXJ
	JUMPE J,.+2
	PUSHJ P,DISJOB
	SKIPL DXS
	JRST NOGOD
	PUSHJ P,DISMES
	ASCIZ/  SWAP OP!/
NOGOD:
	PUSHJ P,DISMES
	ASCIZ/

/
	POPACS
	MOVE TAC,DSKACS+DDB
	MOVEI TAC1,IODERR
	IORM TAC1,DEVIOS(TAC)
	POPJ P,


ICALLA:
	SKIPGE TAC,LSTREC		;NEED BACKUP?
	JRST ICALLN			;NO, XWCMA & SCDAT ARE NEXT OP TO DO
	SETOM LSTREC			;NOTE WE ARE BACKED UP
	EXCH TAC,SCDAT+1		;BACKUP RECORD
	CAMLE TAC,SCDAT+1		;DO WE BACK UP A TRACK?
	JRST TOK			;NO
	MOVSI TAC,(<BYTE(16)<-1>>)	;GET SOMETHING TO DECREMENT HEAD ADDR
	ADDB TAC,SKDAT+1		;DECREMENT HEAD ADDR
	JUMPGE TAC,COK			;CYLINDER OK?
	MOVNI TAC,1⊗4
	ADDB TAC,SKDAT			;DECREMENT CYLINDER
	MOVSI TAC,(<BYTE(16)TRKCYL-1>)
	MOVEM TAC,SKDAT+1		;SET HEAD TO LAST TRACK OF CYLINDER
COK:
	HLRZ TAC,SKDAT+1		;NOW COMPUTE SCDAT FROM SKDAT
	LSH TAC,4
	HRL TAC,SKDAT
	LSH TAC,-2
	MOVEM TAC,SCDAT			;STORE UPDATED SEARCH LOC
TOK:
	LDB TAC,[POINT 8,SCDAT+1,7]	;USE RECORD NUMBER,
	MOVN TAC,RCLTAB(TAC)		;TO GET VALUE TO,
	ADDM TAC,XWCMA			;BACKUP XWCMA BY
ICALLN:
	HRRZ TAC,D2X			;GET LOC OF LAST JSR +1
	LDB TAC,[POINT 4,-1(TAC),12]	;GET CODE FROM AC FIELD OF JSR
	MOVE TAC1,XCMD			;SET FOR DSKERR CODE AS LAST OP IN PROGRESS
	TRNE TAC1,1			;WRITE OP?
	CAIE TAC,2			;YES, IF LAST OP IN PROGRESS WAS READ OR WRITE,
	CAIA
	ADDI TAC,1			;SET CODE FOR WRITE
	MOVEM TAC,ERRCMD
	MOVE TAC1,XWCMA			;GET ERROR WCMA
	CAMN TAC,LSTOP			;SAME COMMAND IN ERROR?
	CAME TAC1,LWCMA			;AND SAME WCMA
	CAIA
	POPJ P,				;NO, DON'T RESET COUNTS
	MOVEM TAC,LSTOP
	MOVEM TAC1,LWCMA		;REMEMBER LAST ERROR
ERRCLR:
					;ENTER HERE TO CLEAR ERROR COUNTS
;;replaced;;FOR @!X←0,4<
;;replaced;;SETZM ERRCL!X>
        SETZM ERRCL0
        SETZM ERRCL1
        SETZM ERRCL2
        SETZM ERRCL3
        SETZM ERRCL4       
	SETOM SHADPE
	POPJ P,

ICALLC:
	SKIPE D2LUZ
	POPJ P,				;EOD, RETURN NOW!!!!!
ICALL:
	SETZM D2DONE			;NOT SUCCESSFUL YET!
	SETZM D2LUZ			;HAVEN'T LOST YET
	SETOM CT			;MAKE SURE WE DON'T INTERPRET RANDOM ERRORS AS LOSING SEARCHES
	MOVEI TAC,D2IGO			;START D2CHN HERE
	MOVEM TAC,D2X
	CONO PI,D2ON			;TURN ON HIGH PRIORITY CHANNEL
	CONO IBM,CNEWST!CLREND!CLRCHL	;MAKE SURE AN INT WILL HAPPEN
	CONO PMP,NEWST!UNEND!CHDEMP!10!D2CHN	;DOWN TO CHANNEL 2
	PUSHJ P,ESYNC			;WAIT TILL DONE OR ERROR
	JRST ICALLB			;RETRY, START D2CHN OVER
	AOSN D2DONE			;SUCCESSFUL OP?
	POPJ P,				;YES, JUST RETURN
	PUSHJ P,ICALLA			;GRONK PARMS
	PUSHJ P,DSKERR			;ERROR, CALL ROUTINE
	JRST ICALLC			;TRY AGAIN
	POPJ P,				;QUIT, ERRORS ALREADY POSTED

ICALLB:
	PUSHJ P,ICALLA
	JRST ICALLC

ISYNC:
	PUSHJ P,ESYNC			;WAIT FOR OP TO HAPPEN
	POPJ P,				;TRY AGAIN RETURN
	AOS (P)				;AT LEAST ONE SKIP
	MOVE TAC,PMPCNI			;GET CONI BITS
	TRNE TAC,UNEND!ATTN!UXCPTN!CUEND!STMOD;ANY ERRORS?
	POPJ P,				;YES, RETURN
	JRST CPOPJ1			;NO ERRORS

ESYNC:
	MOVEM P,INTPDL
	SETZM HNGFLG			;ALWAYS CLEAR HUNG FLAG HERE!
	JRST @INTRTN

↑IXINT:	MOVEM TAC,STAC			;ENTER HERE FROM LOW-PRIORITY CHANNEL
	MOVEM TAC1,STAC1
	MOVEM AC3,SAC3
	MOVEM DAT,SDAT
	MOVEM P,SAVP
	MOVE P,INTPDL
	MOVEI TAC,IXINT2
	MOVEM TAC,INTRTN
	CONI PMP,TAC
	MOVEM TAC,PMPCNI
	TRNE TAC,UNEND			;UNUSUAL END?
	CONO IBM,CLRCHL			;YES, CLEAR ANY WAITING COMMANDS
	CONO IBM,CNEWST!CLREND		;CLEAR NEWST AND UNEND WHEN STATUS GOBBLED
	SKIPN DSKACT			;IS DISK ACTIVE AT ALL?
	JRST ASYNC			;NO
	MOVE TAC1,DHNGST		;THIS IS DISK HUNG TIME COUNT IN SECONDS
	MOVEM TAC1,DSKHNG		;THIS IS WHERE IT IS COUNTED DOWN
	TRNN TAC,NEWST			;IS THIS DEVICE STATUS?
	JRST CPOPJ1			;NO, MUST BE END OF TRANSFER, RETURN
	TRNE TAC,CUEND			;CUEND ALONE?
	POPJ P,				;INDICATE TRY AGAIN
	TRC TAC,STMOD!BUSY
	TRCN TAC,STMOD!BUSY		;CU BUSY?
	JRST CKBUSY			;YES
	XOR TAC,TSTXOR
	TLNN TAC,37700			;WRONG ADDRESS?
	JRST CHKRTY			;NO, CHECK RETRY
	JRST ASYNC0			;USE STACK WE HAVE

ASYNC:
	MOVE TAC,STAC			;RESTORE STATE OF AC'S
 	MOVE TAC1,STAC1
	MOVE AC3,SAC3
	MOVE DAT,SDAT
	MOVE P,SAVP
	JSR DSKSAV			;NOW SAVE THEM ALL!
ASYNC0:
	CONO IBM,CLRCHL
	PUSHACS
	PUSHJ P,DISDATE
	LDB TAC,[POINT 8,PMPCNI,30]
	CAIN TAC,DEVEND⊗-5		;JUST DEVEND?
	JRST DEVRDY			;YES, SHORT MES.
	PUSHJ P,DISMES
	ASCIZ/ASYNCHRONOUS DISK DEVICE INTERRUPT.
/
	JRST SWAIT

DEVRDY:
	PUSHJ P,DISMES
	ASCIZ/DISK PACK /
	LDB TAC,[POINT 3,PMPCNI,11]
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ/ ON LINE.
/
SWAIT:
	PUSHJ P,DISERR
	[ASCIZ/CONI BITS = /]
	DISARG OCT,PMPCNI
	[ASCIZ/
/]
	-1
	CONSO PMP,NEWST
	JRST SDONE
	CONI PMP,PMPCNI
	CONO IBM,CNEWST!CLREND
	JRST SWAIT
SDONE:
	SKIPN DSKACT			;ARE WE ACTIVE?
	JRST SDONE0
	PUSHJ P,DISMES
	ASCIZ/DISK ACTIVE, PACK = /
	LDB TAC,[POINT 3,TSTXOR,11]
	PUSHJ P,DISLOC
SDONE0:
	PUSHJ P,DISMES
	ASCIZ/

/
	POPACS
	PUSHJ P,BLAST			;WAIT FOR IDLE THEN RESET
	SKIPE DSKACT			;IS DISK REALLY ACTIVE?
	JRST UCHKTS			;GIVE TRY AGAIN RETURN!
	CONO PMP,NEWST!UNEND!10!DSKCHN	;WE AREN'T ACTIVE, SET TO QUIET STATE
	CONO IBM,ACTCLR
	POPJ P,				;THIS WILL RESTORE AC'S AND JEN

UCHKTS:
	MOVE TAC,PMPCNI
	TRNN TAC,STMOD			;IF STATUS MODIFIER
	TRNN TAC,UCHK			;OR NOT UNIT CHECK
	POPJ P,				;THEN GIVE TRY AGAIN RETURN
	SETZM D2DONE			;MAKE SURE ERROR ROUTINE IS CALLED
	JRST CPOPJ1			;GIVE DONE RETURN

IXINT2:
	MOVE TAC,STAC
	MOVE TAC1,STAC1
	MOVE AC3,SAC3
	MOVE DAT,SDAT
	MOVE P,SAVP
	JEN @DSKCHL

CKBUSY:
	SETZM D2DONE			;MAKE SURE WE DON'T LOOK DONE!
;	EXCH DDB,DXB
;	LDB TAC1,PDVTIM			;MAKE SURE LOSER DOSEN'T HANG
;	DPB TAC1,PDVCNT
;	EXCH DDB,DXB
	TRNE TAC,CUEND			;CUEND ALREADY?
	POPJ P,				;TRY AGAIN
WAIT:
	CONO PMP,NEWST!UNEND!10!DSKCHN
	CONO IBM,ACTCLR
	JRST IXINT2			;WAIT FOR CUEND

CHKRTY:
	TRC TAC,STMOD!UCHK
	TRCE TAC,STMOD!UCHK
	JRST CPOPJ1
	SETZM D2DONE
	TRNN TAC,DEVEND
	JRST WAIT
	JRST CPOPJ1

;DSKERR		INTERFACE ERRORS
DSKERR:
	PUSHACS
	CONO IBM,CLRCHL
	CONO IBM,CNEWST!CLREND		;FROM HERE ON CHANNEL SHOULD BE IDLE
	SETZM TYPANY			;NO TYPE OUT YET
	SETZM SNSTYP
	SETZM CSTOP
	SETZM DEATH
	SETZM HAFLAG
	SETZM DSKFLG			;HAVEN'T FOUND OUT WHY YET
	MOVE UUO,PMPCNI			;GET ERROR BITS
	MOVEM UUO,CNISAV		;AND SAVE THEM IN A SAFE PLACE
	DATAI IBM,XDSKMA			;GET CURRENT MA
	TLNN UUO,SELERR			;IF SELECT ERROR, CHECK IF OFF LINE
	JRST NOSEL			;NO
	CONO IBM,CRESET			;EXTRA RESET FOR SELERR
	PUSHJ P,BLAST
	POPACS
	CONO IBM,CNEWST!CLREND!ACTCLR
	CONO PMP,NEWST!UNEND!10!DSKCHN
	DATAO IBM,NOPCMD
	PUSHJ P,ISYNC
	JRST .-2			;TRY AGAIN?
	JFCL				;SORT OF IGNORE ERROR RETURN
	PUSHACS				;GET ACS BACK(FORTH?)
	MOVE TAC,PMPCNI
	TLNN TAC,SELERR			;STILL SELECT ERROR?
	JRST NOSELA
	CONO IBM,CRESET
	PUSHJ P,BLAST
	PUSHJ P,DISMES
	ASCIZ/I THINK I'M OFF LINE!
/
	AOS CSTOP
NOSELA:
	PUSHJ P,ERROR1
	MOVE UUO,CNISAV
NOSEL:
	SKIPGE CT			;TOO MANY LOSING SEARCHES?
	JRST NOLSRC			;NO
	PUSHJ P,DISMES
	ASCIZ/TOO MANY LOSING SEARCHES.
/
	AOS TYPANY
	PUSHJ P,ERROR0
	HLRZ TAC,SKDAT+1		;THIS IS A BUG TRAP!!!!*******
	LSH TAC,4
	HRL TAC,SKDAT
	LSH TAC,-2
	EXCH TAC,SCDAT
	CAMN TAC,SCDAT
	JRST NOLSRC
	PUSH P,TAC
	PUSHJ P,DISERR
	[ASCIZ/SCDAT WAS CLOBBERED!
OLD SCDAT = /]
	DISARG OCT,<-1(P)>
	[ASCIZ/
NEW SCDAT = /]
	DISARG OCT,SCDAT
	[ASCIZ/
/]
	-1
	POP P,TAC			;END BUG TRAP!!!!*********
NOLSRC:
	SKIPN HNGFLG			;DOES SOMEONE THINK WE'RE HUNG?
	JRST NOHUNG			;NO
	AOS DSKFLG
	AOS TYPANY
	PUSHJ P,DISMES
	ASCIZ/HUNG TIMEOUT!
/
NOHUNG:
	TDNE UUO,[DCHNER,,ATTN!BUSY!UXCPTN]	;DATA CHAIN ERROR?
	PUSHJ P,ERROR0			;CLASS 0 ERROR
	TLNN UUO,DSKNXM			;NXM?
	JRST NONXM
	PUSHJ P,DISERR
	[ASCIZ/DISK NON-EX-MEM.
DISK MA = /]
	DISARG LOC,XDSKMA
	[ASCIZ/
/]
	-1
	PUSHJ P,ERROR1			;ERROR, CLASS ONE
	AOS TYPANY			;ALWAYS TYPE
NONXM:
	TLNN UUO,CPARER			;CORE PARITY ERROR?
	JRST BPAR
	MOVE TAC,XDSKMA
	CAMG TAC,RMEMSIZ
	CAIGE TAC,20
	AOSE SHADPE
	JRST REALPE	;AW, LOOK, WE'VE BEEN ALL THROUGH THIS BEFORE
	PUSHJ P,ZSHAD
	JFCL		;ZSHAD SKIPS IF NO FAST ACS
	AOS DSKFLG
	JRST NOPAR	;IGNORE IT FOR NOW
REALPE:
	PUSHJ P,DISERR
	[ASCIZ/CORE TO DISK PARITY ERROR.
DISK MA = /]
	DISARG LOC,XDSKMA
	[ASCIZ/
/]
	-1
	SKIPA TAC,RMEMSIZ		;LOOK AT ALL OF CORE FOR ERROR
	SKIP (TAC)
	SOJGE TAC,.-1
	AOS TYPANY			;TELL THEM WHO LOST
BPAR:
	TRNN UUO,PARERR			;PARITY ERROR
	JRST NOPAR			;NO
	PUSHJ P,ERROR1			;ERROR, CLASS ONE

;		DISK ERRORS
NOPAR:
	TRNE UUO,NEWST			;WILL UCHK BE HONEST?
	TRNN UUO,UCHK			;YES, WAS THERE A UNIT CHECK?
	JRST TYPE0			;NO, CHECK TYPEOUT AND ERROR FLAGS
	POPACS
	PUSHJ P,SENSE			;DO SENSE
	CAIA				;SENSE LOST
	JRST SNSDON
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ/SENSE FAILED.
/
	AOS CSTOP			;INDICATE COLD STOP
	AOS TYPANY
	PUSHJ P,ERROR1			;THIS IS CLASS 1 ERROR
	JRST TYPE0

SNSDON:
	PUSHACS
	AOS SNSTYP			;INDICATE TYPEOUT OF SENSE DATA
	LDB UUO,[POINT 16,SNSDAT,15]	;GET FIRST TWO BYTES OF SENSE
	TRNN UUO,CMDRJT			;COMMAND REJECT?
	JRST NORJCT			;NO
	TRNE UUO,WRTINH			;WRITE INHIBITED?
	JRST NORJCT			;YES, CATCH IT AT CLASS 5
	LDB TAC,[POINT 8,SNSDAT+1,31]	;PICK UP BYTE 7
	CAIE TAC,DVERR			;INVALID DATA?
	CAIN TAC,DWERR			;DIAGNOSTIC WRITE ERROR?
	SKIPL ERRCMD			;IS IT REALLY US?
	CAIA				;NO, MAYBE REAL LOSSAGE
	JRST [	AOS DEATH
		AOS DSKFLG		;KILL THE BUM
		JRST NORJCT]
	PUSHJ P,ERROR0			;OTHERWISE ERROR CLASS 0
NORJCT:
	TRNE UUO,BITCL0			;OTHER CLASS 0 ERROR?
	PUSHJ P,ERROR0			;ERROR, CLASS 0
	TRNE UUO,BITCL1			;BUS OUT PARITY IS
	PUSHJ P,ERROR1			;ERROR, CLASS 1
	TRNN UUO,BITEQU			;EQUIPMENT CHECK IS CLASS 1 OR 3
	JRST NOCL13
	LDB TAC,[POINT 8,SNSDAT+1,31]	;GET SENSE BYTE 7
	CAIE TAC,SKCHK			;SEEK CHECK
	CAIN TAC,SKINCP			;OR SEEK INCOMPLETE
	JRST SKCHKA			;ARE CLASS 3
	CAIN TAC,RTYABT			;COMMAND RETRY ABORTED?
	JRST [	PUSHJ P,ERROR4		;ERROR, CLASS 4
		JRST NOCL13]
	TRNE UUO,PERM			;REAL EQUIPMENT CHECK, IS IT PERMANENT?
	AOS CSTOP			;YES, COLD STOP
	PUSHJ P,ERROR1			;ALL ELSE IS CLASS 1
	JRST NOCL13

SKCHKA:
	POPACS
	PUSHJ P,ERROR3
	PUSHACS
	LDB UUO,[POINT 16,SNSDAT,15]	;RELOAD UUO
NOCL13:
	TRNE UUO,BITCL2			;DATA CHECK?
	PUSHJ P,ERROR2			;ERROR, CLASS 2
	TRNE UUO,BITCL4			;OVERRUN?
	PUSHJ P,ERROR4			;ERROR, CLASS 4
	TRNE UUO,BITCL5			;INT. REQ. OR WRITE LOCK?
	PUSHJ P,ERROR5			;ERROR, CLASS 5

;		ERROR/USAGE STATISTICS
	LDB TAC,[POINT 8,SNSDAT,23]	;PICK-UP BYTE 2
	TRNN TAC,ERRUSE			;ERROR-USAGE DATA?
	JRST TYPE0
	AOS DSKFLG
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ/3330 ERROR-USAGE STATISTICS.
/
	PUSHJ P,DRIVEP			;PRINT DRIVE ID
	PUSHJ P,DISMES
	ASCIZ/  PACK = /
	LDB TAC,[POINT 3,LSTAT,11]
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ/
TBYTES = /
	LDB TAC,[POINT 32,SNSDAT+2,31]	;BYTES 8-11 TOTAL BYTES
	PUSHJ P,DISDEC			;IN DECIMAL
	LDB UUO,[POINT 16,SNSDAT+3,15]	;BYTES 12-13 CORRECTABLE DATA CHECKS
	JUMPE UUO,ERRU1
	PUSHJ P,DISMES
	ASCIZ/
CDCHKS = /
	MOVE TAC,UUO
	PUSHJ P,DISDEC
ERRU1:
	LDB UUO,[POINT 16,SNSDAT+3,31]	;BYTES 14-15 RETRY DATA CHECKS
	JUMPE UUO,ERRU2
	PUSHJ P,DISMES
	ASCIZ/
RDCHKS = /
	MOVE TAC,UUO
	PUSHJ P,DISDEC
ERRU2:
	PUSHJ P,DISMES
	ASCIZ/
NSEEKS = /
	LDB TAC,[POINT 16,SNSDAT+4,15]	;BYTES 16-17 NUMBER OF SEEKS
	PUSHJ P,DISDEC
	LDB UUO,[POINT 8,SNSDAT+4,31]	;BYTE 19 NUMBER OF ERROR SEEKS
	JUMPE UUO,ERRU3
	PUSHJ P,DISMES
	ASCIZ/
ESEEKS = /
	MOVE TAC,UUO
	PUSHJ P,DISDEC
ERRU3:
	LDB UUO,[POINT 8,SNSDAT+5,7]	;BYTE 20 COMMAND OVERRUNS
	JUMPE UUO,ERRU4
	PUSHJ P,DISMES
	ASCIZ/
COVRRN = /
	MOVE TAC,UUO
	PUSHJ P,DISDEC
ERRU4:
	LDB UUO,[POINT 8,SNSDAT+5,15]	;BYTE 21 DATA OVERRUNS
	JUMPE UUO,ERRU5
	PUSHJ P,DISMES
	ASCIZ/
DOVRRN = /
	MOVE TAC,UUO
	PUSHJ P,DISDEC
ERRU5:
	PUSHJ P,DISMES
	ASCIZ/


/

;		ERROR PRINT
TYPE0:
	SKIPE DSKFLG
	JRST TYPE1
	AOS TYPANY
	PUSHJ P,DISMES
	ASCIZ/UNKNOWN /
TYPE1:
	SKIPN TYPANY			;TYPE ANYTHING?
	JRST ERRGO			;NO, END OF TYPE CHECKING
	PUSHJ P,DISMES
	ASCIZ/DISK ERROR. /
	PUSHJ P,DISDAT
	MOVE UUO,DSKACS+DDB
	SKIPL DSKLRN			;FILE OP?
	SKIPN FILNAM(UUO)		;ANY FILE?
	JRST NOFIL			;NO, DON'T PRINT CRUD
	PUSHJ P,DISMES
	ASCIZ/FILE = /
	MOVE TAC1,FILNAM(UUO)
	PUSHJ P,DISSIX
	HLLZ TAC1,FILEXT(UUO)
	JUMPE TAC1,NOEXT
	MOVEI TEM,"."
	PUSHJ P,DISTYO
	HLLZ TAC1,FILEXT(UUO)
	PUSHJ P,DISSIX
NOEXT:
	MOVEI TEM,"["
	PUSHJ P,DISTYO
	MOVE TAC1,FILPPN(UUO)
	PUSHJ P,DISSIX
	PUSHJ P,DISMES
	ASCIZ/]    /
NOFIL:
	MOVE UUO,ERRCMD
	ADDI UUO,1			;OFFSET SO DIAG WORKS
	PUSHJ P,DISERR
	[	ASCIZ/DIAG/		;-1
		ASCIZ/SEEK/
		ASCIZ/SRCH/
		ASCIZ/READ/
		ASCIZ/WRITE/](UUO)		;3
	[ASCIZ/ OP
/]
	-1
	MOVE TAC,DSKLRN
	CAMN TAC,[-1]
	JRST SATPNT
	CAMN TAC,[-2]			;THIS IS SET FOR ASYNC ERRORS
	JRST NSWAP
	PUSHJ P,DISMES
	ASCIZ/JOB = /
	HRRZ TAC,DXJ
	PUSHJ P,DISDCP
	SKIPL DXJ
	JRST NSWAP1
	PUSHJ P,DISMES
	ASCIZ/ SWAP/
NSWAP1:
	PUSHJ P,DISERR
	[ASCIZ/  DXS = /]
	DISARG OCT,DXS
	[ASCIZ/  DXW = /]
	DISARG OCT,DXW
	-1
	JRST NSWAP

SATPNT:
	PUSHJ P,DISMES
	ASCIZ/SAT TABLE/
NSWAP:
	PUSHJ P,DISERR
	[ASCIZ/
CONI BITS = /]
	DISARG OCT,CNISAV
	[ASCIZ/
/]
	-1
	PUSHJ P,DISMES
	ASCIZ/PACK = /
	LDB TAC,[POINT 3,LSTAT,11]	;GET DEVICE ADDRESS
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ/  CYL = /
	LDB TAC,[POINT 16,SKDAT,31]
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ/  HD = /
	LDB TAC,[POINT 8,SKDAT+1,15]
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ/  REC = /
	LDB TAC,[POINT 8,SCDAT+1,7]
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ/
/
	SKIPN HAFLAG			;HOME ADDRESS TO PRINT?
	JRST NOHA
	PUSHJ P,DISMES
	ASCIZ/HA CYL = /
	LDB TAC,[POINT 16,HA,23]
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ/  HA HD = /
	LDB TAC,[POINT 8,HA+1,7]
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ/
/
NOHA:
	MOVEI UUO,0			;START WITH CLASS 0
CLLOP:
	SKIPN ERRCL0(UUO)		;ANY ERRORS OF THIS CLASS
	JRST NOCL			;NO
	PUSHJ P,DISERR
	[ASCIZ/C/]
	DISARG DEC,UUO
	[ASCIZ/ = /]
	DISARG DEC,ERRCL0(UUO)
	[ASCIZ/  /]
	-1
NOCL:
	CAIGE UUO,4			;HIGHEST COUNTING CLASS?
	AOJA UUO,CLLOP
	SKIPN DEATH
	JRST NODIE
	PUSHJ P,DISMES
	ASCIZ/   DEATH/
NODIE:
	PUSHJ P,DISMES
	ASCIZ/
/
	SKIPN SNSTYP
	JRST TYPDON			;NO SENSE DATA, GO CHECK FOR ERRORS
	PUSHJ P,DRIVEP			;PRINT DRIVE ID
	PUSHJ P,DISMES
	ASCIZ/  SENSE DATA =
/
	MOVE UUO,[POINT 8,SNSDAT]
	PUSH P,[0]
SNSLOP:
	ILDB TAC,UUO
	JUMPE TAC,NULSNS
	PUSH P,TAC
	PUSHJ P,DISERR
	DISARG DEC,-2(P)
	[ASCIZ/ = /]
	DISARG LOC,-1(P)
	[ASCIZ/
/]
	-1
	POP P,(P)
NULSNS:
	AOS TAC,(P)
	CAIGE TAC,SNSLEN
	JRST SNSLOP
	POP P,(P)
TYPDON:
	PUSHJ P,DISMES
	ASCIZ/


/
ERRGO:
	SKIPN CSTOP
	JRST NOSTOP
	PUSHJ P,DISMES
	ASCIZ/DO SOMETHING ABOUT IT, THEN PUSH CONTINUE.


/
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	HALT .+1
NOSTOP:
	POPACS
	PUSHJ P,BLAST		;MAKE SURE ERROR GOES AWAY!
	SKIPN DEATH
	POPJ P,			;DIDN'T DIE, TRY AGAIN RETURN
	MOVE TAC1,DSKACS+DDB		;GET DDB ADDRESS
	MOVEI AC3,IODERR	;START WITH DEVICE ERROR
	MOVE TAC,ERRCL2		;GET DATA ERROR COUNT
	CAML TAC,MAXCL2		;OVER MAX LIMIT?
	TRO AC3,IODTER		;YES, GIVE DATA ERROR ALSO
	IORM AC3,DEVIOS(TAC1)
	JRST CPOPJ1		;GIVE ERROR RETURN

DRIVEP:
	PUSHJ P,DISMES
	ASCIZ/DRIVE /
	LDB TEM,[POINT 6,SNSDAT+1,7]
	JUMPN TEM,ISKNWN	;UNKNOWN?
	PUSHJ P,DISMES		;YES
	ASCIZ/UNKNOWN/
	POPJ P,

ISKNWN:
	ANDI TEM,7			;JUST THE IMPORTANT BITS
	ADDI TEM,"A"
	JRST DISTYO

;ERROR CLASS DESCRIPTIONS
;CLASS 0:		       BYTE    BIT
;	INVALID TRACK FORMAT	1	1
;	END OF CYLINDER		1	2
;	NO RECORD FOUND		1	4
;	FILE MASK VIOLATION	1	5
;	OPERATION INCOMPLETE	1	7
;	TOO MANY LOSING SEARCHES
;	DATA CHAIN ERROR (CHANNEL CONI)
;	ATTENTION (STATUS BYTE)
;	BUSY (STATUS BYTE)
;	UNIT EXCEPTION (STATUS BYTE)
;	COMMAND REJECT		0	0
;		AND NOT:
;			WRITE INHIBITED
;			DIAG LOAD INVALID DATA
;			DIAG WRITE ERROR

;CLASS 1:
;	BUS OUT PARITY		BYTE 0 BIT 2
;	SELECT ERROR (CHANNEL CONI)
;	NXM (CHANNEL CONI)
;	PARITY ERROR (CHANNEL CONI, CORE TO DISK)
;	SENSE FAILED (ERROR ON SENSE AFTER UNIT CHECK)
;	EQUIPMENT CHECK		BYTE 0 BIT 3
;		AND NOT:
;			SEEK CHECK
;			RETRY ABORTED

;CLASS 2:
;	DATA CHECK		BYTE 0 BIT 4

;CLASS 3:
;	SEEK CHECK		BYTE 0 BIT 3  BYTE 7 = 32 OR 33 (OCTAL)

;CLASS 4:
;	OVERRUN			BYTE 0 BIT 5
;	RETRY ABORTED		BYTE 0 BIT 3  BYTE 7 = 6

;ERROR CLASS HANDLERS
ERROR0:
	TDZA TAC1,TAC1		;CLASS 0
ERROR1:
	MOVEI TAC1,1		;CLASS 1
ERRORX:
	AOS DSKFLG		;INDICATE ERROR SEEN
	AOS TOTCL0(TAC1)
	AOS TAC,ERRCL0(TAC1)
	CAMGE TAC,MAXCL0(TAC1)	;TOO MANY?
	JRST TYTST
	AOS DEATH
	JRST TYPIT

TYTST:
	TDNE TAC,TYMSK0(TAC1)	;SHOULD WE TYPE THIS ONE?
	SKIPE TYPCL0(TAC1)	;OR MAYBE ALL OF THEM?
TYPIT:
	AOS TYPANY		;TYPE OUT
	POPJ P,

ERROR2:
	AOS DSKFLG
	AOS TOTCL2
	AOS TAC,ERRCL2
	CAML TAC,MAXCL2
	JRST TBAD
	MOVEI TAC1,2		;CLASS 2
	JRST TYTST

TBAD:
	AOS DEATH
	AOS TYPANY
	JRST	MRKBAD		;JUMP TO DSKSER TO MARK A BAD TRACK

ERROR3:
	MOVEI TAC1,3		;CLASS 3
	PUSHJ P,ERRORX		;COUNT AND TEST DEATH AND TYPING
	SETZM ERRHA		;NOW SETUP FOR READ HA AND RECAL.
	SETZM ERRRCL
REHA:
	PUSHJ P,BLAST		;CLEAR CHANNEL FOR READ HA
	CONO IBM,CNEWST!CLREND!ACTCLR
	CONO PMP,NEWST!UNEND!10!DSKCHN
	DATAO PMP,[HA]
	DATAO IBM,RDHACM
	PUSHJ P,ISYNC
	JRST REHA
	CAIA
	JRST DORCLA
	CONO IBM,2
	AOS TAC,ERRHA
	CAMGE TAC,MAXHA
	JRST REHA
	AOS TYPANY
	AOS CSTOP
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ/READ HOME ADDRESS LOST!
/
	POPACS
	POPJ P,

DORCLA:
	SETOM HAFLAG
DORCL:
	PUSHJ P,BLAST
	CONO IBM,CNEWST!CLREND!ACTCLR
	CONO PMP,NEWST!UNEND!10!DSKCHN
	DATAO IBM,RCALCM
	PUSHJ P,ISYNC
	JRST DORCL
	JRST ERRCAL
	MOVE TAC,PMPCNI
	TRNE TAC,DEVEND			;DEVICE END YET?
	POPJ P,				;YES, DONE
	CONO IBM,ACTCLR			;GO AWAY
	PUSHJ P,ISYNC
	JRST DORCL
	JRST ERRCAL
	MOVE TAC,PMPCNI
	TRNE TAC,DEVEND			;BETTER HAVE IT NOW
	POPJ P,
ERRCAL:
	CONO IBM,2
	AOS TAC,ERRRCL
	CAMGE TAC,MAXRCL
	JRST DORCL
	AOS TYPANY
	AOS CSTOP
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ/RECALIBRATE FAILED!
/
	POPACS
	POPJ P,

ERROR4:
	MOVEI TAC1,4
	JRST ERRORX

ERROR5:
	AOS DSKFLG
	LDB TAC,[POINT 3,LSTAT,11]
	CAIG TAC,FPACKS-1
	JRST SYSLOS
	AOS DEATH			;ERROR BIT TO LOSER!!!!
	MOVEI TAC,IOIMPM		;USE IMPROPER MODE BIT TO INDICATE OFF LINE OR WRITE LOCK
	MOVE TAC1,DSKACS+DDB
	IORM TAC,DEVIOS(TAC1)
	POPJ P,

SYSLOS:
	TRNN UUO,WRTINH			;WRITE INHIBITED?
	JRST SYSLOX			;NO, MUST BE OFF LINE
	PUSHJ P,DISMES
	ASCIZ/PACK IN WRITE LOCK!
/
SYSLOZ:
	AOS TYPANY
	AOS CSTOP
	POPJ P,

SYSLOX:
	LDB TAC,[POINT 6,SNSDAT+1,7]	;DRIVE ID
	JUMPE TAC,SYSLOY
	PUSHJ P,DISMES
	ASCIZ/DRIVE NOT READY!
/
	JRST SYSLOZ

SYSLOY:
	PUSHJ P,DISMES
	ASCIZ/ID PLUG NOT INSTALLED!
/
	JRST SYSLOZ

SENSE:
	SETZM ERRSNS
SENSE1:
	PUSHJ P,BLAST
	CONO IBM,CNEWST!CLREND!ACTCLR
	CONO PMP,NEWST!UNEND!10!DSKCHN
	DATAO PMP,SNWCMA
	DATAO IBM,SNSCMD
	PUSHJ P,ISYNC
	JRST SENSE1
	CAIA
	JRST CPOPJ1
	AOS TAC,ERRSNS
	CAML TAC,MAXSNS		;TOO MANY?
	POPJ P,			;LOSE BIG
	JRST SENSE1

BLAST:
	MOVEI TAC,10000
	CONSO PMP,IDLE		;TRY TO WAIT FOR PMP TO BECOME IDLE!
	SOJG TAC,.-1
	CONO IBM,CRESET!CNEWST!CLREND!ACTCLR	;NOW RESET CHANNEL
	MOVEI TAC,1000		;LET HIM COOL OFF
	SOJG TAC,.
	POPJ P,			;LET'S HOPE THAT'S ENOUGH

;HIGH PRIORITY INTERRUPT CODE (HPIC)
	JSR 0,D2X			;DUMMY FOR FUNNY ERRORS
↑D2IGO:	DATAO PMP,SKWCMA		;ISSUE SEEK COMMAND
	DATAO IBM,SKCMD
SKSRCH:
	MOVNI TAC,RCPBLK*3
	MOVEM TAC,CT			;INITIALIZE LOSING SEARCH COUNT
	SETOM LSTREC			;NO BACKUP FROM HERE
	DATAO PMP,SCWCMA
	DATAO IBM,SCCMD
	JSR 0,D2X
DOCMD:
	DATAO PMP,XWCMA
	DATAO IBM,XCMD
	JSR 1,D2X
	TRNN TAC,STMOD			;SUCCESSFUL SEARCH?
	JRST RESRCH			;NO
	AOS WCT				;INC WINNING SEARCHES
READDN:
					;ENTER HERE FROM READ AFTER READ
	LDB TAC,[POINT 8,SCDAT+1,7]	;GET LAST RECORD NUMBER
	MOVE TAC,RCLTAB(TAC)		;GET WCMA INCREMENT FOR THIS RECORD.
	ADD TAC,XWCMA			;INC WCMA
	XCT ENDTST			;CHECK FOR WC COUNTED OUT
	JRST D2FIN			;IT'S OUT. WE'RE DONE
	MOVEM TAC,XWCMA			;ONLY AFTER IT'S NOT THE END, STORE XWCMA
	MOVE TAC,SCDAT+1		;GET RECORD NUMBER FROM SEARCH COMMAND
	MOVEM TAC,LSTREC		;LAST SUCCESSFUL RECORD
	MOVSI TAC,(<BYTE(8)1>)
	ADDB TAC,SCDAT+1		;INCREMENT RECORD NUMBER FOR SEARCH
	CAMG TAC,[BYTE(8)RCPTRK-1]	;TRACK OVERFLOW?
	JRST READON			;SAME TRACK. CHAIN TO READ OF NEXT RECORD
	SKIPL DSKLRN
	JRST D2EOD			;FILE SYSTEM - NOT ALLOWED TO WRAP AROUND
	MOVE TAC,XWRAP			;THIS IS RECORD TO WRAP TO (SET UP AT CADDR)
	MOVEM TAC,SCDAT+1
	MOVE TAC,[BYTE(16)1]		;PREPARE TO INC HEAD BY 1
	ADDB TAC,SKDAT+1
	CAMG TAC,[BYTE(16)TRKCYL-1]	;OVERFLOW CYLINDER?
	JRST SKOK			;NO, START SEEK
	MOVEI TAC,1⊗4			;INC CYLINDER ADDRESS
	ADDM TAC,SKDAT
	SETZM SKDAT+1			;WRAP TO HEAD 0
	LDB TAC,[POINT 3,SKCMD,21]	;PACK NUMBER
	MOVE TAC,NCYLSH(TAC)		;<NUMBER CYLS THIS PACK>⊗4
	CAMG TAC,SKDAT			;OFF END OF PACK?
	JRST D2EOD			;YES, ALWAYS ERROR
SKOK:
	HLRZ TAC,SKDAT+1
	LSH TAC,4
	HRL TAC,SKDAT
	LSH TAC,-2
	MOVEM TAC,SCDAT			;SET UP SCDAT FROM CYL IN SKDAT AND HD IN +1
	DATAO PMP,SKWCMA
	DATAO IBM,SKCMD
	JSR 2,D2X
	JRST SKSRCH

;MORE HPIC
D2EOD:
	SETOM D2LUZ
D2FIN:
	DATAO IBM,NOPCMD
	JSR 2,D2X
	SETOM D2DONE		;FLAG OP COMPLETE TO DSKCHN
LSRCH:
	CONO PMP,NEWST!UNEND!10!DSKCHN
	JSR 2,D2X
	JRST D2BARF

RESRCH:
	DATAO IBM,NOPCMD	;SEND NOOP TO STOP CHAINING AFTER FAILING SEARCH
	AOS LCT
	AOSL CT
	JRST LSRCH		;TOO MANY LOSING SEARCHES!
	DATAO PMP,SCWCMA
	DATAO IBM,SCCMD
	JSR 1,D2X		;LAST OP WAS SEARCH
	SETOM LSTREC		;RETRYING SEARCH, NO BACKUP
	JRST DOCMD

;OLD CODE, DO SEARCH AFTER WRITE
SRCLUP:
	MOVNI TAC,RCPBLK*3
	MOVEM TAC,CT
	DATAO PMP,SCWCMA
	DATAO IBM,SCCMD
	JSR 2,D2X		;LAST OP WAS WRITE
	SETOM LSTREC		;READ DONE, NO BACKUP
	JRST DOCMD

;NEW CODE, CHAIN READ FROM READ
READON:
	MOVE TAC,XCMD		;READ OR WRITE?
	TRNE TAC,1
	JRST SRCLUP		;WRITE. MUST ALWAYS CHAIN WRITE FROM SEARCH
	DATAO PMP,XWCMA		;BUT, READ CAN BE CHAINED FROM READ
	DATAO IBM,XCMD
	JSR 2,D2X		;LAST OP WAS READ
	SETOM LSTREC		;READ DONE, NO BACKUP
	JRST READDN		;LEAP IN HERE

;TABLE OF WCMA INCREMENTS CORRESPONDING TO EACH RECORD OF A TRACK.
RCLTAB:

REPEAT BKPTRK,<
	SECSIZ,,SECSIZ
REPEAT RCPBLK,<
	RECSIZ,,RECSIZ
>
>

BEND DSKINT

↑IXINT←IXINT

BEND DSKSER
;: DSKINT[J17,SYS] EOF.
;: DTCSER[J17,SYS]
COMMENT ⊗   VALID 00029 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	BEGIN DTCSER - DECTAPE SERVICE ROUTINE
C00006 00003	DECTAPE DISPATCH TABLE
C00008 00004	RENAME UUO ROUTINE
C00013 00005	ROUTINE TO MOVE 4 WORD DIRECTORY ENTRY FROM USER
C00014 00006	ROUTINE TO SEARCH DIRECTORY FOR ENTER AND LOOKUP
C00016 00007	DUMP OUTPUT UUO ROUTINE
C00017 00008	DUMP INPUT UUO ROUTINE
C00020 00009	OUTPUT UUO ROUTINE -BUFFERED
C00023 00010	WRITE BLOCK 1 - COPY USER BUFFER INTO EXEC DIRECTORY CORE BUFFER
C00024 00011	INPUT UUO ROUTINE - RING BUFFERED
C00027 00012	ILLEGAL BLOCK NO.
C00029 00013	COMMON ROUTINE TO CHECK INTERLOCK, INITIALIZE
C00031 00014	ROUTINE TO CHECK IF DIRECTORY IN CORE
C00033 00015	CLOSE UUO
C00034 00016	UTPCLR UUO - CLEAR DECTAPE DIRECTORY
C00037 00017	USETI UUO - SET NEXT INPUT BLOCK NO TO READ
C00039 00018	UGETF UUO - GET NEXT FREE BLOCK NO.
C00040 00019	READ BLOCK NOS.
C00043 00020	HERE WHEN BLOCK NO.FOUND FOR DUMP OUTPUT
C00045 00021	HERE WHEN BLOCK NUMBER FOUND FOR BUFFERED WRITING
C00046 00022	HERE WHEN BLOCK NUMBER FOUND FOR BUFFERED INPUT
C00048 00023	WRITE 1 BLOCK IN REVERSE DIRECTION
C00049 00024	↑ENPT0:	JSR ENPT1
C00051 00025	HERE ON INTERRUPTS ON DECTAPE CONTROL AFTER DATA TRANSMITTED
C00055 00026	STOP TAPE AND DESELECT THIS UNIT BEFORE GOING TO ANOTHER UNIT
C00058 00027	INTERRUPT ON DT CHANNEL WHILE READING BLOCK NOS. ON DC CHANNEL
C00060 00028	HERE ON EACH OF 5 TYPES OF HARDWARE DETECTED ERRORS
C00062 00029	DTREDO:	SKIPE TAC,ERRFLG	CLEAR ERROR COUNT,DID DC MISS DATA?
C00065 ENDMK
C⊗;

BEGIN DTCSER - DECTAPE SERVICE ROUTINE
SUBTTL DTCSER	8 SEPT 67

;SPECIAL I/O STATUS BITS

RBNTRY←←20	;NUMBER OF TIMES HE CAN

UDIREN←←200	;DIRECTORY HAS BEEN ENTERED INTO BY ENTER UUO
UNWFRE←←400	;FREE BLOCK POINTER HAS BEEN CHANGED IN CORE
ULINKF←←1000	;LAST OUTPUT BLOCK LINKED TO FREE STORAGE
UDMPO←←2000	;DUMP OUTPUT AS OPPOSED TO BUFFERED OUTPUT
UDMPI←←4000	;DUMP INPUT AS OPPOSED TO BUFFERED INPUT
UREV←←10000	;UNIT LAST WENT IN REVERSE DIRECTION
URDIR←←20000	;READING DIRECTORY(BLOCK 1)
UDSD←←100	;SUPPRESS DIRECTORY HANDLING (RH IOS). SET BY
		;INIT OR SETSTS. CLEARED BY SETSTS OR RELEASE.

;CONO BITS FOR UTC

SL←←220000	;TURN ON, SELECT UNIT
DTR←←3000	;START/STOP DELAY (300 MS)
DT←←2000	;TURN AROUND DELAY (160 MS)
RDS←←1000	;RESELECT DELAY (20 MS)
RD←←300		;READ DATA
WD←←700		;WRITE DATA
RB←←200		;READ BLOCK NOS.
GR←←10000	;GO IN REVERSE DIRECTION(BACKWARDS)
JDE←←40000	;JOB DONE ENABLE
EE←←100000	;ENABLE END FLAG
TFE←←4000	;TIME FLAG ENABLE

DCIN←←4010+DCTCHN
DCOUT←←3410+DCTCHN

;DECTAPE DISPATCH TABLE



	JRST DTCINI	;INITILIZE
	JRST DTC1	;DEVICE HUNG TIME OUT, STOP TAPE, AND JOB
↑DTCDSP:
	JRST UTPREL	;RELEASE
	JRST UTPCLS	;CLOSE
	JRST UOUT	;OUTPUT - BUFFERED
	JRST UIN	;INPUT - BUFFERED
	JRST UENTER	;ENTER FILE NAME IN DIRECTORY
	JRST ULOOK	;LOOKUP FILE NAME IN DIRECTORY
	JRST UOUTD	;OUTPUT - DUMP MODE
	JRST UIND	;INPUT - DUMP MODE
	JRST SETO	;USETO - SET NEXT OUTPUT BLOCK NO.
	JRST SETI	;USETI - SET NEXT INPUT BLOCK NO.
	JRST GETF	;UGETF - GET NEXT FREE BLOCK NO.
	JRST DTCREN	;RENAME - CALL NEW ROUTINE - RPH
	POPJ PDP,	;CLOSE - INPUT
	JRST UTPCLR	;UTPCLR - CLEAR DIRECTORY (CALL [SIXBIT /UTPCLR/]
	POPJ PDP,	;MTAPE - IGNORE ON DECTAPE

;INITIALIZE DECTAPE


DTCINI:
	CONO DTC,0	;CLEAR CONTROL
	HLLZS DTCCON	;CLEAR CONSO FLAGS
	CONO DC,0	;CLEAR DATA CONTROL
IFE MTCNUM,<		; IF MAG TAPES IN SYSTEM, THEY
			; WILL SET UP DCLOC AND DCLOC1
	MOVEI TAC,40+DCTCHN*2
	CONSZ APR,MAOFF
	ADDI TAC,100
	MOVEM TAC,DCLOC
	ADDI TAC,1
	MOVEM TAC,DCLOC1
>
	POPJ PDP,

;RENAME UUO ROUTINE

DTCREN:
	TRNE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST CPOPJ1		;YES, GIVE SUCCESS RETURN
	SKIPE TAC,CURENT(DDB)	;PICK UP CURRENT ENTRY POINTER AND CHECK
	SKIPN (TAC)		;AND MAKE SURE ITS THERE
	POPJ P,			;ERROR RETURN
	MOVSI IOS,UDIREN	;MAKE SURE DIRECTORY GETS OUT
	IORB IOS,DEVIOS(DDB)
	XCTR	XR,[SKIPN (UUO)]	;DELETING?
	JRST	DTCDEL			;YES
	XCTR	XR,[MOVE TAC1,(UUO)]
	MOVEM	TAC1,(TAC)
	XCTR	XR,[MOVE TAC1,1(UUO)]
	HLLM	TAC1,1(TAC)
	XCTR	XR,[MOVE TAC1,2(UUO)]
	MOVEM	TAC1,2(TAC)
	XCTR	XR,[MOVE TAC1,3(UUO)]
	MOVEM	TAC1,3(TAC)
	JRST	CPOPJ1

DTCDEL:
	SETZM CURENT(DDB)		;CLEAR CURRENT ENTRY POINTER SINCE WE ARE DELETING IT
	HRLI TAC,4(TAC)		;PREPARE TO BLT DOWN OVER THIS ENTRY
	HRRZ TAC1,UDIR(DDB)	;ADDR OF DIRECTORY
	BLT TAC,177(TAC1)	;BLT DIR DOWN
	SETZM 177(TAC1)		;CLEAR END IN CASE WASN'T 0
	SETZM 176(TAC1)
	SETZM 175(TAC1)
	SETZM 174(TAC1)
	JRST CPOPJ1

;LOOKUP UUO ROUTINE

;CALL:	LOOKUP D,E
;	NOT FOUND IN DIRECTORY RETURN
;	FOUND

;C(E)=LEFT JUSTIFIED SIXBIT FILE NAME
;C(E+1)=LH=LEFT JUSTIFIED 3 CHAR. SIXBIT FILE NAME EXTENSION
;  RH=FIRST BLOCK NO. IN FILE
;C(E+2)=RIGHT 12 BITS=DATE FILE WAS CREATED
;C(E+3)=BLKI POINTER FOR DUMPE SAVE-GET FILES



ULOOK:
	TRNE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST CPOPJ1		;YES.
	SETZM CURENT(DDB)		;CLEAR CURRENT ENTRY POINTER
	PUSHJ PDP,UDIRSH	;NO. SEARCH DIRECTORY
	POPJ PDP,		;NOT FOUND ERROR RETURN
	HRR DAT,1(TAC)		;FIRST BLOCK OF FILE
	HRRZM TAC,CURENT(DDB)	;SAVE REL ADDR OF CURRENT ENTRY
	HRRM DAT,DTNEXT(DEVDAT)	;SET NEXT INPUT BLOCK NO.
	TLZ TAC,-1		;CLEAR INDEX FIELD, DIRECTORY IS ABSOLUTE
	MOVE DAT,UUO		;SETUP DESTINATION POINTER
	JRST BLTENT		;BLOCK TRANSFER 4 WORD ENTRY


;ENTER UUO ROUTINE

UENTER:
	TRNE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST CPOPJ1		;YES. GIVE SUCCESSFUL RETURN
	SETZM CURENT(DDB)		;CLEAR CURRENT ENTRY POINTER
	SKIPN @UUO		;NO. NULL NAME?
	POPJ PDP,		;YES. ERROR
	PUSHJ PDP,UDIRSH	;NO. SEARCH DIRECTORY.
	JRST UENTE1		;NOT IN DIRECTORY.
	SKIPL 3(TAC)		;IN DIRECTORY. IS IT A DUMP FILE?
	JRST UENTE1		;NO
	ADDI UUO,3		;YES, GET NEW BLKO POINTER
	MOVE TAC1,@UUO
	SUBI UUO,3
	JUMPGE TAC1,UENTE1	;IS THIS A LEGITIMATE BLKO POINTER?
	CAMGE TAC1,3(TAC)	;YES. IS NEW FILE SHORTER THAN OLD.
	JRST UENTE1		;NO.IT'S LONGER. PUT IT AT END OF TAPE
	HRRZ DAT,1(TAC)		;YES. RE-SAVE AT SAME SPOT ON TAPE
	CAME TAC1,3(TAC)	;SAME SIZE BLOCK?
	TLO IOS,UDIREN		;NO. SET UDIREN SO DIRECTORY WILL BE
				;WRITTEN ON RELEASE.
	JRST UENTE2
UENTE1:
	TLO IOS,UNWFRE+ULINKF+UDIREN	;FILE GOES AT END OF TAPE
	AOS DAT,UFREE(DEVDAT)	;GET FIRST FREE BLOCK
UENTE2:
	AOS UUO			;POINT TO SECOND DIRECTORY WORD IN USER AREA
	HRRZM TAC,CURENT(DDB)	;SAVE CURRENT ENTRY POINTER
	HRRM DAT,@UUO		;STORE FIRST BLOCK NO. OF FILE
	HRLM DAT,DTNEXT(DEVDAT)	;STORE NEXT BLOCK TO WRITE
	HRRZ DAT,TAC		;SET DESTINATION IN CORE DIRECTORY AREA
	SOS TAC,UUO		;SET SOURCE TO USER AREA
	MOVEM IOS,DEVIOS(DEVDAT)


;ROUTINE TO MOVE 4 WORD DIRECTORY ENTRY FROM USER
;AREA TO MONITOR OR VICE VERSA
;SOURCE IN AC TAC, DESTINATION IN AC DAT

BLTENT:
	NOSHUFFLE		;PREVENT CORE SHUFFLING DURING BLT
	MOVSI TAC1,@TAC		;SETUP ABS. SOURCE POINTER
	HRRI TAC1,@DAT		;SETUP ABS. DESTINATION POINTER
	MOVEI DAT,@DAT	;ABS. STOP ADDRESS
	BLT TAC1,3(DAT)
	MOVEI TAC,@TAC		;ABS. SOURCE ADDR.
	LDB TAC1,[POINT 12,2(TAC),35]	;GET SOURCE DATE
	JUMPN TAC1,BLTEN1	;IS IT ALREADY SET?
	MOVE TAC1,THSDAT	;NO, USE TODAYS DATE
	DPB TAC1,[POINT 12,2(DAT),35]	;AND SET DESTINATION DATE
BLTEN1:
	SHUFFLE		;ALLOW SHUFFLING AGAIN
	JRST CPOPJ1		;SKIP RETURN TO USER

;ROUTINE TO SEARCH DIRECTORY FOR ENTER AND LOOKUP
;CALL:	PUSHJ PDP,UDIRSH
;	NOT IN DIRECTORY RETURN
;	NORMAL RETURN WHEN ENTRY IS FOUND
;	NEVER RETURNS IF DIRECTORY FULL



UDIRSH:
	MOVEI AC1,3(UUO)	;IS LAST WORD IF ENTRY IN BOUNDS?
	PUSHJ PDP,UADCK1	;NEVER RETURN IF OUT OF BOUNDS
	PUSHJ PDP,DIRCHK	;CHECK IF DIRECTORY IN CORE
	HRRZ TAC,UDIR(DEVDAT)	;LOC. OF DIRECTORY
	HRRZ TAC1,(TAC)		;REL. ADR. OF 1ST ENTRY
	HRLI TAC,-=129+4(TAC1)	;ENTRY COUNTER
	ADDM TAC1,TAC		;START OF FIRST ENTRY
UDIR2:
	SKIPN TAC1,(TAC)	;FIRST WORD OF NEXT ENTRY
	POPJ PDP,		;FILE NOT IN DIRECTORY RETURN
	CAMN TAC1,@UUO		;CHECK IF EQUAL TO USER AREA
	AOJA UUO,UDIR4		;IS IS CHECK FILE EXTENSION
UDIR3:
	ADD TAC,[XWD 4,4]
	JUMPL TAC,UDIR2		;FINISHED YET?
	JRST TPOPJ		;YES ERROR RETURN TO USER(POP,POPJ)

UDIR4:
	HLRZ TAC1,@UUO
	SOS UUO
;	JUMPE TAC1,CPOPJ1	;MATCH IF USER EXT. IS ZERO
	HLRZ DAT,1(TAC)		;EXTENSION IN DIRECTORY
	CAIE DAT,(TAC1)		;EXTENSION MATCH?
	JRST UDIR3		;NO, KEEP LOOKING
	JRST CPOPJ1		;YES, SETUP RETURN

;DUMP OUTPUT UUO ROUTINE
;CALL:	OUTPUT D,ADR
;WHERE ADR IS START OF A COMMAND LIST OF FOLLOWING FORM:
;	IOWD N,LOC	;ARBITRARY NO OF THESE
;	XWD 0,LOC1	;ARBITRARYNO OF THESE
;	0



UOUTD:
	TLO IOS,IO+UDMPO	;FLAG OUTPUT AND DUMP-OUTPUT
	MOVEI TAC,DWRITE	;DISPATCH ADR. WHEN BLOCK NO. FOUND
	PUSHJ PDP,UINTER	;CHECK INTERLOCK AND INITIALIZE
	HLRZ TAC,DTNEXT(DEVDAT)	;NEXT OUTPUT BLOCK NO.
	TRNN IOS,UDSD		;SUPPRESSING DIRECTORY?
	CAILE TAC,1		;TRYING TO WRITE BLOCK 0 OR BLOCK 1
	JRST DFILL		;NO.
	JRST UTBERR		;YES, STOP TAPE AND PRINT ERROR MESSAGE

;DUMP INPUT UUO ROUTINE
;CALL:	INPUT D,ADR

UIND:
	TLZ IOS,IO		;FLAG INPUT IN PROGRESS
	TLO IOS,UDMPI		;AND INPUT DUMP
	MOVEI TAC,DREAD		;DISPATCH ADR. WHEN BLOCK NO. FOUND
	PUSHJ PDP,UINTER	;CHECK INTERLOCK
	HRRZ TAC,DTNEXT(DEVDAT)	;BLOCK NO. TO BE READ

DFILL:
	HRRM TAC,UBKN		;STORE FIRST BLOCK NO(LAST WILL BE CHECKED)
	MOVE TAC1,[JSR DMPADV]
	MOVEM TAC1,@DCLOC1	;WHERE TO GO WHEN BLKO/BLKI FINISHED
	MOVEI TAC1,16		;SET ERROR FLAGS(ALL EXCEPT INCOMPLETE BLOCK)
	HRRM TAC1,CONSZ1
	HRRZM PROG,UDPROG	;STORE JUST USER RELOCATION(FOR DMPADV)
	PUSHJ PDP,COMCHK	;CHECK ENTIRE DUMP COMMAND LIST
	JRST ADRER		;ADDRESS CHECK
	SKIPN @UUO		;IS COMMAND LIST EMPTY?
	JRST DTC1		;YES, STOP TAPE AND RETURN
	SOS DAT
	ASH DAT,-7		;CONVERT TO BLOCK COUNT-1
	ADDI DAT,@UBKN		;ADD FIRST BLOCKNO.
	TRNE IOS,UDSD		;NON-STANDARD TAPE?
	JRST .+3		;YES, DON'T CHECK BLOCK NO.
	CAILE DAT,1101		;LAST BLOCK TOO HIGH?
	JRST UTBERR		;YES
	TLNN IOS,IO		;OUTPUT?
	AOJA DAT,UMPIN		;NO, SET DAT TO NEXT BLOCK AFTER FILE
	HRRZ TAC,UFREE(DEVDAT)
	CAMGE DAT,TAC		;YES, GREATER THAN CURRENT FREE BLOCK?
	JRST IMPOT		;NO
	HRRM DAT,UFREE(DEVDAT)	;YES, SET LAST BLOCK USED
	AOS DAT			;SET DAT TO BLOCK NO. AFTER FILE
	HRLM DAT,DTNEXT(DEVDAT)	;SET NEXT BLOCK TO WRITE(AFTER THIS)
	TLOA IOS,UNWFRE		;FLAG AS MODIFIED
UMPIN:
	HRRM DAT,DTNEXT(DEVDAT)	;SET NEXT BLOCK TO READ
IMPOT:
	MOVEM IOS,DEVIOS(DEVDAT)
	MOVEI TAC,@UUO		;ABS. ADR. OF FIRST COMMAND
	MOVEM TAC,DMPLST	;STORE
	MOVE TAC,@DMPLST	;GET FIRST BLK POINTER
	ADDI TAC,(PROG)		;RELOCATE IOWD ADDRESS
	MOVEM TAC,DMPPTR	;SET DUMP BLKI/BLKO POINTER
	JRST FILL1		;GO START TAPE(FIRST BLOCK NO ALREADY STORED)

ADRER:
	PUSHJ PDP,DTC1		;GO RELEASE TAPE
	JRST ADRERR		;STOP JOB AND PRINT ADDRESS CHECK MESSAGE

;OUTPUT UUO ROUTINE -BUFFERED


UOUT:
	NOSHUFFLE
	MOVEI TAC,@DEVOAD(DEVDAT)
	SKIPN 1(TAC)		;WORD COUNT ZERO?
	JRST DTNOPO		;YES.
	SHUFFLE
	TLZ IOS,UDMPO+ULINKF	;CLEAR OUTPUT DUMP BIT
				;AND LINKED TO FREE STORAGE
	TLO IOS,IO		;FLAG THAT OUTPUT IS BEING DONE
	HLRZ TAC1,DTNEXT(DEVDAT)	;OUTPUT BLOCK NO. TO WIRTE
	TRNE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST UOUT2		;YES
	CAIN TAC1,1		;TRYING TO WRITE BLOCK 1?
	JRST UOUT4		;YES, COPY INTO MONITOR DIR. AREA
UOUT2:
	MOVEI TAC,WRITE		;SETUP DISPATCH WHEN CURRENT BLOCK NO. FOUND
	PUSHJ PDP,UINTER	;CHECK INTERLOCK

;HERE AT INTERRUPT LEVEL IF NEXT BUFFER READY WITH DATA TO GO OUT

UOUTGO:
	MOVEI TAC,@DEVOAD(DEVDAT)	;ABS. ADR. OF USER OUTPUT BUFFER
	MOVEM TAC,UBUF
	TLZ IOS,ULINKF		;FLAG THIS BLOCK NOT LINKED TO FREE STORAGE
	HLRZ TAC1,1(TAC)	;BLOCK TIE FROM BUFFER(NEXT BLOCK)
	JUMPN TAC1,UOUT1	;USE BLOCK NO.INDICATED IF NON ZERO
	TLO IOS,UNWFRE+ULINKF	;FLAG LINKED TO FREE STORAGE
	AOS TAC1,UFREE(DEVDAT)	;NEXT FREE BLOCK
UOUT1:
	MOVEM IOS,DEVIOS(DEVDAT)
				;STORE WHETHER THIS BLOCK
				;LINKED TO FREE STORAGE
				;AND FREE BLOCK POINTER
				;MODIFIED.
	TLZ TAC1,-1		;GET UFREE ALONE
	CAIN TAC1,1		;IF 1, THIS IS LAST BLOCK(SET BY CLOSE)
	MOVEI TAC1,0		;SET BLOCK TIE TO 0
	HRLM TAC1,1(TAC)	;IN USER BUFFER
	HLRZ TAC,DTNEXT(DEVDAT)	;BLOCK TO WRITE NOW
	HRLM TAC1,DTNEXT(DEVDAT)	;STORE BLOCK TO WRITE NEXT
	JRST FILL		;GO START TAPE

DTNOPO:
	SHUFFLE
	PUSHJ PDP,ADVBFE	;WORD COUNT WAS ZERO. IGNORE BUFFER
	JFCL
	POPJ PDP,		;RETURN TO UUOCON

;WRITE BLOCK 1 - COPY USER BUFFER INTO EXEC DIRECTORY CORE BUFFER



UOUT4:
	NOSHUFFLE		;NO SHUFFLING DURING BLT
	MOVEI TAC1,@DEVOAD(DEVDAT)	;ABS. ADR. OF USER BUFFER
	MOVSI TAC1,1(TAC1)	;SOURCE IS THIRD WORD OF USER BUFFER
	HRR TAC1,UDIR(DEVDAT)	;ADR. OF DIRECTORY BUFFER IN EXEC
	MOVE TAC,TAC1
	BLT TAC1,177(TAC)	;MOVE 200 WORDS FROM USER TO EXEC
	SETZM CURENT(DDB)	;THIS MAY NOT BE TRUE NOW!
	TLO IOS,UDIREN		;FLAG. DIR. ENTERED INTO
	MOVEM IOS,DEVIOS(DEVDAT)
	PUSHJ PDP,ADVBFE
	JFCL
	SHUFFLE		;ALLOW CORE SHUFFLING AGAIN
	JRST DIRCH1		;SET DVDIREN AND UFREE

;INPUT UUO ROUTINE - RING BUFFERED



UIN:
	TLZ IOS,UDMPI+IO	;CLEAR INPUT DUMP BIT AND FLAG AS INPUT
	HRRZ TAC,DTNEXT(DEVDAT)	;NEXT BLOCK TO READ
	TRNE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST UIN3		;YES
	CAIN TAC,1		;TRYING TO READ DIRECTORY?
	JRST UIN2		;YES, COPY CORE INTO USER AREA
UIN3:
	MOVEI TAC,READ		;SETUP DISPATCH WHEN BLOCK NO. FOUND
	PUSHJ PDP,UINTER	;NO,CHECK DECTAPE AND DATA CONTROL INTERLOCK

;HERE AT INTERRUPT LEVEL IF NEXT INPUT BUFFER READY FOR DATA

UINGO:
	MOVEI TAC,@DEVIAD(DEVDAT)	;ABS ADR OF USER BUFFER
	MOVEM TAC,UBUF
	HRRZ TAC,DTNEXT(DEVDAT)	;NEXT BLOCK TO READ

;HERE FROM OUTPUT UUO ALSO - BLOCK TO READ OR WRITE IN TAC

FILL:
	HRRM TAC,UBKN		;STORE BLOCK NO.TO READ OR WRITE
	TRNE IOS,UDSD		;NON-STANDARD TAPE?
	JRST FILL1		;YES. DON'T CHECK BLOCK NO.
	CAIL TAC,1102		;IS IT TOO LARGE?
	JRST UTBERR		;YES,ILLEGAL BLOCK NO.
FILL1:
	SETZM UERRCN		;CLEAR NO. OF ERRORS FOR THIS OPERATION
	SETZM ERRFLG		;CLEAR DC DATA MISSED FLAG
FILLER:
	MOVE TAC,[JSR RDBN]	;SETUP TO READ BLOCK NOS.
	MOVEM TAC,@DCLOC	;IN EVEN DC PI LOC
	PUSHJ PDP,STOIOS	;STORE IOS AND RESET HUNG DEVICE COUNT
	MOVEI TAC,RBNTRY	;NUMBER OF REVERSALS WE WILL ALLOW
	MOVEM TAC,RBNCNT
	MOVE TAC,DTUNIT		;GET UNIT NO + DTC CHANNEL
	CONO DC,DCIN		;SET TO READ BLOCK NOS FROM DECTAPE
	CONO PI,DCTON		;TURN DC PI CHANNEL ON
	CONSZ DTC,20000		;IS TAPE MOVING? (IE ARE WE AT INTERRUPT LEVEL)
	JRST FILLC		;YES
	TLNN IOS,UREV		;NO, WAS LAST DIRECTION REVERSE?
	IORI TAC,GR		;NO,REVERSE THIS TIME
	HRLI TAC,17		;CONSZ TEST FLAGS
	IORI TAC,SL+DTR+RB+EE	;CONO FLAGS
	STARTDV DTC
	POPJ PDP,		;RETURN

FILLC:
	CONSZ DTC,GR		;TAPE ALREADY MOVING, GOING BACKWARD?
	IORI TAC,DT		;YES,TURN AROUND DELAY
	CONO DTC,SL+RB+EE(TAC)	;MAKE GO FORWARD ALWAYS
	POPJ PDP,		;RETURN AT UUO LEVEL OR DISMISS INTERRUPT

;ILLEGAL BLOCK NO.


UTBERR:
	TRO IOS,IOBKTL		;SET IOBKTL TO INDICATE ILLEGAL BLOCK NO.
	JRST DTC1		;STOP TAPE AND DESELECT

;COPY CORE IF TRYING TO READ BLOCK 1



UIN2:
	PUSHJ PDP,DIRCHK	;CHECK IF DIRECTORY IN CORE
	MOVE TAC1,UFREE(DEVDAT)	;PLACE FREE BLOCK POINTER
	HRLM TAC1,@UDIR(DEVDAT)	;IN DIRECTORY
	NOSHUFFLE		;PREVENT CORE SHUFFLING DURING BLT
	MOVEI TAC,@DEVIAD(DEVDAT)	;ABS. OF 2ND WORD OF BUFFER
	MOVEI TAC1,1(TAC)	;BUFFER ADDRESS DESTINATION
	HRL TAC1,UDIR(DEVDAT)	;SOURCE
	BLT TAC1,200(TAC)	;MOVE DIRECTORY TO BUFFER
	PUSHJ PDP,ADVBFF	;ADVANCE INPUT BUFFER
	JFCL			;IGNORE IF NEXT ONE STILL FULL
	SHUFFLE
	POPJ PDP,

;COMMON ROUTINE TO CHECK INTERLOCK, INITIALIZE
;CALLED ONLY AT UUO LEVEL
;BITS IN IOS HAVE BEEN SET BUT NOT STORED
;TAC CONTAINS DISPATCH ADR. WHEN BLOCK NO. FOUND
;(READ,WRITE,DREAD,DWRITE)



DINTER:
	TLOA IOS,URDIR		;FLAG DIRECTORY OPERATION
UINTER:
	TLZ IOS,URDIR		;CLEAR DIRECTORY OPERATION BIT
	PUSHJ PDP,GETDCDT	;GET DATA CONTROL AND DECTAPE CONTROL
	AOSE	DTREQ		;ARGUMENT EXECUTED BY GETDCDT
	CONO DC,0		;TURN OFF DATA CONTROL
	HRRM TAC,BNDISP		;STORE DISPATCH ADR. WHEN BLOCK NO. FOUND
	LDB TAC,PUNIT		;UNIT NO. OF THIS DECTAPE
	LSH TAC,3		;SHIFT TO UNIT POSITION
	IORI TAC,DTCCHN		;OR IN DT CHANNEL
	MOVEM TAC,DTUNIT	;SAVE
	MOVEI TAC,116
	HRRM TAC, CONSZ1
	HLRE TAC,UFREE(DEVDAT)	;RESET BLOCK QUANTUM ALLOTMENT
	MOVEM TAC,BLKCNT	;LET THIS JOB READ THIS MANY BLOCKS
				;BEFORE SWITCHING TO ANOTHER JOB
				;AS LONG AS TAPE KEEPS MOVING
	MOVE TAC,[JSR ENPT]	;SETUP END FOR NON-DUMP DC OPERATIONS
	MOVEM TAC,@DCLOC1	;IN PI TRAP LOC+1
	PUSHJ PDP,SETACT	;SET DEV. ACTIVE FLAG AND STORE
				;IOS. ALSO RESET HUNG DEVICE TIME COUNT
	MOVEM DEVDAT,USVDB	;SAVE ADR. OF DEVICE DATA BLOCK
	MOVEM PROG,UPROG	;SAVE ABS.LOC. OF USER AREA
	POPJ PDP,

;ROUTINE TO CHECK IF DIRECTORY IN CORE
;IF NOT, IT IS READ IN


DIRCHK:
	TRNN IOS,UDSD		;DIRECTORY BEING SUPPRESSED?
	SKIPGE DEVMOD(DEVDAT)	;NO. DIRECTORY IN CORE?
	POPJ PDP,		;YES
	MOVEI TAC,READ		;DISPATCH ADR. WHEN BLOCK NO. FOUND
	PUSHJ PDP,UTPRL1	;READ DIR. AND RETURN WHEN FINISHED
	HRRZ TAC,@UDIR(DEVDAT)	;CHECK REL. POINTER TO FIRST DIR. ENTRY
	JUMPE TAC,DIRERR	;BAD IF ZERO
	CAIL TAC,174
	JRST DIRERR		;PRINT BAD DIRECTORY AND DO NOT RETURN
	TLZ IOS,UDIREN+ULINKF+UNWFRE	;BUT NOT ENTERED INTO, LINKED TO FREE
				;STORAGE, OR FREE BLOCK POINTER CHANGED
DIRCH1:
	MOVSI TAC,DVDIRIN	;SET DIRECTORY IN CORE BIT. CLEARED BY ASSIGN
	IORM TAC,DEVMOD(DEVDAT)
	HLRZ TAC,@UDIR(DEVDAT)	;LAST BLOCK WRITTEN
	HRRM TAC,UFREE(DEVDAT)	;SAVE IN DEVICE DATA BLOCK
	POPJ PDP,

;CLOSE UUO
;CALLED ONLY IF THIS USER CHANNEL HAS DONE OUTPUT



UTPCLS:
	SETZM CURENT(DDB)		;CLEAR CURRENT ENTRY POINTER
	LDB TAC,PIOMOD		;GET DATA MODE?
	CAIGE TAC,DR		;IS IT DR OR D(DUMP MODE)?
	TLNN IOS,ULINKF		;NO, NOT LINKED TO FREE STORAGE?
	POPJ PDP,		;YES, DO NOT WRITE OUT LAST BUFFERFUL
	MOVE TAC,DEVOAD(DEVDAT)	;ADR. OF USER OUTPUT BUFFER
	AOS TAC			;ADDRESS THIRD WORD
	MOVEI TAC1,1		;SET LINK TO 1 IN LH OF THIRD WORD
	HRLM TAC1,@TAC		;IN USER AREA(FLAG AS LAST BLOCK)
	JRST OUT		;DO OUTPUT

;UTPCLR UUO - CLEAR DECTAPE DIRECTORY

UTPCLR:
	TRNE IOS,UDSD		;DIRECTORY BEING SUPPRESSED?
	POPJ PDP,		;YES
	TLO IOS,UDIREN+UNWFRE	;NO. FLAG DIR. ENTERED INTO AND UFREE MODIF.
	MOVE TAC,UDIR(DEVDAT)	;INITIALIZE EXEC CORE DIRECTORY
	MOVE TAC1,[XWD 1,5]	;SET FIRST WORD IN DIRECTORY
	MOVEM TAC1,(TAC)	;LH=LAST BLOCK USED,RH=FIRST 
				;FREE REL. DIR. ENTRY.
	HRL TAC,TAC
	AOBJN TAC,.+1		;INCREMENT BOTH HALVES
	SETZM (TAC)		;CLEAR SECOND WORD
	MOVE TAC1,TAC
	AOS TAC
	BLT TAC,176(TAC1)	;CLEAR REST OF 200 WORD DIRECTORY
	PUSHJ PDP,DIRCH1	;SET DVDIRIN AND UFREE
				;ALWAYS WIRITE TAPE

;RELEASE UUO
;WRITE DIRECTORY IF CORE VERSION DIFFERS FROM TAPE VERSION(BLOCK 1)



UTPREL:
	TRZE IOS,UDSD		;SUPPRESSING DIRECTORY?
	JRST SETI1		;YES, STORE IOS AND RETURN
	SKIPG DEVMOD(DEVDAT)	;HAS ASSIGN COMMAND BEEN TYPED
				;SINCE DIRECTORY READ IN?
	TLZN IOS,UDIREN+UNWFRE	;NO, DIR. ENTERED INTO OR
				;FREE BLOCK POINTER MODIFIED?
	POPJ PDP,		;NO, DO NOT WRITE DIRECTORY
	MOVEI TAC,WRITE		;DISPATCH ADR. WHEN BLOCK NO. FOUND
UTPRL1:
	PUSHJ PDP,DINTER	;CHECK INTERLOCK AND FLAG DIRECT. OPER.
	MOVE TAC,UFREE(DEVDAT)	;NEW FREE BLOCK POINTER
	HRLM TAC,@UDIR(DEVDAT)	;STORE IN LH OF FIRST WORD OF DIR.
	HRRZ TAC,UDIR(DEVDAT)	;ADD. OF EXEC DIR. CORE BUFFER
	SOS TAC			;ADRRESS-1
	MOVEM TAC,UBUF		;STORE BUFFER ADR.
	MOVEI TAC,1		;WRITE (OR READ) BLOCK 1
	PUSHJ PDP,FILL		;GO START TAPE
	JRST WAIT1		;WAIT BEFORE RETURNING TO USER

;USETI UUO - SET NEXT INPUT BLOCK NO TO READ



SETI:
	PUSHJ PDP,BLKCHK	;CHECK FOR ILLEGAL BLOCK NO.
	PUSHJ PDP,WAIT1		;WAIT TILL ALL BUFFERS FILLED.
	TLZ IOS,IOEND		;CLEAR END OF FILE BIT
	TRZ IOS,IODEND		;SYSTEM AND USER
	HRRM UUO,DTNEXT(DEVDAT)	;STORE NEXT BLOCK TO READ IN DDB
SETI1:
	MOVEM IOS,DEVIOS(DEVDAT)
	POPJ PDP,

;USETO UUO - SET NEXT OUTPUT BLOCK NO. TO WRITE



SETO:
	PUSHJ PDP,BLKCHK	;CHECK FOR LILLEGAL BLOCK NO.
	PUSHJ PDP,WAIT1		;WAIT TILL ALL BUFFERS EMPTIED.
	HRLM UUO,DTNEXT(DEVDAT)	;SET NEXT BLOCK NO. IN DEVICE DATA BLOCK
	POPJ PDP,

;ROUTINE TO CHECK FOR ILLEGAL BLOCK NUMBER
;CALL MOVE UUO,BLOCK #
;	PUSHJ PDP,BLKCHK
;	RETURN IF BLOCK NO. OK

;IF NON-STANDARD TAPE (UDSD=1), ALL BLOCK NOS. ARE LEGAL
;OTHERWISE, IF UUO>1101, SETS IOBKTL AND RETURNS TO USER.

BLKCHK:
	TLZ UUO,-1		;CLEAR LEFT HALF UUO FOR COMPARE.
	TRNE IOS,UDSD		;NON-STANDARD TAPE?
	POPJ PDP,		;YES
	CAIG UUO,1101		;NO. LEGAL BLOCK NUMBER?
	POPJ PDP,		;YES
	TRO IOS,IOBKTL		;NO. SET IOBKTL, STORE IOS
	JRST SETI1		;AND RETURN TO USER.

;UGETF UUO - GET NEXT FREE BLOCK NO.
;IF DIRECTORY IS SUPPRESSED, RETURN XWD NEXT BLOCK TO WRITE,NEXT
; BLOCK TO READ.



GETF:
	PUSHJ PDP,WAIT1		;WAIT TILL DEVICE INACTIVE
	MOVE TAC,DTNEXT(DEVDAT)
	TRNE IOS,UDSD		;IS DIRECTORY BEING SUPPRESSED?
	JRST STOTAC		;YES
	PUSHJ PDP,DIRCHK	;CHECK TO SEE IF DIRECTORY IN CORE
	TLO IOS,UNWFRE		;FLAG FREE BLOCK POINTER ALTERED
	MOVEM IOS,DEVIOS(DEVDAT)
	AOS TAC,UFREE(DEVDAT)	;GET FREE BLOCK POINTER
	HRLM TAC,DTNEXT(DEVDAT)	;SET NEXT BLOCK TO WRITE
	TLZ TAC,-1
	JRST STOTAC		;STORE TAC IN USER AREA

;READ BLOCK NOS.



↑RDBN1:	MOVEM TAC,DTTAC
	EXCH DEVDAT,USVDB	;RESET HUNG DEVICE TIME COUNT
	LDB TAC,PDVTIM		;TIME IN SECONDS
	DPB TAC,PDVCNT		;COUNT DOWN TO 0 BEFORE HUNG
	EXCH DEVDAT,USVDB
	DATAI DC,TAC		;READ IN BLOCK NO. JUST READ
	ANDI TAC,7777		; FOR PDP-8 FORMAT TAPE, MASK OUT CRAP
	SUBI TAC,@UBKN		;COMPARE WITH DESIRED ONE
	JUMPE TAC,@BNDISP	;IS IT EQUAL?
	SOS BLKCNT		;DECREMENT COUNT OF BLOCKS READ
	JUMPL TAC,LOW		;NO,IS IT LESS THAN DESIRED?
	MOVE TAC,DTUNIT		;NO, UNIT NO.+DT CHANNEL
	CONSZ DTC,GR		;IS TAPE GOING BACKWARD?
	JRST BAKWRD
	SOSGE RBNCNT		;ANOTHER REVERESAL
	JRST RBNLOS		;TOO MANY!
	IORI TAC,DT		;NO,ADD IN DELAY TO CHANGE DIRECTION
BAKWRD:
	CONO DTC,SL+RB+GR+EE(TAC);MAKE TAPE GO BACKWARD
	JRST DXIT

LOW:
	MOVE TAC,DTUNIT		;POSITION IS BEFORE DESIRED
	CONSO DTC,GR		;IS TAPE GOING FORWARD
	JRST ISLOW
	SOSGE RBNCNT		;ANOTHER REVERSAL
	JRST RBNLOS		;TOO MANY!
	IORI TAC,DT		;NO, ADD IN DELAY TO CHANGE DIRECTION
ISLOW:
	CONO DTC,SL+RB+EE(TAC)	;MAKE TAPE GO FORWARD
DXIT:
	MOVE TAC,DTTAC
	CONO DC,DCIN		;SET DATA CONTROL TO READ BLOCK NOS.
	JEN @RDBN

RBNLOS:
	CONO DC,0		;SHUT OFF DATA CONTROL
	CONO PI,DCTOFF		;TELL PI ABOUT SHUTTING OFF DECTAPE
	CONO DTC,200000!JDE!TFE!DTR(TAC)	;SELECT, TURN OFF, SET DELAY, INTERRUPT AT END
	MOVEI	TAC,DTTRY	;MAKE SURE THAT WE
	MOVEM	TAC,UERRCN	;DON'T TRY AGAIN
	MOVEI	TAC,20		;TURN ON A BIT
	IORM	TAC,DTCCON	;WHERE CH.4 GETS TO TEST IT
	SETOM	ERRFLG		;MAKE SURE IT LOOKS LIKE AN ERROR!
	MOVE	TAC,DTTAC	;RESTORE TAC
	JEN	@RDBN		;DISMISS

;HERE WHEN BLOCK NO.FOUND FOR DUMP OUTPUT


DWRITE:
	MOVE TAC,DTUNIT		;UNIT+DT CHANNEL
	CONSZ DTC,GR		;TAPE GOING IN REVERSE?
	JRST BAKWRD		;YES, MAKE IT GO BACKWARD ONE MORE BLOCK
	CONO DC,DCOUT		;SET DATA CONTROL TO WRITE ON DC CHANNEL
	CONO DTC,SL+WD+JDE+EE(TAC)
	MOVE TAC,[BLKO DC,BLKPTR]	;IO INSTR. FOR PI LOC
	JRST DEXIT

;HERE WHEN BLOCK NO. FOUND FOR DUMP INPUT


DREAD:
	MOVE TAC,DTUNIT		;UNIT + DT CHANNEL
	CONSZ DTC,GR		;GOING BACKWARDS?
	JRST BAKWRD		;YES, MAKE IT GO BACKWARD ONE MORE BLOCK.
	CONO DTC,SL+RD+JDE+EE(TAC)	;NO, SET TO READ(JOB DONE ENABLED)
	MOVE TAC,[BLKI DC,BLKPTR]
DEXIT:
	MOVEM TAC,@DCLOC	;STORE BLKI/BLKO IN EVEN DC CHANNEL LOC.
	EXCH DEVDAT,USVDB	;SET HUNG DEVICE COUNT TO 60 SECONDS
	MOVEI TAC,=60		;SINCE DUMP MODE CAN TAKE A LONG TIME
	DPB TAC,PDVCNT
	EXCH DEVDAT,USVDB
	MOVE TAC,DMPPTR		;SETUP DUMP BLKI OR BLKO POINTER
	JRST BNEXIT

;HERE WHEN BLOCK NUMBER FOUND FOR BUFFERED WRITING


WRITE:
	CONO DC,DCOUT		;SET DC FOR WRITING ON DC CHANNEL
	MOVE TAC,DTUNIT		;DT UNIT+DT CHANNEL
	CONSO DTC,GR		;GOING BACKWARD?
	JRST WRFORW		;NO,WRITE FORWARD
	CONO DTC,SL+WD+GR+JDE+EE(TAC)	;YES, SET TO WRTIE REVERSED
	MOVE TAC,[JSR WTRV]	;PLACE TO GE FOR EVERY WORD
	JRST REVBLK		;SET BLKPTR FOR REVERSE

WRFORW:
	CONO DTC,SL+WD+JDE+EE(TAC)	;WRITE FORWARD(JOB DONE ENABLED)
	MOVE TAC,[BLKO DC,BLKPTR]	;BLKO POINTER FOR INTERRUPT LOCATION
	JRST FORBLK		;SET BLKPTR FOR FORWARD

;HERE WHEN BLOCK NUMBER FOUND FOR BUFFERED INPUT


READ:
	MOVE TAC,DTUNIT		;UNIT+UTC CHANNEL
	CONSO DTC,GR		;GOING BACKWARD?
	JRST RDFORW		;NO,READ FORWARD
	CONO DTC,SL+GR+RD+JDE+EE(TAC)	;YES, READ BACKWARD(JOB DONE ENB.)
	MOVE TAC,[JSR RDRV]	;PLACE TO GO FOR EACH WORD
REVBLK:
	MOVEM TAC,@DCLOC	;STORE JSR FOR REVERSE INTERRUPT ON EACH WORD
	MOVE TAC,UBUF		;ADDRESS OF BUFFER-1(SECOND WORD)
	ADDI TAC,200-1		;LAST ADDRESS OF 200 WORD BUFFER
	JRST BLKXIT		;STORE BLKI/BLKO POINTER

RDFORW:
	CONO DTC,SL+RD+JDE+EE(TAC)	;READ FORWARD(JOB DONE ENABLED)
	MOVE TAC,[BLKI DC,BLKPTR]	;BLKI POINTER
FORBLK:
	MOVEM TAC,@DCLOC	;STORE BLKI/BLKO IN INTERRUPT LOC.
	MOVE TAC,UBUF		;ADDRESS OF BUFFER
BLKXIT:
	HRLI TAC,-200		;WORD COUNT FOR 1 BLOCK
BNEXIT:
	MOVEM TAC,BLKPTR	;SOTRE BLKI OR BLKO POINTER
	MOVE TAC,DTTAC		;RESTORE TAC
	JEN @RDBN		;DISMISS DC CHANNEL INTERRUPT

;WRITE 1 BLOCK IN REVERSE DIRECTION

↑WTRV1:	BLKO DC,BLKPTR
	JSR ENPT1
	SOS BLKPTR
	SOS BLKPTR
	JEN @WTRV

;READ 1 BLOCK IN REVERSE DIRECTION

↑RDRV1:	BLKI DC,BLKPTR
	JSR ENPT1
	SOS BLKPTR
	SOS BLKPTR
	JEN @RDRV

↑ENPT0:	JSR ENPT1
	JEN @ENPT

;END OF BLKI OR BLKO BUFFERED IO
;OR END OF DUMP MODE COMAND LIST


↑ENPT2:	CONSZ DC,10000		;DATA MISSED?
	SETOM ERRFLG		;YES,SET FLAG
	CONSO DTC,400		;WRITING?
	CONO DC,0		;NO,READING TURN OFF DATA CONTROL
	CONO PI,DCTOFF		;TURN OFF DATA CONTROL CHANNEL
	JRST @ENPT1

;END OF BLKI OR BLKO DUMP MODE READING OR WRITING

↑DMPA0:	MOVEM TAC,DTTAC
	AOSA TAC,DMPLST
DMPA1:
	HRRZM TAC,DMPLST
	SKIPN TAC,(TAC)
	JRST DMPA3
	ADD TAC,UDPROG		;ADD XWD 0,USER RELOCATION
	JUMPGE TAC,DMPA1
	MOVEM TAC,BLKPTR	;SETUP DUMP MODE BLKI/BLKO POINTER
DMPA2:
	MOVE TAC,DTTAC
	JEN @DMPADV

DMPA3:
	JSR ENPT1
	JRST DMPA2

;HERE ON INTERRUPTS ON DECTAPE CONTROL AFTER DATA TRANSMITTED



↑DTCINT:	JSR DTCSAV		;SAVE REGISTERS.
	CONSO DTC,JDE		;JOB DONE ENABLED
			;(IE, READ-WRITING DATA OR WAITING
				;FOR TIME FLAG)
	JRST BN			;NO,MUST BE READING BLOCK NOS.
	CONSO	DTC,4000	;TIME FLAG ENABLED?
	JRST	DCCONO		;NO GO TURN OFF DATA CONTROL
	SKIPL	RBNCNT		;BLOCK NUMBER TRIES EXHAUSTED?
	JRST	UTIME		;NOPE, HONEST TIME FLAG ENABLING
	SETZM	RBNCNT		;SO WE DON'T GO THIS WAY AGAIN
	MOVEI	TAC,20		;SHUT OFF BIT THAT RBNLOS SET
	ANDCAM	TAC,DTCCON	;SHUT OFF BIT
DCCONO:
	CONO DC,0		;NO,TURN OFF DATA CONTROL
	MOVE DEVDAT,USVDB	;SETUP DEVICE DATA BLOCK ADDRESS
	MOVE PROG,UPROG		;USER RELOC, AND PROTECTION
	MOVE IOS,DEVIOS(DEVDAT)	;IO STATUS
	CONSO DTS,@CONSZ1		;ANY ERRORS?(16 FOR DUMP MODE)
	SKIPE ERRFLG		;NO,DATA CONTROL MISS DATA?
	JRST DTREDO		;YES,REDO OPERATION
	TLZE IOS,IOW		;NO, JOB IN IO WAIT?
	PUSHJ PDP,SETIOD	;YES,SET JOB TO RUN AGAIN
	TLZE IOS,URDIR		;READING DIRECTORY?
	JRST DTC1		;YES
	TLNN IOS,IO		;NO,OUTPUT?
	JRST UIN1		;NO
	TLNN IOS,UDMPO		;YES,OUTPUT DUMP MODE?
	PUSHJ PDP,ADVBFE	;NO,IS NEXT OUTPUT BUFFER NOT READY YET?
	JRST DTC1		;YES,STOP TAPE
	PUSHJ PDP,CHKCNT	;DECREMENT QUANTUM BLOCK COUNT.
				;FINISHED QUANTUM?
	JRST UOUTGO		;NO, GO OUTPUT NEXT BLOCK
	JRST DTC1		;YES, STOP TAPE AND LET OTHER USER HAVE IT

UIN1:
	TLNE IOS,UDMPI		;INPUT DUMP MODE?
	JRST DTC1		;YES, STOP TAPE
	MOVEI TAC, @DEVIAD(DEVDAT)	;NO,GET ABS. ADR OF 
				;BUFFER JUST READ INTO
	HLRZ TAC1,1(TAC)	;GET LINK TO NEXT BLOCK
	HRRM TAC1,DTNEXT(DEVDAT)	;STORE NEXT BLOCK TO READ
	JUMPN TAC1,.+2		;WAS THIS LAST BLOCK
	TLO IOS,IOEND		;YES,SET END OF FILE
	PUSHJ PDP,ADVBFF	;ADVANCE INPUT BUFFER
	JRST DTC1		;NOT EMPTIED BY USER YET,STOP TAPE
	TLNE IOS,IOEND		;WAS THIS LAST BLOCK?
	JRST DTC1		;YES, STOP TAPE
	PUSHJ PDP,CHKCNT	;NO, REDUCE QUANTUM BLOCK COUNT.
				;FINISHED QUANTUM?
	JRST UINGO		;NO, GO READ IN NEXT BLOCK
				;YES, STOP TAPE AND SCHEDULER WILL RUN WAITING JOB

;STOP TAPE AND DESELECT THIS UNIT BEFORE GOING TO ANOTHER UNIT




DTC1:
	CONSO DTC,20000		;IS TAPE MOVING? I.E., AT INTERRUPT LEVEL?
	JRST DTC2		;NO.
	SKIPG TAC,BLKCNT	;RESTORE BLOCK COUNT
	MOVEI TAC,BLKQNT
	HRLM TAC,UFREE(DEVDAT)
	MOVEI TAC,DTCCHN	;DTC PI CHANNEL
	TLO IOS,UREV		;REMEMBER DIRECTION, SET REVERSE BIT
	CONSO DTC,GR		;TAPE GOING FORWARDS?
	TLZA IOS,UREV		;YES, CLEAR REVERSE BIT
	TRO TAC,GR		;NO, PRESERVE DIRECTION FOR STOP CONO
	MOVEI TAC1,20	;ENABLE SOFTWARE FOR TIME FLAG ONLY
	HRRM TAC1,DTCCON
	CONO DTC,TFE+RDS+JDE(TAC)	;STOP TAPE AND ENABLE
				;TIME FLAG AND JOB DONE(AS A FLAG ONLY)
				;SO WONT THINK READING BLOCK NOS. AT
				;DTCINT+1 CONSO INSTRUCTION
DTC3:
	SOSL DCREQ		;DECREMENT DATA CONTROL REQUEST COUNT
	SETOM DCAVAL
	PUSHJ PDP,CLRACT	;CLEAR DEVICE ACTIVE FLAG, STORE IOS
	LDB ITEM,PJOBN
	TLNN DEVDAT,SYSDEV	;SYSTEM TAPE?
	POPJ PDP,		;NO
	HLRZ TAC,JBTSTS(ITEM)	;YES
	TRNN TAC,CMWB		;DELAY ↑C?
	POPJ PDP,		;NO
	JRST RELEA9		;YES. RELEASE SYSTEM TAPE.

DTC2:
	PUSHJ PDP,DTC3		;FREE DC AND SYSTEM TAPE
	SOSL DTREQ
	SETOM DTAVAL
	CONO DC,0
	CONO PI,DCTOFF
	CONO	DTC,0
	HLLZS	DTCCON
	POPJ PDP,


;CHECK BLKCNT. IF IT IS < 0 AND SOMEONE IS WAITING FOR THE
;DATA CONTROL OR DECTAPE CONTROL, STOP THE TAPE.

;CALL	PUSHJ PDP,CHKCNT
;	CONTINUEα;	STOP TAPE


CHKCNT:
	SOSLE BLKCNT		;COUNT RUN OUT?
	POPJ PDP,		;NO. CONTINUE
	SKIPN DCREQ		;YES. IS SOMEONE WAITING FOR DATA CONTROL?
	SKIPE DTREQ		;NO. DECTAPE CONTROL?
	AOS (PDP)		;YES. STOP TAPE.
	POPJ PDP,

;INTERRUPT ON DT CHANNEL WHILE READING BLOCK NOS. ON DC CHANNEL

BN:
	CONSZ DTS,2		;END OF TAPE FLAG?
	JRST ENDZON		;YES,REVERSE DIRECTION
			;MUST BE AN ERROR FLAG OF SOME SORT.
	JRST DCCONO		;YES, STOP TAPE

ENDZON:
	MOVE TAC,DTUNIT		;MUST BE READING BLOCK NOS.
	CONSO DTC,GR		;GOING BACKWARDS?
	IORI TAC,GR		;NO, MAKE IT GO BACKWARDS.
	CONO DTC,SL+RB+EE+DT(TAC)	;KEEP READING BLOCK NOS.
	CONO DC,DCIN		;SET DC TO READ BLOCK NOS. AGAIN.
	POPJ PDP,

;INTERRUPT FROM TIME FLAG AFTER STOP DEVICE



UTIME:

	SOSL DTREQ		;YES, REDUCE DECTAPE CONTROL REQUEST COUNT
	SETOM DTAVAL		;SOME OTHER JOB WAITING, SET AVAILABLE FLAG
				;FOR SCHEDULER
	CONO DTC,0		;CLEAR CONTROL(AND UTS)
	HLLZS DTCCON		;CLEAR CONSO UTS, FLAGS
	POPJ PDP,		;DISMISS INTERRUPT.


;HERE ON EACH OF 5 TYPES OF HARDWARE DETECTED ERRORS
;EACH OPERATION CAUSING AN ERROR IS TRIED "DTTRY" TIMES AS
;DEFINED ON THE CONFIGURATION
;A "FATAL ERROR" IS ONE WHICH FAILS DTTRY TIMES IN A ROW
;   THEN AND ONLY THEN THE IOS WORD IS SET APPROPRIATELY
;   TO INDICATE TO THE USER THAT AN ERROR HAS OCCURRED
;A RECORD OF ALL ERRORS(FATAL AND NON-FATAL) IS KEPT FOR
;ALL DRIVES COMBINED
;A RECORD OF EACH FATAL ERROR IS ALSO KEPT FOR EACH
;DRIVE AS WELL AS FOR ALL DRIVES COMBINED

;THE ERROR COUNT IS SPLIT INTO 5 FIELDS TO MAKE A TOTAL
;IF 36 BITS:
;THE 5 TYPES IF ERRORS ARE:
;ERROR COUNT	;IOS BIT	;DESCRIPTION
ECDERR←←1	;(RH)IODERR	;DC DETECTS DATA MISSED(DEVICE ERROR)
ECDTER←←1000	;(RH)IODTER	;PARITY ERROR(UTS)(DATA ERROR)
ECBKTL←←1	;(LH)IOBKTL	;INCOMPLETE BLOCK(UTS)(BLOCK TOO LARGE)
ECIMPM←←100	;(LH)IOIMPM	;TWO UNITS DIALED THE SAME
				;OR MARK TRACK ERROR, BOTH DETECTED
				;WHILE READING BLOCK NOS.(IMPROPER MODE)
ECIMP1←←10000	;(LH)IOIMPM	;ATTEMPT TO WRITE ON WRITE-LOCKED TAPE

DTREDO:
	SKIPE TAC,ERRFLG	;CLEAR ERROR COUNT,DID DC MISS DATA?
	MOVEI TAC,IODERR+ECDERR	;YES, CLEAR TAC,SET DEVICE ERROR 
				;FLAG, ERROR COUNT POSITION
	CONSZ DTS,10		;NO, PARITY ERROR?
	TRO TAC,IODTER+ECDTER	;YES, SET DATA ERROR FLAG+COUNT
	CONSZ DTS,100		;NO, INCOMPLETE BLOCK?
	TDO TAC,[XWD ECBKTL,IOBKTL]	;YES, SET BLOCK TOO LARGE+COUNT
	CONSO DTS,4		;NO, ILLEGAL OPERATION?
	JRST ERSTOP		;NO
	TRO TAC,IOIMPM		;YES, FLAG AS IMPROPER MODE
	CONSO DTC,JDE		;READING BLOCK NOS.(JOB DONE NOT ENABLED)?
	TLOA TAC,ECIMPM		;YES, 2 UNITS MUST BE DIALED THE SAME
	TLO TAC,ECIMP1		;NO, MUST BE WRITE LOCKED
ERSTOP:
	MOVE TAC1,TAC		;INCREMENT ERROR COUNT
	TRZ TAC1,IODERR+IODTER+IOBKTL+IOIMPM	;CLEAR OUT IOS ERROR BITS
	ADDM TAC1,DTOTAL	;ADD TO TOTAL ERROR COUNT FOR ALL UNITS
	AOS DAT,UERRCN		;INCREMENT ERROR COUNT
	CAIGE DAT,DTTRY		;EQUAL TO DTTRY YET?
	JRST DTRED1		;NO, TRY AGAIN
	ADDM TAC1,DFTOTAL	;ADD TO TOTAL FATAL ERROR COUNT
	ADDM TAC1,DTERR(DEVDAT)	;ADD TO FATAL COUNT FOR THIS UNIT
	TRZ TAC,ECDERR+ECDTER	;CLEAR RH COUNT BITS
	TRNE IOS,IOIMPM		;HAS USER BEEN TOLD ABOUT BAD OPERATION?
	TLZ IOS,URDIR		;YES. CLEAR URDIR SO WILL RETURN TO USER
	TRO IOS,(TAC)		;SET ERROR BITS IN IO STATUS WORD
	TLZE IOS,IOW		;JOB IN IO WAIT?
	PUSHJ PDP,SETIOD	;YES, START JOB UP AGAIN
	TLZN IOS,URDIR		;DIRECTORY ERROR?
	JRST DTC1		;NO, STOP TAPE WITHOUT SETTING BUFFER USE BIT
	PUSHJ PDP,DTC1
DIRERR:
	MOVSI TAC,DVDIRIN	;YES, CLEAR DIRECTORY IN CORE BIT
	ANDCAM TAC,DEVMOD(DEVDAT)
	LDB ITEM,PJOBN		;LOAD JOB NUMBER INTO ITEM.
	JRST BADDIR		;PRINT BAD DIRECTORY AND STOP JOB


DTRED1:
	LDB TAC1,PIOMOD
	CAIGE TAC1,16		;DUMP MODE?
	JRST FILLER		;NO
	TRNE TAC,IODTER+IODERR	;YES. PARITY OR DATA MISSED?
	SOS DMPLST		;YES. BACK UP POINTER
	JRST FILLER

BEND DTCSER
;: DTCSER[J17,SYS] EOF.
;: MTCSER[J17,SYS]
COMMENT ⊗   VALID 00022 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	BEGIN	MTCSER 
 SUBTTL	MTCSER - MAGNETIC TAPE ROUTINES FOR PDP-6(516)
C00005 00003	MTC CONO BITS:
C00008 00004	MAG TAPE SERVICE DISPATCH
C00009 00005		MTAPE UUO
C00014 00006	IS SYSTEM AVAILABLE
C00018 00007	MTAPE 0 WAITS UNTIL THE CONTROL IS FREE
C00020 00008	ROUTINE TO SEE IF UNIT IS REWINDING
C00023 00009	READ AND WRITE
C00026 00010	CLOSE OUTPUT
C00028 00011	INTERRUPTS FROM MAG TAPE CONTROL ARE SENT HERE FROM IOINIT
C00031 00012	MTPDUN:	AOS	MTCBKN(DDB)	COUNT NR. OF BLOCKS READ OR WRITTEN FOR THIS DRIVE
C00033 00013	MTEND1:	CONO	DC,0		TURN OFF DATA CONTROL
C00035 00014	MTNIO1:	CONO	MTS,0		CLEAR MAG TAPE ENABLES.
C00038 00015	ROUTINE CALLED AT CLOCK LEVEL TO SEE IF ANY UNITS WHICH ARE IN A
C00040 00016	MTNOTI:	PUSHJ	P,ADVBFE	WRITING
C00041 00017	MTEOR2:	SKIPE	MTEOFF		END-OF-FILE?
C00044 00018	THIS ROUTINE BACKSPACES OVER ONE RECORD (A BAD ONE) THEN
C00047 00019	LOGICAL END OF TAPE LOOP
C00048 00020	DEVICE DEPENDENT DUMP MODES. MODE 16.
C00051 00021	MTDPI1:	TRNE	IOS,IODEND	EOF?
C00052 00022	MDRTRY:	MOVE	TAC,@MTCMDP	RETRY LAST OPERATION
C00054 ENDMK
C⊗;

BEGIN MTCSER
SUBTTL	MTCSER - MAGNETIC TAPE ROUTINES FOR PDP-6(516)
;	25-JUL-68 FROM DEC MTCSR6 OF 7-MAY-68

;STATUS BITS IN MTS.  * MEANS CAUSES INTERRUPT WHEN ENABLED.
;NAMES ARE TAKEN FROM "MAGNETIC TAPE CONTROL 516 INSTRUCTION MANUAL" H-516

ICR←←1B35	;* INTERFACE AND CONTROL READY
RDY←←1B34	;  TAPE TRANSPORT READY
ERF←←1B33	;* END OF RECORD FLAG
PER←←1B32	;  LATERAL PARITY ERROR
LPE←←1B31	;  LONGITUDINAL PARITY ERROR
RCE←←1B30	;  READ COMPARE ERROR (NOT USED)
MIS←←1B29	;  TAPE MISSED CHARACTER
TWL←←1B28	;  TAPE WRITE-ENABLE LOCKOUT RING OUT
EFF←←1B27	;  END-OF-FILE SENSED
BCT←←1B26	;  OTHER COMPUTER USING TRANSPORT OR IN LOCAL
TLR←←1B25	;  LAST OPERATION WAS A WRITE (NOT USED)
TLP←←1B24	;  TAPE AT LOAD POINT
TEP←←1B23	;  TAPE AT END POINT
RWD←←1B22	;  TRANSPORT IS REWINDING
XNC←←1B21	;* TRANSFER NEW COMMAND
LIF←←1B20	;* LOAD POINT INTERRUPT FLAG (NOT USED)
DCS←←1B19	;  DATA CONTROL SELECTED (NOT USED)
ILC←←1B18	;  ILLEGAL COMMAND:
		;     WRITE OR WEF ON A WRITE-LOCKED TAPE
		;     BACKSPACE RECORD, BACKSPACE FILE, OR READ
		;	BACKWARDS WHILE AT BEGINNING OF TAPE
		;     ANY OPERATION ON A TRANSPORT BEING USED
		;	BY THE OTHER COMPUTER


;MTC CONO BITS:
;BITS 33-35	ARE PI CHANNEL ASSIGNMENT (=MTCCHN)
;BITS 29-31	ARE UNIT SELECT, BYTE POINTER IS PUNIT
;BIT 28		IS "DO NOT RETURN TO POOL" (NOT USED)
;BITS 24-27	ARE "FUNCTION".  THEY ARE AS FOLLOWS:
;			00=NO OPERATION (UNUSED)
;			01=REWIND
;			02=WRITE
;			03=WRITE END-OF-FILE
;			04=READ-COMPARE (NOT USED)
;			05=READ
;			06=SPACE FORWARD RECORD
;			07=BACKSPACE RECORD
;			10=NO OPERATION (NOT USED)
;			11=REWIND AND UNLOAD (SAME AS REWIND AT STANFORD)
;			12=READ ACROSS RECORD (NOT USED)
;			13=WRITE THREE INCHES (APPROX) OF MAG TAPE
;			14=WRITE WITH LONG EOR (NOT USED)
;			15=READ BACKWARD (NOT USED)
;			16=SPACE FORWARD FILE
;			17=BACKSPACE FILE
;BITS 22-23	SPECIFY DENSITY:
;			0=200 BPI
;			1=556 BPI
;			2=800 BPI
;			3=556 BPI
;BIT 21		SPECIFIES PARITY
;			0=EVEN
;			1=ODD
;BIT 20		SPECIFIES SLICE LEVEL
;			0=HIGH (NORMAL)
;			1=LOW


MTDC←←2		;MAG TAPE DATA CONTROL DEVICE NUMBER
SEL←←2		;UNIT TO COMMAND BUFFER
IOSEOF←←4000	;SPACING ONE RECORD FORWARD FOUND EOF
IODT←←10000	;A 1 FOR A DATA TRANSFER TYPE COMMAND
IOSLIC←←20000	;A 1 IF SLICE LEVEL IS 1, OTHERWISE 0.
HASMT←←40000	;IF A 1, THIS JOB HAS THE MAG TAPE CONTROL
IOREW←←400000	;A 1 IF UNIT IS REWINDING AND ANOTHER OPERATION
		;IS ATTEMPTED ON SAME UNIT. MUST BE SIGN BIT.
MTREDO←←=10	;NUMBER OF TIMES TO RETRY ON ERRORS

;MAG TAPE SERVICE DISPATCH

	JRST	MTCINI		;INITIALIZATION
	JRST	CPOPJ1		;MTA HUNG TIMEOUT. RELEASE DATA CONTROL,
				;MAGTAPE CONTROL, PRINT ERROR AND STOP JOB
↑MTCDSP:
	JRST	WAIT1		;RELEASE - WAIT FOR IOACT TO BE OFF.
	JRST	MTCLSO		;CLOSE OUTPUT
	JRST	MTOUT		;OUTPUT
	JRST	MTIN		;INPUT
	JRST	CPOPJ1		;ENTER IN DIRECTORY
	JRST	CPOPJ1		;LOOKUP IN DIRECTORY
	JRST	MTDMPO		;DUMP OUTPUT
	JRST	MTDMPI		;DUMP INPUT
	POPJ	P,		;SETO
	POPJ	P,		;SETI
	POPJ	P,		;GETF
	JRST	CPOPJ1		;RENAME
	POPJ	P,		;CLOSE INPUT
	POPJ	P,		;UTPCLR
	JRST	MTAPEU		;MTAPE UUO


;	MTAPE UUO
;THE FOLLOWING MTAPES ARE LEGAL:
C←←0
C←←C!1B35	;0 = NOP
C←←C!1B34	;1 = REWIND
C←←C!1B26	;11= REWIND, UNLOAD
C←←C!1B28	;7 = BACKSPACE RECORD
C←←C!1B20	;17= BACKSPACE FILE
C←←C!1B32	;3 = WRITE END OF FILE
C←←C!1B29	;6 = SPACE FORWARD RECORD
C←←C!1B21	;16= SPACE FORWARD FILE
C←←C!1B24	;13= WRITE 3" OF BLANK TAPE
C←←C!1B27	;10= SKIP TO LOGICAL EOT (PROGRAMMED)

MTAPEU:
	MOVEI	ITEM,1		;CHECK FOR LEGAL MTAPE UUO
	LSH	ITEM,(UUO)	;SHIFT BIT ACCORDING TO THE USER'S UUO
	TRNN	ITEM,C		;DID HE SPECIFY A LEGAL CODE ?
	JRST	UUOERR		;NO--TYPE MONITOR ERROR MESSAGE.
	SOJE	ITEM,MTP0	;CHECK FOR MTAPE 0 (SPECIAL SYNC WAIT NO-OP)
	PUSHJ	P,MTCHK2	;MAKE SURE SYSTEM IS AVAILABLE.
	TRZ	IOS,776000	;CLEAR ERROR BITS: IOF, IOACT, IOBOT AND IOTEND.
	SKIPA	ITEM,UUO	;CALL MTAPE2
MTAPE:
	PUSHJ	P,MTCHK2	;CHECK IF MAG TAPE CONTROL AVAIL.
MTAPE2:
	TDZ	IOS,[XWD IODT!IOSEOF,IOACT]
	TRNN	ITEM,SLICE	;SET SLICE LEVEL THIS UUO?
	JRST	NOSET		;NO
	TLZ	IOS,IOSLIC	;YES, CLEAR LEVEL
	TRNE	ITEM,SLEVEL	;SET TO 1?
	TLO	IOS,IOSLIC	;YES
NOSET:
	LSH	ITEM,=8		;MOVE CODE TO MT FUNCTION POSITION
	ANDI	ITEM,17B27	;LEAVE ONLY THE FUNCTION BITS
	CAIN	ITEM,10B27	;LOGICAL EOT?
	JRST	MTLEOT		;YES.
	CONSO	MTS,TLP		;AT LOAD POINT?
	JRST	MTGO1		;NOT AT LOAD POINT.
	CAIE	ITEM,7B27	;YES, BACKSPACE RECORD?
	CAIN	ITEM,1B27	;NO, REW?
	JRST	MTFIN		;AVOID BACKWARDS MOTION WHEN AT LOAD POINT
	CAIN	ITEM,17B27	;NO. BACKSPACE FILE?
	JRST	MTFIN		;YES. AVOID BACKWARDS MOTION FROM LOAD POINT.


MTGO1:
	LDB	TAC,PUNIT	;IN, OUT, MTAPE UUOS & INTERRUPT FOR NEXT RECORD
	DPB	TAC,[POINT 3,ITEM,31]	;FROM COMMAND IN ITEM. STORE UNIT NUMBER.
	LDB	TAC,[POINT 3,IOS,28]	;DENSITY PARITY
	TRNN	TAC,7		;NO DENSITY OR PARITY SPECIFIED?
	IORI	TAC,STDENS	;YES, USE STANDARD
	XORI	TAC,5		;ODD, 556
	DPB	TAC,[POINT 3,ITEM,23]
	MOVEI	TAC,MTCCHN(ITEM);ADD PI CHANNEL TO COMMAND
	TLNE	IOS,IOSLIC	;SLICE LEVEL A 1?
	TRO	TAC,100000	;YES, SET COMMAND.
	SETZM	MTEOFF		;CLEAR EOF FLAG
	HRRM	DDB,MTDEV
	HRLM	TAC,MTDEV	;COMMAND,,DDB ADDRESS INTO MTDEV
	MOVEI	TAC1,MTNIO2	;ASSUME NON-DATA TRANSFER
	TLNN	IOS,IODT	;IS THIS A DATA TRANSFER OPERATION  REQUIRING DC?
	JRST	MTGO2		;NO, MUST BE SPACING OPERATION
	CONO	DC,@MDCSAV	;YES, ATTACH DC TO MAGTAPE
	CONO	PI,DCTON	;TURN DC PI CHANNEL ON
	SETZM	MISSED		;CLEAR DATA MISSED FLAG
	MOVEI	TAC1,MTXNC	;ON INTERRUPT, GO TO MTXNC
MTGO2:
	MOVEM	TAC1,MTIDSP	;STORE DISPATCH ADDRESS FOR INTERRUPT
	PUSH	P,TAC
	PUSHJ	P,STOIOS
	POP	P,TAC
	HRLI	TAC,XNC
	CONO	PI,PIOFF	;DISABLE INTERRUPTS
	CONO	MTC,(TAC)	;ISSUE OPERATION TO CONTROLLER
	HLRM	TAC,MTCCON	;ENABLE SOFTWARE FOR XNC
	CONO	MTS,XNC		;ENABLE HARDWARE FOR XNC
	CONO	PI,PION		;ENABLE INTERRUPTS
	POPJ	P,		;EXIT

;IS SYSTEM AVAILABLE
MTCHEK:
	PUSHJ	P,GETDCMT	;GET DATA AND MAG TAPE CONTROLS
	AOSE	MTREQ		;ARGUMENT
	MOVE	IOS,DEVIOS(DDB)
	TLO	IOS,IODT	;FLAG DATA TRANSFER
	PUSHJ	P,MTCHK4	;WAIT FOR REWIND
	JRST	MTCHEK		;GET DC & MT AGAIN
	JRST	SETACT		;SET DEV. ACTIVE BIT

MTCHK2:
	AOSE	MTREQ		;GET MAGTAPE CONTROL ONLY-SPACING OPERATION.
	PUSHJ	P,MTWAIT
	MOVE	IOS,DEVIOS(DDB)
	PUSHJ	P,MTCHK4	;CHECK STATUS
	JRST	MTCHK2		;GET MT AGAIN
	POPJ	P,

MTCHK4:
	TLO	IOS,HASMT	;THIS JOB NOW HAS MTC
	TLZE	IOS,IOBEG	;FIRST OPERATION AFTER INIT 
	TLZ	IOS,IOSLIC	;YES, SET SLICE LEVEL TO 0.
	TLZ	IOS,IOREW	;CLEAR MAG TAPE REWINDING
	PUSHJ	P,REWCK		;CHECK IF REWINDING?
	JRST	CPOPJ1		;NO - STATUS OK
	JRST	QSTAT		;QUERY STATUS
	PUSHJ	P,DETMDC	;REWINDING- DETACH MTC, DC AND TURN OFF IODT & HASMT
	TLO	IOS,IOREW+IOW	;SET REWIND WAIT, IO WAIT
	MOVEM	IOS,DEVIOS(DDB)	;STORE IOS
	AOSG	MTREWN		;ADD 1 TO REWIND WAIT COUNT SKIP IF CLREQ IN
	PUSHJ	P,MTCLK		;MAKE A CLOCK REQUEST. THIS IS ONLY UNIT REWINDING
	PUSH	P,J		;SAVE J
	LDB	J,PJOBN		;GET THE JOB NUMBER OF TAPE OWNER
	MOVNI	AC1,IOWQ	;REQUE THIS GUY
	MOVEM	AC1,JOBQUE(J)	;TO IOWQ UNTIL MT REWINDS
	PUSHJ	P,REQUE		;
	POP	P,J		;RESTORE J
	JRST	WSCHED		;WAIT...

QSTAT:
	PUSHJ	P,DETMDC	;DETACH MTC AND DC
	LDB	J,PJOBN		;LOAD UP JOB NUMBER
	JRST	HNGSTP		;CHECK STATUS (PULL FINGERS OUT, ETC)

;MTAPE 0 WAITS UNTIL THE CONTROL IS FREE
;THUS MTAPE 0 PROVIDES THE ONLY WAY FOR A USER TO WAIT UNTIL A SPACING OPERATION
; (I.E., SKIP, BACKSPACE, OR REWIND) IS COMPLETED.

MTP0:
	PUSHJ	PDP,MTCHK2	;WAIT FOR CONTROL TO BECOME FREE,
				; THEN GIVE IT BACK IMMEDIATELY,
				; AND RETURN TO THE USER.




;DETMDC-
;	DETACH MTC, AND TURN OFF HASMT.
;	THEN (IFF IODT ON)
;	TURN OFF IODT AND DETACH DC

↑DETMDC:
	TLZN	IOS,HASMT	;THIS JOB HAS MTC?
	JRST	STOIOS		;NO
	SOSL	MTREQ		;YES- ANYONE ELSE WAITING FOR IT?
	SETOM	MTAVAL		;YES- FLAG AS JUST BECOME AVAILABLE
↑DETDC:	TLZN	IOS,IODT	;DOES JOB HAVE DATA CONTROL?
	JRST	STOIOS		;NO- EXIT
	SOSL	DCREQ		;ANYONE ELSE WAITING FOR IT?
	SETOM	DCAVAL		;YES- FLAG AS JUST BECOME AVAILABLE
	JRST	STOIOS		;AND EXIT

MTHUNG:
	TLNN	IOS,HASMT
	POPJ	P,		;HOW DID WE GET HERE IF HE DIDN'T HAVE IT?
	CONO	MTS,400000	;FLUSH CURRENT COMMAND
	CONO	MTC,0		;GRONK DELAYS
	TLNE	IOS,IODT	;DOES HE HAVE THE DATA CONTROL?
	CONO	DC,0		;HOLD DATA CONTROL
	JRST	DETMDC		;DEATCH EVERYTHING.

;ROUTINE TO SEE IF UNIT IS REWINDING
;CALL	MOVE DEVDAT,ADDRESS OF DDB
;	PUSHJ PDP,REWCK
;	UNIT READY
;	UNIT OFF
;	UNIT REWINDING

REWCK:
	LDB	TAC,PUNIT
	ROT	TAC,4
	CONO	MTC,MTCCHN(TAC)
	CONO	MTS,SEL		;JAM UNIT INTO COMMAND BUFFER
	CONSZ	MTS,RWD		;SKIP IF REWIND MOTION OFF
	JRST	CPOPJ2		;RETURN TO CALL+2 IF TAPE REWINDING
	CONSO	MTS,BCT		;OTHER COMPUTER USING TRANSPORT, OR IN LOCAL?
	CONSO	MTS,RDY		;IS UNIT READY?
	JRST	CPOPJ1		;UNIT UNREADY OR UNAVAILABLE
	CONSZ	MTS,TLP		;UNIT READY AND AVAILABLE IS IT AT LOAD POINT?
	IORI	IOS,IOBOT	;YES.
	CONSZ	MTS,TEP		;END POINT?
	IORI	IOS,IOTEND	;YES.
	POPJ	PDP,		;UNIT HAPPY. DIRECT RETURN


COMMENT $
THIS WORKS WITH THE FOLLOWING MOD TO 545 TRANSPORT:

DELETE 1B23K TO ??

ADD	1B16K TO 1B08K		REW(1)(GND) BUFFERED
	1B19S TO 1B08L		FWD/LP(1)(GND)
	1B08N TO 1B23K		(REW(1).OR.FWD/LP(1))

THIS MOD SETS IOB22(1) WHILE MAGTAPE IS REWINDING OR SPACING FORWARD
TO LOAD POINT- IE ENABLES THE PROCESSOR TO DISTINGUISH BETWEEN A
TAPE WHICH IS AT THE END OF A REWIND COMMAND, AND A TAPE WHICH IS
SWITCHED TO LOCAL, OR OFF

ADD	1B08U TO 1B08N		CLAMPED LOAD FOR LOCAL
	1B08R TO 1B10J		LOCAL (-3V)
	1B08S TO 1B15F		SELECT (-3V)
	1B08V TO P1-42		LOCAL STATUS TO OLD POOL STATUS BIT
	P1-42 TO P2-42		ADD THROUGH CONNECTION FOR DRIVES BEYOND

THIS MOD MAKES BIT 26 OF CONI 224,  A ONE IF THE SELECTED
DRIVE IS IN LOCAL.  IT USES A SPARE SECTION OF R111 IN EACH 545
AND LOGIC IN THE 516/521 USED FOR POOLING WITH 570 TAPE DRIVES.
$

;READ AND WRITE

MTIN:
	PUSHJ	P,MTCHEK	;IS SYSTEM AVAILABLE?
	TLZ	IOS,IO		;READING.
MTIN1:
	SETCM	TAC,@DEVIAD(DDB)	;-SIZE-1
	HRRI	TAC,@DEVIAD(DDB)	;BUFFER ADDRESS,PROG INCLUDED
	ADD	TAC,[XWD 2,1]	;-SIZE+1,BUFFER+1
	MOVEI	ITEM,5B27	;READ
	MOVE	TAC1,[BLKI DC,4000!<MTDC*10>!DCTCHN]
	JRST	MTINDC

MTOUT:
	PUSHJ	P,MTCHEK
	TLO	IOS,IO		;WRITING
	CONSZ	MTS,TWL		;IS FILE PROTECT RING IN?
	JRST	MTOUTE		;NO, ERROR CANT WRITE. CROCK!!
MTOUT1:
	MOVEI	TAC,@DEVOAD(DDB)	;BUFFER ADDRESS, PROG INCLUDED
	MOVN	TAC1,1(TAC)	;-WD COUNT
	JUMPE	TAC1,MTNOPO	;IF WC=0, DONT DO ANYTHING
	HRL	TAC,TAC1	;-WD CMT,BUFFER
	ADDI	TAC,1		;BUFFER+1
	MOVE	TAC1,[BLKO DC,3400!<MTDC*10>!DCTCHN]
	MOVEI	ITEM,2B27	;WRITE
MTINDC:
	CONO	PI,DCTOFF	;TURN DATA CONTROL PI CHANNEL OFF
	MOVEM	TAC,MTDCCN	;BLKO POINTER
	MOVEM	TAC,DCWRD
	HRRZM	TAC1,MDCSAV	;SAVE DC COMMAND
	HRRI	TAC1,DCWRD
	MOVEM	TAC1,@DCLOC	;BLK COMMAND
	MOVE	TAC1,[JSR MTDCND]
	MOVEM	TAC1,@DCLOC1
	IORI	IOS,IOACT	;SET IOACT
	JRST	MTGO1		;GO START OPERATION

MTOUTE:
	TRO	IOS,IOIMPM	;WRITE LOCK, DEVICE ERROR
	JRST	MTNOP1		;DETACH DATA CONTROL AND MAG TAPE. RETURN TO UUOCON

MTNOPO:
	PUSHJ	P,ADVBFE	;ADVANCE OVER THE EMPTY BUFFER
	JFCL			;IGNORE CONTINUE INDICATION
MTNOP1:
	PUSHJ	P,ETCHK		;JUST IN CASE
	TLZE	IOS,IOW		;UNWAIT THE JOB
	PUSHJ	P,SETIOD
	PUSHJ	P,CLRACT
	JRST	DETMDC		;DETACH EVERYTHING AND RETURN

;CLOSE OUTPUT

MTCLSO:
	TLNN	DDB,OUTPB	;HAS AN OUTPUT BEEN DONE?
	POPJ	P,		;NO. DONT WRITE ON TAPE.
	LDB	TAC,PIOMOD	;DUMP MODE?
	CAIGE	TAC,DR
	PUSHJ	P,OUT		;BUFFERED MODE: OUTPUT LAST PARTIAL BUFFER
	PUSHJ	P,WSYNC		;WAIT FOR OUTPUT TO FINISH
	PUSH	P,ITEM		;DON'T CLOBBER J!!!
	MOVEI	ITEM,3		;WRITE EOF
	PUSHJ	P, MTAPE
	MOVEI	ITEM,3		;WRITE EOF
	PUSHJ	P,MTAPE
	MOVEI	ITEM,7		;BSP
	PUSHJ	P,MTAPE
	POP	P,ITEM		;RESTORE J
	POPJ	P,


MTCINI:
	SETOM	MTREWN		;SET CLOCK REQUEST COUNT TO -1
	MOVEI	TAC,40+DCTCHN*2
	CONSZ	APR,MAOFF	; MA TRAP OFFSET?
	ADDI	TAC,100		; YES, OFFSET ADDRESS
	MOVEM	TAC,DCLOC
	ADDI	TAC,1
	MOVEM	TAC,DCLOC1
	JRST	MTNIO1


;BLK COUNTED OUT

↑MTDCN1:
	CONO	PI,DCTOFF	;SHUT OFF DC CHANNEL
	CONSZ	DC,10000	;DATA MISSED?
	SETOM	MISSED		;YES. OOPS
	JEN	@MTDCND		;DISMISS INTERRUPT.

;INTERRUPTS FROM MAG TAPE CONTROL ARE SENT HERE FROM IOINIT
↑MTCINT:JSR	MTCSAV		;SAVE AC'S
	HRRZ	DDB,MTDEV	;SET UP DDB POINTER
	LDB	PROG,PJOBN	;JOB NUMBER
	MOVE	PROG,JBTADR(PROG)
	MOVE	IOS,DEVIOS(DDB)
	JRST	@MTIDSP		;DISPATCH TO WHOEVER WANTS INTERRUPT.

;HERE ON FIRST INTERRUPT FROM DATA TRANSFER OPERATION (XNC)
MTXNC:
	MOVEI	TAC,ERF		;ENABLE SOFTWARE FOR ERF
	HRRM	TAC,MTCCON
	MOVEI	TAC,MTEOR	;SET DISPATCH ADDRESS TO MTEOR
	MOVEM	TAC,MTIDSP
	CONO	MTS,ERF		;ENABLE HARDWARE FOR ERF
	POPJ	P,		;DISMISS INTERRUPT

;HERE ON ERF INTERRUPT FROM DATA TRANSFER OPERATION
MTEOR:
	CONO	PI,DCTOFF	;TURN OFF DC IN CASE BLKI/BLKO DIDNT OVERFLOW
	CONSZ	DC,10000	;DATA MISS?
	SETOM	MISSED		;YES.
	CONSZ	MTS,EFF		;END-OF-FILE?
	SETOM	MTEOFF		;YES. SET FLAG

	MOVE	ITEM,DCWRD	;GET THE IOWD
	TLNE	IOS,IO		;SKIP IF INPUT
	TLNN	ITEM,-1		;OUTPUT. SKIP IF WORDS REMAIN IN THE IOWD
	JRST	MTEOR0		;INPUT OR IOWD EXHAUSTED.
	SETOM	MISSED		;SET DATA MISSED. - OUTPUT FAILED TO EXHAUST IOWD
	JRST	MTEOR2		;ERROR.

MTEOR0:
	CONSO	DC,160000	;DATA REMAINING IN DC?
	JRST	MTEOR1		;NO.
	TLNN	IOS,IO		;OUTPUT?
	SKIPE	MISSED		;NO.  DATA MISSED?
	JRST	MTEOR2		;YES.  ERROR.
	CONI	DC,TAC1		;FETCH DC STATUS BITS
	LSH	TAC1,-15	;SHIFT CHARACTER COUNT TO LSBITS
	IMULI	TAC1,-6		;-NO OF BITS TOO FAR RIGHT
	CONO	DC,@MDCSAV	;?? IF DON SAYS SO, WELL, OK (JUST)
	DATAI	DC,TAC		;FETCH LAST PART-WORD OF DATA
	LSH	TAC,44(TAC1)	;SHIFT LAST CHARACTERS TO LEFT END
	JUMPG	ITEM,MTEOR1
	AOBJN	ITEM,.+1	;BUMP DATA POINTER
	MOVEM	TAC,(ITEM)	;STORE LAST WORD
	MOVEM	ITEM,DCWRD	;LET LOSER SEE LAST WORD, PLS! (DWP 3 MAY 71)
	CONO	DC,0		;SHUT DOWN DC.

MTEOR1:
	CONSZ	MTS,LPE!PER!ILC!MIS
				;IF END OF RECORD, CHECK
				;PARITY,DATA MISSED,  AND ILLEGAL FLAG
	JRST	MTEOR2		;IF ERROR CAUSE INTERRUPT TO
				;ERROR ROUTIE VIA ICR

MTPDUN:
	AOS	MTCBKN(DDB)	;COUNT NR. OF BLOCKS READ OR WRITTEN FOR THIS DRIVE
	LDB	TAC,PIOMOD
	CAIL	TAC,DR
	JRST	DMPDUN		;DUMP
	TLNE	IOS,IO
	JRST	MTNOTI		;WRITING
	SKIPE	MTEOFF		;NOT EOF?
	JRST	MTEOF
	MOVEI	TAC,@DEVIAD(DDB);BUFFER ADDRESS
	JUMPE	TAC,MTEND1	;JUMP IF RELEASE HAS WIPED OUT BUFFERS
	MOVN	TAC1,MTDCCN	;WD CNT-1
	AOBJN	TAC1,.+1	;WD CNT
	HLLZ	TAC1,TAC1	;CLR RT HALF
	ADD	TAC1,DCWRD	;ADD CURRENT COUNT=NO. OF WDS
	HLRM	TAC1,1(TAC)	;STORE AT WORD COUNT
	PUSHJ	P,ADVBFF
	JRST	MTEND1		;NEXT BUFFER FULL
	JRST	MTCONN		;CONTINUE MODE

DMPDUN:
	TLNN	IOS,IO		;INPUT OR OUTPUT?
	SKIPN	MTEOFF		;ONLY CHECK EOF ON INPUT
	SKIPA			;OUTPUT OR INPUT+EOF
	TRO	IOS,IODEND	;INPUT+EOF
	SETZM	MTEOFF		;RESET EOF FLAG IN CASE SET.
	PUSHJ	PDP,ETCHK	;CHECK FOR EOT
	AOS	TAC,MTCMDP	;NEXT ITEM IN COMMAND LIST.
	TLNN	IOS,IO		;READING OR WRITING?
	JRST	MTDPI1		;READING
	JRST	MTDPO1		;WRITING.

MTEOF:
	TLO	IOS,IOEND
	SETZM	MTEOFF		;CLEAR EOF FLAG

;AND FALL INTO MTEND1

MTEND1:
	CONO	DC,0		;TURN OFF DATA CONTROL
	CONO	PI,DCTOFF
	PUSHJ	P,DETDC		;DETACH DC (IF ASSIGNED)
	PUSHJ	P,ETCHK		;CHECK FOR END OF TAPE (FOR DUMP MODE OUT)
	PUSHJ	P,CLRACT	;CLEAR IOACT, STORE IOS
	MOVEI	TAC,MTFIN	;SET DISPATCH ADDRESS TO MTFIN
	MOVEM	TAC,MTIDSP
	HRRZM	DDB,MTDEV	;STORE DDB ADDTRESS (DUMP MODE)
	JRST	MTIGN		;RETURN WHEN ICR

;HERE ON XNC INTERRUPT FROM NON-DATA TRANSFER.
MTNIO2:
	PUSHJ	P,MTERST	;RETURN WHEN ICR
	HLRZ	TAC,MTDEV	;COMMAND
	ANDI	TAC,17B27
	CAIE	TAC,6B27	;NO. SPACING ONE RECORD?
	JRST	MTNIO		;YES, EXIT
	CONSZ	MTS,EFF		;EOF?
	TDO	IOS,[XWD IOSEOF,IODEND]
MTFIN:

MTNIO:
	TLZE	IOS,IOW		;CLEAR WAIT
	PUSHJ	P,SETIOD
	PUSHJ	P,DETMDC	;DETACH MTC (IF HASMT SET) AND DC (IF IODT)
	PUSHJ	P,ETCHK		;CHECK FOR END OF TAPE
	PUSHJ	P,CLRACT	;RESTORE BITS,CLEAR IOACT

;AND FALL INTO MTNIO1

MTNIO1:
	CONO	MTS,0		;CLEAR MAG TAPE ENABLES.
	CONO	MTC,MTCCHN	;CLEAR MAG TAPE CONTROL.
	HLLZS	MTCCON		;CLEAR THE INTERRUPT MASK BITS.
	MOVNI	TAC,MTREDO	;REPEAT COUNTER
	MOVEM	TAC,MTERCN
	SKIPGE	MTREWN		;SOME OTHER UNIT REWINDING WITH A COMMAND HELD UP?
	POPJ	P,		;NO, DISMISS INTERRUPT

;SOME UNIT IS REWINDING AND HAS HAD ANOTHER COMMAND HELD UP.
;CHECK ALL UNITS

MTREWW:
	SETOM	MTREWN		;SET COUNT TO NO. UNITS IN REW WAIT
	PUSH	P,DDB
	MOVEI	DDB,MTCDDB	;GET BEGINNING OF MT DATA BLOCK CHAIN

REWLP:
	MOVE	IOS,DEVIOS(DDB)
	JUMPGE	IOS,REW2	;IS UNIT IN A REW WAIT?
	PUSHJ	PDP,REWCK	;YES,SEE IF FINISHED REW.
	JRST	.+3		;HAS FINISHED REWINDING
	JRST	.+2		;OFF- WAKE JOB AND LET HIM LOSE.
	JRST	REW0		;STILL REWINDING
	TDZ	IOS,[XWD IOREW,IOACT]	;GET JOB OUT OF IO WAIT
	TLZE	IOS,IOW
	PUSHJ	P,SETIOD	;START JOB UP AGAIN
	MOVEM	IOS,DEVIOS(DDB)
	JRST	REW2

REW0:
	PUSHJ	P,STOIOS	;RESET HUNG COUNT IF STILL REWINDING
REW1:
	AOS	MTREWN		;INCREMENT COUNT OF REW WAIT UNITS
REW2:
	HLRZ	DDB,DEVSER(DDB)	;LINK TO NEXT DDB
	JUMPE	DDB,REW3	;LAST DDB?
	HLRZ	DAT,DEVNAM(DDB)	;NO. GET LH OF NAME.
	CAIN	DAT,'MTA'	;IS THIS A MAGTAPE?
	JRST	REWLP		;YES. CONTINUE
REW3:
	POP	P,DDB
	POPJ	P,		;YES, DISMISS INTERRUPT OR RETURN TO MTCLOK

ETCHK:
	CONSZ	MTS,TEP		;EOT SEEN?
	IORI	IOS,IOIMPM!IOTEND	;YES- SET FLAGS	;THIS IS A CROCK!
	TDZ	IOS,[XWD IOREW,IOBOT]	;NO LONGER REWINDING
	CONSZ	MTS,RWD!TLP	;UNLESS
	TRO	IOS,IOBOT	;IS REALLY REWINDING
	POPJ	P,		;EXIT

;ROUTINE CALLED AT CLOCK LEVEL TO SEE IF ANY UNITS WHICH ARE IN A
;REW WAIT HAVE FINISHED REWIND.

MTCLOK:
	SKIPGE	MTREQ		;IS ANY JOB USING ANY UNIT NOW?
	PUSHJ	P,MTREWW	;NO, CHECK ALL MAG TAPE
				;UNITS TO SEE IF JUST FINISHED
				;REWINDING(WHICH WERE IN REW WAIT)
	SKIPGE	MTREWN		;YES,ARE ANY UNITS STILL IN REW WAIT?
	POPJ	P,		;NO, RETURN TO CLOCK ROUTINE WITHOUT
				;PUTTING IN CLOCK REQUEST

;ROUTINE TO PUT IN A CLOCK REQUEST

MTCLK:
	MOVEI	TAC1,JIFSEC/2	;CHECK EVERY HALF SECOND
	HRLI	TAC1,MTCLOK	;DISPATCH ADDRESS
	CONO	PI,PIOFF	;TURN OFF PI
	IDPB	TAC1,CLOCK	;STORE CLOCK REQUEST
	CONO	PI,PION		;TURN ON PI
	POPJ	P,

MTNOTI:
	PUSHJ	P,ADVBFE	;WRITING
	JRST	MTEND1
MTCONN:

	CONSZ	MTS,TEP!BCT	;END OF TAPE OR IN LOCAL?
	JRST	MTEND1		;STOP TAPE
	CONO	DC,0		;CLEAR DATA CONTROL
	TLZE	IOS,IOW
	PUSHJ	P,SETIOD
	MOVEM	IOS,DEVIOS(DDB)
	MOVNI	TAC,MTREDO
	MOVEM	TAC,MTERCN
	TLNN	IOS,IO		;INPUT OR OUTPUT?
	JRST	MTIN1		;CALL INPUT SUBROUTINE
	JRST	MTOUT1		;CALL OUTPUT SUBROUTINE

MTEOR2:
	SKIPE	MTEOFF		;END-OF-FILE?
	JRST	MTPDUN		;YES. IGNORE ERRORS.
MTERR:
	MOVEI	ITEM,0
	CONSZ	MTS,LPE		;LONGITUDINAL PARITY ERROR?
	TLO	ITEM,1000	;YES, COUNT IN QUARTER 1
	CONSZ	MTS,PER		;LATERAL PARITY ERROR?
	TLO	ITEM,1		;YES, COUNT IN QUARTER 2
	CONSZ	MTS,ILC		;ILLEGAL OP?
	TRO	ITEM,1000	;YES, COUNT IN QUARTER 3
	SKIPE	MISSED		;DATA MISSED?
	TRO	ITEM,1		;YES, COUNT IN QUARTER 4
	ADDM	ITEM,MTCENT(DEVDAT);ADD TO ERROR COUNTS FOR THIS DRIVE
	TRNE	IOS,IONRCK	;DOES USER WANT TO SUPPRESS ERROR HANDLING?
	JRST	MTERR3		;YES, GIVE HIM HIS ERROR BITS
	PUSHJ	P,MTERST	;RETURN ON ICR
	AOSL	MTERCN		;ENOUGH ERRORS?
	JRST	MTERR2		;YES.
	HLRZ	TAC,MTDEV	;COMMAND
	ANDCMI	TAC,17B27
	MOVEI	TAC,7B27(TAC)	;BSP
	PUSHJ	P,MTXCT		;INITIATE THE OPERATION
	PUSHJ	P,MTERST	;RETURN WHEN OPERATION COMPLETE.

;COME HERE AFTER ERROR BACKSPACE OR WRITE BLANK TAPE
;TO RE-ISSUE THE READ OR WRITE COMMAND.

MRETRY:
	LDB	TAC,PIOMOD	;GET MODE.
	CAIL	TAC,DR		;DUMP MODE?
	JRST	MDRTRY		;YES.
	TLNE	IOS,IO		;INPUT OR OUTPUT?
	JRST	MTOUT1		;OUTPUT
	JRST	MTIN1		;INPUT

;COME HERE AFTER ENOUGH RETRIES.  ASSUME ERROR
;IS PERMANENT.

MTERR2:
	TLNE	IOS,IO		;WRITING?
	JRST	WRBLNK		;YES. ERASE BAD SPOT.
MTERR3:
	CONSO	MTS,ILC!MIS	;SET IODERR IF ILLEG OR MISSED CHAR FLAGS
	SKIPE	MISSED		;SET IODERR IF DATA MISSED
	TRO	IOS,IODERR
	CONSZ	MTS,LPE!PER	;SET IODTER IF LONG OR LAT PARITY
	TRO	IOS,IODTER
	JRST	MTPDUN

;THIS ROUTINE BACKSPACES OVER ONE RECORD (A BAD ONE) THEN
;WRITES 3" OF BLANK TAPE WHICH WILL BE SKIPPED OVER ON
;INPUT (LOOKS LIKE A LONG INTER-RECORD GAP).  THE PROCESS
;CONTINUES UNTIL NO ERRORS ARE ENCOUNTERED OR EOT IS REACHED.

WRBLNK:
	CONSZ	MTS,TEP		;EOT?
	JRST	MTFIN		;YES. GIVE UP.
	HLRZ	TAC,MTDEV	;LAST COMMAND
	ANDCMI	TAC,17B27	;MASK OUT IRREVALENCIES
	MOVEI	TAC,7B27(TAC)	;BSP
	PUSHJ	P,MTXCT		;INITIATE THE OPERATION
	PUSHJ	P,MTERST	;RETURN WHEN BSR DONE.
	HLRZ	TAC,MTDEV	;GET BACK COMMAND
	ANDCMI	TAC,17B27
	MOVEI	TAC,13B27(TAC)	;WRITE 3" OF BLANK TAPE
	PUSHJ	P,MTXCT		;START THE WRITE
	MOVNI	TAC,MTREDO	;RESET ERROR COUNT.
	HRREM	TAC,MTERCN
	PUSHJ	P,MTERST	;WAIT FOR WBT.
	JRST	MRETRY		;GO RE-ISSUE READ OR WRITE.

MTERST:
	POP	P,MTIDSP	;STORE RETURN ADDRESS.
MTIGN:
	MOVEI	TAC,ICR		;RETURN ON ICR
	HRRM	TAC,MTCCON
	CONO	MTS,ICR		;ENABLE HARDWARE FOR ICR
	POPJ	P,		;DISMISS INTERRUPT

;INITIATE THE EXECUTION OF AN MTAPE FOR THE 
;   ERROR ROUTINES.  MUST BE CALLED FROM INTERRUPT LEVEL
;   WITH INTERFACE AND CONTROL READY (ICR)

MTXCT:
	POP	P,MTIDSP	;STORE RETURN ADDRESS
	MOVEI	TAC1,XNC	;RETURN ON XNC
	CONO	PI,PIOFF
	CONO	MTC,(TAC)	;ISSUE THE OPERATION
	CONO	MTS,XNC		;ENABLE THE HARDWARE
	HRRM	TAC1,MTCCON	;AND THE SOFTWARE
	CONO	PI,PION		;ALLOW INTERRUPTS AGAIN
	POPJ	P,		;DISMISS INTERRUPT

;LOGICAL END OF TAPE LOOP
MTLEOT:
	MOVEI	ITEM,7		;BACKSPACE
	PUSHJ	P,MTAPE2
	PUSHJ	P,MTCHK2	;CALL INTERLOCK. PICKUP IOS
				;AFTER PREVIOS TASK FINISHED.
MTEOT2:
	MOVEI	ITEM,16		;SPACE ONE FILE
	PUSHJ	P,MTAPE2
	MOVEI	ITEM,6		;SPACE ONE RECORD
	PUSHJ	P,MTAPE
	PUSHJ	P,MTCHK2	;CALL INTERLOCK. 
				;RETURN WHEN SPACING DONE WITH NEW IOS
	TLNN	IOS,IOSEOF	;WAS EOF DETECTED?
	JRST	MTEOT2		;NO, RESUME SPACING.
	MOVEI	ITEM,7		;PREPARE FOR BACKSPACE MTAPE
	JRST	MTAPE2		;BACKSPACE, LOGICAL EOT FOUND RETURN TO CALLER

;DEVICE DEPENDENT DUMP MODES. MODE 16.
;OUTPUT:
MTDMPO:

	PUSHJ	P,COMCHK
	JRST	ADRERR
	PUSHJ	P,MTCHEK	;IS SYSTEM AVAILABLE
	TLO	IOS,IO		;WRITING
	CONSZ	MTS,TWL		;WRITE LOCK?
	JRST	MTOUTE		;YES.
	MOVE	TAC1,[BLKO DC,3400!<MTDC*10>!DCTCHN]
				;BLKO AND DATA CONTROL COMMAND
	HRRZ	TAC,UUO		; COMMAND LIST POINTER
	MOVEI	ITEM,2B27	;WRITING COMMAND
MTDMP1:
	HRLI	TAC,PROG	;ACTUAL ADDRESS OF COMMAND LIST
	MOVEM	TAC,MTCMDP	;COMMAND POINTER
	SKIPN	TAC,@TAC	;COMMAND WORD
	JRST	MTEND1
	TLNN	TAC,777777
	JRST	MTDMP1		;CHANGE COMMAND SEQUENCE
	HLROM	TAC,SVCNTR	;SAVE COUNTER
	MOVEI	TAC,(TAC)	;GET ADDRESS ALONE
	SUB	TAC,SVCNTR	;GET LAST ADDRESS
	CAILE	TAC,JOBPFI	;ABOVE PROTECTED PART OF JOB DATA AREA?
	CAMLE	TAC,USRREL(PID)	;LESS THAN END?
	JRST	MTDMP2		;OUT OF BOUNDS
	MOVE	TAC,@MTCMDP	;PICK UP POINTER AGAIN
	ADDI	TAC,(PROG)	;GET ACTUAL ADDRESS
	PUSHJ	P,MTINDC	;MOVE TAPE
	JRST	WAIT1

;INPUT
MTDMPI:

	PUSHJ	P,COMCHK
	JRST	ADRERR
	PUSHJ	P,MTCHEK
	TLZ	IOS,IO		;READING
	TRNE	IOS,IODEND	;END-OF-FILE?
	JRST	MTEND1		;YES. GIVE BACK MAG TAPE.
	MOVE	TAC1,[BLKI DC,4000!<MTDC*10>!DCTCHN]
				;BLKI AND DATA CONTROL COMMAND
	HRRZ	TAC,UUO		;GET COMMAND LIST POINTER
	MOVEI	ITEM,5B27	;READ COMMAND
	JRST	MTDMP1		;DUMP
;ADDRESS ERROR

MTDMP2:
	PUSHJ	P,MTEND1
	JRST	ADRERR

MTDPI1:
	TRNE	IOS,IODEND	;EOF?
	JRST	MTEND1		;YES.
	MOVEI	ITEM,5B27	;READ COMMAND
	MOVE	TAC1,[BLKI DC,4000!<MTDC*10>!DCTCHN]
	JRST	MTDMP3

MTDPO1:
	CONSZ	MTS,TEP		;AT EOT?
	JRST	MTEND1		;YES.
	MOVEI	ITEM,2B27	;WRITE COMMAND.
	MOVE	TAC1,[BLKO DC,3400!<MTDC*10>!DCTCHN]
MTDMP3:
	HRLI	TAC,PROG	;FOLLOW COMMAND LIST.
	MOVEM	TAC,MTCMDP
	SKIPN	TAC,@TAC
	JRST	MTEND1		;END OF LIST.
	JUMPGE	TAC,MTDMP3	;CHANGE OF LIST.
	HLROM	TAC,SVCNTR
	HRRZS	TAC
	SUB	TAC,SVCNTR
	HLRZ	DAT,PROG
	CAILE	TAC,JOBPFI
	CAMLE	TAC,DAT
	JRST	MTDMP2
	MOVE	TAC,@MTCMDP
	ADDI	TAC,(PROG)
	JRST	MTINDC		;GO DO BLKO/BLKI

MDRTRY:
	MOVE	TAC,@MTCMDP	;RETRY LAST OPERATION
	ADDI	TAC,(PROG)
	TLNN	IOS,IO		;INPUT?
	JRST	MDRT1		;YES.
	MOVE	TAC1,[BLKO DC,3400!<MTDC*10>!DCTCHN]
	MOVEI	ITEM,2B27	;WRITE COMMAND.
	JRST	MTINDC

MDRT1:
	MOVE	TAC1,[BLKI DC,4000!<MTDC*10>!DCTCHN]
	MOVEI	ITEM,5B27	;READ COMMAND
	JRST	MTINDC		;START TAPE AND DISMISS INTERRUPT.
BEND MTCSER
;: MTCSER[J17,SYS] EOF.
;: XGPSER[J17,SYS]
COMMENT ⊗   VALID 00034 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	BEGIN	XGPSER	
SUBTTL	XGPSER	SERVICE ROUTINES FOR XEROX GRAPHICS PRINTER
C00006 00003		DISPATCH FOR XGPSERVICE
C00007 00004		MTAPE UUO for the XGP.
C00011 00005		MTAPE UUO
C00016 00006		SET ERROR CODE ROUTINES.
C00018 00007		INITIALIZATION, RELEASE.
C00020 00008		DUMP MODE OUTPUT UUO.
C00023 00009		START THE XGP FROM THE PDP-10
C00025 00010		SET I-LEVEL DISPATCH AT FIRST UUO.
C00027 00011		XGP BUFFERED MODE OUTPUT UUO, CLOSE UUO
C00034 00012		XGPIOW	START XGP AND WAIT UNTIL IT EMPTIES THE BUFFER
C00036 00013		XGPUUO	COMMUNICATE TO/FROM THE FONT COMPILER
C00038 00014		FONT COMPILER ROUTINES.  FCREQ, FCWAIT, XWAKE, XPAUSE,FCWAKE
C00043 00015		MORE ROUTINES FOR FC
C00047 00016		INTERPROCESSOR COMMUNICATION AT CLOCK LEVEL. HUNG TIMEOUT
C00050 00017		User Programming for the XGP
C00057 00018		INTERRUPT LEVEL ROUTINES
C00064 00019		HERE FOR 'NOT XGPOK'	ALSO, QUEUE CUT MARKS.
C00066 00020		MODE 17 I-LEVEL
C00072 00021		XADV	ADVANCE IOWD AT I-LEVEL
C00075 00022		BUFFER ADVANCE AT I-LEVEL
C00080 00023		Character Mode for the XGP
C00091 00024		MODE 0	COMMENTS ABOUT INTERNAL STRUCTURE.
C00102 00025		MODE 0  CHANNEL 2 INTERRUPTS
C00112 00026		MODE 0 I-LEVEL  'SCAN PHASE'
C00116 00027		ROUTINES TO MANIPULATE COMMAND HEADER BLOCKS.
C00123 00028		XGP LINE COMPILER CO-ROUTINES
C00128 00029		HERE TO QUEUE A TEXT NODE.
C00136 00030		MODE 0	GET NEXT CHARACTER
C00139 00031		HERE FOR SPECIALS
C00141 00032		HERE TO PROCESS RUBOUT
C00154 00033		HERE FOR A 'NORMAL' CHARACTER
C00158 00034	BEND XGPSER
C00159 ENDMK
C⊗;

BEGIN	XGPSER	
SUBTTL	XGPSER	SERVICE ROUTINES FOR XEROX GRAPHICS PRINTER
;R. E. GORIN JANUARY, 1973

;BITS FOR THE XGP:

;CONO XGP,

SETX←←140000			;SETS THE COLUMN REGISTER IN INTERFACE
SETN←←150000			;TURNS ON 1 BITS IN INTERFACE
SETPI←←160000			;SET PI CHANNEL, DONENB, BLANK, PAPER,CLRDON
	DONENB←←100		;ALLOWS DONE TO BE SET
;	BLANK←←40		;IGNORE BUFFER DATA
	PAPER←←20		;TURN ON THE PAPER
	CLRDON←←10		;CLEAR DONE
	SETALL←←SETPI+PAPER+DONENB+CLRDON+XGPCHN
				;THIS IS USUAL CONO WHILE SENDING DATA
	

SETCON←←170000			;ALLOWS SWPBUF,CUTNOW, AND MARKIT COMMANDS
	SWPBUF←←4		;SWAP BUFFERS
	CUTNOW←←2		;CUT PAPER RIGHT NOW.
	MARKIT←←1		;MARK PAPER TO BE CUT LATER.

;CONI XGP,
	XGPOK←←100		;INTERFACE AND XGP ARE READY WHEN THIS BIT IS OFF!
;	VIDENB←←40		;VIDEO DATA IS HAPPENING RIGHT NOW.
	NZ←←20			;SET WHEN INTERFACE IS READY FOR ANOTHER COMMAND
	↑XGPDON←←10		;DONE. (REFERENCED IN OUTER)

;LH BITS IN XGPIOS
	XPAPER←←200		;XGP IS RUNNING PAPER NOW (PAPER UP TO SPEED)
	XGPERR←←400		;PDP-6 DETECTED ERROR


TNSIZE←←100			;SIZE OF TEXT NODE
VNSIZE←←5			;VECTOR NODE SIZE


ERRMSK←←IOIMPM!IODTER!IODERR!IOBKTL	;ERROR BITS


;	DISPATCH FOR XGPSERVICE

	JRST	XGPINI			;SYSTEM INITIALIZATION
	JRST	HUNG			;HUNG TIME OUT
↑XGPDSP:
	JRST	XGPREL			;RELEASE
	JRST	XCLSO			;CLOSE OUTPUT
	JRST	XOUT			;BUFFERED OUTPUT
	JRST	ILLINP			;INPUT ILLEGAL
	JRST	CPOPJ1			;ENTER
	JRST	CPOPJ1			;LOOKUP
	JRST	XDMPO			;DUMP MODE OUTPUT
	JRST	ILLINP			;DUMP INPUT
	POPJ	P,			;USETO
	POPJ	P,			;USETI
	POPJ	P,			;UGETF
	JRST	CPOPJ1			;RENAME
	POPJ	P,			;CLOSE INPUT
	POPJ	P,			;UTPCLR
	JRST	XMTAPE			;MTAPE


DWCNT:
	POINT	6,XGPGCW,35		;WORD COUNT
LNSKIP:
	POINT	11,XGPGCW,11
COLSKP:
	POINT	12,XGPGCW,23

;	MTAPE UUO for the XGP.
COMMENT $

	MTAPE  CHAN,ADR
where CHAN is the channel number on which the  XGP has been opened is
interpreted as follows:
	ADR contains  the operation selector.  The  data at ADR+1 and
following depends on the operation selected.

Operation

0		Return error status.
		ADR+1/	major error code
		ADR+2,3,4/ error data

1		Font selection.
		ADR+1/ Font file name in sixbit
		ADR+2/ Font extension
		ADR+3/ PPN of font file
		ADR+4/ font identification number. (0 to 15.)
		(This UUO will skip if there is no error).

		The font named will be read by  the font compiler. It
		will be  assigned the font identification number that
		you supply. The  identification number  is used  only
		by the Font selection operator.

2		Read Margins
		ADR+1/ Top of page margin
		ADR+2/ Page body size
		ADR+3/ Bottom of page margin.
		ADR+4/ Left margin
		ADR+5/ Right side margin
		ADR+6/ Minimum interline space

3		Set Margins
		ADR+1/ Top of page margin 		<37777
		ADR+2/ Page body size			<37777
		ADR+3/ Bottom of page margin.		<37777
		ADR+4/ Left Margin			< 3777
		ADR+5/ Right side margin. 		Left < Right < 7777
		ADR+6/ Minimum interline space		< 3777

		If the bottom of page margin is set to 0 then the paper
		will not be cut.  If the page body size is set to 0 then
		the paper will be cut only when a form feed is encountered.
		The action of form feed in this case is to space down by the
		amount specified in the bottom of page margin and then cut.

4		Get status
		ADR+1/	XGPIOS is returned
		ADR+2/	-1 if I-level is running, else 0.

5		Pseudo Close. 
		Contents of the system buffer are transmitted to the XGP.
		XGP is not marked as CLOSEd, but another CLOSE is nearly
		a no-op.

6		Set Node Counts
		ADR+1/  The number of Text Nodes (currently =16)
		ADR+2/  The number of Vector Nodes (Currently =100)
		Zero in either parameter will use the default.
$

;	MTAPE UUO
XMTAPE:
	XCTR	XR,[SKIPL TAC,(UUO)]	;N.B. THIS ADDRESS CHECKS BEGINNING OF DATA
	CAIL	TAC,XMTTLN
	MOVNI	TAC,1
	SKIPG	XMTTAB(TAC)		;SKIP UNLESS WE NEED A CLOSE FIRST.
	TDNN	IOS,[DEVSBB,,IOACT]	;DEVICE MUST NOT BE ACTIVE.
	JRST	@XMTTAB(TAC)		;DISPATCH
	PUSH	P,UUO
	MOVEI	UUO,0			;MAKE THE EFFECTIVE ADDRESS 0 FOR CLOSE.
	PUSHJ	P,XCLSO			;FORCE A CLOSE FIRST
	POP	P,UUO
	XCTR	XR,[MOVE TAC,(UUO)]	;GET DISPATCH AGAIN  (CAN'T BE WRONG)
	JRST	@XMTTAB(TAC)

		CPOPJ
XMTTAB:
		XMTP0
	SETZ	XMTP1
		XMTP2
	SETZ	XMTP3
		XMTP4
		XCLSP			;FORCE DATA TRANSMISSION, PSEUDO CLOSE.
	SETZ	XMTP6			;SET NODE COUNTS
XMTTLN←←.-XMTTAB

XMTP0:
	XCTR	XR,[MOVE TAC,4(UUO)]	;ADDRESS CHECK LAST WORD (FIRST WORD IS OK)
	HRRI	TAC1,1(UUO)		;DESTINATION
	PUSHJ	P,RELOCA		;RELOCATE DESTINATION
	JRST	ADRERR			;ADDRESS CHECK
	JUMPL	TAC1,ADRERR		;WRITE PROTECTED
	HRLI	TAC1,XGPERC		;SOURCE
	MOVEI	TAC,3(TAC1)
	BLT	TAC1,(TAC)
	SETZM	XGPERC			;CLEAR ERROR COUNT
	POPJ	P,

XMTP1:
	XCTR	XR,[MOVE TAC,4(UUO)]	;ADDRESS CHECK THE END OF THE TRANSFER
	MOVEI	TAC1,1(UUO)		;RELATIVE FIRST LOC OF SOURCE
	PUSHJ	P,RELOCA
	JRST	ADRERR
	MOVSI	TAC,(TAC1)		;SWAP TO SOURCE
	HRRI	TAC,XGPNST+1		;DESTINATION
	BLT	TAC,XGPNST+4

	MOVEI	TAC,2			;OP CODE FOR FONT COMPILER.
	MOVEM	TAC,XGPNST
	PUSHJ	P,FCREQ
	POPJ	P,			;LOSE ERROR CODE WILL BE SET ALREADY
	MOVE	TAC,XGPOST		;GET OLD STATUS
	CAIE	TAC,2			;EXPECTED REPLY IS YESSIR
	JRST	FCERRX			;OOPS FC REPLIED WRONG.
	MOVE	TAC,XGPOST+1		;GET RELATIVE ADDRESS OF FONT TABLE
	MOVE	TAC1,XGPNST+4		;GET FONT NUMBER THAT WE TOLD THE FC.
	MOVEM	TAC,XFTADR(TAC1)
	JRST	CPOPJ1

XMTP2:
	XCTR	XR,[MOVE TAC,6(UUO)]	;ADDRESS CHECK LAST WORD (FIRST WORD IS OK)
	MOVEI	TAC1,1(UUO)		;DESTINATION
	PUSHJ	P,RELOCA
	JRST	ADRERR
	JUMPL	TAC1,ADRERR
	HRLI	TAC1,XGPPS1		;SOURCE
	MOVEI	TAC,5(TAC1)		;LAST WORD OF DESTINATION
	BLT	TAC1,(TAC)
	POPJ	P,

XMTP3:
	MOVEI	TAC1,0
XMTP3A:
	XCTR	XR,[MOVE TAC,1(UUO)]
	ANDI	TAC,37777
	MOVEM	TAC,XGPPS1(TAC1)
	ADDI	UUO,1
	CAIGE	TAC1,2
	AOJA	TAC1,XMTP3A
	XCTR	XR,[MOVE TAC,1(UUO)]	;LEFT MARGIN
	ANDI	TAC,3777
	MOVEM	TAC,XGPLMR
	XCTR	XR,[MOVE TAC,2(UUO)]	;RIGHT MARGIN
	ANDI	TAC,7777
	CAMG	TAC,XGPLMR
	MOVEI	TAC,7777
	MOVEM	TAC,XGPRMR
	XCTR	XR,[MOVE TAC,3(UUO)]
	ANDI	TAC,3777
	MOVEM	TAC,XGPILS
	POPJ	P,

XMTP4:
	MOVE	IOS,XGPIOS
	XCTR	XW,[MOVEM IOS,1(UUO)]
	MOVE	TAC,XGPIGO
	XCTR	XW,[MOVEM TAC,2(UUO)]
	POPJ	P,

XMTP6:
	XCTR	XR,[SKIPG TAC,1(UUO)]	;GET THE TEXT NODE COUNT
	MOVEI	TAC,NTNODE
	MOVEM	TAC,XNTNOD
	XCTR	XR,[SKIPG TAC,2(UUO)]
	MOVEI	TAC,NVNODE
	MOVEM	TAC,XNVNOD
	POPJ	P,

;	SET ERROR CODE ROUTINES.
XERR1:
	JSP	TAC,XERRC		;FC LOSSAGE: JOB CAPACITY EXCEEDED
XERR2:
	JSP	TAC,XERRC		;FC LOSSAGE: NO INITIAL RESPONSE.
XERR3:
	JSP	TAC,XERRC		;FC LOSSAGE: NO INTERMEDIATE RESPONSE.
XERR4:
	JSP	TAC,XERRC		;FC LOSSAGE: ILLEGAL RESPONSE.
XERR5:
	JSP	TAC,XERRC		;I-LEVEL  DATA MISSED. - BUFFERED MODE.
XERR6:
	JSP	TAC,XERRC		;XGP IS HUNG - HUNG TIMEOUT.
XERR7:
	JSP	TAC,XERRC		;ILLEGAL MODE.
XERR10:
	JSP	TAC,XERRC		;LINE COMPILER ERROR. LINE TOO COMPLEX.
XERR11:
	JSP	TAC,XERRC		;OUT OF ORDER
XERR12:
	JSP	TAC,XERRC		;I MISSED IT!
XERR13:
	JSP	TAC,XERRC		;PAGE TOO LONG
XERR14:
	JSP	TAC,XERRC		;ILLEGAL VECTOR PARAMETERS

XERRC:
	SKIPE	XGPERC			;ONLY LET ONE ERROR THROUGH
	POPJ	P,			;
	SUBI	TAC,XERR1
	HRRZM	TAC,XGPERC		;SET ERROR CODE FOR USER.
XERRCL:
	SETZM	XGPERC+1		;AND CLEAR EXTRA ERROR WORDS.
	SETZM	XGPERC+2
	SETZM	XGPERC+3
	POPJ	P,

FCERRX:
	PUSHJ	P,XERR4			;SET ERROR CODE.
	MOVE	TAC,[XGPOST,,XGPERC+1]	;GET FC STATUS
	BLT	TAC,XGPERC+3		;STORE FC STATUS AS 3 EXTRA ERROR WORDS.
	POPJ	P,

;	INITIALIZATION, RELEASE.

XGPINI:
	SYNINI	XGPCSC		;INITIALIZE XGP SYNCHRONIZATION CELLS.
	SETZM	XFLAPC		;FLAPPER COUNT
	SETZM	XFLAPB		;FLAPPER BITS
	SETZM	XFLAPA		;MORE FLAPPER BITS
	SETZM	XCUTQ
	MOVE	TAC,[POINT 36,XCUTQ-1,35]
	MOVEM	TAC,XCUTBP
	SETZM	XIBUF		;THERE IS NO INTERNAL BUFFER FOR DEVICE.

XCPIN1:
	SETZM	XGPGO		;NO ONE READY TO XFER DATA.
	SETZM	XGPHDW		;ZERO HEADER IOWD
	SETZM	XGPAT2
	SETZM	XGPMDP		;INITIALIZE DUMP MODE STUFF
	SETZM	XGPNXC	
	SETZM	XGPBIG
	SETZM	XGPIWD
	SETZM	XGPERC		;CLEAR ERROR CODE.
	MOVE	TAC,[XMSET,,XGPPS1]
	BLT	TAC,XGPBLN
	JRST	XERRCL		;CLEAR MINOR ERROR CODES AND RETURN


↑XGPIN2:			;P2 INITIALIZE THE XGP.
	MOVSI	IOS,XPAPER
	PUSHJ	P,XGPCLR
	SETZM	P2CH2		;SO XGPP2 WILL START XGP NOW.
	SETOM	XGPP2F		;LET CLOCK LEVEL START US.
	JRST	XGPP2		;RUN OUR CLOCK LEVEL AND RETURN TO SYSINI


XGPREL:
	SETOM	XGPKIL
	PUSHJ	P,FCKILL	;KILL THE FONT COMPILER
	SKIPE	AC1,XIBUF
	PUSHJ	P,FSGIVE
	SETZM	XIBUF
	PUSHJ	P,PSYNCX	;
	SETZM	XGPBIT		;TELL PDP-6 THAT WE DON'T HAVE ANY MORE.
	MOVE	IOS,[XGPERR!IOW!DEVSBB!IOBEG!IOEND,,ERRMSK!IOACT]
	ANDCAM	IOS,XGPIOS
	PUSHJ	P,XSYNCX	;RELEASE SYNCHRONIZER
	JRST	XCPIN1


;	DUMP MODE OUTPUT UUO.
XDMPO2:
	TRNE	IOS,ERRMSK
	POPJ	P,			;DON'T WAIT IF HE'S GOT ERROR BITS ON.
	PUSHJ	P,WSYNC			;STOP FOR A WHILE. (SETS IOW)
XDMPO:
	SKIPE	XGPNXC			;IS THERE A 'NEXT' COMMAND ALREADY?
	JRST	XDMPO2			;YES. WAIT UNTIL THERE ISN'T ONE

	PUSHJ	P,COMCHK		;CHECK COMMAND LIST
	JRST	ADRERR			;ADDRESS ERROR IN COMMAND.
	MOVE	J,JOB(PID)		;FIX J, CLOBBERED BY COMCHK
					;UUO POINTS TO FIRST COMMAND IOWD OR 0.
	HRRZ	TAC,UUO			;COMMAND LIST POINTER
	HRLI	TAC,PROG
	SKIPN	@TAC			;GET ACTUAL COMMAND WORD.
	POPJ	P,			;NULL COMMAND LIST. DO NOTHING.
	MOVEM	TAC,XGPNXC		;POINTER TO COMMAND SAVED AS 'NEXT COMMAND'
	SKIPE	XGPMDP			;IS THERE A CURRENT MAIN POINTER?
	JRST	XDMPO5			;YES.
	SETZM	XGPNXC			;XGP IS IDLE, CLEAR NEXT
	SUBI	TAC,1
	MOVEM	TAC,XGPMDP		;AND SET MAIN.
XDMPO5:
	PUSHJ	P,PSYNCX
	MOVE	IOS,XGPIOS
	TLZE	IOS,IOBEG		;IF IOBEG,
	PUSHJ	P,SETXIO		;SET I-LEVEL DATA DISPATCH.
	TRNE	IOS,ERRMSK
	JRST	XSYNCX			;IN CASE OF ERROR, DESYNCHRONIZE AND RETURN
	PUSHJ	P,XSYNCX
	PUSHJ	P,XGPSTR		;START THE XGP. (DON'T CLOBBER J,PROG)
	PUSHJ	P,PSYNCX
	MOVE	IOS,XGPIOS
	TRNE	IOS,ERRMSK
	JRST	XSYNCX			;FLUSH ERRORS.
	MOVEM	PROG,XGPROG		;SET UP FOR XADV
	PUSHJ	P,SETACT
	PUSHJ	P,XSYNCX
	SETOM	XGPGO			;TELL PDP-6 TO START DOING DATA.
	TRNE	IOS,100			;CONTINUOUS MODE?
	JRST	TPOPJ			;AVOID CALLING WSYNC IN UUOCON
XDMPO8:
	PUSHJ	P,WAIT1			;RETURN WHEN IOACT OFF.
XDMPO1:
	SETZM	XGPGO
	PUSHJ	P,PSYNCX
	SETZM	XGPBIT
	JRST	XSYNCX

;	START THE XGP FROM THE PDP-10
XGPSTR:
	SETZM	XGPKIL			;HERE TO START THE XGP
	SETZM	XGPAOK			;
XGSTR1:
	PUSHJ	P,PSYNCX
	SETOM	XGPCNY			;IF PAPER IS MOVING, I-LEVEL JUMPS TO PAPOON.
	SETOM	XGPBIT			;TELL PDP-6 WE WANT PAPER MOTION.
	LDB	TAC,PDVTIM
	DPB	TAC,PDVCNT
	MOVE	IOS,XGPIOS		;GET CURRENT STATE OF AFFAIRS
	TDNE	IOS,[DEVSBB,,IOACT]	;IS THE BEAST RUNNING NOW?
	JRST	XGSTR4			;YES. RETURN QUICK
	PUSHJ	P,XSIOS			;SET IOS RIGHT.
	PUSHJ	P,XSYNCX
	LDB	J,PJOBN
	MOVNI	IOS,DIOWQ		;REQUEUE TO DIOW TO ALLOW SYNC.
	MOVEM	IOS,JOBQUE(J)
XGSTR2:
	PUSHJ	P,WSCHED		;RESCHEDULE.
	MOVE	IOS,XGPIOS
	TLNE	IOS,IOW			;DID THE RIGHT GUY BRING ME OUT?
	JRST	XGSTR2			;NO. WAIT SOME MORE.
	TRNE	IOS,ERRMSK		;ANY ERRORS?
	POPJ	P,			;YES. RETURN THEM
	PUSHJ	P,PSYNCX
	PUSHJ	P,XSIOS			;SET SOME GOOD BITS IN XGPIOS.
XGSTR4:
	TLO	IOS,IO!IOW
	TRNE	IOS,100			;OVERLAPPED MODE?
	TLZ	IOS,IOW			;YES. THEN NOT REALLY IN IOW.
	MOVEM	IOS,XGPIOS
	JRST	XSYNCX			;RETURN. PAPER IN MOTION.

XSIOS:
	MOVSI	IOS,IOW!IO!DEVSBB	;ASSUME BUFFERED MODE
	MOVE	TAC,XGPDDB+DEVCMR
	TLNN	TAC,DEVIBF		;SKIP IF REALLY BUFFERED MODE
	TDC	IOS,[DEVSBB,,IOACT]	;FLUSH DEVSBB, TURN ON IOACT FOR DUMP MODE.
	IORB	IOS,XGPIOS		;SET THOSE BITS.
	POPJ	P,

;	SET I-LEVEL DISPATCH AT FIRST UUO.
SETXIO:
	LDB	TAC,PIOMOD
	MOVE	TAC,XIODSP(TAC)
	TRNE	IOS,100		;SPECIAL MODE?
	MOVS	TAC,TAC
	HRRZM	TAC,XDISP2	;
	TRNE	TAC,-1		;SKIP IF ZERO DISPATCH
	JRST	SETXI1
	TRO	IOS,IOIMPM	;ILLEGAL.
	PUSHJ	P,XERR7
SETXI1:
	MOVEM	IOS,XGPIOS
	LDB	TAC,PIOMOD
	MOVE	IOS,XGPDDB+DEVCMR
	CAIL	TAC,D
	TLZA	IOS,DEVIBF	;NO INTERNAL BUFFER IN DUMP MODE
	TLO	IOS,DEVIBF	;INTERNAL BUFFER IN BUFFERED MODE.
	MOVEM	IOS,XGPDDB+DEVCMR
	MOVE	IOS,XGPIOS
	POPJ	P,

XIODSP:
	0,,XCIBEG		;MODE 0
	0,,XCIBEG		;MODE 1
	0			;MODE 2
	0			;MODE 3
	0			;MODE 4
	0			;MODE 5
	0			;MODE 6
	0			;MODE 7
	0			;MODE 10
	0			;MODE 11
	0			;MODE 12
	0,,XCIBEG		;MODE 13 - SAME AS MODE 0
	0			;MODE 14
	0			;MODE 15
	0			;MODE 16
	XDI,,XDI		;MODE 17 

XGPSET:
	PUSHJ	P,PSYNCX
	IORB	IOS,XGPIOS
XSYNCX:
	XSYNC	XGPCSC
	POPJ	P,

XGPCLR:
	PUSHJ	P,PSYNCX
	ANDCAB	IOS,XGPIOS
	JRST	XSYNCX

PSYNCX:
	PSYNC	XGPCSC
	POPJ	P,

;	XGP BUFFERED MODE OUTPUT UUO, CLOSE UUO
XCLSP:
	MOVEI	UUO,0			;KLUDGE FOR MTAPE 5.
XCLSO:
	MOVSI	IOS,IOEND		;FLAG CLOSE UUO.
	PUSHJ	P,XGPSET
	LDB	TAC,PIOMOD		;GET THE MODE.
	CAIL	TAC,SD			;IS THIS A DUMP MODE?
	JRST	XDMPO8			;YES. WAIT FOR ALL IO AND STOP XGP
	PUSHJ	P,OUT			;DO ONE MORE OUTPUT.
	MOVSI	IOS,IOBEG		;NOW, READY TO INITIALIZE AGAIN.
	JRST	XGPSET			;SET IOBEG IN DEVIOS AND RETURN.

XOUT:
	MOVEI	IOS,ERRMSK		;CLEAR ANY ERRORS
	PUSHJ	P,XGPCLR		;...
	TLNN	IOS,IOBEG		;FIRST OPERATION?
	JRST	XOUT1			;NO.
	MOVE	AC3,XGPBLN
	SKIPN	AC1,XIBUF		;IN CASE SOMEONE LEFT IT HERE
	PUSHJ	P,UFSGET		;GET A BLOCK OF FREE STORAGE.
	MOVEM	AC1,XIBUF		;FIRST LOC OF BUFFER.
	MOVEM	AC1,XTAKE		;TAKE POINTER
	MOVEM	AC1,XPUT		;PUT POINTER
	SETZM	XBFCNT			;BUFFER COUNT.
	ADD	AC1,XGPBLN
	MOVEM	AC1,XIBFND		;END OF BUFFER+1
	PUSHJ	P,NFONT			;IF WE NEED A FONT, GET ONE.
	JRST	F.LOSE			;(N.B. DON'T CLEAR IOBEG!)
	PUSHJ	P,PSYNCX
	MOVE	IOS,XGPIOS		;ONCE THIS IS SET UP,...
	TLZ	IOS,IOBEG		;NOW, NO LONGER THE BEGINNING
	PUSHJ	P,SETXIO
	PUSHJ	P,XSYNCX
XOUT1:
	MOVE	IOS,XGPIOS		;IF ERRORS, REPORT THEM TO USER
	TRNE	IOS,ERRMSK		;DON'T TRY TO GO ON.
	POPJ	P,
	PUSHJ	P,DEVSTU		;SET UP TO PROCESS THIS BUFFER
	JRST	XOUT3			;BUFFER IS ALREADY EMPTY?
	CAMLE	AC2,XGPBLN		;COULD IT EVER FIT?
	JRST	XBTLRR			;NO. FLUSH LOSER.
	JUMPE	AC2,XOUT2A		;TAKE 2 GIANT STEPS IF EMPTY BUFFER
	MOVE	TAC,XGPBLN
	SUB	TAC,XBFCNT		;TAC←SPACE REMAINING.
	CAILE	AC2,(TAC)		;IS THERE SPACE ENOUGH?
	JRST	XOUT4			;NO ROOM. WE HAVE TO WAIT
	MOVE	TAC,XPUT
	CAMGE	TAC,XTAKE
	JRST	XOUT2			;PUT<TAKE DATA FITS FROM PUT TO TAKE
					;WE NEED TO DO ONLY ONE BLT.

	MOVE	TAC1,XIBFND		;POINTER TO THE END OF THE BUFFER+1
	SUBI	TAC1,(TAC)		;CALCULATE SPACE TO THE END.
	CAIL	TAC1,(AC2)		;COMPARE WITH DATA SIZE...
	JRST	XOUT2			;ONE BLT WILL SUFFICE.

	HRLI	TAC,(AC3)		;S,,D FOR BLT
	MOVE	AC1,XIBFND		;END OF THE BLT+1
	BLT	TAC,-1(AC1)		;FROM USER THRU THE END OF THE BUFFER.
	MOVE	TAC,XIBUF		;NEW XPUT INTO TAC.
	ADDI	AC3,(TAC1)		;MAKE NEW POINTER TO USER.
	SUBI	AC2,(TAC1)		;MAKE NEW COUNT.
	PUSHJ	P,PSYNCX
	ADDM	TAC1,XBFCNT		;INCREMENT THE BUFFER USE COUNT.
	PUSHJ	P,XSYNCX
XOUT2:
	HRLI	TAC,(AC3)		;DATA WILL FIT UPWARDS FROM PUT.
	MOVEI	AC1,(TAC)		;S,,D IN TAC.  D IN AC1.
	ADDI	AC1,(AC2)		;COMPUTE LAST DESTINATION OF BLT+1
	BLT	TAC,-1(AC1)		;MOVE DATA.
	CAML	AC1,XIBFND		;IS POINTER AT THE END NOW?
	MOVE	AC1,XIBUF		;YES. WRAP BACK TO FRONT.
	MOVEM	AC1,XPUT		;SAVE THE NEW PUT POINTER.
	PUSHJ	P,PSYNCX
	ADDM	AC2,XBFCNT		;INCREMENT BUFFER SIZE.
	PUSHJ	P,XSYNCX
XOUT2A:
	PUSHJ	P,ADVBFE		;ADVANCE THE OUTPUT BUFFER
	JRST	XOUT3			;NO MORE DATA THERE.
	JRST	XOUT1			;PROCESS NEXT BUFFER FULL.

XOUT3:
					;HERE IF SYSTEM BUFFER IS NOT FULL.
	TLNE	IOS,IOEND		;IS THIS THE LAST UUO?
	SKIPG	XBFCNT			;LAST UUO. IS THERE DATA TO SEND?
	POPJ	P,			;NO DATA OR NOT LAST (LET USER ADD MORE).
	SETZM	XGPWSZ			;ZERO WAITING SIZE ⊃ LAST UUO.
					;XGP WILL RESDUCE XBFCNT TO 0 BEFORE
					;REACTIVATING P1.
	PUSHJ	P,XGPIOW		;YES. START XGP AND WAIT.
	JRST	F.LOSE			;FONT COMPILER LOSES
	POPJ	P,			;HERE WE LOST WITH XGP ERROR.
	MOVSI	IOS,IOEND		;NO LONGER LAST UUO.
	PUSHJ	P,XGPCLR		;CLEAR BIT.
	JRST	XDMPO1			;CLEAR OUT REMAINING BITS AND CELLS.


XOUT4:
					;HERE IF SYSTEM BUFFER TOO FULL.
	SUB	AC2,XGPBLN
	MOVNM	AC2,XGPWSZ		;WHEN XBFCNT≤XGPWSZ, P2 REACTIVATES P1.
					;SPACE THAT WE'LL NEED.
	TLNN	IOS,IOEND		;LAST UUO?
	PUSHJ	P,DEVCR			;NOT LAST. CHECK BUFFER RING USE BIT.
	JRST	XOUT5			;USER HAS NO FREE BUFFERS. OR CLOSE UUO
	POPJ	P,			;WAIT UNTIL USER FILLS ALL HIS BUFFERS.
XOUT5:
	PUSHJ	P,XGPIOW		;USER HAS NO FREE BUFFERS. START XGP. WAIT.
	JRST	F.LOSE			;FONT COMPILER LOSES
	POPJ	P,			;WE LOST WITH XGP HUNG.
	JRST	XOUT1			;SYSTEM BUFFER ¬FULL. GOBBLE USER BUFFER.


XBTLRR:
	SETOM	XGPKIL			;STOP THE XGP. GRIND. ARRGH.
	JRST	BTLERR			;GIVE USER A MESSAGE.

;	XGPIOW	START XGP AND WAIT UNTIL IT EMPTIES THE BUFFER

XGPIOW:

	SKIPE	XGPBIT			;ARE WE TELLING PDP-6 WE WANT PAPER?
	JRST	XGPIO1			;YES. THEN PAPER MUST BE GOING.
					;NO IT'S TIME TO START XGP.
	SKIPG	XFCJN			;DOES FC EXIST?
	JRST	XGPIO0			;NO SO DON'T LOCK IT
	PUSHJ	P,FCLOCK
	POPJ	P,
XGPIO0:
	PUSHJ	P,XGPSTR		;START THE XGP.
	MOVE	IOS,XGPIOS
	TRNE	IOS,ERRMSK
	JRST	CPOPJ1			;ERRORS.  TELL LOSER.
XGPIO1:
	MOVSI	IOS,IOW!DEVSBB		;IOWAIT, SYSTEM BUFFER BUSY
	PUSHJ	P,XGPSET
	SETOM	XGPGO			;DATA IS IN CORE (SYSTEM) AND READY.
	MOVNI	TAC,DIOWQ		;REQUE TO DEVICE WAIT...
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,WSCHED
	MOVE	IOS,XGPIOS
	TLNE	IOS,IOW			;REALLY DONE?
	JRST	XGPIO1			;NO
	JRST	CPOPJ2			;YES

;	XGPUUO	COMMUNICATE TO/FROM THE FONT COMPILER
;	CALLED BY CALL AC,['XGPUUO']

;	AC LEFT POINTS TO FC CURRENT STATUS BLOCK. (20 WORDS)
;	AC RIGHT POINTS TO FC NEW STATUS BLOCK.(20 WORDS)
;	IF THERE IS NO NEW STATUS, JOB WILL BE REQUEUED TO WAIT.

↑XGPUUO:
	MOVE	TAC,JBTPRV(J)
	TLNN	TAC,XGPPRV
	POPJ	P,			;WRONG CREDENTIALS.

	SETZM	XGPOST			;ASSUME BY DEFALT, NULL OLD STATUS.
	XCTR	XR,[HLRZ TAC,(UCHN)]	;GET THE OLD SATAUS ADDRESS.
	JUMPE	TAC,XGPUU1		;JUMP IF THERE IS NO OLD STATUS
	MOVEI	TAC1,17(TAC)		;CHECK ENDING ADDRESS FOR LEGALITY
	XCTR	XR,[MOVE TAC1,(TAC1)]	;WE LOSE CONTROL ON ADDRESS CHECK.
	ADDI	TAC,(PROG)		;ADDRESS OF NEW STATUS.
	MOVSI	TAC,(TAC)		;SOURCE
	HRRI	TAC,XGPOST		;OLD STATUS BLOCK
	BLT	TAC,XGPOST+17		;GOBBLE OLD STATUS
XGPUU1:
	PUSHJ	P,XWAKE			;REPORT OLD STATUS TO ONE WHO WAITS.
	PUSHJ	P,XPAUSE		;AND PUT US TO BED.
	XCTR	XR,[HRRZ TAC,(UCHN)]	;GET THE NEW STATUS ADDRESS.
	JUMPE	TAC,XGPUU2		;JUMP IF NO NEW STATUS BLOCK.
	MOVEI	TAC1,17(TAC)		;CHECK ENDING ADDRESS FOR LEGALITY
	XCTR	XR,[MOVE TAC1,(TAC1)]
	HRLI	TAC,XGPNST		;NEW STATUS BLOCK
	ADDI	TAC,(PROG)
	MOVEI	TAC1,17(TAC)
	BLT	TAC,(TAC1)
XGPUU2:
	POPJ	P,

;	FONT COMPILER ROUTINES.  FCREQ, FCWAIT, XWAKE, XPAUSE,FCWAKE
;	NEW STATUS FOR XGP HAS TO BE SET UP BEFORE CALL.

FCREQX:
	POP	P,J
	MOVE	PROG,JBTADR(J)
	JRST	XERR1			;LOSE BECAUSE OF JOB CAPACITY EXCEEDED

FCREQ:
	SKIPE	XFCJN			;DOES FC EXIST?
	JRST	FCREQ1			;YES. JUST WAKE IT UP.
	PUSH	P,J			;CREATE A FONT COMPILER
	PUSHJ	P,INIJOB		;ATTEMPT TO GLOM A JOB SLOT
	JRST	FCREQX			;NONE AVAILABLE
	JRST	FCREQX			;WAIT FOR FREE STORAGE. (CAN'T HAPPEN).
	MOVE	AC3,['XGPSYS']		;PPN OF FONT COMPILER.
	MOVEM	AC3,PRJPRG(J)
	MOVEM	AC3,JOBPPN(J)
	MOVE	AC1,['[-FC-]']		;NAME OF FONT COMPILER.
	MOVEM	AC1,JOBNAM(J)
IFN FTSTAT,<PUSHJ P,NAMSTT>
	MOVSI	AC1,XGPPRV
	MOVEM	AC1,JBTPRV(J)
	MOVEM	AC1,JB2PRV(J)		;ALSO PASSIVE ONES
	MOVSI	AC1,JNA
	IORM	AC1,JBTSTS(J)
	MOVEM	J,XFCJN
	LSH	J,=12
	ADD	J,[GETBT0,,1]		;PLANT CLOCK REQUEST.
	CONO	PI,PIOFF
	IDPB	J,CLOCK
	CONO	PI,PION
	POP	P,J			;RESTORE J AND WAIT.
	MOVE	PROG,JBTADR(J)		;RESET THIS
	PUSHJ	P,FCWAIT		;AND WAIT FOR IT TO TELL US 'READY'
	JRST	XERR2			;OOPS.
FCREQ1:
	MOVE	TAC,PRJPRG(J)
	MOVEM	TAC,XGPNST+17		;SET USER PPN AS PART OF NEW STATUS
	MOVEM	J,XGPNST+16		;AND USER JOB NUMBER TOO.
	PUSHJ	P,FCWAKE		;WAKE THE FONT COMPILER.  GIVE IT NEW STATUS
	PUSHJ	P,FCWAIT		;WAIT FOR FC TO RESPOND
	JRST	XERR3			;OOPS.
	JRST	CPOPJ1			;CALLER WILL INSPECT FC STATUS.


FCWAIT:
	MOVE	TAC,XCLKNM
	LSH	TAC,=12
	ADD	TAC,[FCRQCK,,=60*JIFSEC]
	CONO	PI,PIOFF
	IDPB	TAC,CLOCK
	CONO	PI,PION
;HERE XGPSER WAITS FOR FC (OR TIMEOUT)
	SETOM	XGPFC1			;FLAG THAT WE ARE WAITING FOR FC
	SETZM	FCRQER			;INITIALLY, NO ERROR.
FCWAT1:
	MOVNI	TAC,IOWQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,WSCHED		;DELAY
	SKIPE	XGPFC1			;IS THIS WAKEUP LEGITIMATE?
	JRST	FCWAT1			;NO. WAIT MORE.
	SKIPE	FCRQER			;CLOCK TIME OUT?
	POPJ	P,			;YES. FAILURE. (OOPS)
	AOS	TAC,XCLKNM		;CANCEL THE CLOCK REQUEST.
	CAILE	TAC,77
	SETZM	XCLKNM
	JRST	CPOPJ1			;RETURN SUCCESS.

FCRQCK:
	CAME	TAC,XCLKNM
	POPJ	P,
	SETOM	FCRQER			;CLOCK ERROR
;HERE FC (OR TIMEOUT) WAKES XGPSER
XWAKE:
	SETZM	XGPFC1			;XGP NOT WAITING FOR FC ANY MORE.
	PUSH	P,J
	MOVEI	DDB,XGPDDB
	LDB	J,PJOBN
	JUMPE	J,XWAKE1
	SKIPL	JBTSTS(J)		;DON'T START HIM IF HE CANT RUN
	JRST	XWAKE1
	MOVNI	TAC,RUNQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
XWAKE1:
	POP	P,J
	POPJ	P,

;HERE THE FC WAITS FOR XGPSER
XPAUSE:
	SETOM	XGPFC2			;FC WAITS FOR SYSTEM
	HRRZM	PROG,XFCADR		;SAVE REL ADDRESS OF FC
	MOVNI	TAC,IOWQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,WSCHED
	SKIPE	XGPFC2
	JRST	XPAUSE			;WOKEN FOR THE WRONG REASON
	POPJ	P,

;HERE XGPSER WAKES UP THE FC
FCWAKE:
	PUSH	P,J			;WAKE UP FC
	SETZM	XGPFC2			;FC NOT WAITING FOR SYSTEM ANY MORE
	SKIPLE	J,XFCJN			;SKIP IF THERE'S NO SUCH JOB
	SKIPL	JBTSTS(J)		;JOB EXISTS. SKIP IF IT CAN BE RUN
	JRST	XWAKE1			;CANT RUN OR NO SUCH JOB
	MOVNI	TAC,RUNQ
	MOVEM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
	JRST	XWAKE1


;	MORE ROUTINES FOR FC
FCLOCK:
	MOVEI	TAC,3
	MOVEM	TAC,XGPNST
	PUSHJ	P,FCREQ
	POPJ	P,			;TIME OUT.  ERROR CODE IS SET ALREADY
	SKIPE	XGPOST			;EXPECTED REPLY IS 'READY'
	JRST	FCERRX			;BARF! SET EXTENDED ERRORS
	JRST	CPOPJ1

FCKILL:
	SETZM	XGPNST
	SETZM	XFTADR			;CLEAR OUT OUR MEMORY OF OLD FONTS
	MOVE	TAC,[XFTADR,,XFTADR+1]
	BLT	TAC,XFTADR+17
	SKIPG	TAC,XFCJN		;GET OLD JOB NUMBER
	POPJ	P,
	MOVSI	TAC1,XGPPRV
IFE FTSTAT,<
	TDNE	TAC1,JBTPRV(TAC)	;ARE WE SURE THIS IS THE RIGHT JOB?
	SETZM	JOBNAM(TAC)		;YES. CLEAR JOB NAME.
>;IFE FTSTAT
IFN FTSTAT,<
	TDNN TAC1,JBTPRV(TAC)
	JRST $FCKIL
	SETZM JOBNAM(TAC)
	PUSH P,J
	MOVE J,TAC
	PUSHJ P,NAMSTT
	POP P,J
$FCKIL:

>;FTSTAT
	ANDCAM	TAC1,JBTPRV(TAC)	;CLEAR OUT PRIVILEGES
	PUSHJ	P,FCWAKE		;WAKE HIM UP TO DIE.
	SETZM	XFCJN
	POPJ	P,

XBIDSP:
	4001			;BITS ON FOR MODES THAT NEED FONTS

NFONT:
	LDB	TAC,PIOMOD	;GET THE MODE AGAIN
	MOVEI	TAC1,1
	LSH	TAC1,(TAC)
	TDNN	TAC1,XBIDSP	;NEEDING A FONT?
	JRST	CPOPJ1		;NO.
	MOVEI	TAC,1		;ALLOCATE COMMAND
	MOVEM	TAC,XGPNST
	MOVE	TAC,XNTNOD	;NUMBER OF TEXT NODES
	IMULI	TAC,TNSIZE	;TIMES THEIR SIZE
	MOVEM	TAC,XGPNST+1	;STORE
	MOVE	TAC,XNVNOD	;NUMBER OF VECTOR NODES
	IMULI	TAC,VNSIZE	;TIMES THEIR SIZE
	ADDM	TAC,XGPNST+1	;ADD TO TEXT NODE SPACE, TOTAL NODE SPACE NEEDED
	PUSHJ	P,FCREQ		;REQUEST ALLOCATION FROM FC
	POPJ	P,		;LOSE.
	MOVE	TAC,XGPOST
	CAIE	TAC,1		;EXPECTED RESPONSE IS 'ALLOCATION MADE'
	JRST	FCERRX		;UNEXPECTED RESPONSE.
	MOVE	TAC,XGPOST+1
	MOVEM	TAC,XFREBA	;SAVE ADDRESS OF THE ALLOCATION.
	SKIPE	XFTADR		;YES. WE NEED A FONT. SKIP UNLESS WE HAVE ONE.
	JRST	CPOPJ1		;NO. MAKES THINGS EASY.
	SETZM	XGPNST+1
	SETZM	XGPNST+2
	SETZM	XGPNST+3
	SETZM	XGPNST+4
	MOVEI	TAC,2
	MOVEM	TAC,XGPNST
	PUSHJ	P,FCREQ
	POPJ	P,		;TIME OUT. ERROR CODE IS SET ALREADY.
	MOVE	TAC,XGPOST
	CAIE	TAC,2
	JRST	FCERRX		;ERROR. UNEXPECTED RESPONSE.  SET EXTENDED ERROR
	MOVE	TAC,XGPOST+1
	MOVEM	TAC,XFTADR	;STOW FONT ADDRESS
	JRST	CPOPJ1

F.LOSE:
	MOVEI	IOS,IODTER		;USE THIS BIT FOR FC LOSSAGE
	JRST	XGPSET			;SET BIT IN IOS AND RETURN TO UUOCON.


;	INTERPROCESSOR COMMUNICATION AT CLOCK LEVEL. HUNG TIMEOUT

HUNG:
	SKIPN	XGPAOK		;IS THE MAJIC CELL SET?
	JRST	HUNG1		;NO.. IT MUST REALLY BE HUNG
	SETZM	XGPAOK
	LDB	TAC,PDVTIM
	DPB	TAC,PDVCNT	;RESET HUNG TIME..
	JRST	CPOPJ1		;THE XGP IS STILL THERE.

HUNG1:
	SETOM	XGPKIL		;KILL THE XGP
	MOVEI	IOS,IOIMPM	;TELL HIM AN ERROR.
	PUSHJ	P,XGPSET	;SET BITS
	PUSHJ	P,XERR6		;SET ERROR CODE
	TRNE	IOS,200		;IS USER ENABLED TO HANDLE HUNG XGP?
	AOS	(P)		;YES.  DON'T GIVE HIM HUNG DEVICE THEN.
	PUSHJ	P,XDMPO1	;SHUT OFF XGPGO, XGPBIT
	MOVE	IOS,[DEVSBB,,IOACT]
	PUSHJ	P,XGPCLR	;CLEAR IOACT AND KICK THE PDP-10

;PDP-10 HERE 
↑XGPP1:	SETZM	XGPP1F			;CLEAR REQUEST SET BY P2.
	MOVEI	DDB,XGPDDB		;DDB ADDRESS FOR STTIOD

	PUSHJ	P,PSYNCX
	MOVE	IOS,XGPIOS
	TLZE	IOS,IOW			;WAS HE IN WAIT?
	PUSHJ	P,STTIOD		;YES, GET HIM OUT FAST
	MOVEM	IOS,XGPIOS
	JRST	XSYNCX			;UNSYNCHRONIZE AND POPJ


;	PDP-6 HERE EVERY SECOND TO MAKE SURE THAT XGP IS RUNNING.
↑XGPP2:	MOVEI	TAC,JIFSEC
	MOVEM	TAC,XGPP2F		;BACK HERE IN 1 SECOND.
	MOVEI	TAC,0			;
	EXCH	TAC,P2CH2		;
	JUMPN	TAC,CPOPJ		;XGP HAS INTERRUPTED.
	CONSZ	XGP,XGPOK		;IS THE XGP STILL HAPPY?
	POPJ	P,			;NO. WELL, WHAT CAN I DO?
	CONO	PI,XGPOFF		;SNEAK IN.
	CONO	XGP,SETPI+XGPCHN+DONENB	;ASSIGN PI CHANNEL. WAIT FOR INTERRUPT.
	PUSHJ	P,XIHNG0		;SET UP TO RESYNCHRONIZE.
	CONO	PI,XGPON		;MAKE SURE CHANNEL IS LISTENING.
	POPJ	P,			;RETURN TO CLOCK LEVEL.

;	User Programming for the XGP
COMMENT $
	This  document reflects  the  state  of  the software  as  of
system 6.12/N.   Changes may be made without prior notice and without
maintaining compatability with earlier systems.

	The Xerox Graphics  Printer (XGP) provides a means  of making
a hardcopy listing  of virtually any drawing that can be expressed as
a one-bit raster.   The XGP  accepts as data  a bit array  describing
each  scan-line that  is printed.   Each  scan line  is approximately
1700 bits;  scan lines  are spaced at  about 190  per inch along  the
paper.   A picture is  built by sending successive  scan lines to the
XGP.

	There are presently two distinct modes  of operating the XGP,
video mode and character mode.

	Video Mode

	In video mode,  36 bit words  are interpreted as  video data.
Words  are grouped together into  portions of a scan-line  by the use
of a Group Command Word (GCW).  The GCW precedes the data  portion of
the group.  The GCW specifies how  many words of video data are to be
found  in this  group.   Also  the GCW  allows the  video data  to be
positioned anywhere along  the scan  line.  The  exact format of  the
GCW is:

	BYTE (1)MARK (11)LNSKIP (12)COLSKP (6)UNUSED, DWCNT

	The fields of the GCW are interpreted as follows:

	The  paper will  be advanced  by  LNSKIP blank  lines
	before  printing.   LNSKIP =  1  is used  for normal,
	single spacing. LNSKIP  = 0  prevents any advance  to
	the next  scan line  and prints on  the same  line as
	the last group.

	The column register in the XGP  interface will be set
	to COLSKP before transmitting data. 

	DWCNT words following the GCW will  be transmitted to
	the  XGP as  video data  (a bit  = 0  is white,  1 is
	black). If DWCNT = 0 then there are no data words  in
	this group and the next word is another GCW.

	After data is sent,  if the MARK bit is  1, the paper
	will  be marked  for cutting.   Paper cutting  is not
	exact so a MARK  should be preceeded and followed  by
	several blank lines.

	The field  labeled UNUSED  has no  meaning currently.
	It  should be set to zero  to avoid confusion if some
	other meaning is attached to this field.


	
	Modes 17  and 117  are used  for video  data.   All of  these
modes accept the format that is described above.

	In mode 17,  the effective address of the OUT uuo points to a
standard dump  mode command  list.   The command  list specifies  the
data  to send  to the  XGP.   Each  OUT  will wait  until the  entire
command  list is processed before  returning to the  user.  The paper
will be cut at the completion of each command list.  

	Mode 117 is like mode  17 except that the OUT uuo  returns to
the user while data is being  sent to the XGP.  In this mode the user
can overlap the input of one  data block with the output of  another.
Three data blocks are  needed in this mode: one being  emptied by the
XGP, another  pending, and another being filled  by the user program.
The first two  OUT uuos will  return immediately (having  established
the current  and pending output  blocks).   After the user  fills his
third block  and gives an OUT uuo he will be forced to wait until the
current block  is  empty (at  which time  the  pending block  becomes
current and  the  block specified  in this  OUT will  become the  new
pending block).   When the third OUT returns, the first block will be
free to use.  In  video mode the XGP  requires up to 10,000 words  of
data per second.   Care should be exercised in  programming to always
have data ready for the XGP.

	Another requirement  of mode  117 is  that the command  lists
that  point to the  three data blocks  must be disjoint.   The actual
requirement is that  the command list  for each  block must be  valid
while the block is  being output.  In particular, don't  use the same
physical location in your program for more than one command list.

	In mode 117 you must do a CLOSE UUO  after the last OUTPUT to
force  the transmission of  all buffers to  the XGP.   It is possible
that a user  program may not be  able to supply  data fast enough  in
mode 117.  In this event,  the output will  be cut wherever  the data
runs  out.  A status bit, 2000  (IOTEND), is provided which warns the
program that this  has occurred.   This bit is  set only in mode  117
when the data runs out and no CLOSE has been done.

$

;	INTERRUPT LEVEL ROUTINES
;LOCATIONS MARKED WITH *1 ARE FIRST LEVEL DISPATCH TARGETS.
;LOCATIONS MARKED WITH *2 ARE SECOND LEVEL DISPATCH TARGETS.
;LOCATIONS MARKED WITH *4 ARE DISPATCH TARGETS AT PI CHANNEL 4. (TEXT MODE)
       

SDISP1:
	MOVEM	TAC,XDISP1		;JSP TAC,SDISP1 TO SET NEW DISPATCH ADDRESS
	POPJ	P,			;JSR XGPSAV MUST HAVE BEEN DONE ALREADY.

↑XGPINT:
	CONO	XGP,SETALL≠PAPER	;CLEAR DONE. SET DONE ENABLE, ETC.
	SOSLE	XFLAPC			;DECREMENT FLAPPER COUNT
	JRST	XGINT1
	MOVEM	TAC,XGPTMP		;SAVE TAC
	MOVEI	TAC,=100
	MOVEM	TAC,XFLAPC		;SET UP FLAPPER COUNT
	MOVE	TAC,XFLAPA		;WORD 1
	EXCH	TAC1,XFLAPB		;WORD 2
	LSHC	TAC,1			;SHIFT THEM BOTH
	MOVEM	TAC,XFLAPA		;STORE 1
	EXCH	TAC1,XFLAPB		;AND 2
	TRNE	TAC,1000		;TIME TO FLAP?
	DATAO	500,[20,,0]		;YES: FLAP THE FLAPPER
	MOVE	TAC,XGPTMP

XGINT1:
	SOSE	XCUTQ			;TIME TO CUT NOW?
	JRST	XGINT2			;NO.
	CONO	XGP,SETCON!CUTNOW
	SOS	XCUTBP
	MOVEM	TAC,XGPTMP
	MOVE	TAC,[XCUTQ+1,,XCUTQ]
	BLT	TAC,XCUTQ+=46		;MOVE QUEUE NODES DOWN
	MOVE	TAC,XGPTMP

XGINT2:
	CONSZ	XGP,XGPOK		;IS THE XGP STILL ALIVE?
	JRST	XIHUNG			;INTERFACE REPORTS XGP LOSSAGE.
	SETOM	XGPAOK			;TELL PDP-10 THAT WE STILL SEE INTERRUPTS.
	CONO	XGP,SETX
	CONO	XGP,SETCON!SWPBUF
	CONO	XGP,SETX
	JRST	@XDISP1			;DISPATCH LEVEL1


;*1	HERE TO ESTABLISH XGP SYNCHRONIZATION.
XGSYNC:
	SETZM	XGPIGO
	SOSLE	XYNCNT			;COUNT BUFFER SWITCHES.
	JEN	@XGPCHL			;DISMISS INTERRUPT
	JSR	XGPSAV
	MOVEI	TAC,=4096
	MOVEM	TAC,XYNCNT
XGIDLE:
	JSP	TAC,SDISP1		;WE ARE NOW IN SYNC. -SET TO IDLE

;*1	HERE TO MAINTAIN SYNCHRONIZATION.
	MOVEM	TAC,XGPTMP
	MOVE	TAC,XGPBIT
	JUMPN	TAC,XGSYGO		;IS THE PDP-10 REQUESTING ACTION?
	MOVE	TAC,XGPTMP
	JEN	@XGPCHL			;KEEP IDLING.

XGSYGO:
	MOVE	TAC,XGPTMP
	JSR	XGPSAV
	MOVEI	TAC,=600		;SET UP COUNT
	MOVEM	TAC,XGPCNT
	JSP	TAC,SDISP1		;SET NEW DISPATCH AND DISMISS

;*1 	RUN THE PAPER FOR 600 LINES UNTIL IT'S GOING FAST ENOUGH.
	CONO	XGP,SETALL		;START THE PAPER.
	SOSLE	XGPCNT
	JEN	@XGPCHL
	JSR	XGPSAV
	MOVSI	IOS,XPAPER
	PUSHJ	P,PSYNCX		;SET A BIT IN IOS,
	IORM	IOS,XGPIOS
	MOVE	IOS,XGPBIT		;THIS CELL HOLDS THE PDP-10'S DESIRES.
	JUMPE	IOS,.+2
PAPOON:
	SETOM	XGPP1F			;TELL PDP-10 TO LOOK.
	MOVE	IOS,[DEVSBB,,IOACT]
	ANDCAM	IOS,XGPIOS
	PUSHJ	P,XSYNCX
	JSP	TAC,SDISP1		;SET NEW DISPATCH.

;*1	HERE WE WAIT UNTIL PDP-10 SAYS DATAREADY
	CONO	XGP,SETALL
	JSR	XGPSAV
	MOVE	IOS,XGPKIL
	JUMPN	IOS,XMITFF		;JUMP IF PDP-10 IS KILLING THIS TRANSFER.
	MOVE	IOS,XGPGO
	JUMPE	IOS,CPOPJ
	JSP	TAC,SDISP1		;SET NEW DISPATCH AND DISMISS.

;*1	HERE FOR INTERRUPT AND WE WANT TO SEND DATA.
XMITIN:
					;DATA TRANSMIT INTERRUPT.
	SETOM	XGPIGO			;I-LEVEL DATA TRANSFER IN PROGRESS.
	CONO	XGP,SETALL		;CLEAR DONE, SET DONE ENABLE,PI, AND PAPER
	JSR	XGPSAV			;SAVE ALL AC'S FOR I LEVEL CODE.
	MOVE	TAC,XGPKIL		;LOOK TO SEE IF PDP-10 HAS TIMED OUT
	JUMPN	TAC,XMITFF		;PDP-10 THINKS WE'RE HUNG. STOP QUICK.
	PUSHJ	P,@XDISP2		;DISPATCH ACCORDING TO DATA MODE.
	POPJ	P,			;NORMAL RETURN. DISMISS.
	JRST	XMITFG			;END OF TRANSFER.
XMITFF:
	PUSHJ	P,QCUT			;FORCED END. CUT PAPER.
XMITFG:
	MOVEI	PID,P2PID		;MAKE SURE PID IS RIGHT.
	PUSHJ	P,PSYNCX
	MOVE	IOS,[DEVSBB,,IOACT]
	ANDCAM	IOS,XGPIOS
	SETZM	XGPBIT			;CLEAR XGPBIT SO IF THE 10 HANGS, WE DONT
	SETZM	XGPIGO			;I-LEVEL DATA XFER IDLE.
	SETOM	XGPP1F			;TELL PDP-10 THAT DATA XFER COMPLETE
;TRANSMISSION DONE. COUNT AS THE PAPER RUNS OUT 5000 LINES.
;CUT THE PAPER EVERY 2200 LINES (11 INCHES) SO THE STACKER WILL NOT HAVE
;20 INCH PAGES TO CONTEND WITH.
	MOVEI	TAC,=16
	MOVEM	TAC,XGPCNY		;16 TIMES 263 LINES
XMITD1:
	PUSHJ	P,XSYNCX		;RELEASE INTERLOCK
	MOVEI	TAC,=275
	MOVEM	TAC,XGPCNT
	JSP	TAC,SDISP1

;*1	HERE AFTER COMMAND LIST HAS RUN OUT. COUNT PAPER FEED.
	SOSLE	XGPCNT			;COUNT PAPER FEED
	JEN	@XGPCHL
	JSR	XGPSAV
	PUSHJ	P,PSYNCX
	SOSLE	TAC,XGPCNY
	TRNN	TAC,7
	PUSHJ	P,QCUT0			;QUEUE CUT (MARK PAPER TOO SO WE DON'T FORGET)
	JUMPG	TAC,XMITD1		;TIME TO STOP COUNTING THE PAPER?
	MOVSI	IOS,XPAPER		;WE WANT TO CLEAR THIS.
	MOVE	TAC,XGPBIT		;DOES PDP-10 HAVE THIS BIT ON?
	JUMPN	TAC,PAPOON		;YES. THEN DON'T CLEAR IT!
	ANDCAM	IOS,XGPIOS
	PUSHJ	P,XSYNCX
	JRST	XGIDLE			;SET IDLE DISPATCH.

;	HERE FOR 'NOT XGPOK'	ALSO, QUEUE CUT MARKS.
XIHUNG:
 JSR	XGPSAV
	MOVE	TAC,XGPBIT		;ARE WE SUPPOSED TO BE DOING SOMETHING?
	MOVSI	IOS,XPAPER		;
	TDNN	IOS,XGPIOS		;
	JUMPE	TAC,XIHNG0		;WE HAVE BEEN IDLE.
	PUSHJ	P,PSYNCX
	SETZM	XGPBIT			;WE ARE GOING TO BE IDLE.
	MOVEI	TAC,IODERR		;SET ERROR FLAG.
	IORM	TAC,XGPIOS
	ANDCAB	IOS,XGPIOS		;TURN OFF XPAPER IN XGPIOS.
	PUSHJ	P,XERR6			;XGP IS NOT OK.
	SETOM	XGPP1F			;TELL THE PDP-10 WE LOST.
	PUSHJ	P,XSYNCX
XIHNG0:
	MOVEI	TAC,=4096
	MOVEM	TAC,XYNCNT
	MOVEI	TAC,XGSYNC		;SET DISPATCH TO RESYNCHRONIZE XGP.
	MOVEM	TAC,XDISP1		;
	MOVEM	TAC,XGPIGO		;NOT IN DATA PORTION OF I-LEVEL
	POPJ	P,			;(POSITIVE DENOTES UNHAPPY!)

QCUT0:
	CONO	XGP,SETCON!MARKIT	;MARK PAPER TOO (SO WE DON'T FORGET)
QCUT:
	PUSH	P,TAC
	PUSH	P,TAC1
	MOVEI	TAC,XCUTQ		;GET THE ADDRESS OF THE CUT QUEUE
	MOVEI	TAC1,=4650		;THIS IS THE CUT DELAY (TWIDDLE)
QCUT1:
	CAILE	TAC,@XCUTBP		;ARE WE STILL IN THE LIST?
	JRST	QCUT2			;NO. (DONE)
	SUB	TAC1,(TAC)		;DECREMENT
	AOJA	TAC,QCUT1		;LOOK FOR MORE

QCUT2:
	CAILE	TAC1,=100		;CUT TOO SMALL?
	IDPB	TAC1,XCUTBP		;NO. ADD IT TO THE QUEUE
	POP	P,TAC1
	JRST	TPOPJ			;RESTORE TAC AND RETURN


;	MODE 17 I-LEVEL
;XGPIWD HAS ABSOLUTE AOBJN POINTER
;XGPMDP HAS PROG,,REL ADDRESS OF THIS IOWD.
;XGPROG HAS RELOCATION OF CURRENT JOB.

;*2	HERE AT FIRST LINE OF TRANSFER, OR FIRST LINE OF PAGE
XDI:
	SETZM	XSCNLN				;COUNT SCAN-LINES.
	MOVEI	TAC,XDILIN
	MOVEM	TAC,XDISP2
	JRST	XDILIN

XDI4:
	JSP	AC3,XADV			;HERE TO ADVANCE TO NEXT COMMAND

;*2	HERE WE KNOW THAT WE ARE ON A NEW SCAN LINE.
XDILIN:
	MOVE	TAC,XGPIWD			;GET CURRENT IOWD
	JUMPGE	TAC,XDI4			;JUMP IF IT HAS RUN OUT.
XDI0:
	MOVE	DAT,(TAC)			;GET GROUP COMMAND WORD.
	MOVEM	DAT,XGPGCW			;SAVE IT.
	LDB	DAT,LNSKIP			;GET THE LINE SKIP COUNT
	ADDM	DAT,XSCNLN			;COUNT SCAN-LINES
	SOJLE	DAT,XDI1			;JUMP IF THERE ARE NO LINES TO SKIP.
	MOVEM	DAT,XGPCNT			;SAVE COUNT
	JSR	XDISP2				;SET DISPATCH AND DISMISS INTERRUPT.

;*2	HERE TO SKIP LINES FOR A WHILE.
	SOSLE	XGPCNT				;DECREMENT COUNT OF LINES TO SKIP.
	POPJ	P,				;DISMISS
	MOVEI	DAT,XDILIN			;RESET INTERRUPT DISPATCH
	MOVEM	DAT,XDISP2
	MOVE	TAC,XGPIWD			;REFORM AC'S.
XDI1:
	LDB	DAT,COLSKP			;HOW FAR TO SKIP?
	CONO	XGP,SETX(DAT)			;SET X POSITION IN XGP
	AOBJN	TAC,.+1				;ADVANCE AOBJN POINTER.
	MOVEM	TAC,XGPIWD
XDI1A:
	HLRO	TAC1,TAC			;GET -(COUNT REMAINING)
	MOVM	TAC1,TAC1			;GET (COUNT REMAINING)
	LDB	AC1,DWCNT			;GET DATA COUNT FROM USER
	MOVEI	DDB,(AC1)			;A COPY.
	CAILE	AC1,(TAC1)			;DATA COUNT SHOULD BE SMALLER
	MOVEI	AC1,(TAC1)			;SET TO MAX ALLOWED COUNT.
	SUBI	DDB,(AC1)			;REMAINDER AFTER OVERFLO.
	DPB	DDB,DWCNT			;SAVE REMAINDER.
	MOVEI	TAC1,(AC1)			;AND THIS IS HOW WE FIX IOWD
	HRLI	TAC1,(TAC1)
	ADDM	TAC1,XGPIWD			;FIX AOBJN POINTER.
	JUMPE	AC1,XDI3			;POSSIBLE ZERO DATA WORDS.
	MOVNI	AC1,(AC1)			;AND FORM AOBJN POINTER IN TAC
	HRLI	TAC,(AC1)
	MOVE	AC1,TAC				;AOBJN POINTER IN AC1
	MOVEM	P,XGPTMP			;SAVE PUSHDOWN POINTER
	MOVSI	13,XDI2				;SOURCE,,DESTINATION
	BLT	13,13				;STUFF CODE IN AC'S
	JRST	XDI2A				;JUMP INTO THE START
						;RUN THE INNER LOOP IN THE AC'S.

XDI2:

	PHASE	0				;CODE ASSUMES AC1>13
XDI2A::
	MOVE	AC3,(AC1)			;0 GET 36 BITS OF VIDEO DATA.
	MOVEI	AC2,0				;1
	LSHC	AC2,=16				;2
	DATAO	XGP,AC2				;3 SEND 16 BITS
	MOVEI	AC2,0				;4
	LSHC	AC2,=16				;5
	DATAO	XGP,AC2				;6 ANOTHER 16
	LSHC	AC2,=16				;7
	IORI	AC2,200004			;10 OR BITS FOR SPECIAL MODE, WIDTH 4.
	DATAO	XGP,AC2				;11 SEND DATA
	AOBJN	AC1,XDI2A			;12 LOOP.
	JRST	XDI2B				;13
	DEPHASE

XDI2B:
	MOVE	P,XGPTMP			;RESTORE P
	MOVEI	PID,P2PID			;RESTORE PID
	LDB	TAC,DWCNT
	JUMPE	TAC,XDI3			;JUMP IF NO IOWD OVERFLOW.
	JSP	AC3,XADV			;ADVANCE TO NEW IOWD.
	MOVE	TAC,XGPIWD			;GET A NEW AOBJN POINTER.
	JRST	XDI1A				;PROCESS MORE VIDEO.

XDI3:
	SKIPGE	XGPGCW
	PUSHJ	P,XDICUT			;MAKE PAPER GET CUT
	SKIPL	TAC,XGPIWD			;PEEKING AT NEXT GCW
	POPJ	P,				;IOWD RAN OUT-NO NEXT GCW
	LDB	DAT,[POINT 11,(TAC),11]		;GET THE LINE SKIP FROM NEXT GCW
	JUMPE	DAT,XDI0			;IF COUNT=0, DO MORE ON THIS LINE.
	POPJ	P,				;RETURN. DONE WITH LINE.

XDICUT:
	PUSHJ	P,QCUT				;QUEUE A PAPER CUT
	MOVEI	TAC,XDI
	MOVEM	TAC,XDISP2
	MOVE	TAC,XSCNLN
	CAIL	TAC,=2000
	CAILE	TAC,=2200
	POPJ	P,				;PAGE SIZE IS UNUSUAL
	MOVEI	TAC,1
	IORM	TAC,XFLAPB			;FLAP THE FLAPPER (LATER)
	POPJ	P,				;

;	XADV	ADVANCE IOWD AT I-LEVEL
XADV:
	SKIPE	TAC1,XGPBIG		;PART OF A BIG TRANSFER LEFT?
	JRST	XADV2			;YES. SKIP SOME CODE
	MOVE	PROG,XGPROG		;HERE THE IOWD RAN OUT.
	SKIPN	XGPMDP			;IS THERE A COMMAND IN PROGRESS?
	JRST	XADV3			;NO. GET THE NEW COMMAND IF ANY.
	AOS	TAC1,XGPMDP		;GET RELATIVE POINTER AND INCREMENT
XADV1:
	HRLI	TAC1,PROG
	MOVEM	TAC1,XGPMDP
	MOVE	TAC1,@TAC1
	JUMPE	TAC1,XADV3		;COMMAND HAS RUN OUT. SEE IF ANOTHER
	TLNN	TAC1,-1
	JRST	XADV1			;FOLLOW JUMPS
	ADDI	TAC1,1(PROG)		;MAKE IT ABSOLUTE AOBJN WORD.
	MOVEM	TAC1,XGPIWD		;STORE AOBJN WORD.
	JUMPL	TAC1,(AC3)		;RETURN IF SMALL AOBJN WORD.
	TLC	TAC1,400000		;MAKE COUNT 400000 SMALLER.
	MOVEM	TAC1,XGPIWD		;SAVE THE SMALL PART TO DO FIRST
	HLRE	PROG,TAC1		;GET - COUNT OF FIRST PART
	SUB	TAC1,PROG		;CALC FIRST ADDR OF SECOND PART
	HRLI	TAC1,400000		;THIS IS HOW MANY WORDS
	MOVEM	TAC1,XGPBIG		;FLAG MORE TO DO
	JRST	(AC3)

XADV2:
	MOVEM	TAC1,XGPIWD
	SETZM	XGPBIG			;ONLY ONCE
	JRST	(AC3)

XADV3:
	MOVE	TAC1,XGPNXC		;SWAP ZERO FOR THE NEW COMMAND
	JUMPE	TAC1,XADV4		;FINISHED IF NO NEW COMMAND
	SETZM	XGPNXC			;CLEAR NEW COMMAND
	SETOM	XGPP1F			;KICK THE PDP-10
	JRST	XADV1			;AND PROCESS THE NEW COMMAND

XADV4:
	SETZM	XGPMDP			;NO MAJOR COMMAND
	AOS	(P)			;WE SHALL STOP XGP ON RETURN
	PUSHJ	P,PSYNCX
	MOVE	IOS,XGPIOS
	TRNE	IOS,100			;OVERLAPPED MODE?
	TLNE	IOS,IOEND		;YES.  CLOSE UUO DONE YET?
	JRST	XSYNCX			;NOT OVERLAPPED OR CLOSE DONE.
					;RELEASE SYNCHRONIZER AND STOP XGP.
	MOVEI	IOS,IOTEND		;OVERLAPPED MODE, END OF DATA AND NO CLOSE.
	IORM	IOS,XGPIOS		;TURN ON ERROR BIT
	JRST	XSYNCX			;RELEASE SYNCHRONIZER.

;	BUFFER ADVANCE AT I-LEVEL
;BFOSET IS CALLED AT THE BEGINNING OF EACH SCAN LINE TO CALCULATE AN
;AOBJN POINTER TO THE SYSTEM BUFFER. POINTER IS RETURNED IN TAC.

;BFNSET IS CALLED AT THE END OF EACH SCAN LINE TO ADJUST THE BUFFER COUNTS
;AND THINGS. ARGUMENT IS TAC, THE REMAINDER OF THE AOBJN POINTER.

;IF THE AOBJN POINTER RUNS OUT IN THE MIDDLE OF A SCAN LINE IT MAY BE DUE
;TO EITHER WRAP AROUND OR LACK OF DATA. CALL BFNSET TO REFORM PARAMETERS
;FOLLOWED BY BFOSET TO GET A NEW POINTER.  IN CASES OF NO DATA LEFT IN THE
;BUFFER, TAC WILL COME BACK AS A POSITIVE QUANTITY.

BFOSET:
	MOVN	AC1,XBFCNT			;GET -DATA COUNT IN BUFFER.
	MOVE	TAC,XTAKE			;GET TAKE POINTER
	SUB	TAC,XIBFND			;MAKE -COUNT FROM TAKE TO THE END.
	CAMGE	AC1,TAC				;SKIP IF DATA DOESN'T WRAP.
	MOVE	AC1,TAC				;WRAP AROUND. DO THE REST LATER.
	MOVE	TAC,XTAKE
	HRLI	TAC,(AC1)			;FORM AOBJN POINTER IN TAC
	MOVEM	TAC,XGPIWD			;SAVE HERE TOO.
	JRST	(AC3)				;RETURN.

BFNSET:
	MOVE	AC1,XTAKE
	SUBI	AC1,(TAC)			;COMPUTE -COUNT OF WORDS USED UP.
	HLLI	TAC,				;CLEAR TAC LEFT.
	CAML	TAC,XIBFND			;DID WE WRAP AROUND?
	MOVE	TAC,XIBUF			;YES. RESET TAKER
	MOVEM	TAC,XTAKE
	PUSHJ	P,PSYNCX
	ADDB	AC1,XBFCNT			;DECREASE COUNT OF SPACE IN USE.
	CAMG	AC1,XGPWSZ			;IS IT PROPER TO REACTIVATE PDP-10?
	SKIPN	XGPWSZ				;YES. SPECIAL FLAG FOR CLOSE?
	JRST	BFNST1				;NOT TIME YET, OR CLOSE IN PROGRESS
	MOVSI	IOS,DEVSBB
	ANDCAM	IOS,XGPIOS			;SYSTEM BUFFER NOT BUSY.
	SETOM	XGPWSZ				;DON'T REACTIVATE AGAIN SOON.
	SETOM	XGPP1F				;ACTIVATE PDP-10
BFNST1:
	PUSHJ	P,XSYNCX
	JRST	(AC3)

;	Character Mode for the XGP
COMMENT $

	Modes 0 and 13 are the character modes in  the XGP.  In these
modes,  36 bit words are  interpreted as five 7-bit  bytes.  There is
no fixed mapping between byte values and particular  graphic symbols.
The graphic  symbol for any  byte is defined  by the current  font in
use.  Certain  byte  values have  special  meanings  consistient with
ASCII and  one byte  value, octal  177, is  used as  an escape  which
gives the bytes that follow a special meaning.

	Character  mode  permits vectors  and  multiple  active  text
lines.

	Character mode interprets  7-bit bytes taken from  the user's
buffer as follows:

Byte	Usual meaning			Escape significance

0	Null - byte is ignored		Normal
1	Normal				XGP ESCAPE 1
2	Normal				XGP ESCAPE 2
3	Normal				XGP ESCAPE 3
4	Normal				XGP ESCAPE 4
5-10	Normal				Reserved
11	TAB				Normal
12	LF				Normal
13	Normal				Reserved
14	FF				Normal
15	CR				Normal
16-37	Normal				Reserved
40-176	Normal				Normal
177	ESCAPE				Normal

Normal means the definition of this byte in  the current font will be
printed.  If this byte is  undefined in the current  font, it will be
ignored.

ESCAPE causes the next  byte to  have an  alternate meaning  selected
from the column "Escape significance".

TAB produces  a column  select to  the column which  is at  least the
width  of a blank  to the right  of the current  column position, and
some multiple of 8 blank widths to the right of the left margin.

LF activates the current  text line. The current text  will be queued
to printed.   The default Y position of text  will be advanced by the
number of scanlines it  takes to draw this  line, plus the number  of
lines specified  by the  interline space argument  to the  margin set
MTAPE.   This default Y position will be  used for the next text line
(unless changed by a vector command or ESCAPE-3.

FF, like  LF, activates  the text.   In  addition, FF  causes a  page
eject  after the  current text  line is  printed.   FF also  sets the
defalut Y position to the first line below the top of page  margin on
the new page.

CR  causes  a  column  select  to  the  current  left  margin  to  be
generated.

XGP ESCAPE  1 ('177&'001) causes  the next  7 bits  to be  read as  a
special operation code.  The following codes are implemented:

	0-17	Font select.
		The code, 0 to 17 is taken as the font identification
		number of the font to use.

	20-37	Reserved for future use.

	40	XGP Column Selector
		The  next  14  bits  are taken  modulo  4096  as  the
		x-position to print  at next.  (The  intention  is to
		allow arbitrary width spaces for text justification.)

	41	XGP Underscore
		The next byte (in two's complement)  is  the relative
		scan line  on which the underscore is to occur, where
		0  represents  the  baseline  of  the  text, negative
		values   represent   lines  above  the  baseline  and
		positive  values  lines  below  it.  The next 14 bits
		(modulo 4096) specify the length of  the  underscore.
		(If  the  underscore command is the first thing on  a
		line, the baseline will be set to the baseline of the
		current font.)

	42	Line space.
		This does  a line feed and then takes the byte as the
		number of blank lines to insert before the next line.

	43	Base-line adjust.
		The next  7 bits are taken in two's complement as the
		base-line adjustment  to  the  current  font.     The
		adjustment sticks  until  reset  by  another   adjust
		command or a font select. The intention is to allow a
		font to be  used  for  subscripts  and  superscripts.
		(Increment baseline  for  superscript,  decrement for
		subscript).  

	44	Print the paper page number.
		The paper page number is set to 1 by a form feed.  It
		is  incremented  each  time  the  paper  is cut.  The
		decimal value of this count is printed.

	45	Accept heading text.
		The next  byte  is a  count of bytes to follow. Those
		bytes  will be read into the heading line.  When that
		count is exhausted, the heading line will be printed.
		If a line feed or line space command  is  given  that
		would cause text to be printed below the current text
		area,  a  form  feed  is inserted by the XGP and if a 
		heading is defined, it will be printed.

	46	Start Underline.
		Set the left end of an underline. See Stop Underline.

	47	Stop Underline.
		The  next byte is the scan line on which to write the
		underline (same as XGP Underscore).   The  extent  of
		the underscore is defined by this command  and  Start
		Underline. If this command is not preceded by a Start
		Underline, the results will be unpredictable.  Beware
		of column selects.  No  underline  will  happen until 
		this command is given.

	50	Set Inter-Character Space.  The next byte is taken as
		the  column  increment to add  after  each character. 
		Note:   this takes a major amount of extra compuation
		in the Stanford implementation.   Use of this feature
		may produce documents that cannot be listed.

XGP ESCAPE 2  ('177&'002) causes the next 7  bits to be taken  as the
column  increment.    This  quantity  is  signed: 0-77  are  positive
increments 100 to 177 are negative increments (100 → -100, 177 → -1).

XGP ESCAPE 3 ('177&'003) causes  the next 2 bytes to be  taken as the
scan line  number on which to  start this text line.   Scan line 0 is
the first  scan line  on the  page (immediately  following the  cut).
The topmost scanline  of the present text line will  be placed on the
scan  line indicated in this  command.  (If there  is no current text
line, the next text line will be put there.)

XGP ESCAPE 4 ('177&'004).   This escape is used to  specify a vector.
It is followed by 11 bytes describing the vector:

	2 bytes	Y0	Scan line number of first line of vector.
	2 bytes X0	Column  position of left  edge of first  line
			of the vector.
	3 bytes DX	Delta X. 1 bit of sign; 11  bits  of integer;
			9 bits of fraction.
	2 bytes N	The number of scan lines on which this vector
			is visible.
	2 bytes W	The column width of each scan-line.

The  XGP   service  must   be  presented   with  vectors  sorted   by
ascendending  values  of Y0.   If  the  vectors are  not  sorted, the
output will be wrong.

The escape significance  of codes 5 through  10,  13, and  16 through
37 is not defined at the present time but reserved for future use.

$

;	MODE 0	COMMENTS ABOUT INTERNAL STRUCTURE.
COMMENT $
	The code  to process  text in mode  0 is  broken up into  two
phases.   There is  the 'line assembly'  phase which  occurs once per
text line  and  the 'scan'  phase  which  occurs once  per  generated
scanline.

	The 'scan' phase  is intended to  be quite simple.  The inner
loop for this phase  is at SCANX, and runs in the accumulators on the
PDP-6.   The  scan phase  excutes commands  from  a buffer  that  was
generated during  the line  assembly.  The  buffer has  the following
format:


XLINE:

	CAIL	AC1,MIN 		;←----(UCHN - MAJOR COMMAND)
	CAIL	AC1,MAX
L1:
	JRST	L2			;JUMP TO NEXT MC
	MOVEI	TAC,(AC1)
	SUBI	TAC,@.-4
	ROT	TAC,-1
	JSP	AC2,.+2	
	0,,L8				;POINT TO NEXT MINOR GROUP
					;USED BY JRST @(AC2)

;THIS GROUP MAY BE REPEATED FOR EVERY EXPLICIT COLUMN SELECT.-------------⊗
	CONO	XGP,140000+COLUMN	;COLUMN SELECT FOR MINOR GROUP	  |
	JSP	AC3,SCAN		;CALL ROUTINE TO TRANSMIT DATA	  |	
 	-N,,.+1				;←----(DSER - CURRENT AOBJN)	  |
	BLOCK	N			;DATA TO SEND 			  |
;-------------------------------------------------------------------------⊗

	JRST	@(AC2)
L2:
	CAIL	AC1,MIN			;SECOND MAJOR COMMAND
	CAIL	AC1,MAX
L3:
	JRST	L6			;JUMP TO NEXT MC
	MOVEI	TAC,(AC1)
	SUBI	TAC,@.-4
	ROT	TAC,-1
	JSP	AC2,.+2
	0,,L5				;POINT TO NEXT MINOR GROUP
	CONO	XGP,
	JSP	AC3,SCAN
	-N,,.+1
	BLOCK	N
	JRST	@(AC2)
L4:
	JSP	AC2,.+2
	0,,L1				;POINT TO NEXT MINOR GROUP
	....
	JRST	@(AC2)
L5:
	JSP	AC2,.+2
	0,,L3
	...
	JRST	@(AC2)
L6:
	CAIL	AC1,MIN
	CAIL	AC1,MAX
L7:
	JRST	CPOPJ
	MOVEI	TAC,(AC1)
	SUBI	TAC,@.-4
	ROT	TAC,-1
	JSP	AC2,.+2
	0,,L7
	...
	JRST	@(AC2)
L8:
	JSP	AC2,.+2
	0,,L4
	...	
	JRST	@(AC2)

In  an attempt  to provide  job  security, the  author  made this  so
complicated  that no one else  can understand it.   That he failed is
evident:
 he doesn't understand it either.

Pending Queue and Active Lists.
The line compiler processes  text and compiles text nodes  and vector
nodes.   These nodes  are queued  on a single  list.  The  Scan Phase
processes these queues and  activates nodes at the appropriate  time.
There are 4  kinds of nodes; narrow vectors, wide  vectors, text, and
page mark.  Each of  these node types (except the page  mark node) is
linked  onto a separate  list for  the per-scanline processing.   The
page mark node causes all active nodes to be cancelled.

   Narrow Vector  Wide Vector	Text		Page
	
0  Link		  Link		Link		Link
1  Y0		  Y0		Y0		Y0
2  X0,,n	  X0,,n		-n		0
3  Width	  Width		Link-2		-1
4  DX		  DX		Unspecified	EOFFLG

Y0 in  all  cases denotes  the scan  line  number on  which the  node
becomes active. 'n'  denotes the number of lines on which the node is
active.  The  nodes are  all queued on  a single pending  list.   The
nodes are distinguished  by word 2 (negative means text  node) and by
word  3 (negative means page node,  narrow and wide are distinguished
by the values of Width).

Vector nodes are 5 words.  Text nodes are 64. words.

The first interrupt to  transmit data activates XCIBEG in  channel 2.
This routine arranges  for XCPINI, the compiler initialization, to be
run in  channel  4, and  it actiavates  an  interrupt in  channel  4.
XCIBEG also  initializes the  pending queue and  the active  lists to
empty.

Subsequent  channel 2 interrupts  will inspect the  pending queue and
activate the first  node on that queue  when ready.  Nodes  that have
been activated are  linked onto one of the three active lists. (There
is no list  for page  nodes, since only  one can be  active).   After
activating  any pending  nodes that  have become  active, the  active
lists  are  processed.    As  each  active  node  is  processed,  its
activation  counter is  decremented.    When the  activation  counter
reaches 0,  the node is deactivated  by delinking it  from the active
list and linking it to the appropriate free list.  Whenever additions
to the free lists are made, the compiler is activated.

Page  mark  nodes  are  treated specially.    When  such  a  node  is
activated  the paper is  marked for cutting.   Since  there should be
nothing active across the cut mark, all active nodes  are deactivated
without further processing and returned to free storage.  If the cell
EOFFLG in the page mark node contains  a non-negative quantity,  that
signifies that the  end of text processing has been reached.  Channel
2 will  exit  to the  co-routines that  feed  paper and  prepare  for
another transfer.

The active  vector nodes are  processed quite simply.   X←X+dX.   The
vector is  drawn at the new X position for  the specified width.  The
only peculiarity  about vectors  is the  separation,  by width,  into
narrow and wide  vectors.  This separation is  necessary because wide
vectors  take longer to process  in the XGP  interface and no further
interface commands  may be issued  until the  processing of the  wide
vector stops.

Active text  nodes are  processed by  loading AC1  with the  scanline
number and  executing the subroutine that was  compiled into the text
node.  The  text subroutine is  called with  a PUSHJ P,  instruction.
The first location of the subroutine is the fourth word of the node.

The compiler is initialized at XCPINI.  The  address of XCPINI is set
into X2DISP, the  compiler co-routine restart address, by XCIBEG. The
initialization builds the  free vector  node list and  the free  text
node list.   The initial column  position,  Y position,  and font are
set here.   The compilation of each line is started at XCI.  When the
first printing  character (or  underscore  command) is  compiled,   a
text  node  is taken  from  the free  list  and  initialized.   PDP-6
instructions are compiled  into the  text node.   If  there are  more
instructions than  will fit,  another text  node is  gotten from  the
free list and  linked appropriately to the existing nodes.  If at any
point there are no text nodes free, the compiler sets  an appropriate
co-routine restart  address and dismisses until  activated by channel
2.    When a  vertical  spacing  character is  encountered,  the line
compilation is terminated. The text node is linked to  the end of the
pending  queue.   From  the particular  line  spacing character,  the
vertical position of the  next line is calculated.   (Form feed  will
cause a page mark node to be generated and  queued, as will line feed
off  the bottom of the  page body.) After queuing  the text node, the
compiler starts on the next text line.

$

;	MODE 0  CHANNEL 2 INTERRUPTS
;*2	HERE ON FIRST INTERRUPT TO SEND DATA.
XCIBEG:
	MOVEI	TAC,XCPINI		;INITIAL DISPATCH FOR THE COMPILER
	MOVEM	TAC,X2DISP		;SET FOR CHANNEL 4.
	SETZM	XPENDH			;NO PENDING LIST.
	MOVEI	TAC,XPENDH
	MOVEM	TAC,XPENDT		;TAIL OF THE PENDING LIST POINTS TO HEAD.
	SETZM	XASVLH			;NO ACTIVE LISTS.
	SETZM	XALVLH
	SETZM	XATLH
	SETOM	XSCNLN			;MORE INITIALIZATION
	PUSHJ	P,QCUT			;MAKE A CUT HERE.
	CONO	PI,1B24!<1⊗<7-XGPC2N>>	;MAKE AN INTERRUPT ON CH4
	MOVE	TAC,[JRST P2CH4S]
	MOVEM	TAC,P2CH4E		;CLOBBER CHANNEL 4 EXIT ROUTINES.
	JSR	XDISP2			;SET DISPATCH FOR ALL OTHER INTERRUPTS.

;*2	HERE ON NORMAL, CH 2 DATA TRANSFER INTERRUPT.
XCW:
	SETZM	XACT4			;NO NEED TO KICK CH4 YET.
	AOS	AC1,XSCNLN		;INCREMENT PAGE POSITION.
XCW1:
	SKIPE	AC2,XPENDH		;ANY PENDING NODES?
	CAMGE	AC1,1(AC2)		;YES.  TIME YET?
	JRST	XCW3			;NONE PENDING OR NOT YET.
	CAMG	AC1,1(AC2)		;DID WE MISS IT?
	JRST	XCW1X			;NO. RIGHT ON TIME
	MOVE	IOS,[XGPERR,,IODERR]	;SET ERROR BIT FOR USER. WE CONTINUE
	PUSHJ	P,XGPSET		;UNTIL THE END OF THE NEXT LINE IN CH4
	SKIPE	XGPERC			;ERROR CODE SET YET?
	JRST	XCW1X			;AVOID DOING IT AGAIN
	PUSHJ	P,XERR12		;I MISSED IT!
	MOVEM	AC1,XGPERC+1		;SAVE CURRENT SCANLINE NUMBER FOR LOSER
	MOVE	AC3,1(AC2)		;GET Y0 OF NEXT NODE
	MOVEM	AC3,XGPERC+2		;GIVE THAT TO THE LOSER TOO.
XCW1X:
	MOVE	AC3,(AC2)		;GET OLD LINK OUT.
	MOVEM	AC3,XPENDH		;SET OLD LINK OUT INTO LIST HEAD.
	JUMPN	AC3,XCW1A		;JUMP UNLESS LIST IS EMPTY.
	MOVEI	AC3,XPENDH		;ADDRESS OF LIST HEAD.
	MOVEM	AC3,XPENDT		;TAIL POINTS TO LIST HEAD.
XCW1A:
	SKIPGE	AC3,2(AC2)		;GET X0,,N
	JRST	XCW1C			;THIS IS A TEXT NODE.
	HRRZM	AC3,1(AC2)		;STORE N TO CLOBBER Y0.
	ANDCMI	AC3,-1			;LEFT SIDE ONLY IS X0
	SKIPL	4(AC2)			;DON'T BUGGER X0 IF DX<0 6/12/73
	SUB	AC3,4(AC2)		;X0-DX
	MOVEM	AC3,2(AC2)		;CLOBBER X0 WITH X0-DX.
	SKIPG	AC3,3(AC2)		;GET THE WIDTH FIELD.
	JRST	XCW1D			;THIS IS A PAGE NODE.  CUT THE PAPER.
	CAILE	AC3,SETN+=200		;IS IT SMALL ENOUGH TO GET DONE QUICK?
	JRST	XCW1B			;NO. THIS GOES IN THE WIDE VECTOR LIST.
	EXCH	AC2,XASVLH		;STORE POINTER IN ACTIVE NARROW V. LIST HEAD
	MOVEM	AC2,@XASVLH		;STORE OLD LIST IN NEWLY ACTIVATED.
	JRST	XCW1			;LOOK FOR MORE NEWLY ACTIVATED

XCW1B:
	EXCH	AC2,XALVLH		;STORE POINTER IN ACTIVE WIDE V. LIST HEAD
	MOVEM	AC2,@XALVLH		;STORE OLD LIST IN NEWLY ACTIVATED.
	JRST	XCW1			;LOOK FOR MORE NEWLY ACTIVATED

XCW1C:
	MOVEM	AC1,1(AC2)		;SET STARTING LINE NUMBER.
	EXCH	AC2,XATLH		;SET ACTIVE TEXT HEADER
	MOVEM	AC2,@XATLH		;LINK NEW NODE TO OLD LIST.
	JRST	XCW1			;LOOK FOR MORE.

XCW1D:
	SKIPG	XGPPS3			;TOP OF PAGE. IS THERE A BOTTOM MARGIN?
	JRST	XCW1DA			;NO BOTTOM MARGIN: NO CUT
	PUSHJ	P,QCUT			;CUT THE PAPER.
	MOVE	TAC,XSCNLN
	CAIL	TAC,=2000
	CAILE	TAC,=2200
	JRST	XCW1DA			;PAGE SIZE IS UNUSUAL
	MOVEI	TAC,1
	IORM	TAC,XFLAPB		;TURN ON A BIT TO MAKE IT FLAP
XCW1DA:
	SETOM	XSCNLN			;NEXT SCAN LINE IS 0
	MOVE	TAC1,4(AC2)		;GET THE END OF FILE INDICATOR.
	EXCH	AC2,XVNFL		;FREE THIS PAGE MARK NODE.
	MOVEM	AC2,@XVNFL

	MOVEI	AC2,0			;FREE NARROW ACTIVE VECTORS
	EXCH	AC2,XASVLH		;AC2←LIST HEADER; LIST HEADER←0
XCW1E:
	SKIPN	AC3,AC2			;AC3←FIRST ELEMENT IN LIST
	JRST	XCW1F
	MOVE	AC2,(AC2)		;ADVANCE IN LIST.
	EXCH	AC3,XVNFL		;FREE NODE THAT AC3 POINTS TO
	MOVEM	AC3,@XVNFL
	JRST	XCW1E

XCW1F:
	MOVEI	AC2,0			;FREE WIDE ACTIVE VECTORS.
	EXCH	AC2,XALVLH		;AC2←LIST HEADER; LIST HEADER←0
XCW1G:
	SKIPN	AC3,AC2
	JRST	XCW1H
	MOVE	AC2,(AC2)
	EXCH	AC3,XVNFL
	MOVEM	AC3,@XVNFL
	JRST	XCW1G

XCW1H:
	MOVEI	AC2,0			;FREE TEXT NODES.	
	EXCH	AC2,XATLH		;AC2←LIST HEADER; LIST HEADER←0
XCW1I:
	SKIPN	AC3,AC2
	JRST	XCW1K
	MOVE	AC2,(AC2)		;LINK AHEAD.
XCW1J:
	MOVEI	TAC,(AC3)
	EXCH	AC3,XTNFL
	MOVEM	AC3,@XTNFL
	SKIPE	AC3,3(TAC)
	JRST	XCW1J
	JRST	XCW1I

XCW1K:
	SETOM	XACT4			;NODES HAVE BEEN FREED
	JUMPL	TAC1,XCW6		;WAKE COMPILER UNLESS EOF.
	MOVEI	TAC1,XCIBEG
	MOVEM	TAC1,XDISP2		;SET DISPATCH THRU THE TOP.
	JRST	CPOPJ1			;SKIP RETURN INDICATES EOF.

XCW3:
	SKIPN	XALVLH			;ANY WIDE VECTORS?
	SKIPE	XASVLH			;NO. ANY NARROW VECTORS?
	JRST	.+2			;THERE ARE SOME ACTIVE VECTORS.
	JRST	XCW5			;NO VECTORS ACTIVE.
	MOVEM	P,XGPTMP		;SAVE P FOR LATER.
	MOVSI	AC3,XNVC		;PICKUP THE NARROW VECTOR CODE
	BLT	AC3,XNVC3		;LOAD NVC INTO THE AC'S.
	MOVEI	AC1,XASVLH		;POINTER TO FIRST VECTOR.
	JRST	XNVC1			;EXECUTE THE CODE IN THE AC'S.

XCW4:
	SKIPN	XALVLH			;ANY WIDE VECTORS?
	JRST	XCW4A			;NO. AVOID THIS STUFF.
	MOVE	AC3,[XWVC,,XWVC1]
	BLT	AC3,XWVC2
	MOVEI	AC3,XCW4A
	HRRM	AC3,XWVC3		;SET RETURN ADDRESS.
	MOVEI	AC1,XALVLH
	JRST	XNVC1			;DO LONG VECTORS. RETURN TO XCW4A

XCW4A:
	MOVE	P,XGPTMP		;HERE AFTER ALL VECTORS DONE
XCW5:
	MOVEI	AC3,XATLH		;FOR ACTIVE TEXT LIST.
	MOVE	IOS,[SCANX,,SCAN]	;SOURCE,,DESTINATION
	BLT	IOS,SCAND		;MOVE CODE INTO THE AC'S.
					;IOS,TAC,TAC1,AC2,3 ARE 'FREE'
					;P IS FOR STACK. AC1=MAJOR SCANLINE #.
XCW5A:
	MOVEI	AC2,(AC3)		;LINK AHEAD. AC2=LAST ONE DONE.
XCW5B:
	SKIPN	AC3,(AC2)		;GET THE FORWARD LINK
	JRST	XCW6			;THERE IS NONE LEFT.
	PUSH	P,AC2
	MOVE	AC1,XSCNLN
	SUB	AC1,1(AC3)		;RELATIVE SCAN LINE NUMBER.
	PUSHJ	P,4(AC3)		;EXECUTE THE NODE.
	POP	P,AC2
	MOVE	AC3,(AC2)		;SET UP AGAIN.
	AOSGE	2(AC3)			;COUNT A LINE USED UP.
	JRST	XCW5A			;NODE IS STILL ACTIVE.
					;DELINK HEADER FROM ACTIVE LIST.
	MOVE	TAC,(AC3)		;GET THE LINK TO NEXT ACTIVE TEXT NODE.
	MOVEM	TAC,(AC2)		;STORE INTO THE GUY WHO POINTS HERE.
					;ADD HEADER AND LINKED BLOCKS TO FREE LIST.
XCW5C:
	MOVEI	TAC,(AC3)		;SAVE THIS BLOCK ADDRESS
	EXCH	AC3,XTNFL		;LINK THIS BLOCK INTO TEXT NODE FREE LIST.
	MOVEM	AC3,@XTNFL		;STORE OLD FL POINTER INTO NEW BLOCK.
	SKIPE	AC3,3(TAC)		;SKIP IF THERE IS NO FURTHER LINK
	JRST	XCW5C			;GIVE BACK ANOTHER BLOCK.
	SETOM	XACT4			;WE WILL KICK CH4.
	JRST	XCW5B			;DON'T ADVANCE AC2.

XCW6:
	SKIPN	XACT4
	POPJ	P,
	CONO	PI,1B24!<1⊗<7-XGPC2N>>	;ACTIVATE INTERRUPT ON COMPILER CHANNEL.
	MOVE	TAC,[JRST P2CH4S]
	MOVEM	TAC,P2CH4E		;CLOBBER CHANNEL 4 EXIT ROUTINES.
	POPJ	P,			;DISMISS CHANNEL 2.

;	MODE 0 I-LEVEL  'SCAN PHASE'
;ENTER SCANE FOR LEFT SIDE (EVEN)
;ENTER SCANO FOR RIGHT SIDE (ODD)
;IOS, TAC, AC3 ARE IN USE.  TAC1 IS FREE, P IS STACK.

SCANX:
	PHASE	4
SCAN::
	MOVE	AC3,(AC3)		;4 CALLED BY JSP AC3,  GET AOBJN PTR
	JUMPL	TAC,SCANO		;5 JUMP TO ODD SIDE SCAN
SCANE::
	HLRZ	IOS,@(AC3)		;6 LOAD DATA
	DATAO	XGP,IOS			;7 SEND DATA
	AOBJN	AC3,SCANE		;10 LOOP IN MINOR COMMAND
	JRST	(AC3)			;11 RETURN TO COMMAND BUFFER
SCANO::
	DATAO	XGP,@(AC3)		;12 SEND DATA
	AOBJN	AC3,SCANO		;13 LOOP
SCAND::
	JRST	(AC3)			;14 RETURN. END OF PHASED CODE.
	DEPHASE	

;REGISTER ASSIGNMENTS:
;IOS  FREE EXCEPT CLOBBERED INSIDE SCAN
;TAC  HAS RELATIVE LINE NUMBER AND ODD/EVEN INDICATOR
;TAC1 FREE
;P    STACK
;AC1  MAJOR SCANLINE NUMBER
;AC2  RETURN ADDRESS FOR CURRENT MINOR COMMAND
;AC3  ARGUMENT ADDRESS FOR SCAN.

;NARROW VECTOR PROCESSING:
XNVC:
	PHASE	0			;AC1 SET UP INITIALLY.
XNVC1::
	MOVEI	AC3,(AC1)		;0 LINK AHEAD. AC1=LAST ONE DONE.
XNVC2::
	SKIPN	AC1,(AC3)		;1 GET THE FORWARD LINK
XWVC3::
	JRST	XCW4			;2 THERE IS NONE.  ;*CLOBBERED FOR WIDE
	MOVE	AC2,4(AC1)		;3 DX
	ADDB	AC2,2(AC1)		;4 X←X+DX
	HLRZ	AC2,AC2			;5 GET X AS A RIGHT SIDE QUANTITY
	CONO	XGP,SETX(AC2)		;6 SET X COLUMN REGISTER
	CONO	XGP,@3(AC1)		;7 SEND THE WIDTH.
	SOSLE	1(AC1)			;10 DECREMENT N
	JRST	XNVC1			;11 ADVANCE TO THE NEXT VECTOR
XNVC3::
	JRST	XNVC4			;12 RUN THE CODE TO FLUSH THIS VECTOR
	DEPHASE	

XWVC:
	PHASE	10			;HERE FOR WIDE VECTORS.
XWVC1::
	CONSO	XGP,NZ			;10 WAIT HERE FOR DONE
	JRST	XWVC1			;11 LOOP.
	SOSLE	1(AC1)			;12
	JRST	XNVC1			;13
XWVC2::
	JRST	XNVC4			;14
	DEPHASE				;15, 16, 17 ARE AC1,2,3
	
XNVC4:
	MOVE	AC2,(AC1)		;GET THE LINK TO NEXT ACTIVE VECTOR
	MOVEM	AC2,(AC3)		;STORE INTO THE GUY WHO POINTS HERE.
	EXCH	AC1,XVNFL		;LINK TO VECTOR NODE FREE LIST.
	MOVEM	AC1,@XVNFL		;STORE OLD FL POINTER INTO NEW BLOCK.
	SETOM	XACT4			;WE WILL KICK CHANNEL 4.
	JRST	XNVC2			;DON'T ADVANCE IN LIST.

;	ROUTINES TO MANIPULATE COMMAND HEADER BLOCKS.
;SCHB, OFFCHB, ACHB
;ALL OF THESE ARE CALLED BY JSP AC1,
;MOST REQUIRE THAT AC2, AC3 BE SET UP WITH MINIMUM AND MAXIMUM VALUES.
;CAUTION----DON'T CLOBBER DAT INSIDE THESE ROUTINES!

;SEARCH FOR A COMMAND BLOCK WITH THE RIGHT PARAMETERS, ELSE MAKE ONE.
;AC2 = MIN, AC3 = MAX
SCHB:
	SKIPN	UUO,XCHBGO			;HAVE WE ANY BLOCKS AT ALL?
	JRST	FCHB				;NO. WE SHALL MAKE THE FIRST.
	MOVEI	UUO,4(UUO)			;POINT TO FIRST EXECUTABLE
SCHB1:
	MOVEI	UCHN,(UUO)			;LINK ON
	CAIN	AC2,@(UCHN)
	CAIE	AC3,@1(UCHN)
	JRST	SCHB2				;NO MATCH. LOOK AT NEXT LINK
	CAIGE	PROG,3(TEM)			;IS THERE ROOM FOR MORE?
	PUSHJ	P,ADDNOD			;NO. ADD A NODE. RESET TEM,PROG.
	MOVEI	AC3,1(TEM)			;GET POINTER TO NEXT AVAIL. WORD.
	EXCH	AC3,7(UCHN)			;SET NEW INTER-GROUP LINK.
	JRST	ADBH1				;GO ADD THE DATA BLOCK HEADER

SCHB2:
	HRRZ	UUO,2(UCHN)			;UUO SET WITH NEXT LINK
	CAIE	UUO,CPOPJ			;WAS THIS THE LAST LINK?
	JRST	SCHB1				;NO. KEEP LOOKING ALONG LIST.
						;MAKE A NEW COMMAND HEADER.

;ADD A COMMAND HEADER BLOCK.  UCHN POINTS TO LAST CHB IN THE LIST. AC2, AC3 SET
ACHB:
	CAIGE	PROG,11(TEM)			;WE ARE ADDING 9 MORE WORDS.
	PUSHJ	P,ADDNOD			;NO ROOM.  ADD A NEW NODE.
	MOVEI	UUO,1(TEM)			;POINTER TO NEXT AVAIL CELL.
	HRRM	UUO,2(UCHN)			;CLOBBER LAST GUY'S RETURN ADDRESS.
	JRST	FCHB1				;NOW MAKE THE COMMAND HEADER BLOCK

;FCHB CALLED FROM SCHB TO MAKE FIRST COMMAND BLOCK.  GET TEXT NODE FROM FREE LIST.
FCHB0:
	CONO	PI,PION
	JSR	X2DISP				;SET CO-ROUTINE ADDRESS FOR LATER
;*4
FCHB:
	CONO	PI,PIOFF
	SKIPN	UUO,XTNFL			;GET DATA FROM THE FREE LIST
	JRST	FCHB0
	MOVE	UCHN,(UUO)
	MOVEM	UCHN,XTNFL
	CONO	PI,PION
	MOVEM	UUO,XCHBGO
	SETZM	XNODUS				;COUNT OF NODES IN THIS LINE.
	SETZM	(UUO)				;MAJOR LINK
	SETZM	3(UUO)				;LINK-2
	MOVEI	TEM,3(UUO)			;PDL POINTER. LEFT HALF ZERO.
	MOVEI	PROG,TNSIZE-1(UUO)		;LAST ADDRESS THAT CAN BE USED
						;CAIGE PROG,n(TEM) WILL SKIP
						;IF n MORE THINGS CAN BE PUSHED.
	MOVE	DSER,TEM			;WE ARE NOT INSIDE A TEXT STRING.

;MAKE COMMAND HEADER BLOCK.  AC2 = MIN, AC3 = MAX
FCHB1:
	PUSH	TEM,[CAIL AC1,0]		;0 STUFF INSTRUCTION
	HRRM	AC2,(TEM)			;SET MINIMUM
	MOVEI	UCHN,(TEM)			;SET UCHN TO POINT TO HEADER.
	PUSH	TEM,[CAIL AC1,0]		;1 ANOTHER INSTRUCTION.
	HRRM	AC3,(TEM)			;SET ARGUMENT IN INSTRUCTION
	CAMLE	AC3,XHMAX			;IS THIS BIGGER THAN CURRENT MAX?
	MOVEM	AC3,XHMAX			;YES. SET MAXIMUM VALUE OF SCAN LINE
	PUSH	TEM,[JRST CPOPJ]		;2 SET RETURN ADDRESS.
	PUSH	TEM,[MOVEI TAC,(AC1)]		;3 MORE CODE
	PUSH	TEM,[SUBI TAC,@0]		;4 MORE CODE
	HRRM	UCHN,(TEM)			;FIX ADDRESS PART
	PUSH	TEM,[ROT TAC,-1]		;5 MORE CODE.
	MOVEI	AC3,2(UCHN)			;SET UP RETURN ADDRESS.
;HERE TO ADD A DATA BLOCK HEADER TO COMMAND BLOCK ADDRESSED BY UCHN
ADBH1:
	PUSH	TEM,[JSP AC2,0]			;SET HEADER WORD
	MOVEI	UUO,2(TEM)
	HRRM	UUO,(TEM)			;SET JUMP ADDRESS
	PUSH	TEM,AC3				;SET RETURN ADDRESS.
	JRST	(AC1)

;HERE TO OFFSET THE MIN,MAX VALUES.  OFFSET IS IN AC3.
OFFCHB:
	MOVE	UCHN,XCHBGO
	MOVEI	UCHN,4(UCHN)			;OFFSET TO FIRST INSTRUCTION
OFFCH1:
	ADDM	AC3,(UCHN)
	ADDM	AC3,1(UCHN)
	HRRZ	UUO,2(UCHN)
	CAIN	UUO,CPOPJ
	JRST	(AC1)				;RETURN WITH UCHN SET UP.
	MOVEI	UCHN,(UUO)
	JRST	OFFCH1

;ADDNOD MAKES A NEW TEXT NODE.  TEM IS OLD PDL, AT LEAST 1 NEEDED IN OLD BLOCK.
;CALLED WITH A PUSHJ.  CLOBBERS UUO.  RETURNS WITH TEM=DSER=NEW PDL. PROG=LAST.
ADDND2:
	PUSHJ	P,XERR10			;ERROR-LINE TOO COMPLEX
	POP	P,(P)				;FLUSH RETURN ADDRESS.
	JRST	XCIG2A				;SET ERROR BIT.
	
ADDND1:
	CONO	PI,PION
	CAML	DSER,XNTNOD			;HOW MANY NODES IN USE?
	JRST	ADDND2				;TOO MANY NODES ARE IN USE.
	JSR	X2DISP				;WAIT FOR A FREE NODE.
	JRST	.+2
ADDNOD:
	AOS	DSER,XNODUS
	CONO	PI,PIOFF
	SKIPN	UUO,XTNFL			;GET FROM FREE LIST
	JRST	ADDND1				;NONE THERE
	MOVE	DSER,(UUO)
	MOVEM	DSER,XTNFL
	CONO	PI,PION
	PUSH	TEM,[JRST]			;SET JRST AT END OF OLD BLOCK.
	MOVEI	DSER,4(UUO)			;JUMP TARGET
	HRRM	DSER,(TEM)
	MOVEI	TEM,3(UUO)			;NEW PDL.
	MOVEI	PROG,TNSIZE-1(UUO)		;LAST ADDRESS THAT CAN BE USED
	MOVE	DSER,XCHBGO
	EXCH	UUO,3(DSER)			;SET LINK TO US.
	MOVEM	UUO,(TEM)			;OLD LINK IN US.
	MOVE	DSER,TEM
	POPJ	P,

;	XGP LINE COMPILER CO-ROUTINES
;*4 HERE FOR FIRST COMPILER ACTIVATION.
XCPINI:
	MOVE	TAC,XFREBA		;GET THE BASE OF FREE SPACE.
	ADD	TAC,XFCADR		;ADD RELOCATION OF THE FC
	MOVEM	TAC,XVNFL		;BASE OF VECTOR NODE FREE LIST
	MOVE	TAC1,XNVNOD		;MAKE THIS MANY NODES.
	ADDI	TAC,VNSIZE		;THIS IS THE NODE SIZE
	MOVEM	TAC,-VNSIZE(TAC)	;STORE LINK
	SOJG	TAC1,.-2		;LOOP LINKING BLOCKS.
	SETZM	-VNSIZE(TAC)		;LAST LINK IS ZERO.
	MOVEM	TAC,XTNFL		;BASE OF TEXT NODE FREE LIST.
	MOVE	TAC1,XNTNOD		;THIS MANY
	ADDI	TAC,TNSIZE		;THIS SIZE
	MOVEM	TAC,-TNSIZE(TAC)
	SOJG	TAC1,.-2
	SETZM	-TNSIZE(TAC)		;CLEAR OUT LAST LINK.

	SETZM	XLFTKF			;SET THE KERN FLAG OFF.
	MOVE	TAC,XGPPS1		;GET THE SIZE OF TOP MARGIN
	MOVEM	TAC,XCYPOS		;CURRENT (DEFAULT) Y POSITION.
	SETZM	XGPLYP			;LAST Y POSITION WRITTEN WAS 0
	SETZM	XTOFRM			;XGP IS AT 'TOP OF FORM'
	MOVE	TAC,XFTADR		;GET THE FONT ADDRESS OF FONT 0
	ADD	TAC,XFCADR		;ADD RELOCATION OF FONT COMPILER
	HRRZM	TAC,XFTCAD		;SAVE AS RELOCATED ADDRESS OF CURRENT FONT.
	MOVE	J,XGPLMR		;SET INITIAL COLUMN AT LEFT MARGIN.
	LDB	TAC,[POINT 5,(TAC),22]	;GET THE COLUMN POS ADJUSTMENT
	SUBI	J,(TAC)			;AND USE IT TO BUGGER THE COLUMN POSITION.
	SETZM	XGPPG2			;PAPER PAGE ← 0
	MOVE	P,XGPPDL		;PDL FOR COMPILER.
	MOVEI	PID,P2PID		;NOT RANDOMNESS

;HERE WE PREPARE TO COMPILE A VECTOR NODE OR A TEXT NODE.

XCI:
	JSP	AC3,BFOSET		;SET UP AOBJN POINTER IN TAC
	JUMPGE	TAC,XCI0		;JUMP IF THERE'S NO DATA TO BE HAD.
;REGISTER USE IN THE COMPILER.
;LINE INITIALIZATION STUFF.
;J ← COLUMN COUNT IN XGP.
;TEM ← POINTER TO NEXT FREE WORD IN BUFFER.
;DSER ← LOCATION OF CURRENT AOBJN WORD IN TEXT NODE.
;UCHN ← LOCATION OF CURRENT COMMAND HEADER BLOCK.
;TAC1←5 INITIAL NUMBER OF BYTES IN THE WORD.
XCIA:
	MOVEI	TAC1,5
	SETOM	XLBL			;CURRENT BASELINE POSITION.
	SETZB	TEM,XHMAX		;CURRENT MAXIMUM HEIGHT
	SETZB	DSER,XCHBGO		;FLAG SCHB THERE ARE NO COMMAND BLOCKS YET.
	SETZB	UCHN,XVNODE		;NO VECTORS TO QUEUE YET.

	MOVE	DAT,@XFTCAD		;DEFINE CURRENT FONT PARAMETERS.
	HLRZM	DAT,XCFBL		;BASE LINE.
	ANDI	DAT,17777		;OMIT THE COLUMN POS ADJ BITS
	HRRZM	DAT,XCFH		;FONT HEIGHT
	LDB	DAT,[POINT 5,@XFTCAD,22];GET THE COLUMN POS ADJUSTMENT
	MOVEM	DAT,XCFCPA		;SAVE COLUMN POS ADJ

;CHARACTER BY CHARACTER LOOP.
XCI1:
	JSP	AC3,XCIG		;GET A CHARACTER
	CAIN	DAT,177			;SKIP IF NOT ESCAPE.
	JRST	XCI2			;PROCESS DLE
	CAIG	DAT,15
	CAIG	DAT,10
	JUMPN	DAT,XCI2A		;JUMP IF NORMAL CHARACTER.
	JUMPE	DAT,XCI1		;THROW OUT NULLS.
;PROCESS SPECIALS HERE  (TAB, LF, VT, FF, CR)
	JRST	@.+1-11(DAT)		;DAT HAS CODE BETWEEN 11 AND 15
	XCI1A				;HT (11)
	XCI4				;LF (12)
	XCI2A				;VT (13) IS JUST ANOTHER CHARACTER.
	XCI4				;FF (14)
	XCI1B				;CR (15)

;	HERE TO QUEUE A TEXT NODE.
;LINE OVERFLOW ROUTINES.
XCI1D:
	MOVE	J,XGPLMR		;SET MARGIN. (CR)
	SUB	J,XCFCPA		;ADJUST COLUMN POSITION
XCI1F:
	MOVEI	DAT,0			;LINE OVERFLOW.

;HERE AT END OF LINE.  DAT HAS THE BREAK CHARACTER.  ONLY FF IS SIGNIFICANT.
XCI4:
	SKIPN	XGPAT2			;THIS SHOULDN'T SKIP EXCEPT IF SCREWED
	SKIPE	XGPHIP			;HEADING IN PROGRESS?
	JRST	XCI4A			;YES. AVOID CLOBBERING IT.
	MOVE	AC3,MTB(TAC1)		;HERE AT END OF A CHARACTER LINE.
	ANDM	AC3,(TAC)		;MASK OUT USED UP BYTES.
	JSP	AC3,BFNSET		;ADVANCE BUFFER POINTERS.
	JRST	XCI4B

XCI4A:
	MOVE	TAC,XSVCAD
	SKIPE	XGPHIP
	MOVEM	TAC,XFTCAD
	SETZM	XGPHIP			;NO LONGER HEADING IN PROGRESS
	SETZM	XGPAT2			;DRD STRIKES AGAIN.
XCI4B:
	SKIPG	UUO,XHMAX		;IS THE MAXIMUM HEIGHT SET?
	MOVE	UUO,XCFH		;NO. SET IT FROM THE CURRENT FONT HEIGHT
	MOVEM	UUO,XHMAX		
	JUMPE	TEM,XCI5		;JUMP IF THERE IS NO COMMAND GROUP.
	PUSH	TEM,[JRST @(AC2)]	;STOP THE CURRENT COMMAND GROUP.
	MOVE	TAC,XCHBGO		;GET THE ADDRESS OF THIS TEXT NODE.
	MOVNM	UUO,2(TAC)		;SAVE THE ACTIVE LINE COUNT.
	MOVE	TAC1,XCYPOS		;GET THE Y POSITION.
	MOVEM	TAC1,1(TAC)		;STORE IN TEXT NODE.
	EXCH	TAC1,XGPLYP		;STORE THIS AS THE LAST Y WE DID.
	SETZM	(TAC)			;ZERO THE LINK OUT
	CONO	PI,PIOFF
	MOVEM	TAC,@XPENDT		;STORE THRU THE TAIL.
	MOVEM	TAC,XPENDT		;STORE NEW QUEUE TAIL
	CONO	PI,PION
	CAMLE	TAC1,XGPLYP		;IS Y0 > OR = THE LAST Y WE DID?
	PUSHJ	P,XGPOOO		;OUT OF ORDER.
	SETOM	XTOFRM			;FLAG TEXT IS ON PAGE.
XCI5:
	CAIN	DAT,14			;FF?
	JRST	XCI6A			;YES.
	SKIPN	UUO,XVNODE		;ANY VECTOR NODE TO QUEUE?
	JRST	XCI6			;NO.
	MOVE	TAC1,1(UUO)		;GET THE Y0 OF THIS VECTOR
	MOVEM	TAC1,XCYPOS		;USE AS THE Y0 OF THE NEXT TEXT
	EXCH	TAC1,XGPLYP		;STORE AS THE LAST Y0 THAT WAS QUEUED
	CONO	PI,PIOFF		;QUEUE THE VECTOR NODE.
	MOVEM	UUO,@XPENDT
	MOVEM	UUO,XPENDT
	CONO	PI,PION
	CAMLE	TAC1,XGPLYP
	PUSHJ	P,XGPOOO		;OUT OF ORDER
	SETOM	XTOFRM			;FLAG TEXT EXISTS ON PAGE.
	CAIN	DAT,14
	JRST	XCI6A			;IN CASE OF ACCIDENT HE ALWAYS ...
	JRST	XCI6Z			;(DAT IS ZERO)
	
XCI6:
	SKIPG	DAT,XGPSLS		;SPECIAL LINE SPACE, IF ANY,
	MOVE	DAT,XGPILS		;ELSE THE REGULAR LINE SPACE.
	SETZM	XGPSLS			;(AND NO SPECIAL LINE SPACE ANYMORE)
	ADD	DAT,XHMAX		;PLUS LINE HEIGHT.
XCI6Z:
	ADDB	DAT,XCYPOS		;PLUS Y0 OF THIS LINE, ICS Y0 OF NEXT LINE.
	SKIPG	TAC,XGPPS2
	JRST	XCI6ZZ			;PMAR=0 MEANS DON'T CUT UNLESS TOLD
	ADD	TAC,XGPPS1		;SUM OF TOP MARGIN+PAGE BODY SIZE
	CAIL	DAT,(TAC)		;SKIP UNLESS WE NEED A FORM FEED HERE.
	JRST	XCI6B			;HERE WE NEED A FORM FEED.
XCI6ZZ:
	MOVSI	TAC,XGPERR		;ERROR FLAG UP?
	TDNE	TAC,XGPIOS		;?
	JRST	XCI6E			;YES.  SCREECH
	JRST	XCI			;GO DO THE NEXT LINE.

XCI6A:
	SETZM	XGPPG2			;REAL FF. PAPER PAGE ← 0
XCI6B:
	MOVSI	TAC,XGPERR		;IS THERE AN ERROR?
	TDNE	TAC,XGPIOS
	JRST	XCI6E			;ERROR.  FAKE EOF.
	JSP	AC3,BFOSET		;SEE IF THERE'S  MORE DATA TO SEND
	JRST	XCI6DX			;TAC<0 MEANS MORE DATA.

XCI6E:
	PUSHJ	P,PSYNCX		;HERE FOR ERROR.
	ANDCA	TAC,XGPIOS		;CLEAR PRIMARY ERROR
	IORI	TAC,IODERR		;TURN ON USER'S ERROR
	MOVEM	TAC,XGPIOS
	SETZM	XGPBIT			;WON'T RUN PAPER.
	PUSHJ	P,XSYNCX
	MOVEI	TAC,1			;MAKE TAC>0 LIKE EOF.
XCI6DX:
	SKIPN	XTOFRM			;ANY TEXT ON THIS PAGE?
	JUMPL	TAC,XCI6F		;NO. AVOID BLANK PAGES. (ONLY IF MORE DATA)
	JRST	XCI6D

XCI6C:
	CONO	PI,PION			;RESTORE PI'S
	JSR	X2DISP			;SET RESTART ADDRESS AND DISMISS.
;*4
XCI6D:
	CONO	PI,PIOFF
	SKIPN	TAC1,XVNFL		;GET A FREE VECTOR.
	JRST	XCI6C			;HAVE TO WAIT FOR A FREE NODE.
	MOVE	DAT,(TAC1)		;GET LINK
	MOVEM	DAT,XVNFL		;STORE LINK
	CONO	PI,PION
	SETZM	(TAC1)			;FIX LINK OUT
	SKIPG	DAT,XGPPS2		;PMAR
	SKIPA	DAT,XCYPOS		;PMAR = 0 USE CURRENT Y POSITION AS A GUIDE
	ADD	DAT,XGPPS1
	ADD	DAT,XGPPS3		;TOTAL PAGE SIZE
	MOVEM	DAT,1(TAC1)		;STORE Y0 IN THE WORD.
	SETZM	2(TAC1)			;N=0 DENOTES VECTOR TYPE NODE.
	SETOM	3(TAC1)			;WIDTH<0 DENOTES PAGE NODE
	MOVEM	TAC,4(TAC1)		;STORE POSITIVE FOR EOF.
	CONO	PI,PIOFF		;QUEUE THE PAGE MARK NODE.
	MOVEM	TAC1,@XPENDT		;STORE AT END OF QUEUE
	MOVEM	TAC1,XPENDT		;UPDATE END OF QUEUE.
	CONO	PI,PION
	SETZM	XTOFRM			;NO TEXT ON PAGE ANY MORE.
XCI6F:
	JUMPGE	TAC,XCIP3		;JUMP IF EOF
	MOVE	TAC,XGPPS1
	MOVEM	TAC,XCYPOS		;SET CURRENT Y POSITION.
	SETZM	XGPLYP			;LAST Y QUEUED WAS 0
	AOS	TAC1,XGPPG2		;INCREMENT "PAPER PAGE" COUNT
	SKIPGE	TAC,XGPHDW		;IS THERE AN AOBJN POINTER FOR HEADING?
	CAIG	TAC1,1			;YES. SKIP IF AFTER FIRST PAPER PAGE.
	JRST	XCI			;NO HEADING OR FIRST PAPER PAGE. SEND DATA.
XCIP2:
	SETOM	XGPHIP			;HEADING IN PROGRESS
	MOVE	TAC1,XFTCAD		;SAVE PRESENT FONT.
	MOVEM	TAC1,XSVCAD		;SAVE IT.
	JRST	XCIA			;GO DO THE HEADING

XCIP3:
	JSR	X2DISP			;EOF. DISMISS INTERRUPT.
	JRST	.-1			;IGNORE FURTHER INTERRUPTS.

XGPOOO:
	MOVEI	DAT,14			;SET TO KILL TRANSFER
	MOVSI	IOS,XGPERR
	PUSHJ	P,XGPSET
	JRST	XERR11			;OUT OF ORDER

;	MODE 0	GET NEXT CHARACTER
BTB:
	POINT	7,(TAC),34		;(BYTE THE BAG?)
	POINT	7,(TAC),27
	POINT	7,(TAC),20
	POINT	7,(TAC),13
	POINT	7,(TAC),6

MTB:
	0
	377
	77777
	17,,-1
	3777,,-1
	-1				;NOT REDUNDANT! USED TO UNTAKE A CHARACTER

;HERE WHEN WE HAVE END OF HEADING DATA.
XCIG4:
	MOVEI	DAT,20			;SET SPECIAL LINE SPACE COUNT
	MOVEM	DAT,XGPSLS
	JRST	XCI1F			;MAKE END OF LINE OCCUR.

XCIG3:
	SKIPN	XGPAT2			;PAGE NUMBER HACK?
	JRST	XCIG4			;NO. JUST HEADING HACK
	SETZM	XGPAT2			;CLEAR PAGE NUMBER CELL
	MOVE	TAC,XGPAT0		;RESTORE TAC, TAC1
	MOVE	TAC1,XGPAT1		;GET NEXT CHARACTER

; JSP AC3,XCIG TO GET NEXT CHARACTER INTO DAT
XCIG:
	SOJL	TAC1,XCIG1		;COUNT DOWN IN WORD.
	LDB	DAT,BTB(TAC1)		;GOBBLE A BYTE
	JRST	(AC3)			;RETURN
XCIG1:
	MOVEI	TAC1,5			;HERE THE WORD RAN OUT.
	AOBJN	TAC,XCIG		;ADVANCE TO NEXT WORD.
	SKIPN	XGPHIP			;HEADING IN PROGRESS OR 
	SKIPE	XGPAT2			;ARE WE IN PAGE NUMBER HACK?
	JRST	XCIG3			;YES. DO IT
	PUSH	P,AC3			;NO NEXT WORD.  SAVE RETURN
	PUSH	P,AC1
	JSP	AC3,BFNSET		;DO THE BUFFER FROTZ
	JSP	AC3,BFOSET
	POP	P,AC1
	POP	P,AC3			;RESTORE RETURN ADDRESS
	JUMPL	TAC,XCIG		;JUMP IF THERE'S DATA LEFT.
XCI0:
	MOVE	DAT,XGPWSZ		;NO DATA LEFT. IS THIS CLOSE TIME?
	JUMPE	DAT,XCI3		;JUMP IF CLOSE UUO DONE.
;WE RAN OUT OF DATA WITHOUT A CLOSE UUO.
	PUSHJ	P,XERR5			;SET DATA MISS ERROR CODE.
XCIG2A:
	MOVSI	IOS,XGPERR		;SET ERROR STATUS.
	PUSHJ	P,XGPSET
XCI3:
	MOVEI	DAT,14			;HERE FOR END OF DATA.
	JRST	XCI4A			;DO A FORM-FEED.

;	HERE FOR SPECIALS
;H. TAB
XCI1A:
	MOVE	AC3,XFTCAD
	MOVE	AC3,41(AC3)		;LOAD AOBJN POINTER
	LDB	AC3,[POINT 9,(AC3),8]	;GET WIDTH OF A SPACE.
	JUMPE	AC3,XCI1		;IF A SPACE IS ZERO WIDTH, SO IS A TAB
	ADDI	J,(AC3)			;ADVANCE AT LEAST ONE SPACE.
	LSH	AC3,3			;TIMES 8
	SUB	J,XGPLMR		;TAB. COMPUTE DISTANCE FROM MARGIN
	IDIVI	J,(AC3)			;QUOTIENT IN J REMAINDER IN DAT
	JUMPE	DAT,.+2
	ADDI	J,1
	IMULI	J,(AC3)
	ADD	J,XGPLMR		;ADD THE MARGIN SIZE BACK IN.
	JRST	XCI1C			;NOW WE LOOK LIKE A COLUMN SELECT

XCI1B:
	MOVE	J,XGPLMR		;HERE FOR CR. LOAD LEFT MARGIN
					;AND DO A COLUMN SELECT.
XCI1C:
	SUB	J,XCFCPA		;MAKE COLUMN ADJUSTMENT
;HERE TO DO SPECIAL COL SEL FROM KERNING FONT.
XCI1CA:
	CAMN	TEM,UCHN		;IS THIS MCG EMPTY?
	JRST	XCI1			;YES. DO COLUMN SELECT BY AN NON-EMPTY MCG
	CAIGE	PROG,2(TEM)		;ROOM LEFT FOR THIS AND JUMP?
	PUSHJ	P,ADDNOD		;NO. ADD A NEW TEXT NODE.
	PUSH	TEM,[CONO XGP,SETX]	
	ADDM	J,(TEM)
	MOVE	DSER,TEM		;DSER NO LONGER POINTS TO AOBJN POINTER.
	JRST	XCI1

;	HERE TO PROCESS RUBOUT
;HERE FOR RUBOUT. - GET NEXT CHARACTER.
XCI2:
	JSP	AC3,XCIG		;HERE FOR DLE. GET NEXT -  PROCESS AS NORMAL
	CAIGE	DAT,XCI2ZL
	JRST	@XCI2Z(DAT)		;DISPATCH THRU TABLE
	CAIL	DAT,20			;TREAT '177 '20 THRU '177 '24 AS LINE SPACE
	CAILE	DAT,24
	JRST	XCI2A			;TREAT AS NORMAL
	MOVEI	DAT,0			;TREAT AS LINE-FEED
	JRST	XCI4			;SINCE ALL CAUSE SPACING ON THE LPT.

XCI2Z:
	XCI2A				;'177 '0 IS NORMAL
	ESC1				;'177 '1 IS ESCAPE 1
	ESC2				;'177 '2 IS ESCAPE 2
	ESC3				;'177 '3 IS ESCAPE 3
	ESC4				;'177 '4 IS ESCAPE 4
XCI2ZL←←.-XCI2Z

;HERE FOR '177 '001 - XGP ESCAPE 1.
ESC1:
	JSP	AC3,XCIG		;GET NEXT CHARACTER
	CAIGE	DAT,40			;IS THIS A COMMAND OR FONT SELECT
	JRST	ESC1A			;FONT SELECT OR ILLEGAL
	CAIL	DAT,XCI2YL+40
	JRST	XCI1			;ILLEGAL COMMAND. GET NEXT CHARACTER
	JRST	@XCI2Y-40(DAT)
XCI2Y:
	ES1.0				;'177 '001 '040	 COLUMN SELECT
	ES1.1				;'177 '001 '041  UNDERSCORE
	ES1.2				;'177 '001 '042	 LINE SPACE SET.
	ES1.3				;'177 '001 '043  FONT BASE LINE TWIDDLE.
	ES1.4				;'177 '001 '044  PAPER PAGE NUMBER
	ES1.5				;'177 '001 '045  SET&PRINT HEADING.
	ES1.6				;'177 '001 '046  START UNDERLINE.
	ES1.7				;'177 '001 '047  STOP UNDERLINE.
XCI2YL←←.-XCI2Y

ES1.0:
	MOVEI	AC2,2			;2 BYTES
	PUSHJ	P,GLOM
	ANDI	AC1,3777		;REDUCE TO REASONABILITY
	MOVEI	J,(AC1)
	JRST	XCI1C			;GO SET COLUMN POSITION.

ES1.7:
	EXCH	J,XUSBEG		;SPECIAL UNDERSCORE COMMAND
	JRST	ES1.1X
ES1.1:
	HRROS	XUSBEG			;FLAG NORMAL UNDERSCORE COMMAND
ES1.1X:
	JUMPE	TEM,ES1.1A
	CAIGE	PROG,2(TEM)		;ROOM TO END THIS COMMAND?
	PUSHJ	P,ADDNOD		;NO. ADD MORE SPACE.
	CAME	UCHN,TEM		;IS THERE AN MCG IN PROGRESS?
	PUSH	TEM,[JRST @(AC2)]	;YES. CLOSE IT.
ES1.1A:
	JSP	AC3,XCIG		;GET SCAN LINE NUMBER
	TRNE	DAT,100			;NEGATIVE?
	ORCMI	DAT,77			;YES. SIGN EXTEND.
	SKIPGE	AC2,XLBL		;LINE BASE-LINE SET YET?
	MOVE	AC2,XCFBL		;NOT YET. DO SO NOW.
	MOVEM	AC2,XLBL
	ADD	AC2,DAT
	MOVEI	AC3,1(AC2)		;GET MAXIMUM
	JSP	AC1,SCHB		;SEEK FOR APPROPRIATE CHB, ELSE MAKE ONE.
	CAIGE	PROG,6(TEM)		;ROOM FOR 6 LEFT?
	PUSHJ	P,ADDNOD		;NO. ADD ANOTHER NODE.
	PUSH	TEM,[CONO XGP,SETX]
	ADDM	J,(TEM)			;SET COLUMN SELECT CODE
	PUSH	TEM,[CONO XGP,SETN]
	SKIPL	XUSBEG			;SKIP IF NORMAL US.
	JRST	ES1.7B			;SPECIAL US.
	MOVEI	AC2,2
	PUSHJ	P,GLOM			;READ 2 BYTES
	ANDI	AC1,7777
ES1.1C:
	ADDM	AC1,(TEM)
	ADDI	J,(AC1)			;GRONK OUR COLUMN POSITION APPROPRIATELY
	PUSH	TEM,[CONSO XGP,NZ]
	MOVEI	UUO,(TEM)
	PUSH	TEM,[JRST]
	HRRM	UUO,(TEM)
ES1.1B:
	PUSH	TEM,[JRST @(AC2)]
	MOVE	UCHN,TEM
	MOVE	DSER,TEM
	JRST	XCI1

ES1.7B:
	MOVE	AC1,XUSBEG
	SUBI	AC1,(J)
	JUMPGE	AC1,ES1.1C
	MOVEI	AC1,0
	JRST	ES1.1C

ES1.2:
	JSP	AC3,XCIG
	MOVEM	DAT,XGPSLS		;SET SPECIAL LINE SPACE
	JRST	XCI1F

ESC1A:
	CAILE	DAT,17			;SKIP IF FONT SELECT
	JRST	XCI1			;THIS IS A CODE FROM 20 TO 37. RESERVED.
	MOVEM	J,1(P)			;SAVE COLUMN ADDRESS. NOTE!!! DON'T DO PUSHJ
	ADD	J,XCFCPA		;ADD ADJUSTMENT WHEN LEAVING FONT
	SKIPN	UUO,XFTADR(DAT)		;SEE IF THERE'S A FONT HERE
	MOVE	UUO,XFTADR		;NONE THERE. USE FONT 0
	ADD	UUO,XFCADR		;RELOCATE THE FONT BASE.
	HRRZM	UUO,XFTCAD		;SAVE AS BASE OF CURRENT FONT
	LDB	DAT,[POINT 5,(UUO),22]	;GET NEW COLUMN POS ADJ
	MOVEM	DAT,XCFCPA		;SAVE IT
	SUBI	J,(DAT)			;AND ADJUST COLUMN POSITION
	HRRZ	DAT,(UUO)		;GET THE NEW FONT HEIGHT
	ANDI	DAT,17777		;MASK OFF THE COLUMN POSITION ADJUST FIELD
	HLRZ	UUO,(UUO)		;AND THE NEW BASELINE
	CAMN	DAT,XCFH		;COMPARE OLD AND NEW HEIGHTS
	CAME	UUO,XCFBL		;OLD AND NEW BASELINES
	JRST	ESC1B			;FONTS ARE NOT COMPATABLE
	CAME	J,1(P)			;DID COLUMN POSITION CHANGE?
	JRST	XCI1CA			;YES. DO A COLUMN SELECT NOW.
	JRST	XCI1			;FOR COMPATABLE FONTS, NO EXTRA WORK

ES1.3:
	JSP	AC3,XCIG		;GET NEXT CHARACTER
	CAIL	DAT,100
	ORCMI	DAT,177
	HLRZ	UUO,@XFTCAD		;GET REAL BASE-LINE
	ADD	UUO,DAT			;ADD THE TWIDDLE
	JRST	ESC1C			;PRETEND WE SAW A NEW FONT.

ESC1B:
	MOVEM	DAT,XCFH		;STORE NEW HEIGHT
ESC1C:
	MOVEM	UUO,XCFBL		;NEW BASELINE
	CAMN	UCHN,TEM		;CHECK TO SEE IF OLD MCG IS EMPTY
	JRST	XCI1			;NO NEED TO CLOSE AN EMPTY MCG
	CAIGE	PROG,2(TEM)		;ROOM TO CLOSE THIS HERE?
	PUSHJ	P,ADDNOD		;NO. MAKE ANOTHER NODE.
	JRST	ES1.1B			;SET RETURN, SET UP FOR NEW CHB

;HERE FOR '177 '001 '044 - INSERT PAPER PAGE NUMBER.
ES1.4:
	MOVE	DAT,XGPPG2
	CAILE	DAT,=99999
	JRST	XCI1			;FLUSH.
	MOVEM	TAC,XGPAT0
	MOVEM	TAC1,XGPAT1		
	MOVEI	TAC,(DAT)
	MOVE	DAT,[POINT 7,XGPAT2]
	PUSHJ	P,ES1.4B
	MOVEI	TAC,XGPAT2
	MOVEI	TAC1,5
	JRST	XCI1
ES1.4B:
	IDIVI	TAC,=10
	HRLM	TAC1,(P)
	JUMPE	TAC,.+2
	PUSHJ	P,ES1.4B
	HLRZ	TAC,(P)
	ADDI	TAC,"0"
	IDPB	TAC,DAT
	POPJ	P,

;HERE FOR '177 '1 '45 - SET AND PRINT HEADING
ES1.5:
	MOVSI	AC2,XGPHDB
	HLRZM	AC2,XGPHDW		;CLEAR HEADING COUNT
	SETZM	XGPHDB			;CLEAR HEADING BUFFER
	HRRI	AC2,XGPHDB+1
	BLT	AC2,XGPHDB+=25		;CLEAR 130 CHARACTERS
	JSP	AC3,XCIG		;GET A CHARACTER. THIS IS THE COUNT.
	MOVEI	AC1,(DAT)		;KEEP THE COUNT.
	JUMPE	AC1,XCI1		;COUNT OF ZERO MEANS FLUSH HEADING.
	MOVE	AC2,[POINT 7,XGPHDB]
ES1.5A:
	JSP	AC3,XCIG
	IDPB	DAT,AC2
	SOJG	AC1,ES1.5A		;DECREMENT COUNT AND LOOP UNLESS RUN OUT
	ANDI	AC2,-1			;GET THE ADDRESS ONLY
	SUBI	AC2,XGPHDB-1		;COMPUTE WORD COUNT
	MOVNI	AC2,(AC2)
	HRLM	AC2,XGPHDW
	MOVE	DAT,MTB(TAC1)
	ANDM	DAT,(TAC)		;CLEAR OUT THE TEXT WE'VE PROCESSED
	JSP	AC3,BFNSET		;GIVE BACK SOME BUFFER SPACE
	MOVE	TAC,XGPHDW		;READY FOR THE HEADING
	JRST	XCIP2			;SET DO THE HEADING.  (OOF)

;HERE FOR '177 '1 '46 - START UNDERLINE.
ES1.6:
	MOVEM	J,XUSBEG		;STORE PRESENT COLUMN FOR START OF UNDERLINE
	JRST	XCI1			;DO MORE.

;HERE FOR '177 '002 - XGP ESCAPE 2
ESC2:
	JSP	AC3,XCIG		;GET ANOTHER CHARACTER
	CAIL	DAT,100			;SKIP IF INTERPRETED AS POSITIVE
	ORCMI	DAT,177			;EXTEND NEGATIVE SIGN
	ADD	J,DAT			;DO FULL WORD ADD.
	JUMPGE	J,XCI1CA		;NOW IT'S LIKE TAB OR CR
	MOVEI	J,0			;PREVENT BACKSPACE OFF LEFT END
	JRST	XCI1CA			;

GLOM:
	MOVEI	AC1,0			;ACCUMULATE MULTIPLE BYTES
					;COUNT IN AC2, RETURNS IN AC1
GLOM1:
	JSP	AC3,XCIG		;GET A BYTE
	LSH	AC1,7
	IORI	AC1,(DAT)
	SOJG	AC2,GLOM1		;DECREMENT COUNT
	POPJ	P,			;RETURN.

;HERE FOR '177 '003 - SET Y POSITION OF CURRENT TEXT LINE.
ESC3:
	MOVEI	AC2,2			;GET 2 BYTES
	PUSHJ	P,GLOM			;GOBBLE GOBBLE
	MOVEM	AC1,XCYPOS		;SET CURRENT Y POSITION.
	JRST	XCI1			;COMPILE MORE.

;HERE FOR '177 '004
ESC4A:
	CONO	PI,PION			;HERE TO WAIT FOR A NODE.
	JSR	X2DISP
ESC4:
	CONO	PI,PIOFF
	SKIPN	UUO,XVNFL		;GOBBLE FROM VECTOR NODE FREE LIST.
	JRST	ESC4A			;WAIT.
	MOVE	DAT,(UUO)
	MOVEM	DAT,XVNFL
	CONO	PI,PION			;UUO NOW POINTS TO THE NEW NODE.
	SETZM	(UUO)
	MOVEI	AC2,2			;2 BYTES OF Y0
	PUSHJ	P,GLOM
	MOVEM	AC1,1(UUO)		;STORE Y0
	MOVEI	AC2,2			;2 BYTES OF X0
	PUSHJ	P,GLOM
	ANDI	AC1,7777		;RESTRICT X0 TO RANGE
	HRLZM	AC1,2(UUO)		;STORE X0
	MOVEI	AC2,3			;3 BYTES OF DX
	PUSHJ	P,GLOM
	TLNE	AC1,4			;SIGN BIT?
	TLO	AC1,777770		;SIGN EXTEND.
	LSH	AC1,11			;SHIFT 9 BITS
	MOVEM	AC1,4(UUO)		;STUFF DX
	MOVEI	AC2,2			;2 BYTES OF N
	PUSHJ	P,GLOM
	HRRM	AC1,2(UUO)		;STORE N
	MOVEI	AC2,2
	PUSHJ	P,GLOM
	ANDI	AC1,7777		;REASONABLENESS
	IORI	AC1,SETN		;TURN ON THE RIGHT BITS
	MOVEM	AC1,3(UUO)		;STORE WIDTH.
	MOVEM	UUO,XVNODE		;STORE NODE ADDRESS.
	SKIPN	DAT,XGPPS2		;SKIP UNLESS SPECIAL PAGE HACK
	JRST	ESC4B			;SPECIAL PAGE HACK. LEAVE IT ALONE.
	ADD	DAT,XGPPS1		;SEE IF WE HAVE A PAGE TOO LONG
	CAML	DAT,1(UUO)		;SKIP IF WE'VE LOST
	JRST	ESC4B			;WE'RE OK SO FAR.
	PUSHJ	P,XERR13		;THIS WILL SET THE ERROR CODE
ESC4X:
	SETZM	1(UUO)			;(THIS WILL FORCE OOO ERROR)
	JRST	XCI1F			;QUEUE THIS TEXT NODE.
ESC4B:
	HRRZ	DAT,2(UUO)		;GET N
	HLLZ	AC1,2(UUO)		;GET X0
	IMUL	DAT,4(UUO)		;N*DX
	ADD	DAT,AC1			;+X0
	CAMG	DAT,[7777,,-1]		;OR TO FAR T'OTHER WAY
	JUMPGE	DAT,XCI1F		;SMALL ENOUGH. JUMP IF BIG ENOUGH
	PUSHJ	P,XERR14		;LOSE - ILLEGAL VECTOR PARAMETERS
	SETZM	4(UUO)			;SET DX TO 0
	HLLZS	2(UUO)			;SET N TO 0
	JRST	ESC4X			;GO FORCE OOO ERROR.

;	HERE FOR A 'NORMAL' CHARACTER
XCI2A:
	ADD	DAT,XFTCAD		;ADD BASE OF TABLE
	SKIPN	AC3,1(DAT)		;SKIP IF THERE'S A CHARACTER THERE.
	JRST	XCI1			;NONE THERE GET ANOTHER CHARACTER
	LDB	AC2,[POINT 1,(AC3),10]	
	JUMPN	AC2,XCI2AW		;JUMP IF THIS IS A LEFT-KERN CHARACTER
XCI2AX:
	CAML	J,XGPRMR		;ARE WE ABOUT TO OVERSTEP RIGHT MARGIN?
	AOJA	TAC1,XCI1D		;YES. PUT BACK THIS CHARACTER.
	CAME	DSER,TEM		;SKIP IF THIS IS A NEW SUBGROUP
	JRST	XCI2B			;NOT NEW
	CAME	UCHN,TEM		;SKIP IF THIS IS A NEW MCG
	JRST	XCI2AZ			;NO. JUST NEW SUBGROUP
	JUMPE	TEM,XCI2AC		;JUMP IF THERE ARE NO MCG'S
	SKIPL	AC2,XLBL		;ARE THERE OTHER CHB'S YET?
	JRST	XCI2AA			;YES.
XCI2AC:
	MOVE	AC2,XCFBL
	MOVEM	AC2,XLBL
XCI2AA:
	SUB	AC2,XCFBL		;SUBTRACT TO FIND BASELINE OFFSET.
	JUMPL	AC2,XCI2AB		;NEW BASELINE IS BIGGER (DEEPER)
	MOVEI	AC3,(AC2)
	ADD	AC3,XCFH
	JSP	AC1,SCHB		;SEARCH FOR A BLOCK THAT'S RIGHT
	SKIPGE	AC2,XLBL		;LINE BASE-LINE SET YET?
	MOVE	AC2,XCFBL		;NOT YET. DO SO NOW.
	MOVEM	AC2,XLBL
	JRST	XCI2AY
 
XCI2AB:
	MOVM	AC3,AC2			;THE AMOUNT TO ADD TO ALL PRIOR COMMANDS.
	ADDM	AC3,XHMAX		;MAX HEIGHT MUST BE INCREASED
	MOVE	AC1,XCFBL
	MOVEM	AC1,XLBL		;SET NEW LINE BASE-LINE
	JSP	AC1,OFFCHB		;SET OFFSET IN ALL PRIOR COMMANDS
	HRRZ	AC3,XCFH		;SET MAX FOR THIS TERM
	MOVEI	AC2,0			;MIN
	JSP	AC1,ACHB		;ADD A NEW COMMAND HEADER BLOCK
	
XCI2AY:
	CAIGE	PROG,2(TEM)
	PUSHJ	P,ADDNOD
	PUSH	TEM,[CONO XGP,SETX]
	ADDM	J,(TEM)			;SET COLUMN SELECTOR.
XCI2AZ:
	HLRO	AC3,1(DAT)		;GET THE CHARACTER WIDTH (WORDS)
	ADDI	AC3,(PROG)
	CAIGE	AC3,3(TEM)		;ROOM FOR JSP,PTR,data,JRST?
	PUSHJ	P,ADDNOD		;NO. ADD A NEW NODE.
	PUSH	TEM,[JSP AC3,SCAN]	;STUFF COMMAND INTO BUFFER.
	MOVE	DSER,TEM
	MOVEI	UUO,2(TEM)
	PUSH	TEM,UUO
	MOVE	AC3,1(DAT)		;GET THE DATUM AGAIN.
XCI2B:
	HLRO	AC2,AC3			;GET SIZE OF THIS ITEM.
	ADDI	AC2,(PROG)
	CAIGE	AC2,1(TEM)		;WILL THIS FIT?
	JRST	XCI2AZ			;NO. START A NEW NODE.
	HLLZ	AC2,AC3
	ADDM	AC2,1(DSER)
	LDB	AC1,[POINT 9,(AC3),8]	;GET THE WIDTH
	ADDI	J,(AC1)			;ADD THE WIDTH TO THE COLUMN COUNTER
	LDB	AC1,[POINT 1,(AC3),9]	;GET WIDTH KLUDGE BIT
	PUSH	TEM,(AC3)		;STUFF POINTERS
	AOBJN	AC3,.-1
	JUMPE	AC1,XCI1		;BACK TO GET ANOTHER UNLESS WIDTH KLUDGE
	JRST	XCI1CA			;ELSE EXPLICITLY SET COLUMN POSITION.

XCI2AW:
	AOSN	XLFTKF			;LEFT-KERN FLAG SET?
	JRST	XCI2AX			;YES. WE WERE THRU HERE LAST TIME
	SETOM	XLFTKF
	LDB	AC2,[POINT 9,-1(AC3),35]	;GET KERN-OFFSET
	SUBI	J,(AC2)
	AOJA	TAC1,XCI1CA		;GO SET THE COLUMN POSTION. PUT CHR BACK

BEND XGPSER
;: XGPSER[J17,SYS] EOF.
;: FBPACK[J17,SYS]
COMMENT ⊗   VALID 00020 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	IFN FTDISK,<BEGIN FBPACK
SUBTTL	LIBRASCOPE SWAPPER AND FAST-BAND SERVICE
C00004 00003	↑FBINI:	SETZM	FBQUE		INITIALIZE
C00007 00004	FAST BAND SERVICE UUO'S
C00010 00005	ADDRESS CHECK THE GOODIE TABLE - DON'T RETURN UNLESS HAPPY.
C00013 00006	UTILITY ROUTINES.
C00015 00007	UUO CALL TO GET A BAND
C00018 00008	UUO TO GET PHYSICAL BAND NUMBER AND OFFSET
C00021 00009	UUO TO TELL YOU IF YOU HAVE A TRANSFER IN PROGRESS
C00023 00010	ROUTINE TO GET A BAND AT ANY LEVEL
C00025 00011	ROUTINE TO RELEASE A BAND AT ANY LEVEL
C00027 00012	ROUTINES TO READ AND WRITE A FAST BAND
C00029 00013	THIS ROUTINE GETS THE PHYSICAL BAND NUMBER FROM THE LOGICAL BAND NUMBER
C00032 00014	COMMON READ-WRITE ROUTINE
C00036 00015	INTERRUPT LEVEL CODE . . .
C00038 00016	FIRST, THE DISK STARTUP ROUTINE . . .
C00043 00017	COME HERE WHEN A TASK HAS BEEN COMPLETED . . .
C00046 00018	HERE AFTER THE TV CAMERA INTERRUPT HAS GONE OFF.
C00047 00019	DISK ERROR HANDLER.
C00050 00020	IOP ERROR RECOVERY
C00054 ENDMK
C⊗;

IFN FTDISK,<
BEGIN FBPACK
SUBTTL LIBRASCOPE SWAPPER AND FAST-BAND SERVICE
;JAM 22-APR-69

;;POINTERS INTO FBBAND

↑FBLOGP:	POINT 6,(AC3),23	; POINTS TO LOGICAL BAND NUMBER
FBLUZP:
		POINT 4,(AC3),27	; COUNTS WHEN BAND LOSES
FBPROT:
		POINT 2,(AC3),29	; POINTS TO FOREIGN JOB READ-WRITE ENABLE BITS
↑FBJOBP:	POINT 6,(AC3),35	; POINTS TO JOB NUMBER

RDEN←←1		; READ ENABLE
WREN←←2		; WRITE ENABLE

DSKCHL←←CAT(CH,\DSKCHN)

↑FBINI:	SETZM	FBQUE		;INITIALIZE
	SETZM	FBTASK
	SETZM	FBSBUSY
	SETOM	FBBUSY
	SETZM	FBACT
	MOVEI	AC1,LJOBN-1	;ASSUME THE WORST.
	MOVEM	AC1,JOBNM1
	CONSZ	DSK,1B27	;IF BIT 27 IS ON, THE DISK IS OFF LINE
	POPJ	P,		;IF NO DISK, QUIT NOW
	SETOM	FBACT		;FAST BANDS ARE HERE TODAY.
	MOVNI	AC1,14		;KEEP RESERVE FOR ERRORS, LARGE JOBS & SEGMENTS
	MOVEM	AC1,JOBNM1
	MOVE	AC3,[XWD -NBANDS,FBBAND]
FBIN4:
	SKIPGE	(AC3)		;IS THIS PERMANENT LOSER?
	JRST	FBIN5		;YES.
	LDB	AC2,FBLUZP	;GET THE ERROR COUNT.
	LDB	AC1,FBLOGP	;GET LOGICAL NUMBER
	CAIGE	AC1,MAXFB	;IS IT A SWAPPING BAND?
	SETZM	(AC3)		;NOT FOR SWAPPING. DEASSIGN IT.
	DPB	AC2,FBLUZP	;RESTORE THE COUNT.
	AOS	JOBNM1		;ANOTHER BAND FREE!
FBIN5:
	AOBJN	AC3,FBIN4	;LOOP THRU THE BANDS.

	MOVE	AC3,SYSBAND
	LSH	AC3,-=12
	SETOM	FBBAND(AC3)	;PROTECT SYSTEM
	SOS	JOBNM1		;GOBBLED ANOTHER
	MOVEM	AC3,SYSBND	;SET RIGHT-ADJUSTED COPY OF SYSTEM BAND NUMBER

IFN FTDDT,<IFN	FTDSWP,<
	SKIPN	DDTSWP		;IS SWAPPING DDT REQUESTED?
	JRST	FBIN6		;NO. NO NEED TO RESERVE A BAND.
	MOVE	AC3,DDTBAND
	LSH	AC3,=-12
	SETOM	FBBAND(AC3)	;SAVE A BAND FOR SWAPPING DDT.
	SOS	JOBNM1		;AND ANOTHER BAND GOBBLED.
>>

FBIN6:
	MOVE	AC1,JOBNM1	;THIS IS THE NUMBER OF BANDS-RESERVE.
	CAILE	AC1,JOBN-1	;CAN'T BE LARGER THAN THIS
	MOVEI	AC1,JOBN-1	;
	MOVEM	AC1,JOBNM1	;THIS IS NOW THE MAX JOB NUMBER
	POPJ	P,

;FAST BAND SERVICE UUO'S
;CALLING SEQUENCES . . .
;	UFBRD <AC CONTAINING BAND NUMBER>,<ADDRESS OF GOODIE TABLE>
;	<RETURN HERE IF ERRORS ENCOUNTERED>

;	UFBWRT <AC CONTAINING BAND NUMBER>,<ADDRESS OF GOODIE TABLE>
;	<RETURN HERE IF ERRORS ENCOUNTERED>

;WHERE GOODIE TABLE IS . . .
;	1) CORE ADDRESS, SIGN BIT SET IF NO WAIT
;	2) NUMBER OF WORDS
;	3) DISK SECTOR ADDRESS (.LE.2431 DECIMAL)

↑UFBRD:	PUSHJ	P,UFBSET		;CHECK GOODIES. DON'T RETURN IF ERROR.
	XCTR	XR,[SKIPL (UUO)]		;IS THIS A NO WAIT UUO?
	JRST	NORRD			;NO. GO DO THE READ AND WAIT.
	MOVSI	DAT,UFBD		;QUEUE UP THE TRANSFER.
	HRRI	DAT,(J)
	PUSHJ	P,FBRD
	POPJ	P,			;LOSE.
	CONO	PI,DSKON		;TURN ON THE DISK
	MOVEI	AC1,FBINP		;SET THE TRANSFER IN PROGRESS BIT
	IORM	AC1,JBTSTS(J)
	JRST	CPOPJ1			;AND RETURN.

NORRD:
	SETZ	DAT,			;ZERO DAT FOR A TRANSFER AND WAIT UUO.
	PUSHJ	P,FBRD			;QUEUE TRANSFER.
	POPJ	P,			;OOPS.
	JRST	FBWAIT			;WAIT UNTIL TRANSFER IS COMPLETE

↑UFBWRT:PUSHJ	P,UFBSET		;ADDRESS CHECK GOODIES. 
	XCTR	XR,[SKIPL (UUO)]	;SAME AS UFBRD ABOVE.
	JRST	NORWR
	MOVSI	DAT,UFBD
	HRRI	DAT,(J)
	PUSHJ	P,FBWRT
	POPJ	P,
	CONO	PI,DSKON
	MOVEI	AC1,FBINP
	IORM	AC1,JBTSTS(J)
	JRST	CPOPJ1

NORWR:
	SETZ	DAT,
	PUSHJ	P,FBWRT
	POPJ	P,
FBWAIT:
	MOVNI	DSER,IOWQ	;UUO LEVEL WAIT ROUTINE. CALLED AFTER FBCOM.
	MOVEM	DSER,JOBQUE(J)	;REQUEUE TO IOWQ
	CONO	PI,DSKON	;TURN ON THE DISK CHANNEL
	PUSHJ	P,WSCHED	;TURN OFF THIS JOB
	SKIPLE	FBRETRY(AC1)	;HERE WHEN TASK DONE. WERE THERE ERRORS?
	AOS	(P)		;NO ERROR. SET SKIP RETURN TO INDICATE SUCCESS
	CAIE	AC1,FBSPARE	;IS THIS THE SPARE TASK BLOCK?
	JRST	FSGIVE		;NOT SPARE. RETURN TASK BLOCK TO FREE STORAGE
	SETZM	FBSBUSY		;RELEASE SPARE
	POPJ	P,		;RETURN TO UUOCON

;ADDRESS CHECK THE GOODIE TABLE - DON'T RETURN UNLESS HAPPY.

UFBSET:
	MOVEI	TAC1,FBINP		;IS THERE ALREADY A TRANSFER IN PROGRESS
	TDNE	TAC1,JBTSTS(J)
	PUSHJ	P,FBCW			;YES, WAIT FOR IT
	MOVEI	TAC1,FBERP		;CLEAR ERROR BIT FOR PREVIOUS TRANSFER.
	ANDCAM	TAC1,JBTSTS(J)		;CAN'T GET STATUS FOR PREVIOUS ONE
	XCTR	XR,[HRRZ UCHN,(UCHN)]
	PUSHJ	P,FBBGET		;CHECK BAND NUMBER.
	XCTR	XR,[HRRZ TAC1,(UUO)]	; PICK UP CORE ADDRESS
	PUSHJ	P,RELOCA		; RELOCATE AND ADDRESS CHECK
	JRST	UFBSE2			; ILM
	JUMPL	TAC1,UFBSE2		; REFERENCE TO WRITE PROTECTED CORE.
	MOVE	TAC,TAC1		; SAVE RELOCATED ADDRESS
	XCTR	XR,[MOVM AC2,1(UUO)]	; PICK UP WORD COUNT
	JUMPE	AC2,UFBSE2
	XCTR	XR,[MOVE TAC1,(UUO)]	; GET CORE ADDRESS AGAIN!
	ADDI	TAC1,-1(AC2)		; ADDRESS CHECK LAST WORD OF TRANSFER
	PUSHJ	P,RELOCB		; ADDRESS CHECK LAST WORD OF TRANSFER
					; (MUST BE IN SAME SEGMENT)
	JRST	UFBSE2
	XCTR	XR,[SKIPL TAC1,2(UUO)]
	CAILE	TAC1,2*=1216-1
	JRST	UFBSE1
	POPJ	P,

; ROUTINE TO CHECK A LOGICAL OR PHYSICAL BAND NUMBER
; ENTER WITH NUMBER IN UCHN

FBBGET:
	TRNE	UCHN,400000		;PHYSICAL BAND NUMBER?
	CAIL	UCHN,400000+NBANDS	;YES. SKIP IF IN RANGE. 
	CAIGE	UCHN,MAXFB		;LOGICAL BAND, (OR PHYSICAL TOO BIG.)
	POPJ	P,			;BAND IS IN BOUNDS.
	JSP	TAC,UUOMES		;TELL LOSER.
	ASCIZ	/LOGICAL OR PHYSICAL BAND NUMBER OUT OF BOUNDS. UUO/

UFBSE1:
	JSP TAC,UUOMES
	ASCIZ /DISK ADDRESS OUT OF BOUNDS, UUO/

UFBSE2:
	JSP TAC,UUOMES
	ASCIZ /ADDRESS CHECK FOR FAST-BAND CALL, UUO/

;UTILITY ROUTINES.

;HERE IF HE TRIES TO START ANOTHER TRANSFER WHILE A NO-WAIT IS IN PROGRESS.
FBCW:
	MOVNI	AC1,IOWQ		;WAIT FOR TRANSFER TO COMPLETE.
	MOVEM	AC1,JOBQUE(J)		;REQUEUE JOB TO IOWQ
	MOVEI	AC1,FBJWT		;SET FBWAIT IN JBTSTS
	IORM	AC1,JBTSTS(J)		;
	JRST	WSCHED			;WAIT.

;HERE TO COMPLETE A NO-WAIT TRANSFER.
UFBD:
	MOVEI	AC1,FBINP!FBJWT		;HERE WHEN TRANSFER COMPLETES.
	SETZ	AC2,			;ASSUME NO ERRORS.
	TRZE	DAT,400000		;WAS THERE AN ERROR.
	MOVEI	AC2,FBERP		;YES. PICKUP ERROR BIT.
	MOVEI	J,(DAT)			;LOAD JOB NUMBER.
	SOS	JBTGLU(J)		;UNGLUE THIS JOB.
IFN FTSTAT,<PUSHJ P,GLUSTT>
	IORB	AC2,JBTSTS(J)		;TURN ON ERROR BIT IF NEEDED.
	ANDCAM	AC1,JBTSTS(J)		;SHUT OFF TRANSFER IN PROGRESS AND WAIT BITS
	MOVM	AC1,JOBQUE(J)		;IS THIS GUY IN IOWQ?
	CAIN	AC1,IOWQ
	TRNN	AC2,FBJWT		;IN IOWQ. WAS HE WAITING FOR ME?
	POPJ	P,			;NOT IOWQ OR NOT WAITING FOR ME.
	MOVNI	AC1,RUNQ		;HE WAS WAITING. REQUEUE HIM TO RUNQ.
	MOVEM	AC1,JOBQUE(J)
	JRST	REQUE

;UUO CALL TO GET A BAND
; CALLING . . .
;	MOVE AC,[XWD <OFFSET & ENABLE BITS>,<BAND NUMBER>
;	CALL AC,[SIXBIT /UFBGET/]
;	<FAILURE RETURN>
;	<SUCCESS RETURN, PHYSICAL BAND NUMBER IN AC>
; <OFFSET> MAY BE ZERO, FOR LET THE SYSTEM SET IT.
; <ENABLE BITS> ARE 100000 FOR READ ENABLE, 200000 FOR WRITE ENABLE
; <BAND NUMBER> MAY BE 0 TO MAXFB-1 OR 400000 BIT ON FOR PHYSICAL BAND

↑UFBGET:
	PUSH	P,TAC
	TLNN	TAC,403777		;ANY OFFSET THERE?
	JRST	UFBGE1			;NO.
	LDB	AC1,[POINT 11,TAC,17]
	CAIL	AC1,=1216
	JRST	OFFTL			;OFFSET TOO LARGE.
UFBGE1:
	HRRZ	UCHN,(P)		;PICK UP BAND NUMBER
	PUSHJ	P,FBBGET		;CHECK FOR LEGAL BAND NUMBER.
	TRNE	UCHN,400000		;IS THIS A PHYSICAL REQUEST?
	JRST	UFBGE2			;YES. DON'T NEED TO CALL FBGET.
	PUSHJ	P,FBGET			;GO GET A BAND FOR THIS GUY.
	JRST	TPOPJ			;NO BANDS AVAILABE. FIX STACK AND LEAVE
UFBGE3:
	POP	P,AC1			;GET BACK ARGUEMENT
	TLNE	AC1,403777		;ANY OFFSET?
	HLLM	AC1,(AC3)		;YES, SET IT
	LDB	AC2,[POINT 2,AC1,2]	;GET READ/WRITE ENABLE BITS.
	DPB	AC2,FBPROT		;STUFF THEM INTO PROTECTION FIELD.
	LDB	UCHN,PUUOAC		;PICK UP ACCUMULATOR NUMBER AGAIN
	AOS	(P)
	HLL	TAC,(AC3)		;GET THE OFFSET
	DPB	AC2,[POINT 2,TAC,2]	;STUFF THE FOREIGN ENABLE BITS INTO TAC.
	HRRI	TAC,400000-FBBAND(AC3)	;LOAD 400000+PHYSICAL NUMBER IN TAC
	JRST	STOTAC

UFBGE2:
	HRRZI	AC3,FBBAND-400000(UCHN)	;MAKE POINTER
	LDB	AC1,FBJOBP		;IS THIS BAND CLAIMED?
	JUMPE	AC1,UFBGE4		;NO. WE CLAIM IT
	CAIN	J,(AC1)			;PERHAPS THIS IS OURS ALREADY?
	JRST	UFBGE3			;YES. 
	JRST	TPOPJ			;WE CAN'T HAVE THIS BAND.

UFBGE4:
	DPB	J,FBJOBP		;WE HAVE IT NOW
	JRST	UFBGE3

OFFTL:
	JSP	TAC,UUOMES
	ASCIZ	/OFFSET TOO LARGE, UUO/


↑UFBGIV:HRRZ	UCHN,TAC		;UUO TO RELEASE A FAST BAND
	JRST	FBGIVE

;UUO TO GET PHYSICAL BAND NUMBER AND OFFSET
; CALLING . . .
;	MOVE AC,<LOGICAL OR PHYSICAL BAND NUMBER>
;	CALL AC,[SIXBIT /UFBPHY/]
; RETURNS 0 IF NO SUCH BAND
; RETURNS OFFSET IN LH AND PHYSICAL BAND IN RH
; SETS BIT 2 IF YOU HAVE READ ACCESS
; SETS BIT 1 IF YOU HAVE WRITE ACCESS

↑FBPHY:	SKIPN	FBACT			;ARE FAST BANDS ACTIVE TODAY.
	JRST	UUOERR			;NO.
	TRNE	TAC,400000		;PHYSICAL OR LOGICAL?
	JRST	SPHYB			;PHYSICAL.
	MOVEI	UCHN,(TAC)		;GET THE LOGICAL NUMBER.
	PUSHJ	P,FBSEARCH		;SEARCH FOR THIS BAND NUMBER.
	JRST	RTZERO			;NO THERE. TELL HIM 0.
FBPHY1:
	LDB	AC1,FBLOGP		;GET THE LOGICAL NUMBER
	CAIE	AC1,(UCHN)		;IS THIS THE RIGHT ONE.
	JRST	RSH			;NO. CONTINUE SEARCH
	HLL	TAC,(AC3)		;GET THE OFFSET FIELD.
	HRRI	TAC,400000-FBBAND(AC3)	;GET 400000+PHYSICAL NUMBER
FBPHY2:
	TLO	TAC,300000		;OWNER HAS READ AND WRITE ACCESS.
	JRST	STOTAC			;RETURN DATA TO USER.

RSH:
	PUSHJ	P,FBRESEARCH		;LOOK FOR ANOTHER BAND BELONGING TO THIS JOB
	JRST	RTZERO			;NONE THERE.
	JRST	FBPHY1			;CHECK TO SEE IF ITS THE RIGHT ONE.

SPHYB:
	MOVEI	AC3,FBBAND-400000(TAC)	;GET THE POINTER
	HLL	TAC,(AC3)		;GET THE OFFSET FIELD.
	LDB	AC1,FBJOBP		;GET THE JOB NUMBER
	CAIN	AC1,(J)			;SAME AS US?
	JRST	FBPHY2			;YES. OWNER HAS READ&WRITE ACCESS.
	LDB	AC1,FBPROT		;GET THE PROTECTION CODE.
	DPB	AC1,[POINT 2,TAC,2]	;STUFF THE PROT CODE.
	JRST	STOTAC			;RETURN DATA TO USER.

RTZERO:
	LDB	UCHN,PUUOAC
	XCTR	XW,[SETZM (UUO)]
	POPJ	P,

;UUO TO TELL YOU IF YOU HAVE A TRANSFER IN PROGRESS
; CALLING . . .
;	CALL [SIXBIT /UFBSKP/]
;	<ONE IN PROGRESS>
;	<NO TRANSFER IN PROGRESS>

↑FBSKP:	MOVEI	AC1,FBINP		;CHECK TRANSFER IN PROGRESS BIT
	TDNN	AC1,JBTSTS(J)		;FROM JBTSTS.
	AOS	(P)			;NONE IN PROGRESS
	POPJ	P,

;UUO TO WAIT FOR A TRANSFER IN PROGRESS
; CALLING . . .
;	CALL [SIXBIT /FBWAIT/]

↑FBWT:	PUSHJ	P,FBSKP			;IS THERE A TRANSFER IN PROGRESS.
	JRST	FBCW			;YES. WAIT NOW FOR IT TO FINISH
	POPJ	P,			;NO TRANSFER IN PROGRESS. 

; UUO TO TELL YOU IF THE LAST TRANSFER GOT AN ERROR.
; CALLING . . .
;	CALL [SIXBIT /UFBERR/]
;	<ERROR OCCURRED>

↑FBERR:	MOVEI	AC1,FBERP		;TEST THE ERROR BIT FROM JBTSTS
	TDNN	AC1,JBTSTS(J)
	AOS	(P)
	POPJ	P,

;ROUTINE TO GET A BAND AT ANY LEVEL
; CALLING . . .
;	MOVE UCHN,<LOGICAL BAND NUMBER, 0-31>
;	MOVE ITEM,<JOB NUMBER THAT IS CLAIMING THE BAND>
;	PUSHJ PDP,FBGET
;	<RETURNS HERE IF NONE LEFT>
; RETURNS PHYSICAL BAND NUMBER IN TAC

↑FBGET:	SKIPN	FBACT		;ARE FAST BANDS THERE TODAY?
	POPJ	P,		;NO.
	PUSHJ	P,FBGIVE	;GIVE BACK IF WE HAVE THIS LOGICAL ONE ALREADY.
	MOVE	AC3,[XWD -NBANDS,FBBAND]
FBGET1:
	SKIPN	(AC3)		;IS THIS BAND FREE?
	JRST	FBGET3		;YES. CLAIM THIS.
	AOBJN	AC3,FBGET1	;THIS ONE IS IN USE, TRY NEXT ONE
	MOVE	AC3,[XWD -NBANDS,FBBAND]
FBGET2:
	MOVEI	TAC,77
	AND	TAC,(AC3)	;PICKUP JOB NUMBER FIELD.
	JUMPE	TAC,FBGET3	;JOB NUMBER IS ZERO. WE'LL CLAIM IT.
	AOBJN	AC3,FBGET2
	POPJ	P,		;THERE ARE NONE LEFT.

FBGET3:
	DPB	J,FBJOBP	;STORE JOB NUMBER.
	TRNN	UCHN,400000	;DON'T SET LOGICAL NUMBER IF PHYSICAL
	DPB	UCHN,FBLOGP	;PUT LOGICAL BAND NUMBER IN PLACE
	MOVEI	TAC,400000-FBBAND(AC3)
	AOS	(P)
	POPJ	P,

FBSEARCH:

	MOVE	AC3,[XWD -NBANDS,FBBAND]	;LOAD UP AOBJN POINTER
FBSEA1:
	SKIPLE	AC1,(AC3)	;IS THIS BAND CLAIMED?
	JRST	FBSEA2		;BAND IS CLAIMED.
FBRESEARCH:

	AOBJN	AC3,FBSEA1
	POPJ	P,

FBSEA2:
	ANDI	AC1,77		;GET THE JOB NUMBER FIELD ONLY!
	CAIN	AC1,(J)		;BELONGS TO THIS JOB?
	JRST	CPOPJ1		;YES.
	JRST	FBRESEARCH

;ROUTINE TO RELEASE A BAND AT ANY LEVEL
; CALLING . . .
;	MOVE UCHN,<LOGICAL BAND NUMBER>
;	MOVE ITEM,<JOB NUMBER THIS BAND BELONGS TO>
;	PUSHJ PDP,FBGIVE

↑FBGIVE:SKIPE	FBACT		;FAST BANDS TODAY?
	PUSHJ	P,FBSEARCH	;YES. LOOK FOR A BAND FOR THIS JOB.
	POPJ	P,		;NONE THERE OR NO FAST BANDS.
FBGIV1:
	TRNE	UCHN,400000	;IS THIS A PHYSICAL NUMBER?
	JRST	FBGIV3		;YES.
	LDB	AC1,FBLOGP	;IS THIS THE BAND WE WANT?
	CAME	AC1,UCHN
	JRST	FBGIV2		;NOPE.
FBGIV4:
	LDB	AC1,FBLUZP	;PRESERVE THE LOSE COUNT.
	SETZM	(AC3)		;YES, CLEAR IT OUT
	DPB	AC1,FBLUZP
	POPJ	P,

FBGIV3:
	CAIN	UCHN,400000-FBBAND(AC3)		;PHYSICAL NUMBER THE SAME?
	JRST	FBGIV4
FBGIV2:
	PUSHJ	P,FBRESEARCH	; NO, TRY FOR ANOTHER ONE
	POPJ	P,
	JRST	FBGIV1

;;ROUTINE TO FLUSH ALL A JOB'S BANDS
; CALLING . . .
;	MOVE ITEM,<JOB NUMBER>
;	PUSHJ PDP,FBFLUSH

↑FBFLUSH:
	HRRZS	JBTSWP(J)
	HRRZS	JB2SWP(J)
	SKIPN	FBACT
	POPJ	P,		;NO FAST BANDS ACTIVE. 
	PUSHJ	P,FBSEARCH	;LOOK FOR BANDS BELONGING TO ME.
	POPJ	P,
	PUSH	P,TAC
FBFLU1:
	LDB	TAC,FBLUZP	;FLUSH THIS BAND
	SETZM	(AC3)
	DPB	TAC,FBLUZP
	PUSHJ	P,FBRESEARCH	;SEARCH FOR ANOTHER ONE
	JRST	TPOPJ		;NONE.
	JRST	FBFLU1

;ROUTINES TO READ AND WRITE A FAST BAND
; CALLING . . .
;	MOVE TAC,<CORE ADDRESS, INDEXED BY PROG IF FOR A USER>
;	MOVE UCHN,<LOGICAL BAND NUMBER>
;	MOVE AC2,<WORD COUNT AS A POSITIVE NUMBER>
;	MOVE TAC1,<DISK ADDRESS, LESS THAN 1216 DECIMAL>
;	MOVE ITEM,<JOB NUMBER>
;IF AT CLOCK LEVEL, MUST INCLUDE ONE MORE PARAMETER . . .
;	MOVE DAT,<CLOCK LEVEL ADDRESS TO JUMP TO WHEN TASK DONE>
;	PUSHJ P,FBWRITE   OR   PUSHJ P,FBREAD

; SKIPS UPON SUCCESSFUL COMMENCEMENT OF OPERATION AT ALL LEVELS
; AT UUO LEVEL, RETURNS WHEN OP COMPLETE AND SKIPS ON SUCCESSFUL EXECUTION
; AT CLOCK LEVEL, RETURNS TO ADDRESS IN DAT WITH ERROR BITS IN TAC, OR ZERO IF SUCCESSFUL

↑FBWRITE:
	PUSHJ	P,FBWRT
	POPJ	P,
	CONO	PI,DSKON
	JRST	CPOPJ1

FBWRT:
	MOVEI	IOS,WREN
	PUSHJ	P,FBSET
	MOVN	AC3,AC3
	PUSHJ	P,FBCOM
	JRST	CPOPJ1

; READ A BAND
; SAME CALLING SEQUENCE AS IN FBWRITE

↑FBREAD:
	PUSHJ	P,FBRD
	POPJ	P,
	CONO	PI,DSKON
	JRST	CPOPJ1

FBRD:
	MOVEI	IOS,RDEN
	PUSHJ	P,FBSET		; GET PHYSICAL BAND NUMBER FROM LOGICAL NUMBER
	PUSHJ	P,FBCOM
	JRST	CPOPJ1

;THIS ROUTINE GETS THE PHYSICAL BAND NUMBER FROM THE LOGICAL BAND NUMBER
; IN ACCUMULATOR UCHN AND THE JOB NUMBER IN ITEM. IF THE BAND IS NOT INITIALIZED,
; THE ROUTINE POP'S OFF THE RETURN AND POPJ'S BACK. IF THE BAND IS FOUND, THE
; PHYSICAL BAND NUMBER IS PUT IN AC3.

FBSET:
	SKIPN	FBACT		;ANY FAST BANDS TODAY?
	JRST	TPOPJ
	TRNE	UCHN,400000	;IS THIS A PHYSICAL BAND?
	JRST	FBSET3		;YES.
	PUSHJ	P,FBSEARCH	;SEARCH FOR THE LOGICAL BAND HE REQUESTED
	JRST	TPOPJ		;ERROR - HE HAS NOT ASSIGNED THAT BAND YET
FBSET1:
	LDB	AC1,FBLOGP	;THIS BAND BELONG TO THIS JOB. GET LOGICAL NUMBER
	CAIN	AC1,(UCHN)	;IS THIS THE RIGHT LOGICAL BAND?
	JRST	FBSET4		;YES. SAME LOGICAL BAND.
	PUSHJ	P,FBRESEARCH	;NO, FIND NEXT BAND IN HIS NAME
	JRST	TPOPJ		;ERROR. LOGICAL BAND NUMBER NOT INITIALIZED
	JRST	FBSET1		;GO TEST THIS BAND.

FBSET3:
	MOVEI	AC3,FBBAND-400000(UCHN)	;GET POINTER TO PHYSICAL BAND.
	LDB	AC1,FBJOBP	;GET THE JOB NUMBER OF BAND OWNER.
	ANDI	UCHN,177	;CLEAN OUT THE SHIT
	MOVE	TEM,JBTPRV(J)	;GET PRIVILEGES.
	TLNN	TEM,FBWPRV	;DOES THIS GUY HAVE ACCESS?
	CAIN	AC1,(J)		;OR IS THIS THE OWNER?
	JRST	FBSET4		;YES. OPERATION PROCEEDES.
	CAMN	UCHN,SYSBND	;DOES HE WANT THE SYSTEM BAND?
	JRST	FBSYSB		;YES. GO BLESS HIM
	LDB	AC1,FBPROT	;
	SKIPL	(AC3)		;SKIP IF BAD BAND.
	TDNN	AC1,IOS		;CHECK PROTECTION BITS
	JRST	TPOPJ		;ACCESS IS NOT ALLOWED.
FBSET4:
	MOVEI	AC3,-FBBAND(AC3);GET PHYSICAL NUMBER IN AC3
	HRRZ	TAC1,TAC1	;ZERO LEFT SIDE OF TAC1
	CAMN	AC3,SYSBND	;IS THIS THE SYSTEM BAND?
	CAIE	IOS,WREN	;YES. WRITING ON SYSBAND?
	POPJ	P,		;NO.
;	SETZM	SYSTHERE	;THE SYSTEM IS NOW CLOBBERED
	POPJ	P,


FBSYSB:
	CAIE	IOS,WREN	;IS HE WRITING ON SYSTEM BAND?
	JRST	FBSET4		;NO. ANYONE MAY READ
	JRST	TPOPJ		;SCREW HIM.

↑FBTVIN:
	SETOM	TAC1		; FLAG TV REQUEST WITH -1 DISK ADDRESS
	PUSHJ	P,FBCOM		; FROM HERE ON OUT, TREAT AS A STANDARD REQUEST
	CONO	PI,DSKON
	POPJ	P,

;COMMON READ-WRITE ROUTINE

FBCOM:
	PUSH	P,AC3			;SAVE BAND NUMBER ON STACK
	MOVEI	AC3,FBSIZ		;GET A TASK BLOCK FROM FREE STORAGE
	PUSHJ	P,FSGET
	JRST	FBCOM5			;OOPS. WE'LL HAVE TO USE THE SPARE.
FBCOM3:
	MOVEM	TAC,FBADR(AC1)		;LOAD UP THE TASK BLOCK WITH GOOD STUFF
					;IN CASE OF TV THIS IS COMMAND BLOCK ADDRESS
	MOVEM	AC2,FBWC(AC1)		;THE WORD COUNT
	MOVEM	TAC1,FBDA(AC1)		;THE DISK SECTOR ADDRESS 
					;(BAND AND TRACK IS ADDED IN AT I-LEVEL)
					;(-1 FOR TV CALL)
	MOVEM	J,FBJOB(AC1)		; SAVE JOB NUMBER FOR UUO-LEVEL CALLS
	MOVEI	DSER,=10		; ONLY TEN RETRIES
	MOVEM	DSER,FBRETRY(AC1)
	POP	P,FBBND(AC1)		;STORE PHYSICAL BAND NUMBER 
	MOVEM	DAT,FBDONE(AC1)		;CLOCK LEVEL ADDRESS WHEN TASK DONE
	CONSZ	PI,1⊗(17-CLKCHN)	;NOW, ARE WE AT UUO LEVEL?
	JRST	FBCOM2			;WE ARE AT CLOCK LEVEL.
	JUMPL	TAC1,FBCOM2		;TV CALLS HAVE ALREADY LOCKED JOB.
	AOS	JBTGLU(J)		;PIN DOWN THIS JOB.
IFN FTSTAT,<PUSHJ P,GLUSTT>
	MOVNI	DSER,IOWQ		;SET US INTO THE WAIT QUEUE NOW
	SKIPN	FBDONE(AC1)		;AVOID REQUEING IF DOING NO-WAIT UUOS
	MOVEM	DSER,JOBQUE(J)
FBCOM2:
	MOVEI	TEM,DSKSTART		;READY FOR I-LEVEL. GET STARTUP DISPATCH
	CONO	PI,DSKOFF		;TURN OFF THE DISK.
	HLRZ	DSER,FBQUE		;ADD OUR TASK TO THE END OF THE TASK LIST
	SKIPE	DSER			;LH OF FBQUE POINTS TO LAST TASK IN LIST,
					; RH TO FIRST
	MOVEM	AC1,FBLINK(DSER)	;LINK FROM THE LAST TASK TO THIS TASK
	HRLM	AC1,FBQUE		;UPDATE POINTER TO END OF LIST
	SKIPN	DSER
	HRRM	AC1,FBQUE		;IF ONLY TASK, UPDATE POINTER TO FIRST TASK
	SETZM	FBLINK(AC1)		;SINCE WE ARE THE LAST TASK, ZERO OUR LINK
	SKIPL	FBBUSY			;IS THE DISK BUSY NOW?
	POPJ	P,			;YES, WE DO NOT HAVE TO START IT UP
	MOVEM	TEM,FBBUSY		;NO. STORE DISPATCH LOCATION
	MOVEI	TEM,IOPANY!IOPJDN	;RESET CH6 CONSZ BITS
	HRRM	TEM,DIPCON		;
	CONO	IOP,IOPJDN!DSKCHN	;SET JBDN TO MAKE A STARTUP INTERRUPT.
	POPJ	P,

FBCOM5:
	SKIPE	FBSBUSY			;NO SYSTEM FS LEFT. USE OUR SPARE!
	HALT	FBCOM4			;SPARE BUSY, CAN'T HAPPEN.
FBCOM4:
	SETOM	FBSBUSY			;SET SPARE BUSY.
	MOVEI	AC1,FBSPARE
	JRST	FBCOM3

;INTERRUPT LEVEL CODE . . .

↑IFBINT:
BEGIN IFBINT
	JSR	DSKSAV		;SAVE AC'S.
IFBIN1:
	SKIPGE	AC1,FBBUSY	;PICK UP THE DISPATCH ADDRESS.
				;THIS IS -1 IF DISK IDLE
	JRST	UNIOP		;UNEXPECTED INTERRUPT.
	SETOM	FBBUSY		;DISK NOW IDLE.
				;INITIALIZE DISPATCH ADDRESS AND DISPATCH!
	JRST	(AC1)		;DISPATCH.

UNIOP:
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ππUNEXPECTED IOP INTERRUPT
/
	POPACS
IOPIN1:
	CONO	IOP,DSKCHN
	SETZM	FBTASK		;FLUSH CURRENT TASK.
	POPJ	P,

↑↑DFBINT:
	CONO	DSK,0		;STOP THE DISK, I WANT TO GET OFF!
	ROT	44		;WAIT FOR THE IOP TO COOL OFF. LONG NO-OP
	JSR	DSKSAV		;SAVE AC'S.
	CONO	IOP,DSKCHN	;SET UP IOP WITH PI CHANNEL.
	EXCH	AC1,FBBUSY	;ARE WE BUSY NOW?
	CAME	AC1,[-1]	;
	JRST	DFBGO		;WE WERE BUSY.
DFBFLS:
	EXCH	AC1,FBBUSY	;PUT AC1 BACK.
	CONO	DSK,1B23!1B24!DSKCHN	;CLEAR ERROR BITS AND SET PI CHANNEL
	POPJ	P,		;AND RETURN.

DFBGO:
	EXCH	AC1,FBBUSY	;RESTORE AC1
	CONSO	DSK,1B27	;IS DISK ON LINE?
	JRST	IFBIN1		;YES. GO PROCESS INTERRUPT.
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ππUNEXPECTED LIBRASCOPE INTERRUPT
/
	POPACS
	JRST	DSKSTART

;FIRST, THE DISK STARTUP ROUTINE . . .

↑DSKSTART:
	HRRZ	AC1,FBQUE	;POP THE FIRST TASK OFF THE TASK LIST
	JUMPE	AC1,IOPIN1	;NOTHING THERE, DISMISS INTERUPT AND LEAVE
	MOVE	DSER,FBLINK(AC1);LINK AROUND THE BLOCK
	HRRM	DSER,FBQUE	;THIS IS NEW TOP OF LIST
	SKIPN	DSER		;IF THE TOP ELEMENT IS THE BOTTOM TOO . . .
	SETZM	FBQUE		;THEN ZERO BOTH FORWARD AND BACKWARD POINTERS
	MOVEM	AC1,FBTASK	;NOW SAVE THE ADDRESS OF THIS TASK BLOCK
	MOVE	TAC1,FBDA(AC1)	;PICK UP THE SECTOR ADDRESS
	AOJN	TAC1,DSKGOA	;JUMP UNLESS A TV TRANSFER
	HLLZS	DIPCON		;FIRST MAKE SURE WE WON'T GET THE INTERRUPT
	SETZM	FBBUSY		;MAKE SURE THE WORLD KNOWS WE ARE BUSY
	JRST	TVRED		;OFF TO TVSER.

DSKGOA:
	AOS	NLREQS		;
DSKGO:
	SETZ	TAC1,
	AOS	NLRERS
	MOVM	TEM,FBBND(AC1)	;DEPOSIT PHYSICAL BAND NUMBER IN
				;BITS 14-23 OF THE DISK DATAO WORD
	DPB	TEM,[POINT 8,TAC1,23]
	SETZ	DSER,
	CAMN	TEM,SYSBND	;SYSTEM?
	JRST	DSKST2		;YES, USE ZERO OFFSET
	HLRZ	DSER,FBBAND(TEM);SEE IF THE SECTOR OFFSET IS INITIALIZED YET
	JUMPN	DSER,DSKST2	;YES IT IS, SKIP OVER THIS PART
DSKST3:
	DATAI	DSK,DSER	;ON FIRST WRITEOUT, WE CAN JUST WRITE ANYWHERE
	TRNE	DSER,4000	;GET THE CURRENT SECTOR NUMBER.
	JRST	DSKST3		;SECTOR NUMBER INVALID
	ADDI	DSER,10		;BUMP WHERE WE ARE BY 10 SECTORS FOR SAFETY
	HRLM	DSER,FBBAND(TEM);AND STORE THAT AS OUR SECTOR OFFSET
DSKST2:
	ANDI	DSER,3777	;CLEAN IT UP
	ADD	DSER,FBDA(AC1)	;ADD IN USER'S REQUESTED SECTOR OFFSET
	CAIGE	DSER,=1216	;IF TRACK OVERRUN, BUMP TRACK NUMBER AND RESET SECTOR COUNT MOD 1216
	JRST	DSKST1
	CAIGE	DSER,=2432
	JRST	DSKST4
	SUBI	DSER,=2432
	JRST	DSKST1

DSKST4:
	TRO	TAC1,1B24	;DISK STARTUP ROUTINE, SET COUNT AND START DISK
	SUBI	DSER,=1216
DSKST1:
	IOR	TAC1,DSER	;NOW COMBINE BAND NUMBER, TRACK NUMBER, AND SECTOR ADDRESS
	MOVN	AC2,FBWC(AC1)	;NOW START BUILDING THE IOP DATAO WORD WITH THE WORD COUNT
	MOVS	AC2,AC2		;IN THE LEFT HALF, OF COURSE
	HRR	AC2,FBADR(AC1)	;SO LET US RELOCATE IT PROPERLY
	SETZM	DSER
	SKIPGE	FBBND(AC1)	; SET BIT 100 IN DSER IF THIS IS A WRITE OPERATION
	MOVEI	DSER,100	; OUR BAND IS SET NEGATIVE IF THAT IS TRUE
	CONO	DSK,1B23!1B24!DSKCHN
	CONO	IOP,DSKCHN(DSER); GIVE THE 167 A CHANNEL AND A READ-WRITE BIT
	DATAO	IOP,AC2		; GIVE IT A WORD COUNT AND A MEMORY ADDRESS
	MOVEM	AC2,LASTWC	; STORE LAST WC SENT
	MOVEM	AC2,30		; STORE IT SO WE CAN SEE IT WHEN MEMORY HANGS.
	JFCL			; WELL, IF DAVE SAYS SO . . .
	MOVEM	TAC1,LASTADR	; SAVE THIS FOR ERROR TYPEOUT
	DATAO	DSK,TAC1	; NOW THE DISK ADDRESS AND WE ARE OFF!
	MOVEI	AC1,FINOP	; SET FINOP AS OUR DISPATCH ADDRESS ON THE NEXT TRANSFER
	MOVEM	AC1,FBBUSY
	POPJ	P,		; DISMISS INTERRUPT AND WAIT

;COME HERE WHEN A TASK HAS BEEN COMPLETED . . .

FINOP:

	MOVE	AC1,FBTASK		; PICK UP ADDRESS OF TASK BLOCK
	CONSZ	DSK,3770		; WAS THERE A RED LIGHT ERROR LAST TIME?
	JRST	DSKERR			; YES, GO PROCESS IT (NEXT PAGE)
	CONSZ	IOP,IOPANY		; DO THE SAME FOR IOP ERRORS
	JRST	IOPERR
FINOP1:
	SKIPG	DSER,FBRETRY(AC1)	; ANY ERRORS?
	AOS	NLERRS			; YES, BUMP COUNT	
	JUMPLE	DSER,FINCNT		; SKIP IF HARD ERROR
	CAIGE	DSER,=10		; ANY SUCCESSES AFTER ERROR RETRIES?
	AOS	NSAERR			; YES, COUNT IT
FINCNT:
	SKIPN	DSER,FBDONE(AC1)	; FORK FOR UUO AND CLOCK LEVEL CALLS
	JRST	FINOP2			;UUO WAIT TYPE.

;;COME HERE TO COMPLETE A CLOCK LEVEL CALL . . .

	SKIPG	FBRETRY(AC1)		; GIVE HIM SOME ERROR BITS TOO
	TRO	DSER,400000
	CONO	PI,PIOFF
	IDPB	DSER,CLKQ		; MAKE CLOCK QUEUE REQUEST
	CONO	PI,PION
FINOP3:
	CAIE	AC1,FBSPARE		; IS THIS THE SPARE?
	JRST	FINOP5			; NO. ORDINARY FS BLOCK
	SETZM	FBSBUSY			; YES, RELEASE IT.
	JRST	DSKSTART		; PROCESS NEXT TASK.
FINOP5:
	PUSHJ	P,FSGIVE		; NOW RELEASE THIS PIECE OF FREE STORAGE
	JRST	DSKSTART		; AND GO SCAN FOR ANY MORE TASKS

;;HERE TO COMPLETE A UUO LEVEL CALL . . .

FINOP2:
	MOVE	J,FBJOB(AC1)		; PICK UP JOB NUMBER
	SOS	JBTGLU(J)		; FREE HIM IN CORE
IFN FTSTAT,<PUSHJ P,GLUSTT>
	MOVM	AC1,JOBQUE(J)		; STILL IN IOW?
	CAIE	AC1,IOWQ
	JRST	DSKSTART		; NO, DON'T REQUE HIM
	MOVEI	AC1,RUNQ		; YES, PUT HIM IN RUN QUEUE
	MOVNM	AC1,JOBQUE(J)
	PUSHJ	P,REQUE
	JRST	DSKSTART		; NOW GO SCAN FOR FURTHER TASKS TO BE DONE
					;TASK BLOCK WILL BE GIVEN BACK AT 
					;UUO LEVEL (SEE FBCOM1)

;HERE AFTER THE TV CAMERA INTERRUPT HAS GONE OFF.
;RESET DIPCON, OUR CONSZ LOCATION, AND GIVE THE TASK BLOCK BACK.

↑↑FBDFINT:
	MOVEI	AC1,IOPANY!IOPJDN	; CLEAN UP AFTER TV HAS DONE ITS THING
	HRRM	AC1,DIPCON
	MOVE	AC1,FBTASK		; NOW RELEASE THE TASK BLOCK
	SETOM	FBBUSY			; AND MAKE THE SWAPPER FREE AGAIN
	JRST	FINOP3

;DISK ERROR HANDLER.

DSKERR:
	SKIPE	AC1,FBTASK		;GET THE TASK BLOCK POINTER
	JRST	DSKERA			;WE HAVE ONE.
	PUSHACS
	PUSHJ	P,DISDATE		;NO TASK BLOCK. WHAT ARE WE DOING HERE?
	PUSHJ	P,DISMES
	ASCIZ	/πππLIBRASCOPE ERROR WHILE IT WAS IDLE

/
	POPACS
	JRST	DSKSTART		;ATTEMPT TO PROCESS MORE TASKS.

DSKERA:
	SOSLE	FBRETRY(AC1)		;HAVE WE TRIED ENOUGH?
	JRST	DSKGO			;NO. TRY SOME MORE.
	PUSHACS
	MOVM	AC3,FBBND(AC1)		;GET THE BAND NUMBER
	ADDI	AC3,FBBAND
	LDB	AC1,FBLUZP		;GET THE LOSE COUNT.
	ADDI	AC1,1
	SETZM	(AC3)
	DPB	AC1,FBLUZP
	CAILE	AC1,7
	SETOM	(AC3)			;FORCE A PERMANENT BAD BAND.
	PUSHJ	P,DISERR
	[ASCIZ	/ππLIBRASCOPE ERROR.
LASTADR = /]
	DISARG(OCT,LASTADR)	;HAS SECTOR, BAND, AND TRACK
	[ASCIZ/    LASTWC = /]
	DISARG(OCT,LASTWC)	;WCMA
	[ASCIZ/    WCMA = /]
	-1
	DATAI	IOP,TAC
	PUSHJ	P,DISOCT		;PRINT OUT CURRENT WCMA
	PUSHJ	P,DISMES
	ASCIZ	/
DISK BITS = /
	CONI	DSK,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/    IOP BITS = /
	CONI	IOP,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	PUSHJ	P,DISCRLF
	CONSO	DSK,1B31		;WRITE ERROR?
	JRST	DSKERB			;NO. WE'VE DONE ENOUGH.
	PUSHJ	P,DISMES
	ASCIZ	/WRITE ERRORS. CALL PANOFSKY RIGHT NOW! DO NOT RELOAD!
/
	SETOM	DISFLAG			;FORCE TYPEOUT
	PUSHJ	P,DISFLUSH
	SKIPN	INDDT			;IF DDT IS NOW IN, CALL IT
	HALT	DSKERB			;OTHERWISE, JUST HALT
	PUSHJ	P,DDTCALL		;CALL DDT (IF THERE)
DSKERB:
	POPACS				;RESTORE AC'S AND RETURN.
	JRST	FINOP1

;IOP ERROR RECOVERY

IOPERR:
	SKIPE	AC1,FBTASK
	JRST	IOPERA
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISMES
	ASCIZ	/ππIOP ERROR WHILE DISK WAS IDLE

/
	POPACS
	JRST	DSKSTART

IOPERA:
	CONI	IOP,TAC
	DATAI	IOP,IOPWCM	;SAVE IOP WCMA.
	MOVE	DSER,IOPWCM
	SUB	DSER,FBADR(AC1)	;ADR FROM START OF XFER
	MOVEI	DSER,-1(DSER)	;OFF BY AT LEAST 1, ALSO FLUSH WC
	TRNE	DSER,36		;MORE THAN 2 WORDS IN?
	SOJ	DSER,		;YES, EARLY RQ MKES US OFF BY 2
	ADD	DSER,FBADR(AC1)	;PUT ORG BACK - SHOULD NOW BE EXACT ADR
	CONO	DSK,0		; CLEAR ANY ERROR BITS WHAT MAY BE
	CONSO	IOP,IOPMIS	;IGNORE PAR ERR WITH DATA MISS
	CONSO	IOP,IOPPAR	;PARITY ERROR?
	JRST	PARIOP		;NO.
	MOVE	TEM,-1(DSER)	;CAST ABOUT LOOKING FOR BAD PARITY.
	MOVE	TEM,1(DSER)	;LOOK HERE TOO.
	MOVE	TEM,(DSER)	;REFERENCE IT TO CALL PARSER
	CONO	IOP,0		;SET TO READ
	DATAO	IOP,[IOPWRD]	;INTO THIS CELL
	CONO	IOP,2200	;SET RDY & BRRQ, WHICH WILL STORE BR
	PUSHACS
	PUSHJ	P,DISDAT
	PUSHJ	P,DISERR
	[ASCIZ	/IOP PARITY ERROR, LOC /]
	DISARG	LOC,<DSER-20(P)>
	[ASCIZ	/  BR=/]
	DISARG	OCT,IOPWRD
	[ASCIZ	/, C(LOC)=/]
	DISARG	OCT,<TEM-20(P)>
	[ASCIZ	/
LASTWC=/]
	DISARG	OCT,LASTWC
	[ASCIZ	/  IOP CONI = /]
	DISARG	LOC,<TAC-20(P)>
	[ASCIZ	/   FBRETRY = /]
	-1
	MOVE	TAC,AC1-17(P)	;GET REAL AC1 INTO TAC
	MOVE	TAC,FBRETRY(TAC)
	PUSHJ	P,DISDCP
	PUSHJ	P,DISMES
	BYTE(7)15,12,12		;CR,LF,LF,LF
	POPACS
PARIOP:
	TRNE	TAC,100		;I OR O
	JRST	NFBINP		;NOT INPUT
	SETZM	(DSER)		;FIX BAD PARITY WHICH DATA MISS CAN MAKE
	HRRZ	TEM,LASTWC	;GET START OF TRANSFER
	CAILE	TEM,-1(DSER)	;IS PREVIOUS WORD IN TRANSFER?
	SETZM	-1(DSER)	;YES, CLEAR IT ALSO
	CAILE	TEM,-2(DSER)	;HOW ABOUT THIS ONE?
	SETZM	-2(DSER)	;YES, CLEAR IT TOO (BETTER SAFE THAN SORRY)
NFBINP:
	TRNE	TAC,IOPRLY	;IOP EARLY RESPONSE?
	SKIPN	IEARLY		;ARE WE ENABLE FOR THIS PRINTOUT?
	JRST	RLYIOP
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/IOP EARLY RESPONSE   /
	PUSHJ	P,DISDATE
	PUSHJ	P,DISERR
	[ASCIZ	/CONI = /]
	DISARG	LOC,<TAC-20(P)>
	[ASCIZ	/;  LASTWC = /]
	DISARG	OCT,LASTWC
	[ASCIZ	/;  WCMA = /]
	DISARG	OCT,IOPWCM
	[ASCIZ	/

/]
	-1
	POPACS
RLYIOP:
	SOSLE	FBRETRY(AC1)
	JRST	DSKGO
	MOVEI	DSER,=10
	MOVEM	DSER,FBRETRY(AC1)
	PUSHACS
	PUSHJ	P,DISDATE
	PUSHJ	P,DISERR
	[ASCIZ	/IOP ERROR; CONI = /]
	DISARG	LOC,<TAC-20(P)>
	[ASCIZ	/;  LASTWC = /]
	DISARG	OCT,LASTWC
	[ASCIZ	/;  WCMA = /]
	DISARG	OCT,IOPWCM
	[ASCIZ	/

/]
	-1
	POPACS
	JRST	DSKGOA

BEND IFBINT
BEND FBPACK
>
;: FBPACK[J17,SYS] EOF.
;: IMPCLK[J17,SYS]
COMMENT ⊗   VALID 00024 PAGES 
RECORD PAGE   DESCRIPTION
 00001 00001
 00004 00002	BEGIN IMPSER
 00005 00003	 ERROR TYPEOUT ROUTINE. INCREMENTS APPROPRIATE ERROR COUNTER THEN
 00007 00004	 OPCODE DEFINITIONS FOR SECOND LEVEL PROTOCAL
 00011 00005	 PROTOCAL ERROR CODES
 00013 00006	COMMENT 	A BRIEF DESCRIPTION OF THE PROTOCAL
 00018 00007			MORE PROTOCAL DESCRIPTIONS
 00022 00008	 BYTE POINTERS TO PARTS OF MESSAGE HEADER.
 00025 00009	 SPECIAL BITS IN RH OF IOS
 00028 00010	 ROUTINES TO MAKE AND RELEASE IMP DEVICE DATA BLOCKS
 00029 00011	 CLOCK LEVEL ROUTINE. CALLED EVERY TICK. EXAMINES INPUT MESSAGES
 00032 00012	 WE GET HERE IF THERE ARE MESSAGES WAITING ON THE INPUT LIST
 00034 00013	 MESSAGE TYPE DISPATCHES - TRACE, FROM IMP, IMP GOING DOWN
 00036 00014	 IMP DEAD CODE - RUN DOWN LINK TABLE AND WAKE UP ANY WAITERS
 00038 00015	 INTERFACE TIMED OUT (SHUDDER!). BRING THE SYSTEM DOWN.
 00040 00016	 BLOCKED LINK, LINK TABLE FULL, RFNM, AND NOP
 00042 00017	 HOST OR DESTINATION IMP DEAD. MARK HOST DEAD AND GIVE EVERYBODY ERRORS.
 00045 00018	 INCOMPLETE TRANSMISSION, ERROR WITH MESSAGE IDENTIFICATION
 00048 00019	 UNKNOWN LINK AND NO DDB ERROR TYPEOUTS
 00049 00020	 ROUTINE TO MAKE UP A POINTER INTO THE HOST TABLES
 00050 00021	 ROUTINE TO UNBLOCK LINK ZERO AND WAKE UP ANYBODY WAITING FOR IT
 00052 00022	 ROUTINE TO TRANSMIT ANY MESSAGES IN CLOCK WAIT ON LINK 0
 00054 00023	 ROUTINE TO FLUSH ALL CLOCK-LEVEL OUTPUTS TO A PARTICULAR HOST
 00055 00024	 UNBLOCKING ROUTINE FOR NON-ZERO LINK
 00057 ENDMK
⊗;

BEGIN IMPSER
SUBTTL NETWORK CONTROL PROGRAM FOR THE INTERGALACTIC MESSAGE PROCESSOR - JAM SEPT '71

; ERROR TYPEOUT ROUTINE. INCREMENTS APPROPRIATE ERROR COUNTER THEN
; TYPES CTY MESSAGE.

DEFINE TELCTR (CTR,MESS) <
	AOS CTR
	SKIPN IMPPMS	; DO WE PRINT TODAY?
	JRST .+7	; NO, SKIP OVER ERROR MESSAGE
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ / IMP - MESS NUMBER /]
	DISARG DEC,CTR
	[ASCIZ /
/]
	-1
>

DEFINE ERRCTR (CTR,MESS) <
	AOS CTR
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ / IMP - MESS NUMBER /]
	DISARG DEC,CTR
	[ASCIZ /
/]
	-1
>

; DATA BLOCK DEFINITIONS . . .

TLINK←←0	; XWD <NEXT MESSAGE>,<NEXT BLOCK THIS MESSAGE>
TWC←←1		; DATA WORD COUNT
TLEN←←2		; LENGTH OF DATA PORTION OF BLOCK
TBP←←3		; INPUT BYTE POINTER
TDATA←←4	; BEGINNING OF DATA AREA
TLNG←←50	; LENGTH OF ENTIRE BLOCK
↑TDLEN←←TLNG-TDATA
		; LENGTH OF DATA PORTION ONLY

; DEBUGGING MASKS

LEADM←←741774007777	; MASK FOR LEADER
SCM←←740077777400	; MASK FOR SIZE AND COUNT FIELDS

; OPCODE DEFINITIONS FOR SECOND LEVEL PROTOCAL

NOP←←0		; NO-OPERATION
RTS←←1		; ESTABLISH CONNECTION, SENT FROM RECEIVER TO SENDER
		; FOLLOWED BY 32 BITS OF RECEIVE SOCKET,
		; 32 BITS OF SEND SOCKET, AND 8 BITS OF LINK NUMBER
STR←←2		; ESTABLISH CONNECTION, SENT FROM SENDER TO RECEIVER
		; FOLLOWED BY 32 BITS OF SEND SOCKET,
		; 32 BITS OF RECEIVE SOCKET, AND 8 BITS OF BYTE SIZE.
CLS←←3		; CLOSE CONNECTION. FOLLOWED BY 32 BITS LOCAL SOCKET
		; NUMBER AND 32 BITS FOREIGN SOCKET NUMBER
ALL←←4		; ALLOCATE. SENT FROM RECEIVER TO SENDER TELLING HOW
		; MUCH DATA MAY BE SENT AT A TIME. FOLLOWED BY
		; 8 BITS OF LINK NUMBER, 16 BITS OF MESSAGE SPACE
		; AND 32 BITS OF BIT SPACE.
GVB←←5		; GIVE BACK ALLOCATION. SENT FROM RECEIVER TO SENDER
		; TO REQUEST RETURN OF STORAGE. FOLLOWED BY 8 BITS
		; OF LINK NUMBER, 8 BITS OF A 7-FIXED-BINARY-PLACE
		; FRACTION WHICH IS THE FRACTION OF THE MESSAGE
		; SPACE TO BE RETURNED, AND 8 BITS OF FRACTION WHICH
		; IS THE FRACTION OF THE BIT SPACE TO BE RETURNED.
RET←←6		; RETURN STORAGE. SENT FROM SENDER TO RECEIVER EITHER
		; SPONTANEOUSLY OR IN RESPONSE TO A GVB COMMAND. FOLLOWED
		; BY 8 BITS OF LINK, 16 BITS OF MESSAGE SPACE, AND 32
		; BITS OF BIT SPACE.
INR←←7		; INTERRUPT BY RECEIVER. ASKS THE SENDER TO CEASE.
		; FOLLOWED BY 8 BITS OF LINK NUMBER.
INS←←10		; INTERRUPT BY SENDER. TELLS RECEIVER TO INTERRUPT
		; RECEIVING PROCESS. A SPECIAL CHARACTER IS INCLUDED
		; IN THE TEXT STREAM TO MARK WHERE IN TIME THE INTERRUPT
		; IS TO OCCUR. FOLLOWED BY 8 BITS OF LINK NUMBER.
ECO←←11		; ECHO TEST. FOLLOWED BY 8 BITS OF TEST DATA. RECEIVING
		; HOST IS TO RETURN SAID DATA VERBATUM VIA FOLLOWING COMMAND.
ERP←←12		; ECHO REPLY. FOLLOWED BY 8 BITS OF RETURNED TEST DATA.
ERR←←13		; ERROR. FOLLOWED BY 8 BITS OF ERROR CODE AND
		; 80 BITS OF ERROR DATA.
RST←←14		; RESET. ASKS HOST TO CLEAR ALL TABLES AND CONNECTIONS
		; HAVING TO DO WITH US.
RRP←←15		; RESET REPLY. INDICATES THE RESET HAS BEEN DONE.

; PROTOCAL ERROR CODES

ILO←←1		; ILLEGAL OPCODE. AN ILLEGAL OPCODE WAS DETECTED IN
		; A CONTROL MESSAGE. THE "dATA" FIELD CONTAINS THE TEN BYTES OF
		; THE AILING CONTROL MESSAGE BEGINNING WITH THE BYTE CONTAINING
		; THE ILLEGAL OPCODE.
SPS←←2		; SHORT PARAMETER SPACE. THE END OF A CONTROL MESSAGE
		; WAS ENCOUNTERED BEFORE ALL THE REQUIRED PARAMETERS OF
		; THE CONTROL COMMAND BEING DECODED WERE FOUND. THE "dATA"
		; FIELD CONTAINS THE COMMAND IN ERROR.
BDP←←3		; BAD PARAMETERS. ERRONEOUS PARAMETERS WERE FOUND
		; IN A CONTROL COMMAND. DATA FIELD CONTAINS AILING COMMAND.
NES←←4		; NON-EX SOCKET. A COMMAND OTHER THAN STR OR RTS WAS
		; RECEIVED FOR A CONNECTION FOR WHICH NO REQUEST FOR
		; CONNECTION HAS BEEN MADE.
LNC←←5		; LINK NOT CONNECTED. CONTROL COMMAND CONTAINING
		; A LINK NUMBER FOR WHICH NO CONNECTION EXISTS.

; WHEN THE ERROR CODE IS ZERO, THE NEXT 8 BIT BYTE IS THE STANFORD
; PECULIAR ERROR CODE, FOLLOWED BY 72 BITS OF THE AILING COMMAND
; RETURNED. HERE ARE THE STANFORD ERROR CODES.

CTO←←1		; COUNTER OVERFLOW. EITHER MESSAGE SPACE EXCEEDED
		; OR BIT SPACE EXCEEDED BY THE LAST MESSAGE. THE
		; MESSAGE WAS DISCARDED.
ILB←←2		; ILLEGAL BYTE SIZE FOR CONTROL MESSAGE. MESSAGE
		; WAS DISCARDED.

COMMENT ⊗	A BRIEF DESCRIPTION OF THE PROTOCAL
	THE PROTOCAL IS  IN  ABOUT  3  LAYERS.  THE  FIRST  LAYER  IS
IMP-HOST PROTOCAL. THE IMP SENDS US EACH MESSAGE PREFACED BY A 32-BIT
LEADER WHICH LOOKS LIKE THIS:

  0   1     2    3    4       7  8         15  16          23
**************************************************************
*   *    *     *     *         *             *               *
* 0 * FI * TRC * OCT *   TYPE  *     HOST    *      LINK     *
*   *    *     *     *         *             *               *
**************************************************************

	THE FI BIT MEANS THE MESSAGE IF FROM THE IMP TTY. THIS CAN BE
GENERATED USING THE CROSSPATCH MODE AND TYPING A MESSAGE TO  STANFORD
FROM  THE  TTY.  OUR  SYSTEM IGNORES SUCH MESSAGES. THE TRC BIT MEANS
THIS MESSAGE IS FOR TRACING FOR TEST PURPOSES AND WAS ISSUED FROM BBN
OR NMC. WE IGNORE IT ALSO. WE IGNORE THE OCT BIT. THE TYPE FIELD IS A
4-BIT OPCODE TELLING WHAT KIND OF MESSAGE THIS IS. ALL DATA  MESSAGES
FROM  FOREIGN HOSTS ARE TYPE 0 AND ARE CALLED "rEGULAR" MESSAGES. THE
OTHER TYPES ARE DESCRIBED IN BBN DOCUMENT  1822  "SPECIFICATIONS  FOR
THE  INTERCONNECTION  OF  A HOST AND AN IMP". I WILL BRIEFLY DESCRIBE
THEM HERE.
	TYPES 1, 3, 6, 7, 8, AND 9 ARE ALL ERRORS OF DIFFERENT KINDS.
IT MEANS THE LAST MESSAGE YOU SENT OUT WAS FLUSHED. TYPE 1  IS  ERROR
WITHOUT  MESSAGE  IDENTIFICATION.  TYPE  3  IS BLOCKED LINK, WHICH IS
MEANS WE GOOFED. WHEN YOU SEND A MESSAGE OUT, THE LINK (IDENTIFIED BY
THE  HOST-LINK  NUMBER, 16 BITS) BECOMES BLOCKED UNTIL THE MESSAGE IS
EITHER  FLUSHED  OR  DELIVERED  TO  THE  DESTINATION  COMPUTER.   THE
DESTINATION  IMP  THEN  RETURNS  THE REQUEST FOR NEW MESSAGE, TYPE 5,
BACK TO THE SENDING HOST. IF WE SEND OUT A MESSAGE  BEFORE  THE  RFNM
COMES  BACK,  WE  GET  A "bLOCKED LINK" ERROR, TYPE 3. TYPE 6 IS LINK
TABLE FULL. THIS MEANS WE SENT  OUT  SO  MANY  MESSAGES  ON  SO  MANY
DIFFERENT  LINKS  THAT COMBINED WITH THE MESSAGES ALREADY IN THE IMP,
WE OVERFLOWED ITS TABLES. TYPE 7 MEANS THE  DESTINATION  COMPUTER  OR
IMP  IS  DEAD, AS DETERMINED BY THE MESSAGE STAYING IN THE IMP SYSTEM
FOR 90 SECONDS. THE MESSAGE IS TIMES OUT AND FLUSHED. TYPE 8 IS ERROR
WITH  MESSAGE  IDENTIFICATION  AND TYPE 9 IS INCOMPLETE TRANSMISSION.
THESE ARE VERY NEBULOUS ERRORS. IT GENERALLY MEANS YOU SENT A MESSAGE
LONGER  THAN  8092  BITS,  OR  SENT  AN ILLEGAL TYPE IN THE LEADER OR
SOMETHING.
	TO SUMMARIZE, THE NORMAL SEQUENCE OF EVENTS IS THAT  WE  SEND
OUT A MESSAGE AND SOME TIME LATER GET A RFNM BACK.

		MORE PROTOCAL DESCRIPTIONS

	THE SECOND LEVEL PROTOCAL GOES AS FOLLOWS. WHEN A  CONNECTION
IS  OPEN,  THERE  IS  A  UNIQUE HOST-LINK NUMBER ASSOCIATED WITH EACH
DIRECTION OF COMMUNICATION. MESSAGES GO BACK  AND  FORTH  AS  REGULAR
MESSAGES.  OPENING  AND  CLOSING  CONNECTIONS  IS  THE HARD PART. ALL
"cONTROL" MESSAGES, THAT IS MESSAGES REGARDING  OPENING  AND  CLOSING
AND REGULATING CONNECTIONS THEMSELVES, GO ON LINK ZERO. MOST OF THESE
COMMANDS HAVE SOME IDENTIFYING FIELD THAT TELLS WHAT CONNECTION  THEY
ARE  TALKING  ABOUT.  OPENING  AND  CLOSING  A CONNECTION (BEFORE THE
UNIQUE LINK NUMBER IS ASSIGNED) IS DONE WITH THE CODES STR, RTS,  AND
CLS AND CARRY ALONG WHAT ARE CALLED SOCKET NUMBERS. THESE NUMBERS ARE
32-BITS LONG.
	TO  ESTABLISH  A CONNECTION, YOU NEED A FOREIGN SOCKET NUMBER
TO CONNECT TO. THERE  IS  DEFINED  TO  BE  AT  EACH  SITE  A  LOGGER,
LISTENING  TO  SOCKET 1, WHICH RETURNS YOU A SOCKET NUMBER FOR YOU TO
CONNECT TO. TO OPEN A CONNECTION, YOU SEND A STR OR A RTS,  DEPENDING
ON  WHETHER  YOU  ARE  SENDING OR RECEIVING. THESE OPERATIONS CARRY A
LOCAL SOCKET NUMBER AND A FOREIGN SOCKET NUMBER  AND  ONE  ADDITIONAL
BYTE,  WHICH  IS  A  CONNECTION BYTE SIZE IF RTS AND A LINK NUMBER IF
STR. A CONNECTION IS OPEN WHEN  STR  AND  RTS  WITH  MATCHING  SOCKET
NUMBERS  HAVE  BEEN  EXCHANGED.  A  CONNECTION IS HALF-DUPLEX. TO GET
TRANSMISSION BOTH WAYS, YOU NEED TO OPEN TWO CONNECTIONS.  THE  USUAL
WAY  IS  TO  OPEN  A CONNECTION ON THE SOCKET NUMBER YOU GET FROM THE
LOGGER AND ON THAT NUMBER PLUS ONE.
	A  CONNECTION  MAY  BE  CHANGED  IN  AT  LEAST  TWO WAYS. THE
SIMPLEST IS THE RESET (RST). A HOST RECEIVING A RESET IS SUPPOSED  TO
BREAK  ALL  CONNECTIONS  TO THE HOST SENDING THE RESET. THE RECEIVING
HOST IS TO RETURN A RESET REPLY (RRP) AS WELL.
	THE  GRACEFUL  WAY  TO  BREAK A CONNECTION IS TO SEND A CLOSE
(CLS) WITH THE PAIR OF SOCKET NUMBERS. THE HOST RECEIVING THE CLS  IS
TO  RETURN  A  CLS  WITH  THE SAME SOCKET NUMBERS IN IT AND CAUSE THE
CONNECTION TO BE BROKEN. THE CONNECTION IS NOT BROKEN UNTIL CLSS HAVE
BEEN EXCHANGED.
	WHEN A CONNECTION IS OPEN, THE RECEIVER SENDS THE  SENDER  AN
ALLOCATE  MESSAGE  (ALL) TELLING THE SENDER HOW MUCH BUFFERING HE HAS
AVAILABLE. EVERY TIME THE SENDER SENDS A MESSAGE, HE DECREMENTS  THIS
NUMBER.  EACH TIME THE SENDER RECEIVES AN ALLOCATE OPERATION, HE ADDS
THE NEW ALLOCATION INTO THE CURRENT ALLOCATION. ⊗

; BYTE POINTERS TO PARTS OF MESSAGE HEADER.
; ASSUMES POINTER TO FIRST BLOCK OF MESSAGE IN AC1

IMPBP:
	POINT 1,TDATA(AC1),1	; 'MESSAGE FROM IMP' BIT
TRACEP:
	POINT 1,TDATA(AC1),2	; TRACE MESSAGE BIT. MEANS MESSAGE IS
				; BEING ROUTED AROUND THE NETWORK FOR
				; ROUTING AND TIMING MEASUREMENT.
OCTALP:
	POINT 1,TDATA(AC1),3	; MEANS MESSAGE IS FROM IMP DDT AND
				; IS TEXT FOR OCTAL NUMBERS
TYPEP:
	POINT 4,TDATA(AC1),7	; IMP MESSAGE TYPE POINTER.
SRCP:
	POINT 8,TDATA(AC1),15	; HOST NUMBER POINTER
LINKP:
	POINT 8,TDATA(AC1),23	; LINK NUMBER POINTER
ELINKP:
	POINT 16,TDATA(AC1),23	; PICKS UP 16 BIT HOST AND LINK NUMBER
SIZEP:
	POINT 8,TDATA+1(AC1),11	; GETS BYTE SIZE FIELD
COUNTP:
	POINT 16,TDATA+1(AC1),27
				; BYTE COUNT FIELD

; SPECIAL DEFINITIONS FOR 2ND LEVEL PROTOCAL

OPCDP:
	POINT 8,TDATA+2(AC1),7
OLINKP:
	POINT 8,TDATA+2(AC1),15
SZLKP:
	POINT 8,TDATA+4(AC1),15	; FOR STR, IS BYTE SIZE, FOR RTS, IS LINK NUMBER
SOK1AP:
	POINT 24,TDATA+2(AC1),31; POINTS TO FIRST PART OF FIRST SOCKET NUMBER FOR STR, RTS, AND CLS
SOK1BP:
	POINT 8,TDATA+3(AC1),7	; POINTS TO SECOND PART OF FIRST SOCKET NUMBER
SOK2AP:
	POINT 24,TDATA+3(AC1),31; FIRST PART OF SECOND SOCKET NUMBER
SOK2BP:
	POINT 8,TDATA+4(AC1),7	; SECOND PART OF SECOND SOCKET NUMBER
BYTE2P:
	POINT 8,TDATA+2(AC1),15	; SECOND BYTE OF MESSAGE
BYTE3P:
	POINT 8,TDATA+2(AC1),23	; THIRD BYTE OF MESSAGE

; POINTERS INTO TIMEOUT FIELDS. EACH FIELD IS NUMBER OF 2-SECOND UNITS

CLSTP:
	POINT 6,TIMES(DDB),5	; HOW LONG WE WILL WAIT FOR RETURN CLOSE
RFNMTP:
	POINT 6,TIMES(DDB),11	; FOR RFNM ON ZERO OR NON-ZERO LINK
ALLTP:
	POINT 6,TIMES(DDB),17	; FOR ALLOCATION
RFCTP:
	POINT 6,TIMES(DDB),23	; FOR RETURN RFC
INPTP:
	POINT 6,TIMES(DDB),29	; FOR INPUT

; SPECIAL BITS IN RH OF IOS

HDEAD←←002000		; HOST DEAD
CTROV←←001000		; HOST OVERFLOWED OUR ALLOCATION
RSET←←000400		; HE SENT US A RESET
TMO←←000200		; TIMEOUT ON WAIT STATE OCCURRED
BLOK←←000100		; THIS LINK IS BLOCKED

; LH BITS

DEFINE Z(SYM,VAL) <SYM←←VAL 
 ANYW←←ANYW!VAL>

ANYW←←0
Z(INPW,200000)		; INPUT WAIT
Z(LNK0W,100000)		; CONTROL LINK WAIT
Z(BLOKW,040000)		; WAITING FOR LINK TO BECOME UNBLOCKED
Z(ALLW,020000)		; ALLOCATION WAIT
Z(TIMEW,010000)		; TIMEOUT WAIT
Z(RFCW,004000)		; WAIT FOR REQUEST FOR CONNECTION - LISTENING OR CONNECTION REQUESTED
Z(CLSW,002000)		; CLOSE WAIT. ONE CLOSE HAS BEEN SENT

; BITS IN LH OF STATE WORD IN IMPSTB

ANYC←←400000		; ANY CHANGE OF STATE
RFCS←←200000		; RFC HAS BEEN SENT
RFCR←←100000		; RFC HAS BEEN RECEIVED
CLSS←←040000		; CLS SENT
CLSR←←020000		; CLS RECEIVED
LONCE←←010000		; HCLSS HAS BEEN HERE ONCE

; OTHER PARAMETERS . . .

MAXCNT←←2*=60*=60	; THIS IS HOW LONG WE WILL WAIT FOR THE IMP TO GOBBLE
			; OUR OUTPUT
MAXMAL←←2000/TLNG	; MAXIMUM MESSAGE ALLOCATION FOR FOREIGNERS
MAXBAL←←40*2000		; MAXINAL BIT ALLOCATION
MINMAL←←2		; MINIMUM MESSAGE ALLOCATION
MINBAL←←=36*4		; MINIMUM BIT ALLOCATION
DEFMAL←←TDLEN		; DEFAULT MESSAGE ALLOCATION
DEFBAL←←44*TDLEN	; DEFAULT BIT ALLOCATION

; TABLE OF BITS PER WORD FOR DIFFERENT CONNECTION BYTE SIZES
; -1 MEANS THIS BYTE SIZE NOT ALLOWED.

BPW:
	44 
 44 
 44 
 44 
 44 
 -1 
 44 
 44
	40 
 44 
 -1 
 -1 
 44 
 -1 
 -1 
 -1
	40 
 -1 
 44 
 -1 
 -1 
 -1 
 -1 
 -1
	-1 
 -1 
 -1 
 -1 
 -1 
 -1 
 -1 
 -1
	40 
 -1 
 -1 
 -1 
 44

; ROUTINES TO MAKE AND RELEASE IMP DEVICE DATA BLOCKS

↑IMPSET:
	MOVEI AC3,IMPDLN
	PUSHJ P,FSGET
	JRST IMPDD1
	HRRI DDB,1(AC1)
	HRLI AC1,DDBMDL-1
	BLT AC1,TIM(DDB)
	HRLM DDB,DDBMDL+DEVSER
	SETZM DDBMDL+DEVLOG
	POPJ P,

IMPDD1:
	SUB P,[XWD 3,3]
	JRST DLYCM1

↑IMPCLR:
	SETZB IOS,DEVIOS(DDB)
	MOVEI AC1,DDBMDL
IMPCL1:
	MOVE TAC1,AC1
	HLRZ AC1,DEVSER(TAC1)
	JUMPE AC1,CPOPJ
	CAIE AC1,(DDB)
	JRST IMPCL1
	MOVE DDB,DEVSER(AC1)
	HLLM DDB,DEVSER(TAC1)
	SOJA AC1,FSGIVE

; CLOCK LEVEL ROUTINE. CALLED EVERY TICK. EXAMINES INPUT MESSAGES

↑IMPCLK:
	MOVEM P,IMPFP
	SKIPE IMPCLW		; WAITING FOR FREE STORAGE?
	JRST CLKWT		; YES, DO NOTHING ELSE FOR A WHILE
	SKIPE ILIST		; ANY INCOMMING MESSAGES?
	JRST IMPMES		; YES, GO PROCESS THEM
	SOSG IMPOCT		; HOW LONG HAVE WE BEEN WAITING FOR OUTPUT TO FINISH?
	PUSHJ P,IMPTMO		; TOO DAMN LONG. GO SEE ABOUT IT
	SKIPE RECOVER		; HAS ERROR RECOVERY SYSTEM BEEN INVOKED?
	PUSHJ P,ERRREC		; YES, GO KEEP ON RECOVERING.
	SOSGE POLCNT		; TIME TO POLL YET?
	PUSHJ P,POLL		; YES, DO IT NOW
	SKIPE TIMWAIT		; ANYONE WAITING FOR A TIMEOUT?
	SOSLE TIMCNT		; YES, IS IT TIME TO CHECK?
	POPJ P,
	MOVEI AC1,2*JIFSEC	; YES, WAIT FOR ANOTHER SECOND
	MOVEM AC1,TIMCNT	; RESET COUNTDOWN
	SKIPN AC3,FFLNK		; ANYONE TO CHECK?
	POPJ P,			; NO, DON'T BOTHER
TIMCHL:
	SKIPE DDB,IMPDDB-1(AC3)	; ANYONE HOME?
	SKIPGE AC1,TIM(DDB)	; YES, IS HE WAITING FOR US?
	JRST TIMCHI		; NO TO EITHER OR BOTH
	SUB AC1,TIME		; GET DIFFERENCE BETWEEN CRITICAL TIME AND RIGHT NOW
	JUMPL AC1,TIMN		; DIFFERENT ROUTINE FOR NEGATIVE DIFFERENCE
	CAML AC1,[=12*=60*JIFMIN]
	SUB AC1,JIFDAY		; WRAP IT BACK AROUND TO GET A SMALL NUMBER
	JRST TIMC		; NOW CHECK IT

TIMN:
	CAMGE AC1,[-=12*=60*JIFMIN]
	ADD AC1,JIFDAY
TIMC:
	JUMPG AC1,TIMCHI	; IF DIFFERENCE IS POSITIVE, HASN'T EXPIRED YET
	MOVEI IOS,TMO		; NOTE THAT A TIMEOUT HAS HAPPENED
	ORM IOS,DEVIOS(DDB)
	PUSHJ P,QRUN
	SKIPLE TIMWAIT		; ANYONE ELSE?
TIMCHI:
	SOJG AC3,TIMCHL		; YES, GO BACK FOR MORE
	POPJ P,

; WE GET HERE IF THERE ARE MESSAGES WAITING ON THE INPUT LIST

IMPMES:
	HRRZ AC1,ILIST		; YES, PICK UP ADDRESS OF FIRST MESSAGE
	PUSHJ P,LEGAL		; IS THIS A REASONABLE BLOCK
	JRST [	SETZM ILIST	; NO, FLUSH THE LIST
		JRST IMPCLK]
	LDB AC2,IMPBP		; SEE IF IT IS FROM THE IMP
	JUMPN AC2,FRIMP		; YES, DISCARD.
	LDB AC2,TRACEP		; IS IT A TRACE MESSAGE
	JUMPN AC2,TRCMES	; YES, DISCARD IT.
	LDB AC2,TYPEP		; PICK UP MESSAGE TYPE
	CAIGE AC2,MAXMT		; IS IT LEGAL?
	JRST @MTDSP(AC2)	; YES, DISPATCH TO IT
	TELCTR(ILLMT,<ILLEGAL MESSAGE TYPE>)
PSCAN:
	PUSHJ P,POPMESS		; TAKE MESSAGE OFF LIST AND RELEASE STORAGE
	JRST IMPCLK

; DISPATCH TABLE FOR MESSAGE TYPES

MTDSP:
	REGULAR		; REGULAR MESSAGE. ALL DATA AND CONTROL COME THROUGH HERE.
	EWOMI		; ERROR WITHOUT MESSAGE IDENTIFICATION
	IMPGD		; IMP GOING DOWN
	BLKLNK		; BLOCKED LINK - WE GOOFED!
	NOPCN		; NO OPERATION.
	RFNM		; REQUEST FOR NEW MESSAGE, UNBLOCK LINK
	LTABF		; LINK TABLE FULL - HORRIBLE IMP ERROR!
	DDEAD		; HOST OR DESTINATION IMP DEAD
	EWMI		; ERROR WITH MESSAGE IDENTIFICATION
	INCT		; INCOMPLETE TRANSMISSION
MAXMT←←.-MTDSP

; MESSAGE TYPE DISPATCHES - TRACE, FROM IMP, IMP GOING DOWN
; TRACE MESSAGE. LOG THEN DISCARD.

TRCMES:
	AOSA TRACES
FRIMP:
	AOS FRMIMP
	JRST PSCAN

EWOMI:
	TELCTR(ERWOMI,<ERROR WITHOUT MESSAGE IDENTIFICATION>)
	SKIPN RECOVER
	SETOM RECOVER
	JRST PSCAN

IMPGD:
	AOS NIMPDN
	PUSHJ P,IMPDD		; BRING DOWN IMP SYSTEM
	JRST IMPCLK		; GO THROUGH THE LOOP AGAIN

IMPDD:
	SETOM IMPDEAD		; SHUT DOWN THE IMP
	HRLOI AC1,377777
	MOVEM AC1,IMPOCT
	CONO IMP,ODPIEN!IDPIEN!IEPIEN
	SETZM IMPECT		; SET ERROR COUNT TO ZERO
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ / THE IMP IS DEAD!
LONG LIVE THE IMP!
/]
	-1
	SKIPE AC1,ILIST		; NOW WE HAVE TO GIVE BACK ALL THE BUSINESS IN PROGRESS
	PUSHJ P,RELBLS
	SETZM ILIST
	SKIPE AC1,OLIST		; OUTPUT LIST TOO
	PUSHJ P,RELBLS
	SETZM OLIST
	SKIPE AC1,L0CWTL
	PUSHJ P,RELBLS
	SETZM L0CWTL

; IMP DEAD CODE - RUN DOWN LINK TABLE AND WAKE UP ANY WAITERS

	SKIPN AC3,FFLNK		; NOW SEE IF THERE ARE ANY QUEUED RFC'S TO BE RELEASED
	JRST IMPDD4
IMPLLP:
	SKIPE AC1,IMPRFQ-1(AC3)	; IS THERE ANOTHER RFC LIST
	PUSHJ P,RELBLS
	SETZM IMPRFQ-1(AC3)
	SKIPN DDB,IMPDDB-1(AC3)
	JRST IMPDDI
	MOVE IOS,DEVIOS(DDB)
	ORI IOS,HDEAD!IODTER
	ANDCMI IOS,BLOK
	TLZE IOS,ANYW		; BRING THIS GUY OUT OF WAIT STATE
	PUSHJ P,QRUN
	MOVEM IOS,DEVIOS(DDB)
IMPDDI:
	SOJG AC3,IMPLLP
IMPDD4:
	SKIPE AC1,IMPITOP	; GIVE BACK ANY PARTIALLY IMPUTTED MESSAGE
	PUSHJ P,RELLST
	SETZM IMPITOP
	SKIPE AC1,IMPSPARE	; GIVE BACK ANY SPARE BLOCKS WHAT MAY BE
	PUSHJ P,IMPREL
	SETZM IMPSPARE
	SKIPN AC1,IMPFSL
	JRST IMPDD6		; IF NO SPARE LIST, FORGET IT
IMPFDL:
	PUSH P,(AC1)		; SAVE ADDRESS OF NEXT BLOCK
	PUSHJ P,FSGIVE
	POP P,AC1
	JUMPN AC1,IMPFDL
	SETZM IMPFSL
IMPDD6:
	POPJ P,

; INTERFACE TIMED OUT (SHUDDER!). BRING THE SYSTEM DOWN.

IMPTMO:
	ERRCTR(OPTMO,<INTERFACE TIMED OUT>)
	MOVE AC1,OPTMO
	CAIL AC1,10
	JRST IMPDD		; IF TOO MANY TIMEOUTS, BRING DOWN THE IMP
	SKIPLE NOPCNT
	JRST IMPTM3
	SKIPE AC1,IMPOCUR	; PICK UP CURRENT OUTPUT BLOCK
	PUSHJ P,RELLST		; GIVE BACK THE REST OF IT
	SETOM RECOVER
	SKIPN AC1,OLIST
	JRST IMPTM2
	HLRZ AC2,TLINK(AC1)	; GET LINK TO NEXT OUTPUT REQUEST
	HRRM AC2,OLIST		; MAKE IT NEW CURRENT REQUEST
	SKIPN AC2
	SETZM OLIST
	HRRZS AC1
	CONO IMP,FINO		; MAKE SURE INTERFACE THINKS WE ARE DONE
	MOVEI AC3,200
IMPTM1:
	CONSO IMP,ODONE
	SOJG AC3,IMPTM1
	JRST QIDLE		; TRY TO START THE NEXT TRANSFER

IMPTM2:
	SETZM IMPOACT
	HRLOI AC1,377777
	MOVEM AC1,IMPOCT
	POPJ P,

IMPTM3:
	SETOM RECOVER
	CONO PI,IMPOFF
	CONO IMP,FINO		;TRY TO UNHANG OUTPUT IF POSSIBLE
	MOVEI AC3,200
	CONSO IMP,ODONE
	SOJG AC3,.-1
	JRST SNDNOP		;WILL DO CONO PI,IMPON

; BLOCKED LINK, LINK TABLE FULL, RFNM, AND NOP

BLKLNK:
	SKIPE RECOVER
	JRST PSCAN
	SETOM RECOVER
	TELCTR(NBLNKS,<BLOCKED LINK>)
	JRST STERB

LTABF:
	TELCTR(LTFULL,<LINK TABLE FULL!!?!?!>)
	JRST STERB

; REQUEST FOR NEW MESSAGE. UNBLOCK LINK AND WAKE UP ANY WAITERS.

RFNM:
	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER
	TRNN AC2,177400		; HOST ZERO?
	JRST HOST0		; YES, NO SUCH HOST
	TRNN AC2,377		; LINK 0?
	JRST L0RFNM		; YES, UNBLOCK IT SEPARATELY
	PUSHJ P,FNDLNK		; NO, SEARCH LINK TABLE FOR IT
	JRST UNL		; NOT THERE, SEND BACK UNKNOWN LINK ERROR
	SKIPE DDB,IMPDDB-1(AC3)	; LINK THERE, DOES IT HAVE A DDB?
	PUSHJ P,UNBLOK		; YES, UNBLOK IT AND RESUME ANY RELEVANT PROCESS
	JRST PSCAN		; IF NO DDB, PROCESS MIGHT HAVE BEEN RESET, SO DON'T WORRY ABOUT IT

L0RFNM:
	PUSHJ P,UNBL0		; UNBLOCK LINK 0 AND SEND ANY WAITING CONTROL MESSAGES
	JRST PSCAN

HOST0:
	AOS NHOST0
	JRST PSCAN

; NO-OPERATION. LOG AND LEAVE.

NOPCN:
	AOS FLNOPS		; NUMBER OF FIRST-LEVEL NO-OPS
	JRST PSCAN

; HOST OR DESTINATION IMP DEAD. MARK HOST DEAD AND GIVE EVERYBODY ERRORS.
; WAKE ANYBODY UP WAITING FOR US. FLUSH WAITING CLOCK LEVEL CONTROL MESSAGES.

DDEAD:
	PUSHJ P,FLCWL0		; FLUSH WAITING CONTROL MESSAGES
	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER
	ANDCMI AC2,377		; CLEAR LINK NUMBER
	SKIPN AC3,FFLNK		; PICK UP NUMBER OF FIRST FREE ENTRY IN LINK TABLE
	JRST MRKD		; NONE THERE, MARK HOST DEAD AND LEAVE
DDL:
	MOVEI TAC,(AC2)		; SAVE COPY OF HOST NUMBER
	XOR TAC,LNKTAB-1(AC3)	; COMPARE IT WITH HOST NUMBER IN LINK TABLE
	TRNN TAC,177400		; DO HOST NUMBERS MATCH?
	JRST DDGOT		; YES, WAKE HIM UP IF NECESSARY
DDLINC:
	SOJG AC3,DDL		; LOOP AROUND FOR NEXT LINK TABLE ENTRY
MRKD:
	LDB TEM,LINKP		; PICK UP LINK NUMBER
	JUMPN TEM,PSCAN
	PUSHJ P,L0PTR		; PICK UP POINTER INTO HOST TABLES
	ANDCAM AC3,L0BLOK(AC2)	; CLEAR LINK
	JRST PSCAN

; COME HERE WITH DDB OF AN ACTIVE CONNECTION TO SEE IF IT SHOULD
; BE AWAKENED.

DDGOT:
	MOVE TEM,IMPSTB-1(AC3)	; PICK UP THIS HOLE'S STATUS BITS
	TLNE TEM,RFCR!RFCS	; ANY CONNECTION HERE?
	SKIPN DDB,IMPDDB-1(AC3)	; IS THERE A DDB?
	JRST DDLINC		; NO, LOOP AROUND
	MOVE IOS,DEVIOS(DDB)	; YES, PICK UP STATUS WORD
	TLNE IOS,LNK0W		; WAITING FOR LINK 0?
	SOS L0WAIT		; YES, DECREMENT COUNT OF PEOPLE WAITING FOR LINK 0
	ORI IOS,HDEAD!IODTER
	ANDCMI IOS,BLOK		; UNBLOCK LINK
	TLZE IOS,ANYW		; ANY WAIT STATE?
	PUSHJ P,QRUN		; YES, REQUE TO RUN STATE.
	MOVEM IOS,DEVIOS(DDB)	; RESTORE STATUS WORD
	JRST DDLINC		; GO LOOK AT NEXT ONE

; INCOMPLETE TRANSMISSION, ERROR WITH MESSAGE IDENTIFICATION

INCT:
	AOSA INCMTR
EWMI:
	AOS ERWMI
STERB:
	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER
	TRNN AC2,177400
	JRST HOST0		; NO HOST ZERO
	TRNN AC2,377		; LINK 0?
	JRST L0EWMI		; YES, CLEAR IT SEPARATELY
	PUSHJ P,FNDLNK		; NO, LOCATE POSITION IN LINK TABLE
	JRST PSCAN		; UNKNOWN LINK. DO NOT SEND ERROR MESSAGE!
	SKIPN DDB,IMPDDB-1(AC3)	; IS THERE A DDB THERE?
	JRST NODDB		; NO
	PUSHJ P,UNBLOK		; YES, PICK UP IOS AND UNBLOCK LINK
	ORI IOS,IODERR
	MOVEM IOS,DEVIOS(DDB)	; NOTE THAT AN ERROR HAS HAPPENED AND THAT WE MIGHT RECEIVE A RFNM LATER
	JRST PSCAN

L0EWMI:
	PUSHJ P,CLRBL0		; UNBLOCK LINK
	PUSHJ P,CWL0		; WAKE UP ANYBODY WAITING FOR LINK 0
	JFCL
	SKIPE L0WAIT		; IS THERE ANYBODY AT USER-LEVEL WAITING?
	SKIPN AC3,FFLNK		; YES, IS THERE A LINK TABLE TO SEARCH
	JRST PSCAN		; NO, FLUSH TRANSFER AND LEAVE
	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER
L0EWL:
	MOVEI TAC,(AC2)		; SAVE HOST-LINK NUMBER
	XOR TAC,LNKTAB-1(AC3)	; COMPARE IT WITH TABLE
	TRNN TAC,177400		; DO HOST NUMBERS MATCH?
	JRST L0MRKE		; YES
L0EWIN:
	SOJG AC3,L0EWL		; NO, LOOP AROUND
	JRST PSCAN

L0MRKE:
	MOVE TEM,IMPSTB-1(AC3)
	TLNE TEM,RFCR!RFCS
	SKIPN DDB,IMPDDB-1(AC3)	; PICK UP DEVICE DATA BLOCK ADDRESS
	JRST L0EWIN		; NONE THERE, LOOP AROUND
	MOVE IOS,DEVIOS(DDB)
	TLZN IOS,LNK0W		; WAITING FOR LINK 0?
	JRST L0EWIN		; NO, FORGET IT
	PUSHJ P,QRUN		; YES, PUT HIM IN RUN QUEUE
	ORI IOS,IODERR		; AND GIVE HIM ERROR MESSAGE
	MOVEM IOS,DEVIOS(DDB)
	SKIPE L0WAIT		; ARE THERE ANY MORE WAITERS?
	JRST L0EWIN		; YES, GO LOOK FOR THEM
	JRST PSCAN

; UNKNOWN LINK AND NO DDB ERROR TYPEOUTS

UNL:
	TELCTR(UNKLNK,<UNKNOWN LINK>)
	PUSHJ P,UNLMER
	JRST PSCAN

UNLMER:
	PUSH P,AC1		; SAVE INPUT MESSAGE ADDRESS
	PUSHJ P,MAKERB		; MAKE UP AN ERROR BLOCK
	PUSHJ P,CLKWAIT		; IF NONE, WAIT FOR IT (SIGH)
	PUSHJ P,EFILL		; SEND HIM BACK HIS COMMAND
	MOVEI AC3,LNC		; GIVE HIM LINK-NOT-CONNECTED ERROR
	DPB AC3,BYTE2P
	PUSHJ P,CLKOUT		; SEND IT OUT
	POP P,AC1		; GET BACK HIS MESSAGE
	POPJ P,

NODDB:
	TELCTR(NODDBS,<NO DDB>)
	JRST PSCAN

; ROUTINE TO MAKE UP A POINTER INTO THE HOST TABLES
; CALL WITH POINTER TO INCOMMING MESSAGE IN AC1
; RETURNS INDEX IN AC2 AND SINGLE BIT IN AC3

L0PTR:
	LDB AC2,[POINT 5,TDATA(AC1),15]
	MOVEI AC3,1
	LSH AC3,(AC2)
	LDB AC2,[POINT 3,TDATA(AC1),10]
	POPJ P,

; ROUTINE TO UNBLOCK LINK ZERO
; CALL WITH POINTER TO INCOMMING MESSAGE IN AC1

CLRBL0:
	PUSHJ P,L0PTR
	TDNN AC3,L0BLOK(AC2)	; FIRST, IS IT BLOCKED?
	JRST ILLUNB
	ANDCAM AC3,L0BLOK(AC2)	; YES, CLEAR IT
	POPJ P,

; ROUTINE TO UNBLOCK LINK ZERO AND WAKE UP ANYBODY WAITING FOR IT

UNBL0:
	PUSHJ P,CLRBL0		; CLEAR BLOCK ON LINK ZERO
	PUSHJ P,CWL0		; WAKE UP ANY CLOCK LEVEL WAITERS
	SKIPN L0WAIT		; ANY UUO LEVEL WAITERS?
	POPJ P,			; LEAVE IF A CLOCK LEVEL WAITER WAS AWOKEN OR IF NO UUO WAITERS
	SKIPN AC3,FFLNK		; SCAN LINK TABLE
	JRST NOLNKS		; NONE THERE, ERROR
	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER
L0FL:
	MOVE TAC,AC2
	XOR TAC,LNKTAB-1(AC3)
	TRNN TAC,177400		; HOST NUMBERS MATCH?
	JRST L0TRY		; YES, SEE IF HE IS WAITING FOR LINK 0
L0INCR:
	SOJG AC3,L0FL
	POPJ P,

L0TRY:
	SKIPN DDB,IMPDDB-1(AC3)
	JRST L0INCR
	MOVE IOS,DEVIOS(DDB)
	TLZN IOS,LNK0W
	JRST L0INCR
	SOS L0WAIT		; NOTE ONE LESS UUO-LEVEL WAITER
	PUSHJ P,QRUN
	MOVEM IOS,DEVIOS(DDB)
	SKIPE L0WAIT
	JRST L0INCR
	POPJ P,

NOLNKS:
	TELCTR(NRFNL,<RFNM WITH NO LINK>)
	POPJ P,

; ROUTINE TO TRANSMIT ANY MESSAGES IN CLOCK WAIT ON LINK 0
; CALL WITH INCOMMING MESSAGE CAUSING UNBLOCKING IN AC1
; SKIPS IF ANY WAITING MESSAGES WERE FOUND

CWL0:
	SETZ TAC1,		; NOTE NO PREVIOUS WAITER
	LDB AC3,SRCP		; PICK UP HOST NUMBER
	SKIPN AC2,L0CWTL	; PICK UP WAIT LIST
	POPJ P,			; NONE THERE
CWL0A:
	LDB TAC,[POINT 8,TDATA(AC2),15]
	CAMN TAC,AC3		; SAME HOST?
	JRST CWL0G		; YES, SERVE HIM
	MOVE TAC1,AC2		; PUT THIS BLOCK IN LAST BLOCK POSITION
	HLRZ AC2,TLINK(AC2)	; PICK UP NEXT BLOCK ADDRESS
	JUMPN AC2,CWL0A		; IF THERE IS ONE, LOOP AROUND AND SERVE IT
	POPJ P,

CWL0G:
	PUSHJ P,UNLCW		; UNLINK IT
	PUSH P,AC1
	MOVE AC1,AC2
	PUSHJ P,QOUT		; SEND IT OUT
	POP P,AC1
	PUSHJ P,L0PTR
	ORM AC3,L0BLOK(AC2)	; NOTE LINK 0 BLOCKED
	JRST CPOPJ1		; GIVE SKIP RETURN

; ROUTINE TO UNLINK A BLOCK FROM THE CLOCK WAIT LIST
; CALL WITH BLOCK ADDRESS IN AC2 AND ACCRESS OF PREVIOUS BLOCK IN TAC1

UNLCW:
	JUMPN TAC1,CWL0NN
	HLRZ AC3,TLINK(AC2)	; PICK UP ADDRESS OF NEXT BLOCK
	HRRM AC3,L0CWTL
	SKIPN AC3
	SETZM L0CWTL
	POPJ P,

CWL0NN:
	HLRZ AC3,TLINK(AC2)
	HRLM AC3,TLINK(TAC1)
	SKIPN AC3
	HRLM TAC1,L0CWTL
	POPJ P,

; ROUTINE TO FLUSH ALL CLOCK-LEVEL OUTPUTS TO A PARTICULAR HOST
; CALL WITH INCOMMING MESSAGE IN AC1

FLCWL0:
	SETZ TAC1,
	LDB AC3,SRCP
	SKIPN AC2,L0CWTL
	POPJ P,
FLCWA:
	LDB TAC,[POINT 8,TDATA(AC2),15]
	CAMN TAC,AC3
	JRST FLCG
	MOVE TAC1,AC2
	HLRZ AC2,TLINK(AC2)
	JUMPN AC2,FLCWA
	POPJ P,

FLCG:
	HLRZ DAT,TLINK(AC2)
	PUSH P,AC3		; SAVE STATE OF SCAN
	PUSH P,DAT
	PUSH P,AC1
	PUSH P,TAC1
	PUSHJ P,UNLCW		; UNLINK LIST FROM WAIT LIST
	MOVE AC1,AC2
	PUSHJ P,RELLST		; RELEASE STORAGE IN LIST
	POP P,TAC1
	POP P,AC1
	POP P,AC2
	POP P,AC3
	JUMPN AC2,FLCWA
	POPJ P,

; UNBLOCKING ROUTINE FOR NON-ZERO LINK
; DDB MUST BE SET UP

UNBLOK:
	MOVE IOS,DEVIOS(DDB)
	TRZN IOS,BLOK		; IS IT BLOCKED?
	JRST ILLUNB
	TLZE IOS,BLOKW		; IS HE WAITING FOR IT TO BECOME UNBLOCKED?
	PUSHJ P,QRUN		; YES, WAKE HIM UP
UNBLK1:
	MOVEM IOS,DEVIOS(DDB)
	POPJ P,

ILLUNB:
	PUSH P,DDB
	SKIPN RECOVER
	SETOM RECOVER
	TELCTR(BDRFNM,<UNBLOCKING AN ALREADY UNBLOCKED LINE>)
	POP P,DDB
	POPJ P,

; ROUTINE TO FIND THE INDEX OF A GIVEN HOST-LINK NUMBER
; FINDS SEND-SIDE INDEX ONLY
; ENTER WITH HOST-LINK NUMBER IN AC2
; RETURNS INDEX INTO LNKTAB AND IMPDDB IN AC3
; SKIPS ON SUCCESS

FNDLNK:
	SKIPN AC3,FFLNK		; PICK UP NUMBER OF FIRST FREE LINK
	POPJ P,
FNDL1:
	CAMN AC2,LNKTAB-1(AC3)	; IS THIS IT?
	JRST FNDL2		; YES, CHECK FOR SEND-SIDE
FNDL3:
	SOJG AC3,FNDL1
	POPJ P,

FNDL2:
	MOVE TEM,IMPLS-1(AC3)
	TRNN TEM,1
	JRST FNDL3
	JRST CPOPJ1
;: IMPCLK[J17,SYS] EOF.
;: IMPREG[J17,SYS]
COMMENT ⊗   VALID 00043 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00006 00002	SUBTTL IMP SERVICE - REGULAR MESSAGE HANDLING
C00007 00003	 REGULAR MESSAGE ON NON-ZERO LINK. HERE WE HAVE FOUND THE LINK TABLE ENTRY.
C00010 00004	 ALLOCATION UNDERFLOW ERROR
C00011 00005	 CONTROL MESSAGE
C00014 00006	 ERROR MESSAGES FOR LINK ZERO MESSAGES
C00016 00007	 NCP SECOND LEVEL PROTOCALL OPCODE DISPATCH TABLE
C00017 00008	 ALLOCATE. BUMP COUNTERS - RETURN, DECREMENT HIS COUNTERS
C00019 00009	 NOP - NO OPERATION AND COMDDS ERROR RETURNS
C00020 00010	 GVB COMMAND. THEY WANT US TO RETURN SOME STORAGE.
C00022 00011	 GVB COMMAND. HERE WE FORMAT A RET BLOCK
C00023 00012	 INTERRUPTS
C00024 00013	 REQUEST FOR CONNECTION
C00026 00014	 ROUTINE TO SET HOST NUMBER AND EITHER LINK OR BYTE SIZE
C00028 00015	 RFC PENDING. CLOCK REQUEST COMES BACK HERE
C00030 00016	 RFC CONTINUED. HERE THERE EXISTS A SOCKET.
C00033 00017	 RFC CONTINUED. HERE WE ARE GOING TO ESTABLISH A CONNECTION AND RETURN THE RFC
C00035 00018	 CLS COMMAND
C00038 00019	 CLS CONTINUED. HERE WE GOT A RECEIVE-SIDE CLS AND THERE IS A LINK TABLE ENTRY.
C00040 00020	 ECHO COMMAND
C00041 00021	 ERROR - INCOMMING!
C00042 00022	 RESET REPLY
C00043 00023	 RESET - PURGE OUR TABLES
C00046 00024	 RESET - SCAN DOWN THE QUEUED RFC LIST FOR ENTRIES BY THIS GUY
C00048 00025	 ERROR RECOVERY SYSTEM. POOT OUT MESSAGES TO EVERYONE WHO THINKS
C00050 00026	 ERROR RECOVERY FOR LINK ZERO
C00052 00027	 UTILITY ROUTINES FOR THE PRECEEDING ROUTINES - ERROR ROUTINE
C00054 00028	 ROUTINE TO DELETE A LINK IN THE LINK TABLE.
C00056 00029	 ROUTINE TO POLL ALL THE OTHER SITES FOR SIGNS OF LIFE
C00058 00030	 ROUTINE TO PERIODICALLY CHECK AND MAKE SURE ALL IS OK
C00060 00031	 ROUTINE TO SEND THE IMP SOME NOPS
C00062 00032
C00064 00033	 ROUTINE TO DUMP AN INCOMMING COMMAND INTO THE DATA PORTION OF AN ERROR MESSAGE
C00065 00034	 ROUTINE TO WAIT AT CLOCK LEVEL FOR A STANDARD FREE STORAGE BLOCK
C00066 00035	 ROUTINE TO RELEASE THE STORAGE IN A LIST
C00067 00036	 ROUTINE TO PLANT AN INTERRUPT REQUEST
C00068 00037	 ROUTINE TO UNLINK THE TOP MESSAGE ON THE INPUT LIST
C00070 00038	 ROUTINE TO SEND OUT A MESSAGE FROM CLOCK LEVEL ON LINK 0.
C00072 00039	 ROUTINE TO FIND A DDB FROM LINK NUMBER IN A SECOND LEVEL
C00074 00040	 ROUTINES TO PICK UP SOCKET NUMBERS AND STORE THEM FOR CLS, RTS, AND STR
C00075 00041	 ROUTINE TO RETURN A CLS TO THE HOST WHOSE MESSAGE IS IN AC1
C00076 00042	 ROUTINE TO MAKE UP A CLS BLOCK WITH EMPTY SOCKETS
C00077 00043	 SEND CLOSE TO FOREIGN HOST
C00078 ENDMK
C⊗;

SUBTTL IMP SERVICE - REGULAR MESSAGE HANDLING
; REGULAR MESSAGE

REGULAR:

	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER
	TRNN AC2,377		; CONTROL MESSAGE?
	JRST L0REG		; YES, GO PICK UP NCP PROTOCAL OP-CODE
	SKIPN AC3,FFLNK
	JRST RMUNL
	SETZ DAT,
REGFRL:
	CAMN AC2,LNKTAB-1(AC3)
	JRST REGCRS		; LINK NUMBER MATCHES, CHECK FOR RECEIVE-SIDE
REGINC:
	SOJG AC3,REGFRL
	JUMPE DAT,UNL
RMUNL:
	TELCTR(RWNOSS,<INPUT WITH NO RECEIVE SIDE>)
	JRST PSCAN

IWCNO:
	TELCTR(NIWCNO,<INPUT WITH CONNECTION NOT ENTIRELY OPEN>)
	JRST PSCAN

; REGULAR MESSAGE ON NON-ZERO LINK. HERE WE HAVE FOUND THE LINK TABLE ENTRY.

REGCRS:
	MOVE TEM,IMPLS-1(AC3)
	MOVEI DAT,(AC3)		; NOTE THAT WE FOUND A SOCKET OF SOME KIND
	TRNE TEM,1
	JRST REGINC		; SEND SIDE, SKIP THIS ONE.
	MOVE AC2,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLC AC2,RFCR!RFCS
	TLNE AC2,RFCR!RFCS	; IS THE SOCKET ALL THE WAY OPEN?
	JRST IWCNO		; NO, MUST BE COMPLETELY OPEN TO RECEIVE MESSAGES
	SKIPN DDB,IMPDDB-1(AC3)	; PICK UP DDB ADDRESS IF ANY
	JRST NODDB
	MOVE IOS,DEVIOS(DDB)	; PICK UP IO STATUS WORD
	TLZE IOS,INPW		; IS HE WAITING FOR INPUT?
	PUSHJ P,QRUN		; YES, WAKE HIM UP
	MOVEM IOS,DEVIOS(DDB)
	MOVSI AC2,INTINP	; GIVE HIM AN INPUT INTERRUPT
	PUSHJ P,INTCOM
	LDB AC2,SIZEP		; PICK UP BYTE SIZE OF TRANSFER
	LDB AC3,COUNTP		; AND LENGTH OF TRANSFER
	IMULI AC2,(AC3)		; GET TOTAL NUMBER OF BITS IN TRANSFER
	ADDM AC2,BIIL(DDB)	; NOTE THIS MANY MORE BITS IN THE INPUT LIST
	MOVNS AC2
	ADDM AC2,HBA(DDB)	; DECREMENT BIT ALLOCATION
	AOS MIIL(DDB)		; AND THIS MANY MORE MESSAGES IN THE INPUT LIST
	SOSL HMA(DDB)		; DECREMENT MESSAGE ALLOCATION
	SKIPGE HBA(DDB)		; DID BIT ALLOCATION UNDERFLOW?
	JRST CTROVF		; YES, ERROR
	PUSHJ P,UNLNS		; POP MESSAGE OFF INPUT LIST
	SKIPN AC2,INL(DDB)	; DOES HE HAVE AN INPUT LIST?
	JRST REG1		; NO, START ONE
	MOVSS AC2		; GET POINTER TO LAST BLOCK IN RH
	HRLM AC1,TLINK(AC2)	; LINK US ONTO HIS TAIL
REG2:
	HRLM AC1,INL(DDB)	; PUT US IN AS NEW LAST ELEMENT
	HRRZS TLINK(AC1)	; NOTE THAT NOONE FOLLOWS US
	JRST IMPCLK

REG1:
	HRRM AC1,INL(DDB)	; PUT US IN AS FIRST ELEMENT
	JRST REG2

; ALLOCATION UNDERFLOW ERROR

CTROVF:
	ORI IOS,CTROV!IODERR
	MOVEM IOS,DEVIOS(DDB)
	PUSH P,AC1		; SEND ERROR MESSAGE TO HOST
	PUSHJ P,MAKERB		; MAKE UP AN ERROR BLOCK
	PUSHJ P,CLKWAIT
	PUSHJ P,OFILL		; TAG ON HIS MESSAGE
	MOVEI AC3,CTO
	DPB AC3,BYTE3P
	PUSHJ P,CLKOUT		; SEND IT OUT
	POP P,AC1
	JRST PSCAN

; UNKNOWN LINK ERROR

SLUNL:
	TELCTR(SLUNLK,<UNKNOWN LINK IN REGULAR MESSAGE>)
	PUSHJ P,UNLMER
	JRST L0XIT

; CONTROL MESSAGE

L0REG:
	LDB AC3,SIZEP		; YES, CHECK BYTE SIZE
	CAIE AC3,10		; BETTER BE 8
	JRST ILLBS		; ILLEGAL, GIVE ERROR
	MOVEI AC3,(AC1)		; SEPARATE OUT INPUT BLOCK ADDRESS
	HRLI AC3,441000		; MAKE UP AN 8-BIT BYTE POINTER FOR IT
	ADDI AC3,TDATA+2	; MAKE IT POINT AT THE FIRST OPCODE
	MOVEM AC3,TBP(AC1)	; SAVE IT IN INPUT BLOCK
L0MORE:
	ILDB DSER,TBP(AC1)	; PICK UP OPCODE
	CAIL DSER,OPMAX		; IS IT A LEGAL OPCODE?
	JRST RILLO		; NO, GIVE ERROR
	LDB AC3,COUNTP		; PICK UP LENGTH OF MESSAGE
	LDB TAC,[POINT 9,OPTAB(DSER),8]
	CAIL AC3,(TAC)		; IS COMMAND AS LONG AS IT SHOULD BE?
	JRST L0CDSP		; YES, DISPATCH
	TELCTR(BCMM,<SHORT CONTROL COMMAND>)
	PUSH P,AC1		; SAVE INPUT MESSAGE
	PUSHJ P,MAKERB		; MAKE UP AN ERROR BLOCK
	PUSHJ P,CLKWAIT
	PUSHJ P,EFILL		; TAG ON HIS LEADER
	MOVEI AC3,SPS		; GIVE HIM SHORT PARAMETER ERROR
RERR1:
	DPB AC3,BYTE2P
RERR2:
	PUSHJ P,CLKOUT
	POP P,AC1
	JRST PSCAN

L0CDSP:
	SUBI AC3,(TAC)		; SHORTEN TOTAL MESSAGE BY THIS MUCH
	DPB AC3,COUNTP		; AND THIS IS THE NEW MESSAGE LENGTH
	JRST @OPTAB(DSER)

L0XIT:
	HRRZ AC1,ILIST		; PICK UP POINTER TO MESSAGE
	LDB AC2,COUNTP		; SEE IF THERE IS ANYTHING LEFT IN THIS MESSAGE
	JUMPE AC2,PSCAN
	JRST L0MORE

; ERROR MESSAGES FOR LINK ZERO MESSAGES

RILLO:
	SKIPE RECOVER
	JRST PSCAN		; IF ERROR RECOVERY IN PROGRESS, TOLERATE A BIT OF FOOLISHNESS
	SETOM RECOVER		; OTHERWISE INITIATE RECOVERY SEQUENCE
	TELCTR(NILLOP,<ILLEGAL OPCODE>)
	PUSH P,AC1
	PUSHJ P,MAKERB
	PUSHJ P,CLKWAIT
	PUSHJ P,EFILL
	MOVEI AC3,ILO
	JRST RERR1

ILLBS:
	SKIPE RECOVER
	JRST PSCAN		; IF ERROR RECOVERY IN PROGRESS, TOLERATE A BIT OF FOOLISHNESS
	SETOM RECOVER		; OTHERWISE INITIATE RECOVERY SEQUENCE
	TELCTR(BSILL,<ILLEGAL BYTE SIZE ON CONTROL COMMAND>)
	PUSH P,AC1
	PUSHJ P,MAKERB
	PUSHJ P,CLKWAIT
	PUSHJ P,OFILL
	MOVEI AC3,ILB
	DPB AC3,BYTE3P
	JRST RERR2

; NCP SECOND LEVEL PROTOCALL OPCODE DISPATCH TABLE

DEFINE Z (LENGTH,DSP) <XWD LENGTH*1000,DSP>

OPTAB:
	Z(1,SNOPCN)	; NO OPERATION
	Z(12,IRTS)	; REQUEST FOR CONNECTION, RECEIVER TO SENDER
	Z(12,ISTR)	; REQUEST FOR CONNECTION, SENDER TO RECEIVER
	Z(11,ICLS)	; CLOSE
	Z(10,IALL)	; ALLOCATE
	Z(4,IGVB)	; GIVE BACK STORAGE
	Z(10,IRET)	; STORAGE RETURNED
	Z(2,IINR)	; INTERRUPT BY RECEIVER
	Z(2,IINS)	; INTERRUPT BY SENDER
	Z(2,IECO)	; ECHO REQUEST
	Z(2,IERP)	; ECHO REPLY
	Z(14,IERR)	; ERROR
	Z(1,IRST)	; RESET
	Z(1,IRRP)	; RESET REPLY

OPMAX←←.-OPTAB

; ALLOCATE. BUMP COUNTERS - RETURN, DECREMENT HIS COUNTERS

IALL:
	PUSHJ P,COMDDS		; PICK UP DDB OF CONNECTION
	JRST SLUNL		; NON-EX CONNECTION
	JRST RD6NSE		; NO SEND SOCKET
	JRST RD6CC		; CONNECTION CLOSED OR NO DDB
	PUSHJ P,RD2B		; GET 16 CONSECUTIVE BITS INTO AC2
	ADDM AC2,MAL(DDB)	; BUMP HIS MESSAGE ALLOCATION
	PUSHJ P,RD4B		; GET 32 BIT DATUM
	ADDM AC2,BAL(DDB)	; BUMP BIT COUNTER
	MOVE IOS,DEVIOS(DDB)
	TLZE IOS,ALLW		; WAITING FOR ALLOCATION
	PUSHJ P,QRUN		; YES, WAKE HIM UP
	MOVEM IOS,DEVIOS(DDB)
	JRST L0XIT

; RTN COMMAND.

IRET:
	PUSHJ P,COMDDR		; PICK UP DDB OF A RECEIVE-SIDE CONNECTION
	JRST SLUNL		; NON-EX CONNECTION
	JRST RD6NSE		; NO RECEIVE SIDE CONNECTION
	JRST RD6CC		; CONNECTION CLOSED
	PUSHJ P,RD2B		; PICK UP MESSAGE ALLOCATION
	MOVNS AC2
	ADDM AC2,HMA(DDB)	; HE NOW HAS THAT MUCH LESS ALLOCATION
	PUSHJ P,RD4B		; GET BIT ALLOCATION
	MOVNS AC2
	ADDM AC2,HBA(DDB)
	JRST L0XIT		; END OF OPERATION

; NOP - NO OPERATION AND COMDDS ERROR RETURNS

SNOPCN:
	AOS SLNOPS		; BUMP COUNT OF SECOND LEVEL NO-OPERATIONS
	JRST L0XIT

; ERROR RETURNS FOR COMDDS CALLERS

RD6NSE:
	PUSHJ P,RD4B		; PUSH BYTE POINTER ALONG
RD2NSE:
	PUSHJ P,RD2B
RCCANS:
	TELCTR(NSSC,<NO SEND-SIDE CONNECTION>)
	JRST L0XIT

RD6CC:
	PUSHJ P,RD4B
RD2CC:
	PUSHJ P,RD2B
	AOS NALWNC
	JRST L0XIT

; GVB COMMAND. THEY WANT US TO RETURN SOME STORAGE.

IGVB:
	PUSHJ P,COMDDS
	JRST RD2NSE
	JRST RD2CC
	JRST SLUNL
	ILDB AC2,TBP(AC1)	; PICK UP FIRST FRACTION BYTE
	CAILE AC2,200		; FRACTION GREATER THAN ONE?
	MOVEI AC2,200		; YES, GIVE IT ALL BACK
	IMUL AC2,MAL(DDB)	; SEE HOW MUCH HE WANTS
	TRNE AC2,177		; ROUND UP ALWAYS
	ADDI AC2,200
	LSH AC2,-7		; AND THIS IS NUMBER OF BITS HE WANTS
	PUSH P,AC2
	MOVNS AC2
	ADDM AC2,MAL(DDB)

	ILDB AC2,TBP(AC1)	; GET NEXT BYTE
	CAILE AC2,200		; FRACTION GREATER THAN ONE?
	MOVEI AC2,200		; YES, GIVE IT ALL BACK
	IMUL AC2,BAL(DDB)	; SEE HOW MUCH HE WANTS
	TRNE AC2,177		; ROUND UP ALWAYS
	ADDI AC2,200
	LSH AC2,-7		; AND THIS IS NUMBER OF BITS HE WANTS
	PUSH P,AC2
	MOVNS AC2
	ADDM AC2,BAL(DDB)

; GVB COMMAND. HERE WE FORMAT A RET BLOCK

	PUSH P,AC1
	PUSHJ P,IMPGET		; GET SOME STORAGE FOR A RET COMMAND
	PUSHJ P,CLKWAIT
	POP P,AC2
	MOVE AC2,TDATA(AC2)
	MOVEM AC2,TDATA(AC1)
	SETZM TDATA+1(AC1)
	SETZM TDATA+2(AC1)
	MOVEI AC3,10
	DPB AC3,SIZEP		; BOTH SIZE AND COUNT ARE 8 BYTES
	DPB AC3,COUNTP
	MOVEI AC3,RET
	DPB AC3,OPCDP
	LDB AC3,[POINT 8,TDATA+2(AC2),15]
	DPB AC3,OLINKP		; PUT IN LINK
	POP P,AC3
	LSH AC3,4
	MOVEM AC3,TDATA+3(AC1)
	POP P,AC3		; PUT ALLOCATIONS BEING RETURNED IN FIRST 32 BITS
	DPB AC3,[POINT 16,TDATA+2(AC2),31]
	MOVEI AC3,4
	MOVEM AC3,TWC(AC1)
	PUSHJ P,CLKOUT
	JRST L0XIT

; INTERRUPTS

IINR:
	PUSHJ P,COMDDS
	JRST SLUNL
	JRST RCCANS
	JRST L0XIT
	MOVSI AC2,INTINR	; INTERRUPT BY RECEIVER
	ORM AC2,IMPSTB-1(AC3)	; PUT IN STATUS BITS TOO
	PUSHJ P,INTCOM
	JRST L0XIT

IINS:
	PUSHJ P,COMDDR
	JRST SLUNL
	JRST RCCANS
	JRST L0XIT
;	JRST SLUNL		; ?? comddr only has 4 returns, not 5
	MOVSI AC2,INTINS	; INTERRUPT BY SENDER
	ORM AC2,IMPSTB-1(AC3)
	PUSHJ P,INTCOM
	JRST L0XIT

; REQUEST FOR CONNECTION

XTTIME←←TDATA
SOCK1←←TDATA+1		; BLOCK LOCATIONS FOR PENDING MESSAGES
SOCK2←←TDATA+2

IRTS:

ISTR:
	PUSHJ P,RD4B		; GET FIRST SOCKET NUMBER (FOREIGN SOCKET)
	MOVE UUO,AC2		; SAVE FOREIGN SOCKET IN UUO
	PUSHJ P,RD4B
	MOVE JDAT,AC2		; SAVE LOCAL SOCKET NUMBER IN JDAT
	SKIPN AC3,FFLNK		; SCAN LINK TABLE FOR IT
	JRST MAKPND
ISTRL:
	CAMN AC2,IMPLS-1(AC3)
	JRST ISTRFS
	SOJG AC3,ISTRL
MAKPND:
	AOS AC3,FFLNK		; MAKE UP NEW INDEX NUMBER
	CAILE AC3,MAXNLK	; OVERFLOWED TABLES?
	JRST NOLNK		; YES, CANNOT ACCEPT RFC
	SETZM IMPDDB-1(AC3)
	MOVEM AC2,IMPLS-1(AC3)
	MOVEM UUO,IMPFS-1(AC3)
	SETZM IMPRFQ-1(AC3)	; CLEAR OUT OLD GARBAGE
	PUSHJ P,SETHLB		; SET HOST NUMBER AND EITHER BYTE SIZE OR LINK NUMBER
MAKPN:
	PUSHJ P,IMPGET		; GET A BLOCK FOR PENDING MESSAGE
	PUSHJ P,CLKWAIT
	MOVEM JDAT,SOCK2(AC1)	; SAVE SOCKET NUMBER
	MOVEM UUO,SOCK1(AC1)
	HRLI AC1,PNDG		; MAKE IT PEND IN A CLOCK QUEUE REQUEST
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	MOVEI AC2,4*=60*JIFSEC
	MOVEM AC2,XTTIME(AC1)	; WE WILL PEND FOR 4 MINUTES
	MOVSI AC2,RFCR!ANYC
	MOVEM AC2,IMPSTB-1(AC3)	; NOTE THAT A STR HAS BEEN RECEIVED
	JRST L0XIT

; ROUTINE TO SET HOST NUMBER AND EITHER LINK OR BYTE SIZE

SETHLB:
	LDB AC2,SRCP		; SET HOST NUMBER IF NOT ALREADY SET
	DPB AC2,[POINT 8,LNKTAB-1(AC3),27]
	ILDB AC2,TBP(AC1)	; PICK UP SIZE FIELD
SETHB:
	CAIN DSER,STR		; IF SENDER TO RECEIVER,
	MOVEM AC2,IMPBS-1(AC3)	; THEN LET HIM SET THE BYTE SIZE
	CAIN DSER,RTS		; OTHERWISE, LET HIM SET LINK NUMBER
	DPB AC2,[POINT 8,LNKTAB-1(AC3),35]
	POPJ P,

; GET HERE IF THERE IS NO MORE ROOM IN THE LINK TABLE

NOLNK:
	IBP TBP(AC1)		; SKIP OVER SIZE-LINK FIELD
	PUSHJ P,RTNCLS		; SEND HIM BACK A CLOSE
	SOS FFLNK		; UNDO THE DAMAGE
	TELCTR(NNOLNK,<RFC RECEIVED BUT NOT LINK AVAILABLE>)
	JRST L0XIT		; INCOMMING MESSAGE HAS BEEN USED FOR THE CLOSE

; RFC PENDING. CLOCK REQUEST COMES BACK HERE

PNDG:
	MOVEI AC1,(DAT)
	SKIPN AC3,FFLNK		; FIND INDEX OF PARTIAL CONNECTION
	JRST RELLST		; IF NONE, FORGET IT
	MOVE AC2,SOCK2(AC1)	; PICK UP LOCAL SOCKET NUMBER
	MOVE UUO,SOCK1(AC1)
PNDGL:
	CAMN AC2,IMPLS-1(AC3)
	CAME UUO,IMPFS-1(AC3)
	JRST PNDGI
	MOVE TEM,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLNE TEM,RFCS!CLSR!CLSS
	JRST RELLST		; IF ANYTHING HAS HAPPENED ON THE LINE, LEAVE
PNDGN:
	SOSLE XTTIME(AC1)	; OTHERWISE, COUNT DOWN
	JRST DPYTIM
	PUSH P,AC1
	PUSHJ P,IMPGET		; SEND HIM A CLS
	JRST [	POP P,AC1
		JRST DPYTIM]
	PUSHJ P,SNCLS		; SEND A CLOSE
	POP P,AC1
	JRST RELLST

PNDGI:
	SOJG AC3,PNDGL
	JRST RELLST

; RFC CONTINUED. HERE THERE EXISTS A SOCKET.

ISTRFS:
	MOVE DAT,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLNE DAT,RFCS		; HAS AN RFC BEEN SENT TO IT?
	JRST CLRFCW		; YES, CONNECTION HAS BEEN MADE
	SKIPN LNKTAB-1(AC3)	; IS HOST NUMBER INITIALIZED?
	JRST CHKFSK		; NO, OURS WILL WORK THEN
	LDB DAT,ELINKP		; PICK UP HOST NUMBER
	XOR DAT,LNKTAB-1(AC3)
	TRNN DAT,177400		; TWO RFC'S?
	JRST ISTRMP		; YES, CHECK FOR UNOPENED SIDE OF CONNECTION
ISTRF3:
	MOVEI TEM,(AC1)
	PUSHJ P,IMPGET
	PUSHJ P,CLKWAIT
	DPB DSER,OPCDP		; MAKE UP NEW INPUT MESSAGE BLOCK
	MOVE AC2,UUO		; WITH JUST THIS RFC IN IT
	PUSHJ P,PSOCK1
	MOVE AC2,JDAT
	PUSHJ P,PSOCK2
	ILDB AC2,TBP(TEM)	; PICK UP SIZE-LINK FIELD
	DPB AC2,SZLKP
	MOVE AC2,TDATA(TEM)	; GET LEADER
	MOVEM AC2,TDATA(AC1)
	SETZM TDATA+1(AC1)
	MOVEI AC2,10
	DPB AC2,SIZEP
	MOVEI AC2,12
	DPB AC2,COUNTP
	SKIPN AC2,IMPRFQ-1(AC3)	; SEE IF THERE IS A WAITING RFC LIST
	JRST ISTRF2		; NO, WE ARE ONLY ELEMENT
	MOVSS AC2		; POINT US TO TAIL OF LIST
	HRLM AC1,TLINK(AC2)
ISTRF1:
	HRLM AC1,IMPRFQ-1(AC3)
	HRRZS TLINK(AC1)
	JRST L0XIT

ISTRF2:
	HRRM AC1,IMPRFQ-1(AC3)
	JRST ISTRF1

CLRFCW:
	LDB AC2,ELINKP		; PICK UP HOST #
	XOR AC2,LNKTAB-1(AC3)
	TRNE AC2,177400		; SAME HOST NUMBER?
	JRST ISTRF3		; NO, QUEUE RFC
ISTRMP:
	TLNN DAT,RFCR		; HAS THIS SIDE OF THE CONNECTION BEEN ESTABLISHED?
	JRST CHKFSK		; NO, PUT US IN THERE
	CAME UUO,IMPFS-1(AC3)	; DOES THE FOREIGN SOCKET MATCH?
	JRST ISTRF3		; NO, QUEUE US UP
TWORFC:
	AOS N2RFCS
	IBP TBP(AC1)
	JRST L0XIT

; RFC CONTINUED. HERE WE ARE GOING TO ESTABLISH A CONNECTION AND RETURN THE RFC

CHKFSK:
	SKIPL IMPFS-1(AC3)	; HAS SOCKET BEEN INITIALIZED
	CAMN UUO,IMPFS-1(AC3)	; YES, DOES IT MATCH
	JRST CLRFC1		; YES, COMPLETE CONNECTION
	JRST ISTRF3		; NO, QUEUE US UP

CLRFC1:
	MOVEM UUO,IMPFS-1(AC3)
	PUSHJ P,SETHLB		; SET HOST NUMBER AND LINK (OR BYTE SIZE)
	MOVSI AC2,RFCR
	PUSHJ P,CSTAT		; CHANGE STATUS BITS
	SKIPN DDB,IMPDDB-1(AC3)
	JRST MAKPN
	MOVSI AC2,RFCS
	TDNE AC2,IMPSTB-1(AC3)	; HAVE WE ALREADY SENT HIM AN RFC?
	JRST CLRFC2		; YES, SKIP OVER THIS PART
	PUSHJ P,IMPGET		; GET US SOME F.S.
	PUSHJ P,CLKWAIT		; WAIT FOR IT IF NECESSARY
	PUSHJ P,CLRBLK
	CAIN DSER,RTS		; SEND HIM THE OPPOSITE FLAVOR RFC
	MOVEI TEM,STR
	CAIN DSER,STR
	MOVEI TEM,RTS
	DPB TEM,OPCDP
	PUSHJ P,MAKRF		; SET THE REST OF THE MESSAGE, SOCKETS, BYTE SIZE OR LINK, ETC.
	PUSHJ P,CLKOUT
CLRFC2:
	MOVE IOS,DEVIOS(DDB)
	TLZE IOS,RFCW
	PUSHJ P,QRUN
	MOVEM IOS,DEVIOS(DDB)
	JRST L0XIT

; CLS COMMAND

ICLS:
	PUSHJ P,RD4B		; PICK UP FOREIGN SOCKET
	MOVE UUO,AC2
	PUSHJ P,RD4B
	MOVE JDAT,AC2
	SKIPN AC3,FFLNK
	JRST RTCL		; NOBODY HOME.
ICLSL:
	CAMN JDAT,IMPLS-1(AC3)
	JRST RCLSRC		; RECEIVE SIDE SOCKET FOUND
	SOJG AC3,ICLSL
RTCL:
	AOS NSCLSS		; BUMP NUMBER OF STRANGE CLSS
	JRST L0XIT

RCLSRC:
	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER
	XOR AC2,LNKTAB-1(AC3)
	CAMN UUO,IMPFS-1(AC3)	; FOREIGN SOCKET MUST MATCH TOO
	TRNE AC2,177400
	JRST CLSRFQ		; MISMATCH SOMEWHERE, CHECK RFQ LIST
	JRST SRCLSR		; SAME HOST, 

; HERE, WE HAVE RECEIVED A CLS FROM A HOST THAT IS NOT ACTIVE.
; SEE IF HE IS IN THE RFC QUEUE FOR THIS SOCKET. IF NOT, IGNORE IT.
; SHOULD CHECK FOR MATCHING FOREIGN SOCKET

CLSRFQ:
	LDB DAT,SRCP		; PICK UP HOST NUMBER
	PUSHJ P,RTNCLS		; SEND RETURN CLOSE
	SETZ TAC1,		; CLEAR LAST ITEM POINTER
	SKIPN AC1,IMPRFQ-1(AC3)
	JRST QLEAVE
QL1:
	LDB DSER,SRCP		; PICK UP HOST NUMBER
	CAIE DAT,(DSER)		; SAME HOST?
	JRST QLOOP		; NO, GET ANOTHER ONE
	PUSHJ P,GSOCK1
	CAME AC2,UUO		; IS THIS THE SAME ONE?
	JRST QLOOP
	PUSHJ P,UNLRFQ		; YES, UNLINK QUEUED RFC FROM LIST
	PUSHJ P,RELLST		; FLUSH IT
QLEAVE:
	JRST L0XIT

QLOOP:
	MOVE TAC1,AC1
	HLRZ AC1,TLINK(AC1)
	JUMPN AC1,QL1
	JRST QLEAVE

; CLS CONTINUED. HERE WE GOT A RECEIVE-SIDE CLS AND THERE IS A LINK TABLE ENTRY.

SRCLSR:
	MOVSI AC2,CLSR		; HERE WE ARE THE HOST IN QUESTION
	PUSHJ P,CSTAT		; CHANGE THE CONNECTION STATUS
	SKIPN DDB,IMPDDB-1(AC3)	; ANYBODY HOME?
	JRST CHCLSS		; NO
	MOVE IOS,DEVIOS(DDB)	; YES, DOES HE THINK HE WILL GET SOME MORE INPUT?
	TLZE IOS,ANYW
	PUSHJ P,QRUN		; YES, BRING HIM OUT OF WAIT
	MOVEM IOS,DEVIOS(DDB)	; SO HE WILL GET EOF
CHCLSS:
	MOVE AC2,IMPSTB-1(AC3)
	TLNE AC2,CLSS		; RECEIVE-SIDE CLS SENT?
	JRST SRCLWK		; YES, SEE IF HE IS WAITING FOR US
	PUSHJ P,IMPGET		; GET SOME STORAGE
	PUSHJ P,CLKWAIT
	PUSHJ P,SNCLS		; RETURN A CLS TO HIM
SRCLWK:
	SKIPN DDB,IMPDDB-1(AC3)
CALLZL:
	PUSHJ P,ZEROLK		; NO, CLEAR THE LINK IF WE CAN
	JRST L0XIT

; ECHO COMMAND

IECO:
	PUSH P,AC1
	PUSHJ P,IMPGET
	PUSHJ P,CLKWAIT
	MOVE AC2,(P)		; PICK UP ADDRESS OF INCOMING MESSAGE
	MOVE AC3,TDATA(AC2)	; TURN MESSAGE RIGHT AROUND
	MOVEM AC3,TDATA(AC1)
	SETZM TDATA+1(AC1)
	MOVEI AC3,10
	DPB AC3,SIZEP		; PUT IN BYTE SIZE
	MOVEI AC3,2
	DPB AC3,COUNTP		; AND MESSAGE LENGTH
	ILDB AC3,TBP(AC2)	; PICK UP ECHO BYTE
	DPB AC3,BYTE2P		; AND GIVE IT BACK TO HIM
	MOVEI AC3,ERP		; PUT ECHO REPLY OPCODE IN WITH DATA BYTE INPUTTED
	DPB AC3,OPCDP
	PUSHJ P,CLKOUT
	POP P,AC1
	JRST L0XIT

; ECHO REPLY

IERP:
	JRST RILLO		; WE DON'T SEND ECOS

; ERROR - INCOMMING!

IERR:
	AOS RERRM
	PUSH P,AC1
	PUSHJ P,DISDATE
	PUSH P,TDATA(AC1)
	PUSHJ P,DISERR
	[ASCIZ /IMP - WE GOT AN ERROR MESSAGE, #/]
	DISARG DEC,RERRM
	[ASCIZ /
/]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	SUB P,[XWD 1,1]
	POP P,AC1
	MOVEI TAC1,13
	PUSH P,TAC1
	PUSH P,AC1
IEPLOP:
	ILDB TAC,TBP(AC1)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / /
	MOVE AC1,(P)
	SOSLE -1(P)
	JRST IEPLOP
	PUSHJ P,DISMES
	ASCIZ /
/
	POP P,AC1
	SUB P,[XWD 1,1]
	JRST L0XIT

; RESET REPLY

IRRP:
	JRST L0XIT

; RESET - PURGE OUR TABLES

IRST:
	AOS NRSETS
	PUSHJ P,FLCWL0		; FLUSH ALL PENDING MESSAGES TO THIS HOST
	PUSH P,AC1
	PUSHJ P,IMPGET		; GET FREE STORAGE FOR A RESET REPLY
	PUSHJ P,CLKWAIT
	PUSHJ P,CLRBLK
	MOVE AC2,(P)
	MOVE AC3,TDATA(AC2)	; STEAL THE LEADER FROM THE INCOMMING MESSAGE
	MOVEM AC3,TDATA(AC1)
	SETZM TDATA+1(AC1)
	MOVEI AC3,10
	DPB AC3,SIZEP
	MOVEI AC3,1
	DPB AC3,COUNTP
	MOVEI AC3,3
	MOVEM AC3,TWC(AC1)	; WE WILL SEND OUT THE LEADER AND ONE EXTRA WORD
	MOVEI AC3,RRP		; SET RESET REPLY OPCODE
	DPB AC3,OPCDP
	PUSHJ P,CLKOUT
	POP P,AC1
	LDB AC2,ELINKP		; PICK UP HOST-LINK NUMBER (LINK=0)
	SKIPN AC3,FFLNK		; SCAN LINK TABLE FOR OPEN CONNECTIONS TO HIM
	JRST L0XIT
IRST2:
	MOVEI TAC,(AC2)
	XOR TAC,LNKTAB-1(AC3)
	TRNN TAC,177400
	JRST IRST1
IRST3:
	SKIPE AC1,IMPRFQ-1(AC3)	; DOES THIS ENTRY HAVE ANY QUEUED RFCS?
	JRST SCNIRF		; YES, SEE IF HE HAS SOME ENTRIES QUEUED
IRST5:
	SOJG AC3,IRST2
	JRST L0XIT

IRST1:
	SKIPE DDB,IMPDDB-1(AC3)	; DOES HE HAVE A DDB?
	JRST IRST4		; YES, SET ERROR BITS
	SKIPE AC1,IMPRFQ-1(AC3)
	PUSHJ P,APNLST		; APPEND ENTIRE RFC QUEUE ONTO ILIST FOR RE-INTERPRETATION
	PUSHJ P,KILLNK		; NO, DELETE THE LINK ENTIRELY
	JRST IRST3

IRST4:
	MOVE IOS,DEVIOS(DDB)	; CLEAR ANY WAIT STATE
	TLZE IOS,ANYW
	PUSHJ P,QRUN
	ORI IOS,RSET!IODERR
	MOVEM IOS,DEVIOS(DDB)
	MOVSI AC2,CLSS!CLSR	; PRETEND CONNECTION IS CLOSED
	PUSHJ P,CSTAT		; GIVE HIM THE INTERRUPT
	MOVE AC2,IMPLS-1(AC3)	; PICK UP LOCAL SOCKET NUMBER
	TRNN AC2,1		; IS OUR SIDE THE SEND SIDE?
	JRST IRST3		; NO
	SETZM BAL(DDB)		; YES, NO MORE MESSAGES, PLEASE
	SETZM MAL(DDB)
	JRST IRST3

; RESET - SCAN DOWN THE QUEUED RFC LIST FOR ENTRIES BY THIS GUY

SCNIRF:
	SETZ TAC1,		; SET PREDECESSOR TO ZERO
SCNNXR:
	PUSHJ P,LEGAL		; BLESS THIS BLOCK
	JRST [	SETZM IMPRFQ-1(AC3)
		JRST IRST5]
	LDB TAC,ELINKP
	CAIE TAC,(AC2)
	JRST SCNGNX
	PUSH P,AC2
	PUSH P,TLINK(AC1)	; SAVE POINTER TO SUCCESSOR
	PUSHJ P,UNLRFQ		; UNLINK RFC FROM LIST
	PUSHJ P,RELLST		; RELEASE THE STORAGE
	POP P,AC1		; GET BACK SUCCESSOR
	HLRZS AC1		; GET POINTER INTO RIGHT HALF
	POP P,AC2		; GET BACK SOURCE NUMBER
	JRST SCNCZ

SCNGNX:
	MOVEI TAC1,(AC1)	; SET PREDECESSOR TO CURRENT
	HLRZ AC1,TLINK(AC1)	; MOVE DOWN THE LIST
SCNCZ:
	JUMPN AC1,SCNNXR
	JRST IRST5

; ERROR RECOVERY SYSTEM. POOT OUT MESSAGES TO EVERYONE WHO THINKS
; HIS LINK IS BLOCKED. WE WILL THEN GET BACK EITHER A BLOCKED LINK
; OR A RFNM, BUT  IN ANY CASE THE LINK WILL BE CLEARED.

ERRREC:
	SKIPL RECOVER
	JRST ERRCNT
	SKIPN AC3,FFLNK
	JRST ERRL0
ERRNXD:
	SKIPN DDB,IMPDDB-1(AC3)
	JRST ERRLIN
	MOVE IOS,DEVIOS(DDB)
	TRNN IOS,BLOK
	JRST ERRLIN
	PUSHJ P,IMPGET
	PUSHJ P,CLKWAIT
	SETZM TDATA(AC1)
	SETZM TDATA+1(AC1)
	SKIPN AC2,IMPBS-1(AC3)
	MOVEI AC2,10
	DPB AC2,SIZEP
	MOVE AC2,LNKTAB-1(AC3)
	DPB AC2,ELINKP
	MOVEI AC2,2
	MOVEM AC2,TWC(AC1)
	PUSHJ P,CLKOUT		; OUTPUT A ZERO LENGTH MESSAGE
ERRLIN:
	SOJG AC3,ERRNXD

; ERROR RECOVERY FOR LINK ZERO

ERRL0:
	MOVEI AC3,7		;INDEX OF LAST WORD IN L0BLOK TABLE
ERRL0L:
	SKIPN TEM,L0BLOK(AC3)
	JRST ERRL0I
	MOVEI DAT,1
	SETZ TAC,
ERRL0T:
	TDNN DAT,TEM
	JRST ERRL0R
	PUSHJ P,IMPGET
	PUSHJ P,CLKWAIT
	SETZM TDATA(AC1)
	SETZM TDATA+1(AC1)
	SETZM TDATA+2(AC1)
	MOVEI TAC1,3
	MOVEM TAC1,TWC(AC1)
	MOVEI TAC1,10
	DPB TAC1,SIZEP
	MOVEI TAC1,1
	DPB TAC1,COUNTP
	MOVEI TAC1,(AC3)
	LSH TAC1,5
	ORI TAC1,(TAC)
	DPB TAC1,SRCP
	PUSHJ P,QOUT		; BYPASS LINK BLOKAGE
ERRL0R:
	ADDI TAC,1
	LSH DAT,1
	CAIGE TAC,40
	JRST ERRL0T
ERRL0I:
	SOJGE AC3,ERRL0L
	MOVEI AC1,4*=60*=60
	MOVEM AC1,RECOVER
	POPJ P,

ERRCNT:
	SOSGE RECOVER
	SETZM RECOVER
	POPJ P,

; UTILITY ROUTINES FOR THE PRECEEDING ROUTINES - ERROR ROUTINE
; MAKES UP ERROR MESSAGE TO HOST WHOSE INCOMING MESSAGE
; ADDRESS HAS BEEN PUSHED ON THE STACK. SKIPS ON SUCCESS, NON-SKIP
; MEANS NO FREE STORAGE AVAILABLE.

MAKERB:
	PUSHJ P,IMPGET		; GET A FREE STORAGE BLOCK
	POPJ P,			; NONE AVAILABLE
	PUSHJ P,CLRBLK		; ZERO THE FREE STORAGE BLOCK
	MOVE AC2,-1(P)		; PICK UP ADDRESS OF INPUT MESSAGE
	LDB AC3,[POINT 16,TDATA(AC2),23]
	ANDCMI AC3,377		; ZERO OUT LINK NUMBER
	DPB AC3,ELINKP		; SET HOST TO THE SAME, LINK TO CONTROL LINK
	MOVEI AC3,10
	DPB AC3,SIZEP		; BYTE SIZE FOR CONTROL MESSAGES IS 8
	MOVEI AC3,ERR		; PUT IN ERROR OPCODE
	DPB AC3,OPCDP
	MOVEI AC3,14		; ALL ERROR CODES ARE 12 BYTES LONG
	DPB AC3,COUNTP
	MOVEI AC3,7		; PICK UP A WORDCOUNT
	MOVEM AC3,TWC(AC1)
	JRST CPOPJ1

; ROUTINE TO CLEAR A FREE STORAGE BLOCK.
; ENTER WITH BLOCK ADDRESS IN AC1
; ONLY CLEARS DATA PORTION

CLRBLK:
	PUSH P,AC2
	PUSH P,AC3
	SETZM TDATA(AC1)
	HRLI AC2,TDATA(AC1)	; MAKE UP BLT POINTER
	HRRI AC2,TDATA+1(AC1)
	HRRI AC3,TDATA-1(AC1)
	ADD AC3,TLEN(AC1)
	BLT AC2,(AC3)
	POP P,AC3
	POP P,AC2
	POPJ P,

; ROUTINE TO DELETE A LINK IN THE LINK TABLE.
; ENTER WITH THE LINK TABLE INDEX (PLUS ONE) IN AC3

KILLNK:
	SKIPE AC1,IMPRFQ-1(AC3)	; ANY QUEUED RFCS HERE?
	PUSHJ P,APNLST		; YES, RECYCLE THEM
	MOVEI AC2,-1(AC3)	; CORRECT INDEX
	PUSH P,DAT
	SOSE DAT,FFLNK		; DECREMENT FIRST FREE LINK NUMBER
	CAIN DAT,(AC2)		; IS THIS LINK THE TOP ONE?
	JRST KILLN1		; YES, RESTORE ACS AND LEAVE
	PUSH P,AC2
	PUSH P,AC3
	MOVE AC3,LNKTAB(DAT)
	MOVEM AC3,LNKTAB(AC2)
	MOVE AC3,IMPDDB(DAT)
	MOVEM AC3,IMPDDB(AC2)
	MOVE AC3,IMPLS(DAT)
	MOVEM AC3,IMPLS(AC2)
	MOVE AC3,IMPFS(DAT)
	MOVEM AC3,IMPFS(AC2)
	MOVE AC3,IMPRFQ(DAT)
	MOVEM AC3,IMPRFQ(AC2)
	MOVE AC3,IMPBS(DAT)
	MOVEM AC3,IMPBS(AC2)
	MOVE AC3,IMPSTB(DAT)
	MOVEM AC3,IMPSTB(AC2)
	POP P,AC3
	POP P,AC2
KILLN1:
	POP P,DAT
	POPJ P,

; ROUTINE TO POLL ALL THE OTHER SITES FOR SIGNS OF LIFE

POLL:
	MOVEI AC1,POLTIM
	MOVEM AC1,POLCNT
	SKIPE IMPDEAD
	POPJ P,
	SOSG HCLSCT		; TIME TO CHECK HALF-DEAD SOCKETS YET?
	PUSHJ P,HCLSS		; YES, DO IT NOW
	SKIPE IMPECT		; ANY ERROR BITS?
	JRST IERBD

; ROUTINE TO PERIODICALLY CHECK AND MAKE SURE ALL IS OK
; IT DELETES HALF-CLOSED SOCKETS PERIODICALLY

HCLSS:
	MOVEI AC1,HCLSTM
	MOVEM AC1,HCLSCT
HCLSR:
	SKIPN AC3,FFLNK
	POPJ P,
HCLSL:
	SKIPE IMPDDB-1(AC3)
HCLSI:
	SOJG AC3,HCLSL
	JUMPE AC3,CPOPJ
	MOVE AC1,IMPSTB-1(AC3)
	TLNE AC1,CLSS
	TLNE AC1,CLSR
	JRST HCLSI
	TLNE AC1,LONCE
	JRST HCLSZ
	MOVSI AC1,LONCE
	ORM AC1,IMPSTB-1(AC3)
	JRST HCLSI

HCLSZ:
	SKIPE AC1,IMPRFQ-1(AC3)	; GIVE BACK ANY QUEUED RFCS WHAT MAY BE
	PUSHJ P,APNLST
	PUSHJ P,KILLNK
	JRST HCLSR		; GO BACK AND TRY AGAIN

; TYPE OUT ERROR MESSAGE ON IMP ERROR BIT DETECTED
; WE OUGHT TO SOMEHOW CLEAR THE INTERFACE TOO

IERBD:
	SKIPE IMPDEAD
	POPJ P,
	SETZM IMPECT		; START COUNTING AGAIN
	SKIPN RECOVER		; INITIATE ERROR RECOVERY SEQUENCE
	SETOM RECOVER
	TELCTR(IERBIT,<IMP ERROR BIT CAME UP,>)
	POPJ P,

; ROUTINE TO SEND THE IMP SOME NOPS

SNDNOP:
	MOVEI AC3,4
	MOVEM AC3,NOPCNT
	SETOM IMPOACT
	MOVEI AC3,MAXCNT
	MOVEM AC3,IMPOCT
	CONO PI,IMPOFF
	CONO IMP,STROUT!ODPIEN!IMPCHN
	DATAO IMP,[BYTE (8) 4]	;NOP
	CONO PI,IMPON
	POPJ P,

; ROUTINE TO DUMP AN INCOMMING COMMAND INTO THE DATA PORTION OF AN ERROR MESSAGE
; ENTER WITH ERROR MESSAGE IN AC1
; OFFENDING INCOMMING MESSAGE AT -1(P)

EFILL:
	MOVEI DAT,12
	HRRZI AC2,TDATA+2(AC1)
	HRLI AC2,(<POINT 8,0,15>)
EFILL1:
	HRRZ AC3,-1(P)
	ADD AC3,[POINT 8,TDATA+2]
EFILL2:
	ILDB DSER,AC3
	IDPB DSER,AC2
	SOJG DAT,EFILL2
	POPJ P,

; SAME THING EXCEPT FOR STANFORD IDIOSYNCRATIC ERROR MESSAGES.
; DUMPS ONE LESS BYTE ONE BYTE FURTHER DOWN

OFILL:
	MOVEI DAT,11
	HRRZI AC2,TDATA+2(AC1)
	HRLI AC2,(<POINT 8,0,23>)
	JRST EFILL1

; ROUTINE TO WAIT AT CLOCK LEVEL FOR A STANDARD FREE STORAGE BLOCK

CLKWAIT:

	SETOM IMPCLW		; NOTE THAT WE ARE WAITING
	PUSHACS			; SAVE OUR STATE
	MOVEM P,IMPPDP
	MOVE AC1,[XWD CLKPDL,IMPSAV]
	BLT AC1,IMPSAV+CLKPLN-1	; SAVE THE STACK
	MOVE P,IMPFP
	POPJ P,			; RETURN TO CLKSER

CLKWT:
	PUSHJ P,IMPGET
	POPJ P,
	MOVE AC3,[XWD IMPSAV,CLKPDL]
	BLT AC3,CLKPDL+CLKPLN-1
	MOVE P,IMPPDP
	PUSHJ P,IMPREL		;GIVE BLOCK BACK (PROBABLY TO SPARE LIST)
	POPACS
	SETZM IMPCLW
	SOS (P)
	SOS (P)			; BACK UP TO TRY OFFENDING ROUTINE OVER AGAIN
	POPJ P,

; ROUTINE TO RELEASE THE STORAGE IN A LIST
; CALL WITH LIST IN AC1

RELLST:
	HRRZS AC1
	PUSHJ P,LEGAL		; IS THIS A LEGAL BLOCK?
	POPJ P,			; NO, LEAVE NOW
	PUSH P,TLINK(AC1)	; SAVE POINTER TO NEXT BLOCK
	PUSHJ P,IMPREL		; RELEASE STORAGE
	POP P,AC1		; GET PTR TO NEXT BLOCK
	TRNE AC1,-1
	JRST RELLST
	POPJ P,

; ROUTINE TO RELEASE LIST OF LISTS
; ENTER WITH LIST LIST IN AC1

RELBLS:
	PUSHJ P,LEGAL
	POPJ P,
	PUSH P,TLINK(AC1)
	PUSHJ P,RELLST
	POP P,AC1
	HLRZS AC1
	JUMPN AC1,RELBLS
	POPJ P,

; ROUTINE TO PLANT AN INTERRUPT REQUEST
; MUST HAVE DDB SET UP
; ENTER WITH INTERRUPT BIT IN AC2

INTCOM:
	LDB J,PJOBN
	TDNN AC2,JBTIEN(J)
	POPJ P,
	IORM AC2,JBTIRQ(J)
	SETOM INTREQ(PID)
	POPJ P,

; ROUTINE TO UNLINK THE TOP MESSAGE ON THE INPUT LIST
; SKIPS IF THERE ACTUALLY WAS ONE AND PUTS ITS ADDRESS IN AC1

UNLMES:
	CONO PI,IMPOFF
	SKIPN AC1,ILIST		; PICK UP INPUT LIST
	JRST UNLME1
	HLRZ AC2,TLINK(AC1)	; GET POINTER TO NEXT LIST
	HRRM AC2,ILIST
	SKIPN AC2
	SETZM ILIST
	CONO PI,IMPON
	HRRZS TLINK(AC1)	; CLEAR OUT POINTER TO NEXT BLOCK
	JRST CPOPJ1

UNLME1:
	CONO PI,IMPON
	POPJ P,

; SAME THING BUT IS ERROR IF NO LIST THERE

UNLNS:
	PUSHJ P,UNLMES
	JRST UNLERR
	POPJ P,

UNLERR:
	PUSHJ P,DISMES
	[ASCIZ /NO INPUT LIST AT UNLNS
/]
	-1
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

; ROUTINE TO POP THE FIRST TRANSFER OFF THE INPUT LIST AND DELETE IT

POPMESS:

	PUSHJ P,UNLMES
	POPJ P,
	JRST RELLST

; ROUTINE TO SEND OUT A MESSAGE FROM CLOCK LEVEL ON LINK 0.
; IF LINK IS BLOCKED, PUTS MESSAGE ON A LIST (L0CWTL)
; ENTER WITH MESSAGE TO BE SENT IN AC1
; PRESERVEC AC3, BUT DEFINITELY CLOBBERS AC2

CLKOUT:
	SKIPE IMPDEAD
	JRST RELLST		; IF IMP DEAD, FLUSH OUTPUT
CLKOUD:
	LDB AC2,TYPEP		; PICK UP MESSAGE TYPE
	JUMPE AC2,CLKOU4	; IF A REGULAR MESSAGE, BLOCK LINK FIRST
	CAIN AC2,5		; IF REGULAR MESSAGE FOR DISCARD, BLOCK LINK ALSO
	JRST CLKOU4
	JRST QOUT		; OTHERWISE, DON'T WORRY ABOUT TRYING TO BLOCK IT

CLKOU4:
	PUSH P,AC3
	PUSHJ P,L0PTR
	TDNN AC3,L0BLOK(AC2)	; IS THIS LINK BLOCKED?
	JRST CLKOU3		; NO, SEND AWAY
	SKIPN AC2,L0CWTL	; YES, PUT IT ON END OF LIST
	JRST CLKOU1		; NO LIST, PUT IT ON BOTH ENDS
	MOVSS AC2
	HRLM AC1,TLINK(AC2)	; LINK US ON TO END OF LAST GUY
CLKOU2:
	HRLM AC1,L0CWTL
	HRRZS TLINK(AC1)
	POP P,AC3
	POPJ P,

CLKOU1:
	HRRM AC1,L0CWTL
	JRST CLKOU2

CLKOU3:
	ORM AC3,L0BLOK(AC2)	; BLOCK LINK
	POP P,AC3
	JRST QOUT		; OUTPUT MESSAGE

; ROUTINE TO FIND A DDB FROM LINK NUMBER IN A SECOND LEVEL
; NCP COMMAND. GETS SEND OR RECEIVE SIDE AS SPECIFIED.
; RETURNS:
; +1 FOR NO SUCH LINK NUMBER
; +2 FOR WRONG SIDE ONLY
; +3 FOR SOCKET THERE BUT NO DDB

COMDDR:
	SKIPA DDB,[TRNE TEM,1]	; GET RECEIVE SIDE SOCKET NUMBER TEST
COMDDS:
	MOVE DDB,[TRNN TEM,1]	; PICK SEND SIDE TEST
	LDB AC2,SRCP		; PICK UP HOST NUMBER
	LSH AC2,=8
	ILDB AC3,TBP(AC1)
	ORI AC2,(AC3)		; MAKE UP HOST-LINK NUMBER
	SETZ DAT,
	SKIPN AC3,FFLNK		; PICK UP POINTER TO FIRST FREE LINK
	POPJ P,
COMDS2:
	CAMN AC2,LNKTAB-1(AC3)	; HOST-LINK NUMBER MATCH?
	JRST COMDS1
COMDS3:
	SOJG AC3,COMDS2
	SKIPE AC3,DAT		; DID WE FIND ANYTHING AT ALL?
	AOS (P)			; YES, GIVE +2 RETURN
	POPJ P,

COMDS1:
	MOVEI DAT,(AC3)		; SAVE INDEX FOR FUTURE REFERENCE
	MOVE TEM,IMPLS-1(AC3)
	XCT DDB
	JRST COMDS3
	AOS (P)
	AOS (P)
	SKIPE DDB,IMPDDB-1(AC3)
	AOS (P)
	POPJ P,

; ROUTINES TO PICK UP SOCKET NUMBERS AND STORE THEM FOR CLS, RTS, AND STR

RD2B:
	ILDB AC2,TBP(AC1)
	LSH AC2,10
	ILDB TEM,TBP(AC1)
	ORI AC2,(TEM)
	POPJ P,

RD4B:
	ILDB AC2,TBP(AC1)
REPEAT 3,<
	LSH AC2,10
	ILDB TEM,TBP(AC1)
	ORI AC2,(TEM)
>
	POPJ P,

PSOCK1:
	DPB AC2,SOK1BP
	LSH AC2,-10
	DPB AC2,SOK1AP
	POPJ P,

PSOCK2:
	DPB AC2,SOK2BP
	LSH AC2,-10
	DPB AC2,SOK2AP
	POPJ P,

GSOCK1:
	LDB AC2,SOK1AP
	LDB TEM,SOK1BP
	LSH AC2,10
	ORI AC2,(TEM)
	POPJ P,

GSOCK2:
	LDB AC2,SOK2AP
	LDB TEM,SOK2BP
	LSH AC2,10
	ORI AC2,(TEM)
	POPJ P,

; ROUTINE TO RETURN A CLS TO THE HOST WHOSE MESSAGE IS IN AC1
; RETURNS MESSAGE TO FREE STORAGE.

RTNCLS:
	MOVE AC2,TDATA(AC1)
	PUSH P,AC1
	PUSHJ P,IMPGET
	PUSHJ P,CLKWAIT
	PUSHJ P,MCLSB		; MAKE UP A CLS LOCK
	MOVE AC2,JDAT
	PUSHJ P,PSOCK1
	MOVE AC2,UUO
	PUSHJ P,PSOCK2
	PUSHJ P,CLKOUT
	POP P,AC1
	POPJ P,

; ROUTINE TO MAKE UP A CLS BLOCK WITH EMPTY SOCKETS
; CALL WITH IMP HEADER IN AC2
; MUST ALREADY HAVE FREE STORAGE IN AC1

MCLSB:
	MOVEM AC2,TDATA(AC1)
	SETZM TDATA+1(AC1)
	SETZM TDATA+2(AC1)
	SETZM TDATA+3(AC1)
	SETZM TDATA+4(AC1)
	MOVEI AC2,5		; FIVE WORD TRANSFER
	MOVEM AC2,TWC(AC1)
	MOVEI AC2,10
	DPB AC2,SIZEP
	MOVEI AC2,11
	DPB AC2,COUNTP
	MOVEI AC2,CLS
	DPB AC2,OPCDP
	POPJ P,

; SEND CLOSE TO FOREIGN HOST
; CALL WITH FREE STORAGE IN AC1
; CONNECTION INDEX MUST BE IN AC3

SNCLS:
	MOVE AC2,LNKTAB-1(AC3)
	ANDI AC2,177400
	LSH AC2,14
	PUSHJ P,MCLSB
	MOVE AC2,IMPLS-1(AC3)
	SKIPE DDB,IMPDDB-1(AC3)	; MAKE SURE THERE IS A DDB THERE
	TRNN AC2,1		; IS OUR SIDE THE SEND SIDE?
	JRST SNCLS1		; NO
	SETZM BAL(DDB)		; YES, DON'T EMIT ANY MORE MESSAGES
	SETZM MAL(DDB)
SNCLS1:
	PUSHJ P,PSOCK1
	MOVE AC2,IMPFS-1(AC3)
	PUSHJ P,PSOCK2
	PUSHJ P,CLKOUT
	MOVSI AC2,CLSS
	PUSHJ P,CSTAT
	POPJ P,
;: IMPREG[J17,SYS] EOF.
;: IMPUUO[J17,SYS]
COMMENT ⊗   VALID 00061 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00007 00002	SUBTTL IMP UUO-LEVEL CODE - JAM, SEPT '71
C00010 00003	 MORE MTAPE UUO CODES
C00012 00004	 POSITIONS IN USER TABLE OF VARIOUS QUANTITIES
C00013 00005	 UUO DISPATCH TABLE
C00014 00006	 INITIALIZE ROUTINE
C00017 00007	 MTAPE DISPATCH
C00019 00008	 TERMINATE CONNECTION
C00021 00009	 REINITIALIZE THE IMP SYSTEM, BRING UP THE IMP
C00022 00010
C00024 00011	 TEST AND CLEAR INTERRUPT BITS - SET SYSTEM DEFAULT TIMEOUTS
C00026 00012	 LISTEN CODE
C00029 00013	 LISTEN CODE - HERE HE WANTS TO LISTEN TO AN EXTANT SOCKET
C00032 00014	 LISTEN - GET HERE WHEN THE SLOT IN THE TABLE IS OKED FOR CONNECTION
C00033 00015	 CONNECT CODE - FIRST CHECK FOR A PENDING SOCKET, THEN SEND OUT A RFC
C00036 00016	 CONNECT CODE. CHECK SOCKET FOR CLOSURE. IF CLOSED, WE MAY GO AHEAD AND USE IT
C00038 00017	 CONNECT CODE. ROUTINE TO SET UP THE INDEX AND TRY TO WAIT FOR CONNECTION.
C00039 00018	 DUMP. GIVE LOSER A DUMP OF THE MONITOR TABLES.
C00041 00019	 ROUTINE TO GIVE LOSER HIS SOCKET NUMBERS
C00042 00020	 ROUTINE TO WAIT FOR CONNECTION
C00044 00021	 MTAPE 13 - SET ALLOCATION
C00046 00022	 UUO TO SET ALLOCATION. HERE ALLOCATION HE WANTS IS IN AC2 & AC3
C00048 00023	 HERE WE DECREMENT HIS ALLOCATION AND ASK FOR SOME BACK IF NEED BE
C00050 00024	 MTAPE 14 - GIVE USER THE CURRENT ALLOCATIONS
C00051 00025	 ROUTINE TO SEND AN INTERRUPT
C00052 00026	 RELEAS CODE. SEND OUT CLSS IF NOT ALREADY.
C00054 00027	 BUFFERED OUTPUT . . .
C00056 00028	 ROUTINE TO ACTUALLY DO THE OUTPUT
C00059 00029	 FULL WORD MODE OUTPUT - BYTE AT A TIME
C00063 00030	 ROUTINE TO CORRECT WORD COUNT, ALLOCATION, AND SEND OFF MESSAGE
C00065 00031	 BUFFERED OUTPUT. GET HERE TO DO A BLT INTO THE MESSAGE BUFFERS.
C00068 00032	 HERE WE HAVE DECIDED TO SEND THE MESSAGE, WHETHER THERE IS MORE IN THE BUFFER OR NOT
C00069 00033	 IMP INPUT UUOS - BUFFERED MODE AND DUMP MODE
C00071 00034	 COMMON INPUT ROUTINE.
C00074 00035	 COMMON INPUT ROUTINE. READ DATA OUT OF INPUT LIST AND INTO USER CORE
C00077 00036	 HERE WE HAVE CORRECTED THE WORD COUNTS IN THE BUFFERS AND ARE READY TO DO THE INPUT
C00080 00037	 CLOSE CODE. DOESN'T REALLY DO MUCH EXCEPT FLUSH BUFFERS AND SEND OUT CLSS
C00082 00038	 UTILITY ROUTINES FOR UUO-LEVEL STUFF. ROUTINES TO SEND STR OR RTS
C00083 00039	 ROUTINE TO MAKE UP AN RFC BLOCK. MUST HAVE BLOCK IN AC1, CONNECTION INDEX IN AC3,
C00085 00040	 ERROR ROUTINE FOR NO CONNECTION
C00086 00041	 ROUTINE TO SEND OUT A MESSAGE AT UUO LEVEL. WAITS FOR
C00089 00042	 ROUTINE TO WAIT FOR THE LINK TO CLEAR
C00090 00043	 ROUTINE TO BLESS UUO LEVEL OUTPUTS BASED ON HOST STATUS.
C00091 00044	 ROUTINE TO CHECK FOR PROPER CONNECTION AND HOST DEAD.
C00094 00045	 ROUTINE TO INITIALIZE A CONNECTION
C00095 00046	 ROUTINE TO REQUEUE SOMEONE INTO THE RUN QUEUE
C00097 00047	 ROUTINE TO WAIT FOR ALLOCATION
C00099 00048	 ROUTINE TO GET LINK TABLE INDEX FROM A DDB POINTER - SEND SIDE
C00100 00049	 THIS IS CALLED AT CONNECT AND LISTEN TO DETERMINE
C00102 00050	 FREE STORAGE MANAGER FOR IMP SERVICE
C00104 00051	 HERE WE CAN'T GET FS FROM THE SYSTEM, SEE IF WE CAN SCROUNGE A BLOCK
C00105 00052	 ROUTINE TO RELEASE FREE STORAGE
C00107 00053	 ROUTINE TO ASSIGN A NEW LINK NUMBER
C00109 00054	 ROUTINE TO SEE IF A TABLE ENTRY MAY BE CLEARED.
C00110 00055	 ROUTINE TO SEARCH DOWN QUEUED RFC LIST FOR AN RFC THAT MATCHES OUR SOCKET
C00112 00056	 ROUTINE TO APPEND AN ENTIRE RFC QUEUE ONTO ILIST
C00114 00057	 ROUTINE TO GO INTO A WAIT STATE BUT START A COUNTDOWN TOO
C00116 00058	 ROUTINE TO WAIT FOR A MATCHING CLS
C00117 00059	 ROUTINE TO SEND AN ALLOCATION
C00119 00060	 ROUTINE TO CHECK AND SEND INITIAL ALLOCATION
C00121 00061	 ROUTINE TO SEND OUT A SEND-SIDE CLS FROM UUO LEVEL
C00123 ENDMK
C⊗;

SUBTTL IMP UUO-LEVEL CODE - JAM, SEPT '71

; THE NON-STANDARD UUOS WILL BE MTAPE UUOS
; THE ADDRESS OF THE MTAPE POINTS TO A BLOCK
; THE FIRST WORD OF THE BLOCK IS THE FUNCTION CODE
; THAT DETERMINES WHAT TO DO AND HOW TO INTERPRET ANY OTHER WORDS IN THE BLOCK
; FUNCTION=0		; CONNECT
;	1		; STATUS BITS ARE PLACED HERE UPON RETURN
;	2		; LOCAL SOCKET NUMBER. 32 BITS RIGHT-ADJUSTED
;	3		; WAIT FLAG. -1 FOR WAIT FOR CONNECTION.
;	4		; BYTE SIZE, OR IF SENDING, BYTE SIZE IS STORED HERE
;	5		; FOREIGN SOCKET NUMBER
;	6		; HOST NUMBER IS PLACED HERE
; FUNCTION=1		; LISTEN
;	1		; STATUS BITS ARE PLACED HERE
;	2		; LOCAL SOCKET NUMBER
;	3		; WAIT FLAG
;	4		; BYTE SIZE OF CONNECTION. STORED HERE IF SEND
; FUNCTION=2		; STATUS
;	1		; STATUS BITS ARE PLACED HERE FOR SEND SIDE
;	2		; RECEIVE SIDE STATUS BITS ARE PLACED HERE
; FUNCTION=3		; TERMINATE
;	1		; STATUS BITS ARE PLACED HERE
;	2		; LOCAL SOCKET NUMBER
;	3		; WAIT FLAG
; FUNCTION=4		; WAIT FOR CONNECTION COMPLETE
;	1		; STATUS IS RETURNED HERE
;	2		; NEEDS SOCKET NUMBER HERE
; FUNCTION=5		; DUMP. DUMPS MONITOR TABLES
;	1		; NUMBER OF WORDS OF TABLES DESIRED
;	2		; ADDRESS OF PLACE TO PUT TABLES
; FUNCTION=6		; WAKEUP. VALID ONLY IF AT I-LEVEL. USEFUL FOR
;			; WAKING UP PROCESS IN WAIT STATE DUE TO IMP.
; FUNCTION=7		; GET SOCKET NUMBERS AND HOST NUMBER
;	1		; HOST-LINK NUMBER, SEND SIDE
;	2		; LOCAL SEND SOCKET
;	3		; FOREIGN RECEIVE SOCKET
;	4		; HOST-LINK NUMBER FOR RECEIVE SIDE
;	5		; LOCAL RECEIVE SOCKET
;	6		; FOREIGN SEND SOCKET
; FUNCTION=8.		; SKIP IF ANY INPUT IS PRESENT
; FUNCTION=9.		; SEND INTERRUPT
;	1		; STATUS BITS RETURNED HERE
;	2		; NEED SOCKET NUMBER HERE
; FUNCTION=10.		; RESSURECT IMP IF DOWN
; FUNCTION=11.		; BLESS THIS HOST
;	1		; HOST NUMBER REQUIRED HERE

; MORE MTAPE UUO CODES

; FUNCTION=12.		; TEST AND CLEAR INTERRUPT BITS
;	1		; SEND SIDE. 0 FOR NO INT., -1 FOR INT. PRESENT
;	2		; RECEIVE SIDE. 0 FOR NO INT., -1 FOR INT. PRESENT
; FUNCTION=13.		; SET ALLOCATION
;	1		; FUNCTION CODE. 0 NORM, 1 FOR SYS MAX, 2 FOR MIN
;	2		; NUMBER OF BITS OF ALLOCATION
;	3		; NUMBER OF MESSGES OF ALLOCATION
; FUNCTION=14.		; WHAT ARE THE ALLOCATIONS
;	1		; NUMBER OF BITS WE HAVE ALLOCATED HIM
;	2		; NUMBER OF MESSAGES WE HAVE ALLOCATED HIM
;	3		; NUMBER OF BITS HE HAS LEFT
;	4		; NUMBER OF MESSAGES HE HAS LEFT
;	5		; NUMBER OF BITS IN FREE STORAGE
;	6		; NUMBER OF MESSAGES IN FREE STORAGE
;	7		; NUMBER OF BITS HE HAS ALLOCATED US
;	10		; NUMBER OF MESSAGES HE HAS ALLOCATED US
; FUNCTION=15.		; SET TIMEOUTS
;	1		; WORD OF 6-BIT BYTES. GIVES NUMBER OF 2-SECOND UNITS
;			; FOR TIMEOUTS ON CLS, RFNM, ALL, RFC, OR INP
;			; 0 MEANS WAIT INDEFINITELY
; FUNCTION=16.		; GET TIMEOUTS
;	1		; CURRENT TIMEOUT WORD WILL BE PLACED HERE

; POSITIONS IN USER TABLE OF VARIOUS QUANTITIES

STLOC←←1	; STATUS WORD LOCATION
LSLOC←←2	; LOCAL SOCKET LOCATION
WFLOC←←3	; WAIT FLAG
BSLOC←←4	; BYTE SIZE LOCATION
FSLOC←←5	; FOREIGN SOCKET LOCATION
HLOC←←6		; HOST NUMBER LOCATION

; ERROR CODES
; EVERYONE WHO RETURNS STATUS BITS MAY RETURN AN ERROR CODE INSTEAD

SIU←←1		; SOCKET IN USE
CCS←←2		; CAN'T CHANGE SOCKET AFTER RFC DONE
SYS←←3		; HORRIBLE SYSTEM ERROR
NLA←←4		; NO LINK AVAILABLE
ILB←←5		; ILLEGAL BYTE SIZE
IDD←←6		; IMP DEAD

; UUO DISPATCH TABLE

	JRST IMPCLR
	JRST IMPSET
	JRST IMPINI
	JRST CPOPJ
↑IMPDSP:
	JRST IMPRLS	; RELEASE
	JRST CLSO	; CLOSE OUTPUT
	JRST BUFO	; BUFFERED OUTPUT
	JRST BUFI	; BUFFERED INPUT
	JRST CPOPJ1	; ENTER
	JRST CPOPJ1	; LOOKUP
	JRST DMPO	; DUMP MODE OUTPUT
	JRST DMPI	; DUMP MODE INPUT
	JRST CPOPJ	; USETO
	JRST CPOPJ	; USETI
	JRST CPOPJ	; UGETF
	JRST CPOPJ1	; RENAME
	JRST CLSI	; CLOSE INPUT
	JRST CPOPJ	; UTPCLR
	JRST MTAPE	; MTAPE

; INITIALIZE ROUTINE

IMPINI:
	SETZM IMPST		; CLEAR DATA AREA
	MOVE AC1,[XWD IMPST,IMPST+1]
	BLT AC1,IMPEND-1
	MOVEI AC1,MAXNLK
	MOVEM AC1,LNKMAX
	MOVE AC1,[P1PID]
	MOVEM AC1,IMPPID
	MOVEI AC1,IBEGIN	; INITIALIZE THE I-LEVEL DISPATCH ADDRESSES
	MOVEM AC1,IMPIDSP
	HRLOI AC1,377777	; SET OUTPUT COUNT-DOWN TO RANDOM LARGE NUMBER
	MOVEM AC1,IMPOCT
	MOVEI AC1,DONOP
	MOVEM AC1,IMPODSP
	MOVEI AC1,10		; GIVE A LITTLE WHILE FOR THE IMP RELAY TO COOL OFF
	MOVEM AC1,POLCNT
	MOVEI AC1,10		; PICK UP A BUNCH OF SPARE FREE STORAGE BLOCKS
	MOVEM AC1,IMPSPN
	MOVE AC1,[XWD -INTPLN,IMPIPL-1]
	MOVEM AC1,IMPIPD
	MOVE AC1,[XWD -INTPLN,IMPOPL-1]
	MOVEM AC1,IMPOPD
	MOVEI AC1,LPTDDB
	HRLM AC1,DEVSER+DDBMDL	; RELINK DEVICE DATA BLOCK CHAIN
	SKIPN IMPDIE		; DO WE KEEP THE IMP DOWN TODAY?
	JRST IMPGAH
	SETOM IMPDEAD		; YES
	MOVEI AC1,LPTDDB	; LINK AROUND IMP DDB
	HRLM AC1,PTPDDB+DEVSER
	POPJ P,

IMPGAH:
	PUSHJ P,IMPGET		; GET A FREE BLOCK FOR THE INPUT LIST
	HALT NOCORE
	MOVEM AC1,IMPSPARE
	CONO IMP,ODPIEN
	CONO IMP,STRIN!CLRWT!IDPIEN!IEPIEN!IMPCHN
	PUSHJ P,SNDNOP		;SEND THE IMP 4 NOPS
	PUSHJ P,IMPGET		; GET A FREE BLOCK FOR SENDING RESETS TO EVERYONE
	HALT NOCORE
	PUSHJ P,CLRBLK
	MOVEI AC2,377
	DPB AC2,SRCP		; PUT IN BIGGEST HOST NUMBER
	MOVEI AC2,10
	DPB AC2,SIZEP		; PUT IN BYTE SIZE
	MOVEI AC2,1
	DPB AC2,COUNTP		; PUT IN BYTE COUNT
	MOVSI AC2,(<BYTE (8)RST>)
	MOVEM AC2,TDATA+2(AC1)	; PUT IN RST OPCODE
	MOVEI AC2,3
	MOVEM AC2,TWC(AC1)	; AND DATA WORD COUNT
	MOVEI AC2,377		; LARGEST HOST NUMBER
	MOVEM AC2,RSTHST	; SET UP NUMBER OF NEXT HOST TO BE RESET
	JRST CLKOUT	; QUEUE RST BLOCK.  INT ROUTINE WILL DECREMENT HOST NUMBER

; MTAPE DISPATCH

MTAPE:
	XCTR	XR,[HRRZ TAC,(UUO)]	;GET FUNCTION CODE.
	CAIL	TAC,MXUUO		;FUNCTION IN BOUNDS?
	JRST	UUOERR			;NO. ILLEGAL FUNCTION.
	MOVE	TAC1,UUODSP(TAC)	;GET THE DISPATCH ADDRESS
	SKIPE	IMPDEAD			;SKIP IF IMP IS UP
	JRST	MTAPE2			;IMP DOWN.
	JUMPG	TAC1,(TAC1)		;JUMP IF LEGAL WITH IMP UP.
	JRST	UUOERR			;ILLEGAL WITH IMP UP.

MTAPE2:
	JUMPL	TAC1,(TAC1)		;JUMP IF LEGAL WITH IMP DEAD.
	TLNE	TAC1,200000		;DOES THIS MTAPE EXPECT STATUS BITS?
	JRST IDERR			;YES. GIVE THEM.
	POPJ P,				;NO JUST GIVE FAILURE RETURN


UUODSP:
	200000,,CONECT			;0
	200000,,LISTEN			;1
	200000,,STATUS			;2
	200000,,TERMIN			;3
	SWAIT				;4
	DUMP				;5
	WAKE				;6
	GSOCKS				;7
	INPSKP				;10
	200000,,SNDINT			;11
	400000,,NEWINI			;12 ONLY IF IMP DEAD
	CPOPJ	;CHKSIT			;13 BLESS
	TSINT				;14
	USETAL				;15
	UGETAL				;16
	USETTM				;17
	UGETTM				;20
MXUUO←←.-UUODSP

; TERMINATE CONNECTION

TERMIN:
	XCTR	XR,[MOVE AC2,LSLOC(UUO)]
	XCTR	XW,[SETZM STLOC(UUO)]
	PUSHJ P,GETIDX
	POPJ P,
	MOVEI AC1,(DDB)
	SKIPE IMPDDB-1(AC3)		; IF NOBODY HOME, LET HIM KILL IT
	CAMN AC1,IMPDDB-1(AC3)		; IS IT OURS?
	JRST TEROK
	PUSHJ P,TTYERR
	PUSHJ P,INLMES
	ASCIZ /CAN'T TERMINATE SOMEONE ELSE'S SOCKET!
/
TTYSTG:
	MOVSI IOS,USRB
	ORB IOS,DEVIOS(DDB)
	JRST TTYSTR

TEROK:
	TRNE AC2,1			; USE DIFFERENT CLOSE ROUTINE IF SEND SIDE
	JRST TERS
	PUSHJ P,URCLS			; SEND OUT THE CLS
TERW:
	XCTR	XR,[SKIPE WFLOC(UUO)]	; DOES HE WANT TO WAIT FOR IT?
	PUSHJ	P,TCLSW			; YES, DO A TIMED CLS WAIT
	XCTR	XR,[MOVE AC2,LSLOC(UUO)]	; NOW GET THE CONNECTION INDEX AGAIN
	PUSHJ	P,GETIDX
	POPJ	P,
	MOVE	AC1,IMPSTB-1(AC3)
	XCTR	XW,[MOVEM AC1,STLOC(UUO)]
	POPJ	P,

TERS:
	PUSHJ P,USCLS
	JRST TERW

; REINITIALIZE THE IMP SYSTEM, BRING UP THE IMP

NEWINI:
	SKIPN	AC3,FFLNK	;SEE IF THERE ARE ANY LINKS STILL ACTIVE
	JRST	NEWIN1
NEWIN2:
	SKIPN	AC2,IMPDDB-1(AC3)
	JRST	NEWIN3
	CAIE	AC2,(DDB)
	JRST	NEWLOS
NEWIN3:
	SOJGE	AC3,NEWIN2
NEWIN1:
	PUSHJ	P,DISDATE
	PUSHJ	P,DISJOB	;BLAME IT ON THE STONES.
	PUSHJ	P,DISTAB
	MOVE	TAC1,PRJPRG(J)	;GET THE NAME OF LOSER.
	PUSHJ	P,DISSIX
	PUSHJ	P,DISMES
	ASCIZ	/ IS ATTEMPTING TO RESSURECT THE IMP.
/
	SETZM	IMPDIE
	JRST	IMPINI

NEWLOS:
	PUSHJ	P,TTYERR
	PUSHJ	P,INLMES
	ASCIZ	/LINKS STILL ACTIVE
/
	JRST	TTYSTG

; TEST AND CLEAR INTERRUPT BITS - SET SYSTEM DEFAULT TIMEOUTS
; RETURNS FLAG FOR SEND SIDE IN 1(UUO), RECEIVE SIDE IN 2(UUO)

TSINT:
	ANDI	DDB,-1
	XCTR	XW,[SETZM 1(UUO)]
	XCTR	XW,[SETZM 2(UUO)]
	SKIPN	AC3,FFLNK
	POPJ	P,
TSINLP:
	CAMN DDB,IMPDDB-1(AC3)
	JRST TSINDF
TSINCR:
	SOJG AC3,TSINLP
	POPJ P,

TSINDF:
	MOVE AC2,IMPLS-1(AC3)
	MOVE AC1,IMPSTB-1(AC3)
	TLZE AC1,INTINS
	XCTR	XW,[SETOM 1(UUO)]
	TLZE	AC1,INTINR
	XCTR	XW,[SETOM 2(UUO)]
	MOVEM AC1,IMPSTB-1(AC3)
	JRST TSINCR

; SET SYSTEM DEFAULT TIMEOUTS. PUT WORD OF 6-BIT FIELDS IN 1(UUO).
; THE FIELDS ARE IN UNITS OF 2-SECONDS. I.E., THE MAXIMUM WAIT IS 126 SECONDS
; AND THE MINIMUM WAIT IS 2 SECONDS.

USETTM:
	XCTR	XR,[MOVE AC1,1(UUO)]
	MOVEM	AC1,TIMES(DDB)
	POPJ	P,

; ROUTINE TO GET CURRENT TIMEOUTS

UGETTM:
	MOVE AC1,TIMES(DDB)
	XCTR	XW,[MOVEM AC1,1(UUO)]
	POPJ P,

; LISTEN CODE

LISTEN:
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,NSCHECK
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,GETIDX
	JRST LISTN2		; NO KNOWN SOCKET. MAKE US WAIT.
	JRST LISTNG		; KNOWN SOCKET. WHAT'S THIS?

LISTN2:
	AOS AC3,FFLNK		; PICK UP NEW LINK NUMBER
	CAILE AC3,MAXNLK
	JRST LISNLK		; NO LINK AVAILABLE
LISTN4:
	SETZ DAT,		; ZERO HOST-LINK NUMBER
	SETO TEM,		; MARK FOREIGN SOCKET UNUSED
	PUSHJ P,CLRSKT
CHKWAT:
	MOVSI AC2,RFCR		; HAVE WE RECEIVED A REQUEST FOR CONNECTION?
	TDNN AC2,IMPSTB-1(AC3)
	JRST WAIT		; NO, WAIT FOR ONE
	MOVSI AC2,RFCS		; YES, HAS IT BEEN ACKNOWLEDGED?
	TDNN AC2,IMPSTB-1(AC3)
	PUSHJ P,SNDRFC		; NO, DO SO NOW AND LEAVE WITHOUT WAITING
	JRST SETST		; HAS CHANGED, DON'T WAIT

WAIT:
	XCTR XR,[SKIPN WFLOC(UUO)]
	JRST SETST		; NO WAIT, JUST SET STATUS WORD AND RETURN
	MOVNI TAC,IOWQ
	MOVEM TAC,JOBQUE(J)
	MOVSI IOS,RFCW		; NOTE THAT WE ARE WAITING FOR CONNECTION
	ORM IOS,DEVIOS(DDB)
	LDB TEM,RFCTP		; PICK UP RFC WAIT TIME
	PUSHJ P,TW		; DO A TIMED WAIT IF WAIT TIME≠0. OTHERWISE WAIT FOREVER.
	JFCL			; IGNORE ERROR RETURN, GIVE LOSER STATUS BITS
SETST:
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,GETIDX
	JRST NOCONN		; HELP, LINK DISSAPEARED!
	MOVE TAC,IMPFS-1(AC3)
	XCTR XW,[MOVEM TAC,FSLOC(UUO)]
	MOVE AC2,IMPBS-1(AC3)	; GIVE HIM BYTE SIZE FOR KICKS
	XCTR XW,[MOVEM AC3,BSLOC(UUO)]
	MOVE AC2,LNKTAB-1(AC3)	; PICK UP HOST NUMBER
	LSH AC2,-10		; RIGHT-ADJUST IT
	XCTR XW,[MOVEM AC2,HLOC(UUO)]
STST:
	MOVE AC2,IMPSTB-1(AC3)
	TLZ AC2,ANYC		; NOTE WE ARE GIVING HIM UP-TO-DATE STATUS BITS
	MOVEM AC2,IMPSTB-1(AC3)
	XCTR XW,[MOVEM AC2,STLOC(UUO)]
	POPJ P,

; LISTEN CODE - HERE HE WANTS TO LISTEN TO AN EXTANT SOCKET

LISTNG:
	MOVE AC1,IMPSTB-1(AC3)
	SKIPN TAC,IMPDDB-1(AC3)	; DOES IT HAVE A DDB?
	JRST LNODDB		; NO, WE MIGHT BE ABLE TO CONNECT UP
SIUERR:
	MOVEI TAC,SIU		; NO, SOCKET IN USE
	JRST DEPERC

LNODDB:
	TLNE AC1,CLSS
	JRST WCLS
	TLNN AC1,RFCR		; HAS A STR BEEN RECEIVED?
	JRST LISTN4		; NO, WAIT FOR ONE
	TLNN AC1,RFCS		; YES, HAS A RTS BEEN RETURNED?
	JRST USRTSR		; NO, RETURN A RTS AND WE ARE CONNECTED!
ILLST:
	TELCTR(NILLST,<ILLEGAL STATE: STR AND RTS BUT NO DDB!>)
SYSERR:
	MOVEI TAC,SYS		; GIVE HIM SYSTEM ERROR CODE
DEPERC:
	XCTR XW,[MOVEM TAC,STLOC(UUO)]
	POPJ P,

WCLS:
	HRRZM DDB,IMPDDB-1(AC3)
	TLNN AC1,CLSR
	PUSHJ P,TCLSW		; WAIT FOR THE MATCHING CLOSE FOR A WHILE
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	TLZ AC1,CLSS!CLSR!RFCR!RFCS
	MOVEM AC1,IMPSTB-1(AC3)
	MOVEM AC2,IMPLS-1(AC3)
	TRNN AC2,1		; IS IT A SEND SOCKET?
	JRST LNOBS		; NO, HE DOESN'T GET TO SET THE BYTE SIDE.
	ANDI AC1,77
	CAIG AC1,44		; CHECK FOR LEGAL BYTE SIZE
	SKIPGE BPW(AC1)
	JRST UILLBS
	XCTR XR,[MOVE AC1,BSLOC(UUO)]
	MOVEM AC1,IMPBS-1(AC3)
LNOBS:
	SETZM LNKTAB-1(AC3)	; NOTE THAT THERE IS NO HOST NUMBER
	SETOM IMPFS-1(AC3)	; OR FOREIGN SOCKET EITHER
	SKIPE AC1,IMPRFQ-1(AC3)	; ANY PENDING RFCS?
	PUSHJ P,DISPQ		; RUN DOWN RFQ LIST FOR A STR THAT MATCHES OUR SOCKET
	JRST CHKWAT		; NONE FOUND, WAIT FOR ONE
	JRST SETST		; ONE FOUND AND PROCESSED, RETURN TO LOSER

UILLBS:
	MOVEI TAC,ILB
	JRST DEPERC

IDERR:
	MOVEI TAC,IDD
	JRST DEPERC

; LISTEN - GET HERE WHEN THE SLOT IN THE TABLE IS OKED FOR CONNECTION

USRTSR:
	HRRZM DDB,IMPDDB-1(AC3)
SNDRAL:
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	XCTR XR,[MOVE TEM,BSLOC(UUO)]
	TRNE AC2,1
	MOVEM TEM,IMPBS-1(AC3)		; IF WE ARE SENDING SET BYTE SIZE
	PUSHJ P,SNDRFC			; SEND BACK A RTS
	JRST SETST			; GIVE HIM SOME STATUS BITS TOO

; GET HERE IF THERE IS NO ROOM IN THE LINK TABLE FOR HIS LISTEN

LISNLK:
	SOS FFLNK
	MOVEI TAC,NLA		; GIVE HIM "nO-LINK AVAILABLE" ERROR
	XCTR XW,[MOVEM TAC,STLOC(UUO)]
	POPJ P,

; CONNECT CODE - FIRST CHECK FOR A PENDING SOCKET, THEN SEND OUT A RFC

CONECT:
	SKIPE IMPDEAD
	JRST IDERR
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,NSCHECK
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,GETIDX		; SEE IF THIS SOCKET NUMBER EXISTS YET
	JRST MAKRFC		; NO, SEND OUT RFC
	MOVE AC1,IMPSTB-1(AC3)	; YES, SEE IF IT IS PENDING
	SKIPE TAC,IMPDDB-1(AC3)	; DOES IT ALREADY HAVE A DDB?
	JRST SIUERR		; NO, SOCKET IN USE
	TLNE AC1,RFCR		; HAVE WE RECEIVED A RFC?
	TLNE AC1,RFCS		; HAS RFC BEEN SENT?
	JRST CHKCL		; YES, SEE IF IT HAS BEEN CLOSED.
	XCTR XR,[MOVE TEM,FSLOC(UUO)]
	CAME TEM,IMPFS-1(AC3)
	JRST SIUERR
	XCTR XR,[MOVE TEM,HLOC(UUO)]
	LSH TEM,10
	XOR TEM,LNKTAB-1(AC3)	; CHECK HOST NUMBERS
	TRNE TEM,177400
	JRST SIUERR		; NO MATCH, SOCKET IN USE
	HRRZM DDB,IMPDDB-1(AC3)
	JRST SNDRAL		; GO SEND ALLOCATION IF NECESSARY

; CONNECT CODE. CHECK SOCKET FOR CLOSURE. IF CLOSED, WE MAY GO AHEAD AND USE IT

CHKCL:
	TLNN AC1,CLSS
	JRST ILLST
	HRRZM DDB,IMPDDB-1(AC3)
	TLNN AC1,CLSR		; HAVE WE RECEIVED A CLOSE?
	PUSHJ P,TCLSW		; NO, WAIT FOR A WHILE FOR ONE
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
CONSRL:
	TLZ AC1,CLSS!CLSR!RFCR!RFCS
	MOVEM AC1,IMPSTB-1(AC3)
	MOVEM AC2,IMPLS-1(AC3)	; SET RECEIVE SOCKET NUMBER
	XCTR XR,[MOVE TEM,FSLOC(UUO)]
	MOVEM TEM,IMPFS-1(AC3)
	XCTR XR,[MOVE AC1,HLOC(UUO)]
	ANDI AC1,377
	LSH AC1,10
	MOVEM AC1,LNKTAB-1(AC3)
	TRNN AC2,1		; SEND SOCKET?
	JRST CNOBS		; NO, HE CAN'T SET BYTE SIZE
	XCTR XR,[MOVE AC1,BSLOC(UUO)]
	ANDI AC1,77
	CAIG AC1,44
	SKIPGE BPW(AC1)
	JRST UILLBS		; ILLEGAL BYTE SIZE
	MOVEM AC1,IMPBS-1(AC3)
CNOBS:
	SKIPE AC1,IMPRFQ-1(AC3)	; ANYONE WAITING?
	PUSHJ P,DISPQ		; RUN DOWN LIST OF RFCS FOR ONE THAT MATCHES US
	JRST MSSRFC		; NOONE WAITING, SEND OUT RFC
	JRST CONWAT		; FOUND SOMEONE, GO SET USER UP

MSSRFC:
	PUSHJ P,SNDRFC		; SEND OUT REQUEST FOR CONNECTION
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,IODERR!IODTER!HDEAD!RSET
	POPJ P,			; IF ERRORS, LEAVE NOW
	JRST CONWAT		; WAIT FOR REPLY IF LOSER SO CHOSES

; CONNECT CODE. ROUTINE TO SET UP THE INDEX AND TRY TO WAIT FOR CONNECTION.

CONWAT:
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,GETIDX		; PICK UP CONNECTION INDEX AGAIN
	JRST NOCONN
	JRST CHKWAT

NOCONR:
	TELCTR(NNOCLW,<NO RETURN CLS SENT!>)
	JRST CONSRL

; HERE WE INITIALIZE A SOCKET AND SEND OUT RFC

MAKRFC:
	XCTR XR,[MOVE TEM,FSLOC(UUO)]
	AOS AC3,FFLNK		; GET NEW INDEX NUMBER
	CAILE AC3,MAXNLK
	JRST LISNLK
	XCTR XR,[MOVE DAT,HLOC(UUO)]
	ANDI DAT,377
	LSH DAT,10
	PUSHJ P,CLRSKT
	JRST MSSRFC

; DUMP. GIVE LOSER A DUMP OF THE MONITOR TABLES.

DUMP:
	XCTR XR,[MOVE AC2,2(UUO)]
	MOVEI TAC1,(AC2)
	XCTR XRW,[MOVSS (AC2)]
	MOVEI AC3,(AC2)
	XCTR XR,[ADD AC3,1(UUO)]
	XCTR XRW,[MOVSS -1(AC3)]
	XOR AC3,TAC1
	JUMPL AC3,ADRERR
	PUSHJ P,DOLOC		; RELOCATE ADDRESS IN TAC1, PUT RESOLT IN DSER
	HRLI DSER,SYSTBS
	HRRZI AC3,-1(DSER)
	XCTR XR,[ADD AC3,1(UUO)]
	BLT DSER,(AC3)
	POPJ P,

; GIVE LOSER THE STATUS OF HIS CONNECTION

STATUS:
	PUSHJ P,UUSIDX
	JRST STAT1
	MOVSI AC2,ANYC
	ANDCAB AC2,IMPSTB-1(AC3)
	XCTR XW,[MOVEM AC2,1(UUO)]
	JRST STAT2

STAT1:
	XCTR XW,[SETZM 1(UUO)]
STAT2:
	PUSHJ P,UURIDX
	JRST STAT3
	MOVSI AC2,ANYC
	ANDCAB AC2,IMPSTB-1(AC3)
	XCTR XW,[MOVEM AC2,2(UUO)]
	POPJ P,

STAT3:
	XCTR XW,[SETZM 2(UUO)]
	POPJ P,

; WAKE UP MONITOR IF WAITING FOR IMP. SETS TMO IN IOS TO INDICATE ERROR CONDITION

WAKE:
	SKIPN INTACT
	POPJ P,
	MOVE IOS,DEVIOS(DDB)
	TLNN IOS,ANYW
	POPJ P,
	TRO IOS,TMO
	MOVEM IOS,DEVIOS(DDB)
	JRST QRUN

; ROUTINE TO GIVE LOSER HIS SOCKET NUMBERS

GSOCKS:
	PUSHJ P,UUSIDX
	JRST GSOCKA
	PUSHJ P,DMPTBS		; DUMP THEM INTO HIS CORE IMAGE
GSOCKB:
	ADDI UUO,3
	PUSHJ P,UURIDX		; ANY RECEIVE SIDE?
	JRST ZTAB		; NO, CLEAR CELLS
	JRST DMPTBS		; YES, DUMP THEM

GSOCKA:
	PUSHJ P,ZTAB
	JRST GSOCKB

ZTAB:
	XCTR XW,[SETZM 1(UUO)]
	XCTR XW,[SETZM 2(UUO)]
	XCTR XW,[SETZM 3(UUO)]
	POPJ P,

DMPTBS:
	MOVE AC1,LNKTAB-1(AC3)
	XCTR XW,[MOVEM AC1,1(UUO)]
	MOVE AC1,IMPLS-1(AC3)
	XCTR XW,[MOVEM AC1,2(UUO)]
	MOVE AC1,IMPFS-1(AC3)
	XCTR XW,[MOVEM AC1,3(UUO)]
	POPJ P,

; ROUTINE TO WAIT FOR CONNECTION

SWAIT:
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,GETIDX
	JRST NOCONN
	MOVE AC1,IMPSTB-1(AC3)
	TLC AC1,RFCS!RFCR
	TLCE AC1,RFCS!RFCR
	TLNE AC1,CLSR!CLSS
	JRST SWSTST
	MOVNI AC1,IOWQ
	MOVEM AC1,JOBQUE(J)
	MOVSI IOS,RFCW
	ORM IOS,DEVIOS(DDB)
	LDB TEM,RFCTP		; PICK UP RFC WAIT TIMEOUT PERIOD
	PUSHJ P,TW		; DO A TIMED WAIT
	JRST NSW		; TIMEOUT. NO CONNECTION
	MOVSI IOS,RFCW
	ANDCAB IOS,DEVIOS(DDB)
	JRST SWAIT		; IF NO TIME-OUT, GO BACK AND MAKE SURE WE ARE CONNECTED

NSW:
	MOVSI IOS,RFCW
	ANDCAB IOS,DEVIOS(DDB)	; CLEAR BIT IN MEMORY
	POPJ P,			; IF TIMED OUT, GO BACK TO USER NOW

SWSTST:
	XCTR XW,[MOVEM AC1,STLOC(UUO)]
	POPJ P,

; ROUTINE TO SKIP IF THERE IS ANY INPUT PRESENT

INPSKP:
	SKIPE INL(DDB)
	JRST CPOPJ1
	JRST INIALL		; CHECK ON INITIAL ALLOCATION

; MTAPE 13 - SET ALLOCATION
; LOCATION 1 OF THE USER TABLE IS A CODE
;	0 MEANS TAKE LOC 2 AS BIT ALLOCATION AND LOC 3 AS MESSAGE ALLOCATION
;	1 MEANS SET ALLOCATION TO SYSTEM MAXIMUM
;	2 MEANS SET ALLOCATION TO SYSTEM MINIMUM
;	3 MEANS SET ALLOCATION TO SYSTEM DEFAULT
; LOCATION 2 IS THE BIT ALLOCATION
; LOCATION 3 IS THE MESSAGE ALLOCATION

USETAL:
	XCTR XR,[SKIPL TAC,1(UUO)]
	CAILE TAC,3		; CHECK CODE FOR LEGAL RANGE
	JRST UUOERR
	JRST @USETTB(TAC)	; DISPATCH TO RELEVANT ROUTINE

USETTB:
	USETSP
	USETMX
	USETMN
	USETDF

USETMX:
	MOVEI AC3,MAXBAL	; PICK UP MAXIMUM ALLOCATIONS
	MOVEI AC2,MAXMAL
	JRST UCHKB

USETMN:
	MOVEI AC3,MINBAL
	MOVEI AC2,MINMAL
	JRST UCHKB

USETDF:
	MOVEI AC3,DEFBAL	; USE DEFAULT ALLOCATIONS
	MOVEI AC2,DEFMAL
	JRST UCHKB

USETSP:
	XCTR XR,[MOVE AC3,2(UUO)]
	XCTR XR,[MOVE AC2,3(UUO)]
	CAIGE AC3,MINBAL	; IS IT ABOVE MINIMUM ALLOCATION?
	MOVEI AC3,MINBAL	; NO, GIVE HIM AT LEAST THIS MUCH
	CAILE AC3,MAXBAL	; IS IT OVER MAXIMUM?
	MOVEI AC3,MAXBAL	; NO, PUT A LID ON AT AT THE MAXIMUM
	CAIGE AC2,MINMAL	; SAME FOR MESSAGE ALLOCATION
	MOVEI AC2,MINMAL
	CAILE AC2,MAXMAL
	MOVEI AC2,MAXMAL
	JRST UCHKB		; PROCEED ON TO NEXT PAGE

; UUO TO SET ALLOCATION. HERE ALLOCATION HE WANTS IS IN AC2 & AC3
; PUT IT IN THE DDB AND SEND HIM A CONTROL MESSAGE IF NECESSARY

UCHKB:
	MOVEM AC3,NHBA(DDB)	; SET NOMINAL ALLOCATION
	MOVEM AC2,NHMA(DDB)
	LSH AC3,-1		; SET HALFWAY MARKERS TOO FOR SPEED
	LSH AC2,-1
	MOVEM AC3,NHBA2(DDB)
	MOVEM AC2,NHMA2(DDB)
	PUSHJ P,UURIDX		; PICK UP CONNECTION INDEX
	POPJ P,			; NONE YET, DON'T HAVE TO TELL HIM ANYTHING
	MOVE AC1,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLC AC1,RFCR!RFCS	; SEE IF CONNECTION IS REALLY OPEN YET
	TLNN AC1,CLSS!CLSR	; OR REALLY CLOSING
	TLNE AC1,RFCR!RFCS
	POPJ P,			; NOT REALLY OPEN FOR BUSINESS. LEAVE NOW
	MOVE UUO,LNKTAB-1(AC3)	; SAVE HOST-LINK NUMBER HERE
	MOVE AC3,HBA(DDB)	; NOW SEE IF HE NEEDS TO BE ALLOCATED RIGHT NOW
	MOVE AC2,HMA(DDB)
	CAMG AC3,NHBA(DDB)	; ARE WE DECREASING HIS ALLOCATION?
	CAMLE AC2,NHMA(DDB)	; OF EITHER FLAVOR?
	JRST AFSB		; YES, ASK FOR SOME BACK
	ADD AC3,BIIL(DDB)
	ADD AC2,MIIL(DDB)
	CAML AC2,NHMA2(DDB)	; IS HE PAST THE HALFWAY MARK?
	CAMGE AC3,NHBA2(DDB)	; IN EITHER KIND OF ALLOCATION?
	PUSHJ P,SNDBAL		; YES, SEND HIM SOME MORE
	POPJ P,			; END OF UUO

; HERE WE DECREMENT HIS ALLOCATION AND ASK FOR SOME BACK IF NEED BE

AFSB:
	SUB AC3,NHBA(DDB)	; GET AMOUNT OF BIT ALLOCATION TO ASK FOR
	SKIPGE AC3
	SETZ AC3,		; POSITIVE ONLY
	SUB AC2,NHMA(DDB)	; SAME FOR MESSAGE ALLOCATION
	SKIPGE AC2
	SETZ AC2,
	LSH AC2,7		; SET UP FOR GETTING 7-BIT FRACTION
	LSH AC3,7
	IDIV AC2,HMA(DDB)	; DIVIDE WHAT WE WANT BACK BY WHAT HE HAS
	IDIV AC3,HBA(DDB)
	LSH AC2,8
	ORI AC2,(AC3)		; PACK THEM INTO ONE WORD
	HRLI AC2,GVB⊗6		; PUT IN OPCODE
	PUSHJ P,IMPGET		; GET SOME FREE STORAGE FOR A MESSAGE
	JRST NOCORE
	LSH AC2,4		; LEFT JUSTIFY THE COMMAND WORD
	MOVEM AC2,TDATA+2(AC1)	; AND PLACE INTO OUTPUT BLOCK
	SETZM TDATA(AC1)	; CLEAR OUT JUNK IN LEADER
	SETZM TDATA+1(AC1)
	MOVEI AC2,3		; SET WORD COUNT
	MOVEM AC2,TWC(AC1)
	DPB UUO,OLINKP		; PUT IN THE LINK NUMBER
	ANDCMI UUO,177400	; NOW THE HOST NUMBER WITH LINK SET TO ZERO
	DPB UUO,ELINKP
	MOVEI AC2,10
	DPB AC2,SIZEP
	MOVEI AC2,4
	DPB AC2,COUNTP
	JRST UUOQ		; AND AWAY IT GOES!

; MTAPE 14 - GIVE USER THE CURRENT ALLOCATIONS

UGETAL:
	MOVE TAC,NHBA(DDB)
	XCTR XW,[MOVEM TAC,1(UUO)]
	MOVE TAC,NHMA(DDB)
	XCTR XW,[MOVEM TAC,2(UUO)]
	MOVE TAC,HBA(DDB)
	XCTR XW,[MOVEM TAC,3(UUO)]
	MOVE TAC,HMA(DDB)
	XCTR XW,[MOVEM TAC,4(UUO)]
	MOVE TAC,BIIL(DDB)
	XCTR XW,[MOVEM TAC,5(UUO)]
	MOVE TAC,MIIL(DDB)
	XCTR XW,[MOVEM TAC,6(UUO)]
	MOVE TAC,BAL(DDB)
	XCTR XW,[MOVEM TAC,7(UUO)]
	MOVE TAC,MAL(DDB)
	XCTR XW,[MOVEM TAC,10(UUO)]
	POPJ P,

; ROUTINE TO SEND AN INTERRUPT

SNDINT:
	XCTR XR,[MOVE AC2,LSLOC(UUO)]
	PUSHJ P,IMPGET
	JRST NOCORE
	XCTR XW,[SETZM STLOC(UUO)]
	PUSHJ P,GETIDX
	JRST IMPREL
	MOVE DAT,IMPSTB-1(AC3)
	XCTR XW,[MOVEM DAT,STLOC(UUO)]
	SETZM TDATA(AC1)
	SETZM TDATA+1(AC1)
	SETZM TDATA+2(AC1)
	MOVEI DAT,10
	DPB DAT,SIZEP
	MOVEI DAT,2
	DPB DAT,COUNTP
	MOVEI DAT,3
	MOVEM DAT,TWC(AC1)
	MOVE DAT,LNKTAB-1(AC3)
	ANDI DAT,177400
	DPB DAT,ELINKP
	MOVE DAT,LNKTAB-1(AC3)
	DPB DAT,OLINKP
	MOVEI DAT,INS
	TRNN AC2,1
	MOVEI DAT,INR
	DPB DAT,OPCDP
	JRST UUOQ

; RELEAS CODE. SEND OUT CLSS IF NOT ALREADY.

IMPRLS:
	SKIPL TIM(DDB)		; TIME INITIALIZED?
	SOS TIMWAIT		; YES, NOT ANY MORE
	SETOM TIM(DDB)
	SKIPE AC1,INL(DDB)	; ANYTHING STILL ON INPUT LIST?
	PUSHJ P,RELBLS		; YES, GIVE IT BACK
	SKIPE IMPDEAD
	JRST RLDI
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,BLOK
	PUSHJ P,RFNMWT		; IF STILL DATA ON THE LINK, WAIT FOR IT
	PUSHJ P,UUSIDX
	JRST IMPRL3
	MOVE AC1,IMPSTB-1(AC3)
	TLNE AC1,RFCS
	TLNE AC1,CLSS
	JRST IMPRL1
	PUSHJ P,USCLS
	PUSHJ P,UUSIDX
	JRST IMPRL3
IMPRL1:
	SETZM IMPDDB-1(AC3)
	PUSHJ P,ZEROLK
IMPRL3:
	PUSHJ P,UURIDX
	POPJ P,
	MOVE AC1,IMPSTB-1(AC3)
	TLNE AC1,RFCS
	TLNE AC1,CLSS
	JRST IMPRL4
	PUSHJ P,URCLS
	PUSHJ P,UURIDX
	POPJ P,
IMPRL4:
	SETZM IMPDDB-1(AC3)
	JRST ZEROLK		; RELEASE CONNECTION IF ALL CLSS ARE PROPERLY EXCHANGED

; WE GET HERE IF THE IMP IS DEAD

RLDI:
	PUSHJ P,UUSIDX		; SEE IF HE HAS A SEND SOCKET
	JRST RLDI1
	SETZM IMPDDB-1(AC3)	; YES, KILL IT
	PUSHJ P,ZEROLK
RLDI1:
	PUSHJ P,UURIDX
	POPJ P,
	SETZM IMPDDB-1(AC3)
	JRST ZEROLK

; BUFFERED OUTPUT . . .

BUFO:
	PUSHJ P,UUOOOK		; IS HOST ALIVE AND ALL?
	JRST UUXIT		; NO, LEAVE WITH ERROR BITS
	HRRZ TAC1,DEVOAD(DDB)	; PICK UP OUT BUFFER ADDRESS
	XCTR XR,[HRRZ TAC,1(TAC1)]	; PICK UP WORD COUNT
	ADDI TAC1,2		; MOVE POINTER TO DATA AREA
	PUSHJ P,NEWOX		; DO TRANSFER USING USER ADDR IN TAC1 AND WD CT IN TAC
	PUSHJ P,ADVBFE		; ADVANCE BUFFER
	JRST UUXIT
	JRST BUFO		; TRY FOR ANOTHER ONE

; DUMP MODE OUTPUT . . .

DMPO:
	PUSHJ P,UUOOOK
	JRST UUXIT
DMPO1:
	PUSHJ P,DMPCMD		; RETURNS UPLEVEL WHEN DONE
	MOVNS TAC		; GET POSITIVE WD CT IN TAC
	PUSH P,UUO
	PUSHJ P,NEWOX		; DO TRANSFER
	POP P,UUO		; GET PTR TO DMP MODE CMD LIST BACK
	AOJA UUO,DMPO		; DO NEXT COMMAND

; ROUTINE TO ACTUALLY DO THE OUTPUT
; ENTER WITH WORD COUNT IN TAC AND USER ADDRESS IN TAC1

NEWOX:
	JUMPE TAC,CPOPJ		; LEAVE IF USER WORD COUNT=0
	ADD P,[XWD 1,1]		; BUMP STACK FOR FULL WORD FLAG
OUTAGN:
	PUSHJ P,ALLOK		; WAIT FOR ALLOCATION IF NECESSARY
	JRST SPOPJ		; LEAVE ON ERRORS
	HRLI TAC1,440000	; MAKE INPUT POINTER INTO BYTE POINTER
	MOVE IOS,IMPBS-1(AC3)	; CONNECTION INDEX SET UP BY ALLOK
	DPB IOS,[POINT 6,TAC1,11]
	MOVE AC3,IOS
	MOVE AC3,BPW(AC3)	; GET BITS PER WORD IN AC3
	IDIV AC3,IOS		; AC3 NOW HAS BYTES PER WORD
	LDB IOS,[POINT 6,TAC1,11]
	SETOM (P)		; ASSUME FULL WORD MODE
	CAIN IOS,8
	JRST GOBAAT		; ALWAYS DO BYTE AT A TIME FOR 8 BIT BYTES
	MOVE TEM,BAL(DDB)	; HOW MUCH ALLOCATION HAS HE GIVEN US?
	CAILE TEM,400		; IF LESS THAN 8 WORDS, DO BYTE AT A TIME
	CAIGE TAC,10		; IF LESS THAN 8 WORDS, IS MORE EFFICIENT TO GO BYTE AT A TIME
	JRST GOBAAT		; BYTE AT A TIME
	JRST GOFW

GOBAAT:
	IMULI TAC,(AC3)		; IF BYTE AT A TIME, CONVERT TO BYTE COUNT
	SETZM (P)		; CLEAR FULL WORD FLAG
GOFW:
	MOVEI TEM,(AC3)		; SAVE BYTES/WD IN TEM
NEWMSO:
	PUSHJ P,IMPGET		; PICK UP FIRST BUFFER OF MESSAGE
	JRST NOCORE
	SETZM TDATA(AC1)	; CLEAR SPARE BITS IN LEADER
	SETZM TDATA+1(AC1)
	PUSHJ P,UUSIDX		; PICK UP THE LINK TABLE INDEX AGAIN
	JRST NOCONN
	MOVE IOS,LNKTAB-1(AC3)	; PICK UP HOST-LINK NUMBER
	DPB IOS,ELINKP		; PUT IN DESTINATION FIELD
	MOVE IOS,IMPBS-1(AC3)	; PICK UP BYTE SIZE
	DPB IOS,SIZEP		; SET INTO LEADER
	MOVE DAT,TLEN(AC1)	; PICK UP LENGTH OF DATA PORTION OF BUFFER
	MOVEM DAT,TWC(AC1)	; PUT INTO INITIAL WORD COUNT
	SUBI DAT,2		; KNOCK OFF TWO FOR LEADER WORDS
	PUSH P,AC1		; SAVE FIRST BLOCK OF MESSAGE ON STACK
	SETZB AC2,UCHN		; CLEAR BYTE COUNT AND BIT COUNT
	SKIPGE -1(P)		; FULL WORD OR BYTE AT A TIME?
	JRST BFOHW		; FULL WORD MODE

; FULL WORD MODE OUTPUT - BYTE AT A TIME
; HERE IS THE ACTUAL OUTPUT LOOP

NBLOOP:
	PUSH P,AC1		; PUT CURRENT BLOCK ON THE STACK
	IMULI DAT,(TEM)		; DAT NOW HAS NUMBER OF FREE BYTES IN BUFFER
	SETZM TLINK(AC1)
	CAMN AC1,-1(P)		; IS THIS THE FIRST BLOCK
	ADDI AC1,2		; YES, BUMP POINTER PAST LEADER
	ADDI AC1,TDATA		; BUMP BUFFER POINTER TO PAST OVERHEAD WORDS IN BLOCK
	HRLI AC1,440000		; MAKE UP BYTE POINTER TO BUFFER
	DPB IOS,[POINT 6,AC1,11]
NWLOOP:
	ADD UCHN,IOS		; ADD NUMBER OF BITS IN THIS NEXT TRANSFER
	CAIG UCHN,=7900		; MORE THAN THE IMP CAN STAND?
	CAMLE UCHN,BAL(DDB)	; HAVE WE OVERSHOT THE ALLOCATION?
	JRST OUTNOW		; YES, SEND THE MESSAGE NOW AND WAIT FOR MORE ALLOCATION
	XCTR XLB,[ILDB DSER,TAC1]	; PICK UP DATA BYTE
	IDPB DSER,AC1		; PLACE INTO MESSAGE BUFFER
	ADDI AC2,1		; BUMP BYTE COUNT
	CAIN IOS,8
	SOJA TAC,NWTNLP		; CHECK FOR LAST WORD
	SOJLE TAC,ENDNOW	; BUMP USER DATA COUNT, IF END OF MESSAGE, LEAVE
NWLOP1:
	SOJG DAT,NWLOOP		; BUMP FREE BYTE COUNT
	PUSHJ P,IMPGET		; GET ANOTHER BUFFER
	JRST NOCORE
	POP P,UUO		; GET BACK LAST ONE
	HRRZM AC1,TLINK(UUO)	; LINK NEW ONE TO OLD ONE
	MOVE DAT,TLEN(AC1)	; FILL THE WORD COUNT
	MOVEM DAT,TWC(AC1)
	JRST NBLOOP

NWTNLP:
	JUMPE TAC,ENDNOW
	CAILE TAC,4		; SKIP IF DOWN TO LAST WORD
	JRST NWLOP1
	CAIN TAC,4
	ADD TAC1,[400000,,1]	; TAC1 ← 441000,,LAST WORD OF USER BUF
	MOVEI AC3,1
	LSH AC3,-1(TAC)		; SHIFT TO BIT POSITION IN LAST WORD OF USER BUF
	XCTR XR,[TDNN AC3,(TAC1)]
	JRST NWLOP1		; BIT CLEAR, OK TO USE THAT BYTE
	IBP TAC1		; ADVANCE THE BYTE POINTER
	SOJA TAC,NWTNLP		; TRY NEXT BYTE

OUTNOW:
	SUB UCHN,IOS		; SUBTRACT OFF THE AMOUNT WE ADDED IN ALREADY
	PUSHJ P,UUFNO		; FINISH OFF BLOCK
	PUSHJ P,ALLOK		; DO WE HAVE ANY ALLOCATION?
	JRST SPOPJ			; NO, LEAVE NOW
	JRST NEWMSO		; YES, MAKE UP A NEW MESSAGE

ENDNOW:
	SUBI DAT,1
	PUSHJ P,UUFNO
SPOPJ:
	SUB P,[XWD 1,1]		; NORMALIZE STACK WITHOUT CLOBBERING AN AC
	POPJ P,

; ROUTINE TO CORRECT WORD COUNT, ALLOCATION, AND SEND OFF MESSAGE

UUFNO:
	PUSH P,TEM
	SETZ TEM,
UUFILL:
	LDB AC3,[POINT 6,AC1,5]
	CAMGE AC3,IOS		; IS POSITION GREATER THAN BYTE LENGTH?
	JRST UUFIN		; NO, WORD IS FULL
	IDPB TEM,AC1		; YES, FILL THE WORD WITH ANOTHER ZERO BYTE
	JRST UUFILL

UUFIN:
	MOVNS UCHN		; NEGATE BIT COUNT
	ADDM UCHN,BAL(DDB)	; UPDATE ALLOCATION
	SOS MAL(DDB)		; NOTE ONE MORE MESSAGE GONE
	MOVE AC1,-2(P)		; PICK UP ADDRESS OF CURRENT BLOCK
	MOVE TEM,(P)		; PICK UP BYTES/WD FROM STACK
	IDIVM DAT,TEM		; CONVERT FREE BYTE COUNT TO FREE WORD COUNT IN TEM
	MOVNS TEM		; NEGATE FREE WORD COUNT
	ADDM TEM,TWC(AC1)	; MAKE INTO FULL WORD COUNT
	MOVE AC1,-3(P)		; PICK UP TOP TO MESSAGE
	DPB AC2,COUNTP		; SET BYTE COUNT THIS TRANSFER
	PUSHJ P,UUOQ		; SEND IT OUT
	POP P,TEM		; GET BACK THE BYTES/WD.
	SUB P,[XWD 3,3]
	JRST @3(P)

; BUFFERED OUTPUT. GET HERE TO DO A BLT INTO THE MESSAGE BUFFERS.

BFOHW:
	MOVE TEM,IOS		; PICK UP BITS PER WORD
	MOVE TEM,BPW(TEM)	; FROM MAJIK TABLE
	MOVEI AC3,(TEM)
	IMULI AC3,(TAC)		; AC3 NOW HAS NUMBER OF BITS IN TRANSFER
	CAML AC3,BAL(DDB)	; IS THIS OVER THE ALLOCATION?
	MOVE AC3,BAL(DDB)	; YES, ONLY TRANSFER THAT MUCH
	CAILE AC3,=8000		; MORE THAN THE IMP CAN HANDLE?
	MOVEI AC3,=8000		; YES, JUST ONE BIT MESSAGE AT A TIME.
	MOVEI UCHN,(AC3)	; SAVE BITS PER MESSAGE IN UCHN
	IDIVI AC3,(TEM)		; AC3 IS NOW WORD COUNT OF THIS TRANSFER
	CAME AC1,(P)
	JRST HWNB
	LDB IOS,SIZEP		; PICK UP BYTE SIZE OF CONNECTION
	IDIVM TEM,IOS		; GET BYTES PER WORD IN IOS
	IMULI IOS,(AC3)		; IOS NOW HAS NUMBER OF BYTES IN MESSAGE
	DPB IOS,COUNTP		; USE THIS AS BYTE COUNT
HWNB:
	SETZM TLINK(AC1)	; CLEAR LINKAGE WORD
	MOVEI AC2,(AC3)
	CAIL AC2,(DAT)		; MORE WORDS IN XFR THAN IN BUFFER?
	MOVEI AC2,(DAT)		; YES, TRANSFER WHOLE BUFFER FULL
	PUSHJ P,DOLOC		; RELOCATE → RESULT IN DSER
	HRLI UCHN,(DSER)	; AC2 HAS WD CT THIS BUFFER
	CAME AC1,(P)		; IS THIS THE FIRST BLOCK?
	HRRI UCHN,TDATA(AC1)	; UCHN IS BLT POINTER
	CAMN AC1,(P)
	HRRI UCHN,TDATA+2(AC1)	; IS FIRST BLOCK, BUMP POINTER PAST LEADER
	MOVEI UUO,(UCHN)
	ADDI UUO,-1(AC2)
	BLT UCHN,(UUO)
	SUBI AC3,(AC2)		; BUMP WORD COUNT THIS TRANSFER
	ADDI TAC1,(AC2)		; ADD IN WORDS IN BLOCK TO USER POINTER
	ADDI DSER,(AC2)
	SUBI TAC,(AC2)		; DECREMENT WORDS IN ENTIRE OUTPUT
	CAMN AC1,(P)		; IS THIS THE STARTING BLOCK
	ADDI AC2,2		; YES, SKIP OVER THE LEADER
	MOVEM AC2,TWC(AC1)	; SET WORD COUNT INTO BUFFER
	JUMPLE TAC,HWEND	; IF NONE LEFT, LEAVE
	JUMPLE AC3,HWDOX	; MORE WDS LEFT, BUT NOT THIS TRANSFER
	MOVE UUO,AC1		; GET ANOTHER BLOCK
	PUSHJ P,IMPGET
	JRST NOCORE
	SETZM TLINK(AC1)
	HRRZM AC1,TLINK(UUO)	; LINK US ON TO THE LAST ONE
	MOVE DAT,TLEN(AC1)	; PICK UP LENGTH OF DATA PORTION OF BUFFER
	MOVEM DAT,TWC(AC1)
	JRST HWNB

; HERE WE HAVE DECIDED TO SEND THE MESSAGE, WHETHER THERE IS MORE IN THE BUFFER OR NOT


HWDOX:
	POP P,AC1		; GET BACK ADDRESS OF MESSAGE
	PUSHJ P,UPDALL
	PUSHJ P,UUOQ
	JRST OUTAGN

HWEND:
	POP P,AC1
	PUSHJ P,UPDALL
	SUB P,[XWD 1,1]		; SKIP OVER FULL WORD FLAG
	JRST UUOQ

; ROUTINE TO UPDATE THE ALLOCATION FROM THE MESSAGE

UPDALL:
	PUSH P,AC2
	PUSH P,AC3
	LDB AC2,SIZEP
	LDB AC3,COUNTP
	IMULI AC3,(AC2)
	MOVNS AC3
	ADDM AC3,BAL(DDB)
	SOS MAL(DDB)
	POP P,AC3
	POP P,AC2
	POPJ P,

; IMP INPUT UUOS - BUFFERED MODE AND DUMP MODE

BUFI:
	HRRZ TAC1,DEVIAD(DDB)	; PICK UP ADDRESS OF LOSER BUFFER
	XCTR	XR,[HLRZ TAC,(TAC1)]
	ANDCMI TAC,400000
	MOVEI DSER,(TAC1)
	ADDI DSER,-1(TAC)	; GET ADDRESS OF LAST WORD IN BUFFER IN DSER
	XCTR	XRW,[MOVSS (DSER)]	; ADDRESS CHECK IT BY GETTIN ILM ON ILLEGAL ADDRESS
	SUBI TAC,1		; REDUCE WORD COUNT TO SKIP OVER BUFFER HEAD
	ADDI TAC1,2
	PUSHJ P,INPT		; DO THE INPUT
	JRST ENDCHK		; ERROR OR EOF
	HRRZ AC2,DEVIAD(DDB)	; PICK UP BUFFER ADDRESS
	XCTR	XW,[MOVEM DAT,1(AC2)]; SET WORD COUNT IN BUFFER
	PUSHJ P,ADVBFF		; ADVANCE THE BUFFER
	JRST UUXIT
UUXIT:
	MOVE IOS,DEVIOS(DDB)	; UUOCON EXPECTS THIS
	POPJ P,

ENDCHK:
	TLZE IOS,IOEND		; DID WE HIT EOF?
	ORI IOS,IODEND		; YES, SET EOF BIT
	TRNE IOS,TMO		; TIMED OUT.
	ORI IOS,IODERR		; YES, GIVE ERROR BIT SO UUOCON WON'T SHIT ON US
	MOVEM IOS,DEVIOS(DDB)
	POPJ P,

; DUMP MODE INPUT

DMPI:
	PUSHJ P,DMPCMD		; RETURNS UPLEVEL ON END OF COMMAND LIST
	MOVNS TAC
	XCTR	XRW,[MOVSS (TAC1)]
	MOVEI DSER,(TAC1)
	ADDI DSER,-1(TAC)
	XCTR	XRW,[MOVSS (DSER)]
DMPIT:
	PUSHJ P,INPT		; DO AN INPUT
	JRST ENDCHK
	JUMPG TAC,DMPIT		; IF WE HAVEN'T GOTTEN WHAT HE ASKED FOR, GO BACK FOR MORE
	AOJA UUO,DMPI		; CHECK FOR MORE COMMANDS

; COMMON INPUT ROUTINE.
; ENTER WITH USER ADDRESS IN TAC1 AND DESIRED WORD COUNT IN TAC
; RETURNS COUNT OF WORDS TRANSFERRED IN DAT
; RETURNS +1 IF ERROR OR NO DATA AVAILABLE, +2 ON SOME DATA TRANSFERRED

INPT:
	PUSHJ P,UUOIOK		; MAKE SURE HOST ALIVE AND ALL
	POPJ P,			; HOST DEAD
INPTM:
	SETZ DAT,		; CLEAR WORD COUNT
	SKIPE AC1,INL(DDB)	; IS THERE SOME INPUT WAITING FOR US?
	JRST INPT1		; YES, GO GIVE IT TO LOSER
	MOVE AC1,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLNN AC1,CLSR		; HAS HE SENT US A CLS?
	JRST INPWT		; NO, WAIT FOR SOME MORE DATA
	MOVSI IOS,IOEND		; YES, END OF FILE
	ORB IOS,DEVIOS(DDB)
	POPJ P,

INPWT:
	PUSHJ P,INIALL		; CHECK IF INITIAL ALLOCATION DONE YET
	MOVSI IOS,INPW		; NO, GO INTO INPUT WAIT FOR IT
	ORM IOS,DEVIOS(DDB)
	LDB TEM,INPTP		; PICK UP INPUT WAIT TIMEOUT
	PUSHJ P,TW		; WAIT FOR INPUT OR TIMEOUT
	JRST ISETEB		; LEAVE IF TIMEOUT
	MOVE IOS,DEVIOS(DDB)
	TRNN IOS,TMO!IODERR!IODTER!HDEAD!RSET
	PUSHJ P,UURIDX		; GET CONNECTION INDEX BACK
	POPJ P,			; LEAVE ON ERRORS
	MOVE AC1,IMPSTB-1(AC3)
	TLNN AC1,CLSS!CLSR	; SEE IF CONNECTION WENT AWAY
	JRST INPT
	SKIPE INL(DDB)		; DID ANY INPUT SNEAK IN AFTER THE CLOSE?
	JRST INPTOK		; YES, SET UP CONNECTION INDEX AND INPUT FURTHER
	MOVSI IOS,INPW		; NO, WAIT FOR MORE INPUT FOR A LITTLE WHILE
	ORM IOS,DEVIOS(DDB)
	LDB TEM,INPTP		; PICK UP HIS TIMEOUT
	CAIGE TEM,2		; FOUR SECONDS OR MORE, PLEASE.
	MOVEI TEM,2
	PUSHJ P,TW		; WAIT
	JFCL			; WE WILL TELL THAT NOTHING HAPPENED BY INL BEING EMPTY
INPTOK:
	PUSHJ P,UURIDX		; PICK UP CONNECTION INDEX AGAIN
	POPJ P,			; NOBODY HOME, LEAVE
	JRST INPTM		; GOT IT. CHECK INL AGAIN.

ISETEB:
	MOVEI IOS,IODERR		; SET ERROR BIT SO WE CAN GET OUT OF UUOCON
	ORB IOS,DEVIOS(DDB)
	POPJ P,

; COMMON INPUT ROUTINE. READ DATA OUT OF INPUT LIST AND INTO USER CORE

INPT1:
	SKIPGE AC2,TLEN(AC1)	; HAS THIS LIST BEEN INITIALIZED?
	JRST INPT2		; YES, GO ON WITH IT
	LDB AC3,SIZEP		; PICK UP MESSAGE BYTE SIZE
	LDB AC2,COUNTP		; AND LENGTH OF MESSAGE
	IMULI AC3,(AC2)		; GET NUMBER OF BITS IN MESSAGE
	MOVNS AC3
	SOS AC2,MIIL(DDB)	; NOTE ONE LESS MESSAGE IN INPUT LIST
	ADDB AC3,BIIL(DDB)	; NOTE THAT MANY LESS BITS NOW IN INPUT LIST
	ADD AC2,HMA(DDB)	; ADD IN HOW MUCH HE HAS NOW
	ADD AC3,HBA(DDB)	; IN BOTH FLAVORS
	CAMLE AC2,NHMA2(DDB)	; NOW HAS EITHER ONE DROPPED BELOW HALF THE NOMINAL VALUE
	CAMG AC3,NHBA2(DDB)
	PUSHJ P,SNDBAL		; GET SOME MORE ALLOCATION
	LDB AC3,SIZEP		; PICK UP BYTE SIZE OF MESSAGE
	MOVEI AC2,44		; FIRST GET BYTES/WD IN AC3
	IDIVM AC2,AC3
	LDB AC2,COUNTP		; NOW GET WDS/THIS MESSAGE
	IDIVI AC2,(AC3)
	SKIPE AC3
	ADDI AC2,1		; AC2 IS WD CT THIS MESSAGE
	MOVE AC3,TWC(AC1)	; PICK UP WD CT THIS BLOCK
	SUBI AC3,2		; SUBTRACT OFF LEADER
	MOVEM AC3,TWC(AC1)
	MOVEI UCHN,(AC1)	; SAVE BLOCK ADDRESS
COMPTB:
	CAILE AC2,(AC3)		; IS WD CT IN MESSAGE LESS THAN WD CT THIS BLOCK?
	JRST GTNXB		; NO, GO ON TO NEXT BLOCK
	MOVEM AC2,TWC(UCHN)	; YES, CORRECT IT TO SMALLER VALUE
	PUSH P,AC1
	HRRZ AC1,TLINK(UCHN)	; NOW GET RID OF ANY SPURIOUS PADDING WHAT MAY BE
	HLLZS TLINK(UCHN)
	SKIPE AC1
	PUSHJ P,RELLST
	POP P,AC1
	MOVEI AC2,TDATA+2(AC1)	; PICK UP POINTER TO DATA PAST LEADER
	JRST INPT2		; AND GO ON WITH INPUT

GTNXB:
	SUBI AC2,(AC3)		; KNOCK OFF AMOUNT IN THIS BUFFER
	HRRZ UCHN,TLINK(UCHN)	; AND MOVE ON TO NEXT BUFFER
	JUMPN UCHN,GNXWC
	JSP TAC,UUOMES
	ASCIZ /MESSAGE LENGTH NOT CONSISTANT WITH BYTE SIZE, UUO/

GNXWC:
	MOVE AC3,TWC(UCHN)	; PICK UP WC THIS BUFFER
	JRST COMPTB

; HERE WE HAVE CORRECTED THE WORD COUNTS IN THE BUFFERS AND ARE READY TO DO THE INPUT

INPT2:
	MOVE AC3,TWC(AC1)	; PICK UP DATA WORD COUNT
	CAIL AC3,(TAC)		; DOES THE USER WANT LESS THAN THERE IS?
	MOVEI AC3,(TAC)		; YES, JUST GIVE HIM WHAT HE WANTS
	PUSHJ P,DOLOC		; DO SOFTWARE RELOCATION, TAC1 TO DSER
	MOVEI UCHN,(DSER)	; MAKE UP BLT PTR INTO LOSER CORE
	HRLI DSER,(AC2)
	ADDI UCHN,-1(AC3)
	BLT DSER,(UCHN)
	ADDI AC2,(AC3)		; BUMP POINTER INTO MESSAGE BUFFER
	ADDI DAT,(AC3)		; ADD INTO NUMBER OF WORDS TRANSFERRED
	SUBI TAC,(AC3)		; NOTE THAT HE HAS GOTTEN THAT MANY WORDS
	ADDI TAC1,(AC3)		; INCREMENT USER ADDRESS
	TLO AC2,400000		; TURN ON BIT FLAGING PARTIALLY EMPTIED BUFFER
	MOVEM AC2,TLEN(AC1)
	MOVNS AC3		; DECREMENT COUNT OF WORDS LEFT IN MESSAGE BUFFER
	ADDB AC3,TWC(AC1)
	JUMPG AC3,INPMOR	; BUFFER NOT EMPTY, SEE IF HE WANTS ANY MORE
	HRRZ UCHN,TLINK(AC1)	; PICK UP ADDRESS OF NEXT BLOCK IN MESSAGE
	JUMPE UCHN,UNLST	; IF NONE, END OF LIST
	HLRZ DSER,TLINK(AC1)	; THERE IS A BLOCK. PASS DOWN CDR POINTER TO IT
	HRLM DSER,TLINK(UCHN)
	HRRM UCHN,INL(DDB)	; AND MOVE US INTO TOP POSITION
	HLRZ DSER,INL(DDB)	; ARE WE ALSO THE END?
	CAIN DSER,(AC1)
	HRLM UCHN,INL(DDB)
	PUSHJ P,IMPREL		; RELEASE THE FREE STORAGE
	MOVE AC1,UCHN
	TLO UCHN,400000		; SET THE PARTIALLY EMPTY BIT SO WE WON'T TRY TO SKIP OVER THE LEADER
	ADDI UCHN,TDATA		; SKIP OVER THE OVERHEAD WORDS
	MOVEM UCHN,TLEN(AC1)
INPMOR:
	JUMPG TAC,INPT1		; HE WANTS MORE, SEE IF WE CAN GIVE IT TO HIM
	JRST CPOPJ1		; NO MORE

UNLST:
	HLRZ UCHN,TLINK(AC1)	; NO MORE BLOCKS, MOVE TO NEXT MESSAGE
	HRRM UCHN,INL(DDB)
	SKIPN UCHN
	SETZM INL(DDB)
	PUSHJ P,IMPREL
	SKIPE AC1,UCHN
	JRST INPMOR
	SETZM INL(DDB)		; END OF INPUT LIST
	JRST CPOPJ1

; CLOSE CODE. DOESN'T REALLY DO MUCH EXCEPT FLUSH BUFFERS AND SEND OUT CLSS

CLSO:
	SKIPE IMPDEAD
	POPJ P,
	TLNN DDB,OUTBFB!OUTPB	; OUTPUT BUFFER SET UP?
	JRST CLSO1		; NO, FORGET ABOUT FLUSHING LAST BUFFER
	LDB AC1,PIOMOD		; WHAT MODE ARE WE IN?
	CAIGE AC1,DR		; DUMP MAYBE?
	PUSHJ P,OUT		; NO, DO LAST OUTPUT FOR BUFFERED MODE
CLSO1:
	PUSHJ P,UUSIDX		; PICK UP LINK TABLE INDEX
	POPJ P,
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,BLOK		; IS THERE DATA ON THE LINK?
	PUSHJ P,RFNMWT		; YES, WAIT FOR IT
	PUSHJ P,UUSIDX
	POPJ P,
	MOVSI AC2,CLSS		; SEE IF WE HAVE SENT A CLS YET
	TDNE AC2,IMPSTB-1(AC3)
	POPJ P,			; YES, ONE IS ENOUGH
	JRST USCLS		; SEND OUT A SEND-SIDE CLS

; CLOSE INPUT

CLSI:
	SKIPN IMPDEAD
	PUSHJ P,UURIDX
	POPJ P,
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,BLOK
	PUSHJ P,RFNMWT
	PUSHJ P,UURIDX
	POPJ P,
	MOVSI AC2,CLSS
	TDNE AC2,IMPSTB-1(AC3)
	POPJ P,
	JRST URCLS		; SEND OUT A RECEIVE-SIDE CLS

; UTILITY ROUTINES FOR UUO-LEVEL STUFF. ROUTINES TO SEND STR OR RTS
; CONNECTION INDEX MUST BE IN AC3
; POINTER TO USER TABLE MUST BE IN UUO
; DDB MUST BE SET UP
; CAN ONLY BE CALLED AT UUO LEVEL BECAUSE IT DOES XCTR'S

SNDRFC:
	HRRZM DDB,IMPDDB-1(AC3)
	PUSHJ P,IMPGET		; GET SOME FREE STORAGE
	PUSHJ P,CLKWAIT		; IF AT CLOCK LEVEL, WAIT FOR IT
	XCTR	XR,[MOVE AC2,LSLOC(UUO)]
	MOVEI TEM,RTS		; WHAT FLAVOR RETURN MESSAGE?
	TRNE AC2,1
	MOVEI TEM,STR		; SEND SIDE, GIVE HIM A STR INSTEAD
	PUSHJ P,GETIDX		; PICK UP INDEX OF CONNECTION AGAIN
	JRST NOCONN		; NONE THERE!
	PUSHJ P,MAKRF
	JRST UUOQ

; ROUTINE TO MAKE UP AN RFC BLOCK. MUST HAVE BLOCK IN AC1, CONNECTION INDEX IN AC3,
; OPCODE (STR OR RTS) IN TEM, DEVICE DATA BLOCK ADDRESS IN DDB

MAKRF:
	MOVSI AC2,RFCS		; NOTE AN RFC GOING OUT
	PUSHJ P,CSTAT
	PUSHJ P,CLRBLK
	MOVE AC2,LNKTAB-1(AC3)
	ANDCMI AC2,377		; CONTROL MESSAGES GO OUT ON LINK ZERO
	DPB AC2,ELINKP
	MOVEI AC2,10
	DPB AC2,SIZEP
	MOVEI AC2,12
	DPB AC2,COUNTP
	DPB TEM,OPCDP
	MOVE AC2,IMPLS-1(AC3)
	PUSHJ P,PSOCK1
	MOVE AC2,IMPFS-1(AC3)
	PUSHJ P,PSOCK2
	MOVEI AC2,5
	MOVEM AC2,TWC(AC1)
	CAIE TEM,RTS		; WHAT FLAVOR?
	JRST SNDBS		; SEND SIDE, GIVE HIM A BYTE SIZE
	PUSHJ P,GNLNK		; GET NEW AND UNIQUE LINK NUMBER
	DPB AC2,[POINT 8,LNKTAB-1(AC3),35]
	DPB AC2,SZLKP
	POPJ P,

SNDBS:
	MOVE AC2,IMPBS-1(AC3)
	DPB AC2,SZLKP
	POPJ P,

; ERROR ROUTINE FOR NO CONNECTION

NOCONN:
	JSP TAC,UUOMES
	ASCIZ /IMP IO WITHOUT REQUEST FOR CONNECTION
UUO/

; ERROR ROUTINE FOR NO CORE AT UUO LEVEL

NOCORE:
	TELCTR(NNCOR,<NO CORE AT UUO LEVEL>)
	JRST UUOERR

; ROUTINE TO SEND OUT A MESSAGE AT UUO LEVEL. WAITS FOR
; LINK TO UNBLOCK IF NEED BE. IF IMP DEAD, RELEASES STORAGE.
; ENTER WITH MESSAGE IN AC1

UUOQ:
	SKIPN IMPDEAD		; IMP DOWN?
	JRST UUODQ		; NO, GO AHEAD
UUODD:
	MOVEI IOS,HDEAD!IODERR	; YES, GIVE ERROR BITS
	ORB IOS,DEVIOS(DDB)
	JRST RELLST

UUODQ:
	PUSH P,TAC
	PUSH P,TEM
	LDB TAC,LINKP		; PICK UP LINK NUMBER
	JUMPE TAC,UUOQ0		; IF LINK ZERO, CHECK IT SEPARATELY
	MOVE IOS,DEVIOS(DDB)
	TRNN IOS,BLOK		; ARE WE BLOCKED?
	JRST UUOQNW		; NO, GO AHEAD
	PUSHJ P,RFNMWT		; YES, WAIT FOR LINK TO BECOME UNBLOCKED
	TRNE IOS,IODERR!IODTER!HDEAD!RSET
	JRST UUOQRL
UUOQNW:
	ORI IOS,BLOK		; NOTE LINK BLOCKED NOW
	MOVEM IOS,DEVIOS(DDB)
	JRST UUOQO

UUOQ0:
	PUSHJ P,L0PTR		; MAKE UP POINTER INTO 8-WORD HOST TABLES
	TDNN AC3,L0BLOK(AC2)	; SEE IF CONTROL LINK BLOCKED
	JRST UUOQ0N		; NOT BLOCKED, GO AHEAD
	MOVSI IOS,LNK0W		; NOTE WAITING FOR CONTROL LINK
	ORM IOS,DEVIOS(DDB)
	AOS L0WAIT		; NOTE ONE MORE WAITOR
	LDB TEM,RFNMTP		; PICK UP TIME TO WAIT FOR RFNM
	PUSHJ P,TW
	JRST UUOQR1		;TIMED OUT - CLEAR BIT AND GO AWAY
	MOVE IOS,DEVIOS(DDB)
	TRNN IOS,IODERR!IODTER!HDEAD!RSET
	JRST UUOQ0		; GO BACK AND CHECK AGAIN
UUOQRL:
	PUSHJ P,RELLST
	JRST UUOQXT

UUOQR1:
	ANDCAM AC3,L0BLOK(AC2)
	JRST UUOQRL

UUOQ0N:
	ORM AC3,L0BLOK(AC2)	; NOTE LINK BLOCKED NOW
UUOQO:
	PUSHJ P,QOUT		; SEND MESSAGE OUT
UUOQXT:
	POP P,TEM
	POP P,TAC
	POPJ P,

; ROUTINE TO WAIT FOR THE LINK TO CLEAR
; CALL WITH J, DDB AND IOS SET UP
; RESTORES IOS, CLOBBERS TEM

RFNMWT:
	SKIPE IMPDEAD
	POPJ P,
	MOVSI IOS,BLOKW
	ORM IOS,DEVIOS(DDB)
	PUSH P,TEM
	LDB TEM,RFNMTP
	PUSHJ P,TW
	JRST [	POP P,TEM
		SKIPN RECOVER
		SETOM RECOVER
		POPJ P,]
	POP P,TEM
	MOVE IOS,DEVIOS(DDB)
	TRNN IOS,HDEAD!RSET!IODERR!IODTER
	TRNN IOS,BLOK
	POPJ P,
	JRST RFNMWT		; GO BACK AND WAIT SOME MORE

; ROUTINE TO BLESS UUO LEVEL OUTPUTS BASED ON HOST STATUS.

UUOOOK:
	PUSHJ P,UUSIDX
	POPJ P,
	PUSHJ P,UUOCHK		; CHECK FOR CONNECTION
	POPJ P,			; NONE THERE OR HOST DEAD
	PUSHJ P,UUSIDX		; GET INDEX INTO LINK TABLE
	JRST NOCONN
	MOVE AC2,IMPSTB-1(AC3)
	TLNN AC2,CLSR		; HAS HE SENT US A CLS?
	JRST CPOPJ1		; NO, OUTPUT IS OK
	MOVEI IOS,IODERR	; YES, ERROR
	ORB IOS,DEVIOS(DDB)
	POPJ P,

UUOIOK:
	PUSHJ P,UURIDX
	POPJ P,
	PUSHJ P,UUOCHK
	POPJ P,
	PUSHJ P,UURIDX		; PICK UP LINK TABLE INDEX
	JRST NOCONN
	JRST CPOPJ1

; ROUTINE TO CHECK FOR PROPER CONNECTION AND HOST DEAD.
; SKIPS ON SUCCESS. FAILURE MEANS EITHER HOST DEAD OR NO CONNECTION.

UUOCHK:
	SKIPE IMPDEAD
	POPJ P,
	MOVE AC2,IMPSTB-1(AC3)
	TLNN AC2,RFCS		; HAS RFC BEEN SENT?
	JRST NOCONN		; NO, NOTE CONNECTION NOT OPEN YET
	TLNE AC2,RFCR		; YES, HAS IT BEEN ACKNOWLEDGED YET?
	JRST CPOPJ1		; YES, SUCCESS
	MOVSI IOS,RFCW		; NO, WAIT FOR IT
	ORM IOS,DEVIOS(DDB)
	LDB TEM,RFCTP		; DON'T WAIT FOR MORE THAN 5 MINUTES
	PUSH P,IMPLS-1(AC3)	; SAVE SOMETHING SO WE CAN RESET AC3 AFTER TIME WAIT
	PUSHJ P,TW		; DO A TIMED WAIT
	JRST UUOCHL		; ERROR RETURN IF TIMEOUT
	POP P,AC2		; RETRIEVE LOCAL SOCKET NUMBER
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,IODERR!IODTER
	POPJ P,			; LEAVE ON ERROR
	PUSHJ P,GETIDX		; GET CURRENT AC3 (COULD'VE CHANGED DURING WAIT)
	POPJ P,			; ERROR - AC3 NOT ONLY CHANGED, ITS GONE FOREVER!?!?
	JRST UUOCHK		; GO THROUGH THE LOOP AGAIN
UUOCHL:
	POP P,AC2
	POPJ P,			; ERROR RETURN BECAUSE OF TIMEOUT

SETERR:
	ORI IOS,IODERR		; SET ERROR BIT
	MOVEM IOS,DEVIOS(DDB)
	POPJ P,

; ROUTINE TO INITIALIZE A CONNECTION
; ENTER WITH CONNECTION INDEX IN AC3
; LOCAL SOCKET NUMBER IN AC2
; FOREIGN SOCKET NUMBER IN TEM
; HOST-LINK NUMBER IN DAT
; POINTER TO USER TABLE IN UUO

CLRSKT:
	MOVEM AC2,IMPLS-1(AC3)	; SET LOCAL SOCKET NUMBER
	MOVEM TEM,IMPFS-1(AC3)	; AND FOREIGN SOCKET NUMBER
	MOVEM DAT,LNKTAB-1(AC3)	; AND HOST-LINK NUMBER
	XCTR	XR,[MOVE DAT,BSLOC(UUO)]
	TRNE AC2,1		;IF A SEND SOCKET, THEN
	MOVEM DAT,IMPBS-1(AC3)	; SET BYTE SIZE
	SETZM IMPRFQ-1(AC3)
	SETZM IMPSTB-1(AC3)
	HRRZM DDB,IMPDDB-1(AC3)
	POPJ P,

; ROUTINE TO REQUEUE SOMEONE INTO THE RUN QUEUE
; ENTER WITH J CONTAINING THE JOB NUMBER

QRUN:
	LDB J,PJOBN
	SKIPL TIM(DDB)		; MAKE SURE TIMEOUT IS CLEARED
	SOS TIMWAIT		; NOTE ONE LESS WAITOR
	SETOM TIM(DDB)
	MOVM DSER,JOBQUE(J)
	CAIE DSER,IOWQ
	POPJ P,
	MOVE DSER,JBTSTS(J)
	TLNN DSER,RUN
	POPJ P,
	MOVNI DSER,RUNQ
	MOVEM DSER,JOBQUE(J)
	JRST REQUE

; ROUTINE TO CHANGE THE STATUS BITS
; ENTER WITH STATUS BIT TO SET IN AC2
; CONNECTION INDEX IN AC3

CSTAT:
	TLO AC2,ANYC
	ORM AC2,IMPSTB-1(AC3)
	PUSH P,DDB
	SKIPN DDB,IMPDDB-1(AC3)
	JRST CSTAT1
	MOVSI AC2,INTIMS
	PUSHJ P,INTCOM
CSTAT1:
	POP P,DDB
	POPJ P,

; ROUTINE TO GET A CONNECTION INDEX FROM A LOCAL SOCKET NUMBER IN AC2
; RETURNS INDEX IN AC3

GETIDX:
	SKIPN AC3,FFLNK
	POPJ P,
GETID1:
	CAMN AC2,IMPLS-1(AC3)
	JRST CPOPJ1
	SOJG AC3,GETID1
	POPJ P,

; ROUTINE TO WAIT FOR ALLOCATION

ALLOCW:
	SKIPE IMPDEAD
	POPJ P,
	MOVSI IOS,ALLW
	ORM IOS,DEVIOS(DDB)
	PUSH P,TEM
	MOVNI TEM,IOWQ		; NO INTERNAL TIMEOUT FOR THIS
	MOVEM TEM,JOBQUE(J)
	LDB TEM,ALLTP		; WE WILL WAIT ONLY SO LONG FOR ALLOCATION
	PUSHJ P,TW
	JRST [	POP P,TEM	; GET OUR AC BACK
		JRST ALLXIT]
	POP P,TEM
	MOVE IOS,DEVIOS(DDB)	; CLEAR ALLOCATION WAIT BIT
	TRNN IOS,IODERR!IODTER!HDEAD!RSET!TMO
	AOS (P)
ALLXIT:
	MOVSI IOS,ALLW
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,

; ROUTINE TO CHECK ALLOCATION AND WAIT FOR IT IF NECESSARY

ALLOK1:
	PUSHJ P,ALLOCW		; NO, WAIT FOR SOME ROOM
	POPJ P,			; LEAVE ON ERRORS
ALLOK:
	PUSHJ P,UUSIDX		; PICK UP INDEX INTO LINK TABLE ANEW
	JRST NOCONN		; NONE THERE! UNTHINKABLE!
	MOVE IOS,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLNE IOS,CLSS!CLSR	; HAVE WE BEEN CLOSED?
	JRST ALLERS		; YES, LEAVE NOW, SET ERROR BITS
	MOVE IOS,IMPBS-1(AC3)	; PICK UP BYTE SIZE
	SKIPLE MAL(DDB)		; DO WE HAVE ANY MESSAGE ALLOCATION?
	CAMLE IOS,BAL(DDB)	; IS THERE ROOM FOR AT LEASE ONE BYTE?
	JRST ALLOK1
	JRST CPOPJ1		; YES, GO AHEAD

ALLERS:
	MOVEI IOS,IODERR
	ORB IOS,DEVIOS(DDB)	; SET ERROR BITS TO GET THROUGH UUOCON WITHOUT LOSING
	POPJ P,

; ROUTINE TO GET LINK TABLE INDEX FROM A DDB POINTER - SEND SIDE

UUSIDX:
	SKIPN AC3,FFLNK
	POPJ P,
	PUSH P,DDB
	HRRZ DDB,DDB
UUSID1:
	MOVE AC2,IMPLS-1(AC3)		; WHAT GENDER SOCKET
	TRNN AC2,1
	JRST UUSID2
	CAMN DDB,IMPDDB-1(AC3)
	AOSA -1(P)			;SUCCESS. SKIP RETURN
UUSID2:
	SOJG AC3,UUSID1
	POP P,DDB
	POPJ P,

; ROUTINE TO GET LINK TABLE INDEX FROM A DDB POINTER - RECEIVE SIDE

UURIDX:
	SKIPN AC3,FFLNK
	POPJ P,
	PUSH P,DDB
	HRRZ DDB,DDB
UURID1:
	MOVE AC2,IMPLS-1(AC3)		; WHAT GENDER SOCKET
	TRNE AC2,1
	JRST UURID2
	CAMN DDB,IMPDDB-1(AC3)
	AOSA -1(P)			;SUCCESS
UURID2:
	SOJG AC3,UURID1
	POP P,DDB
	POPJ P,

; THIS IS CALLED AT CONNECT AND LISTEN TO DETERMINE
; IF THERE IS ANOTHER SOCKET OPEN ON THIS DDB, AND IF IT IS
; NOT THE SEND-RECEIVE MATE, KILL IT WITHOUT TOO MUCH ADO.
; ENTER WITH SOCKET NUMBER TO BE OPENED IN AC2

NSCHECK:

	SKIPN IMPDEAD
	SKIPN AC3,FFLNK
	POPJ P,
	XORI AC2,1		; PRODUCE THE MATING SOCKET NUMBER
	MOVEI AC1,(DDB)
NSCLOP:
	CAMN AC1,IMPDDB-1(AC3)	; IS THIS THE SAME DDB?
	CAMN AC2,IMPLS-1(AC3)	; YES, IS IT THE APPROPRIATE SOCKET?
	JRST [	SOJG AC3,NSCLOP
		POPJ P,]
	MOVE AC2,IMPLS-1(AC3)	; PICK UP THE LOSING SOCKET NUMBER
	MOVE IOS,DEVIOS(DDB)
	TRNE IOS,BLOK
	PUSHJ P,RFNMWT		; WAIT FOR ANY DATA ON THE LINK TO BO BY
	PUSHJ P,GETIDX		; GET BACK THE INDEX TO THE STRANGE SOCKET
	POPJ P,
	MOVE AC1,IMPSTB-1(AC3)
	TLNE AC1,RFCS
	TLNE AC1,CLSS
	JRST NSCZLK
	PUSH P,AC2
	PUSHJ P,USCLS
	POP P,AC2
	PUSHJ P,GETIDX
	POPJ P,
NSCZLK:
	SETZM IMPDDB-1(AC3)
	JRST ZEROLK

; FREE STORAGE MANAGER FOR IMP SERVICE

IMPGET:
	PUSH P,AC2
	PUSH P,AC3
	MOVEI AC3,TLNG
	PUSHJ P,FSGET
	JRST SCROUNGE
	SKIPG IMPSPN		; NEED ANY SPARES?
	JRST IMPGSX		; NO
	PUSH P,AC1		; YES, SAVE THIS BLOCK AND GET SOME
IMPGE1:
	MOVEI AC3,TLNG
	PUSHJ P,FSGET
	JRST IMPGX		; NO MORE, LEAVE WITH THE GOODIES
	CONO PI,IMPOFF
	EXCH AC1,IMPFSL
	HRRZM AC1,@IMPFSL
	CONO PI,IMPON
	SOSLE IMPSPN		; NOTE ONE LESS BLOCK NEEDED
	JRST IMPGE1		; IF ANY MORE, GO GET THEM
IMPGX:
	POP P,AC1
IMPGSX:
	HRRZ AC3,-1(AC1)	; PICK UP POINTER TO TOP OF BLOCK
	HLRZ AC3,(AC3)		; GET SIZE OF BLOCK
	SUBI AC3,400000+TDATA+2	; SUBTRACT OFF OVERHEAD WORDS
	MOVEM AC3,TLEN(AC1)	; PUT THAT AS LENGTH OF BLOCK
	MOVEM AC3,TWC(AC1)	; AND AS FULL WORD COUNT
	PUSHJ P,LEGAL		; CHECK IT OUT FIRST
	JRST IMPGET		; BAD BLOCK, TRY FOR ANOTHER
	AOS -2(P)		; SET SKIP RETURN
	SETZM TLINK(AC1)	; CLEAR OUT LINKAGE WORD
IMPGEX:
	POP P,AC3
	POP P,AC2
	POPJ P,

; HERE WE CAN'T GET FS FROM THE SYSTEM, SEE IF WE CAN SCROUNGE A BLOCK

SCROUNGE:

	CONO PI,IMPOFF
	SKIPN AC1,IMPFSL
	JRST SCRNG1
	MOVE AC3,(AC1)
	MOVEM AC3,IMPFSL
	CONO PI,IMPON
	PUSHJ P,LEGAL		; IS IT A VALID BLOCK?
	JRST SCRERR		; NO, FLUSH SPARE LIST
	AOS NSPSUS
	AOS IMPSPN
	JRST IMPGSX

SCRERR:
	SETZM IMPFSL		; BAD BLOCK, KILL SPARE LIST
	MOVEI AC1,10		; AND REFILL IT
	MOVEM AC1,IMPSPN
	JRST IMPGEX		; GIVE ERROR RETURN

SCRNG1:
	CONO PI,IMPON
	JRST IMPGEX

; ROUTINE TO RELEASE FREE STORAGE
; REPLENISHES SPARE LIST IF NECESSARY

IMPREL:
	ANDI AC1,-1
	PUSHJ P,LEGAL
	POPJ P,
	SKIPG IMPSPN
	JRST FSGIVE
	SOS IMPSPN
	CONO PI,IMPOFF
	EXCH AC1,IMPFSL
	MOVEM AC1,@IMPFSL
	CONO PI,IMPON
	POPJ P,

; ROUTINE TO CHECK THE LEGALITY OF A FS BLOCK
; RETURNS +1 IF BLOCK BAD
; RETURNS +2 IF BLOCK OK

LEGAL:
	SKIPN DEBMODE		; ARE WE DEBUGGING?
	JRST CPOPJ1		; NO, LEAVE IMMEDIATELY
	PUSH P,AC2
	PUSH P,AC3
	HRRZ AC2,-1(AC1)
	HLRZ AC3,(AC2)		; PICK UP COUNT HALF-WORD
	CAIN AC3,400000+TLNG!7+1
	JRST LEGPCH
LEGERR:
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ /BAD BLOCK IN IMPSER
CALLERS = /]
	DISARG LOC,<-22(P)>
	[ASCIZ /, /]
	DISARG LOC,<-23(P)>
	[ASCIZ /, /]
	DISARG LOC,<-24(P)>
	[ASCIZ /, /]
	DISARG LOC,<-25(P)>
	[ASCIZ /
/]
	-1
	POPACS
	POP P,AC3
	POP P,AC2
	POPJ P,

LEGPCH:
	SUBI AC2,TLNG!7+1
	CAIE AC2,-2(AC1)
	JRST LEGERR
	POP P,AC3
	POP P,AC2
	JRST CPOPJ1

; ROUTINE TO ASSIGN A NEW LINK NUMBER
; ENTER WITH CONNECTION INDEX IN AC3
; RETURNS LINK NUMBER IN AC2

MAXLNK←←=60
MINLNK←←=10

GNLNK:
	PUSH P,AC1
	PUSH P,DSER
	MOVE AC2,LSTLNK		; PICK UP ONE PLUS LAST ASSIGNED LINK NUMBER
	CAIL AC2,MINLNK		; LESS THAN MINIMUM LINK NUMBER?
	CAILE AC2,MAXLNK-1	; GREATER THAN MAXIMUM LINK NUMBER?
	MOVEI AC2,MINLNK	; YES, START AT THE BOTTOM AGAIN
	MOVEM AC2,LSTLNK
	ADDI AC2,1
GNLNK5:
	SKIPN AC1,FFLNK		; SCAN DOWN LINK TABLE FOR DUPLICATES
	JRST GNLNK6
GNLNK1:
	LDB DAT,[POINT 8,LNKTAB-1(AC1),35]
	CAIN DAT,(AC2)		; SAME LINK?
	JRST GNLNK2		; YES, SEE IF IT IS THE SAME HOST TOO
	CAMN AC2,LSTLNK		; HIT OURSELVES YET?
	JRST GNOLNK		; YES, NO LINK!!!
GNLNK4:
	SOJG AC1,GNLNK1
GNLNK6:
	MOVEM AC2,LSTLNK
	POP P,DSER
	POP P,AC1
	POPJ P,

GNLNK2:
	MOVE DSER,LNKTAB-1(AC3)
	XOR DSER,LNKTAB-1(AC1)
	TRNE DSER,177400
	JRST GNLNK4		; IF DIFFERENT HOSTS, IS OK
	ADDI AC2,1		; BUMP LINK NUMBER
	CAILE AC2,MAXLNK
	MOVEI AC2,MINLNK
	JRST GNLNK5

GNOLNK:
	TELCTR(NOLKS,<NO NEW LINK!!!>)
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

; ROUTINE TO SEE IF A TABLE ENTRY MAY BE CLEARED.
; ENTER WITH ENTRY INDEX IN AC3
; IMPDDB-1(AC3) MUST BE ZERO!!!

ZEROLK:
	MOVE AC1,IMPSTB-1(AC3)	; PICK UP STATUS BITS
	TLNE AC1,RFCR!RFCS	; ANYTHING HAPPENED ON THE SEND SIDE?
	JRST ZEROL1		; YES, SEE IF WE HAVE GOTTEN THE CLSS
	TLNE AC1,CLSS		; HAVE WE SENT A CLS?
	TLNE AC1,CLSR		; YES, HAVE WE RECEIVED THE MATCHING ONE?
	JRST KILLNK		; YES, GO TEST THE RECEIVE SIDE
	POPJ P,			; NO, DON'T RELEASE SLOT YET

ZEROL1:
	TLNE AC1,CLSS		; HAVE WE SENT A CLS YET?
	TLNN AC1,CLSR		; YES, MAKE SURE WE HAVE BOTH SENT AND RECEIVED ONE
	POPJ P,
	JRST KILLNK

; ROUTINE TO SEARCH DOWN QUEUED RFC LIST FOR AN RFC THAT MATCHES OUR SOCKET
; UUO LEVEL ONLY. DDB MUST BE SET UP AS WELL AS AC3

DISPQ:
	SETZ TAC1,		; PREPARE TO SCAN DOWN QUEUED RFC'S
RFCQL:
	PUSHJ P,LEGAL		; BLESS BLOCK ADDRESS
	JRST [	SETZM IMPRFQ-1(AC3)
		POPJ P,]	; GIVE NO FIND RETURN
	PUSHJ P,GSOCK2		; PICK UP LOCAL SOCKET NUMBER
	CAMN AC2,IMPLS-1(AC3)	; DOES IT MATCH?
	JRST RFCQD1
RFCQI:
	MOVEI TAC1,(AC1)	; NO, PUT THIS BLOCK AS LAST BLOCK
	HLRZ AC1,TLINK(AC1)	; PICK UP ADDRESS OF NEXT BLOCK
	JUMPN AC1,RFCQL
	POPJ P,

RFCQD1:
	PUSHJ P,GSOCK1		; PICK UP FOREIGN SOCKET NUMBER
	CAME AC2,IMPFS-1(AC3)	; DOES IT MATCH?
	SKIPGE IMPFS-1(AC3)	; OR IS IT UNUSED?
	JRST RFCQD2
	JRST RFCQI

RFCQD2:
	LDB DAT,ELINKP		; PICK UP HOST NUMBER
	XOR DAT,LNKTAB-1(AC3)
	TRNE DAT,177400		; DOES IT MATCH
	SKIPN LNKTAB-1(AC3)	; OR IS IT OPEN?
	JRST RFCQD3		; YES, LOAD US UP
	JRST RFCQI

RFCQD3:
	LDB DAT,SRCP		; PICK UP HOST NUMBER
	DPB DAT,[POINT 8,LNKTAB-1(AC3),27]
	MOVEM AC2,IMPFS-1(AC3)
	LDB AC2,SZLKP		; PICK UP SIZE-LINK FIELD
	LDB DSER,OPCDP		; GET OPCODE
	PUSHJ P,SETHB		; SET LINK NUMBER OR BYTE SIZE
	PUSHJ P,UNLRFQ		; UNLINK RFC FROM QUEUE
	PUSHJ P,IMPREL		; AND GIVE IT BACK
	JRST CPOPJ1		; GIVE SUCCESS RETURN

; ROUTINE TO APPEND AN ENTIRE RFC QUEUE ONTO ILIST
; ENTER WITH RFC QUEUE IN AC1 (XWD <LAST>,<FIRST>)

APNLST:
	SETZM IMPRFQ-1(AC3)
	PUSHJ P,LEGAL		; IS IT A REASONABLE ADDRESS?
	POPJ P,			; NO, LEAVE NOW
	CONO PI,IMPOFF
	SKIPN AC2,ILIST
	JRST APNLS1
	MOVSS AC2
	HRLM AC1,TLINK(AC2)
	HLLM AC1,ILIST
APNLS2:
	CONO PI,IMPON
	POPJ P,

APNLS1:
	MOVEM AC1,ILIST
	JRST APNLS2

; ROUTINE TO UNLINK A RFC FROM THE QUEUED RFC LIST
; MUST HAVE PREDECESSOR IN TAC1 AND INDEX IN AC3

UNLRFQ:
	HLRZ AC2,TLINK(AC1)
	TRNN TAC1,-1
	JRST UNLRF1
	HRLM AC2,TLINK(TAC1)
	SKIPN AC2
	HRLM TAC1,IMPRFQ-1(AC3)
	POPJ P,

UNLRF1:
	HRRM AC2,IMPRFQ-1(AC3)
	SKIPN AC2
	SETZM IMPRFQ-1(AC3)
	POPJ P,

; ROUTINE TO GO INTO A WAIT STATE BUT START A COUNTDOWN TOO
; ENTER WITH WAIT BIT IN IOS, TIME TO WAIT IN TEM
; SKIPS IF WAIT SATISFIED, DOESN'T SKIP IF TIMED OUT

JIFMIN←←=60*JIFSEC

TW:
	JUMPE TEM,TIMAGN	; NO TIME MEANS WAIT INDEFINITELY
	IMULI TEM,2*JIFSEC	; SCALE TO TIX
TIMEDW:
	ADD TEM,TIME		; WRAP AROUND
	CAML TEM,[JIFDAY:	=24*=60*JIFMIN]
	SUB TEM,JIFDAY
	MOVEM TEM,TIM(DDB)
	AOS TIMWAIT		; NOTE THERE IS ANOTHER WAITER
TIMAGN:
	MOVNI TEM,IOWQ
	MOVEM TEM,JOBQUE(J)
	PUSHJ P,WSCHED
	MOVE TEM,DEVIOS(DDB)
	TDNN TEM,IOS		; IS THE WAIT SATISFIED?
	JRST TIMXIT		; YES, LEAVE NORMALLY
	TRNN TEM,TMO!IODERR!IODTER	; NO, DID WE TIME OUT?
	JRST TIMAGN		; NO, SPURIOUS WAKEUP (AS IN ↑C - CONT)
TIMXIT:
	ANDCA IOS,DEVIOS(DDB)	; CLEAR WAIT BIT
	TRZE IOS,TMO		; DID WE TIME OUT?
	JRST TIMXT1		; YES
	AOS (P)			; SET SKIP RETURN
TIMXT1:
	MOVEM IOS,DEVIOS(DDB)
	POPJ P,

; ROUTINE TO WAIT FOR A MATCHING CLS
; ENTER WITH CONNECTION INDEX IN AC3
; RETURNS WITH CONNECTION INDEX IN AC3 AND STATE BITS IN AC1

TCLSW:
	PUSH P,AC2
	MOVE AC2,IMPLS-1(AC3)
	MOVSI IOS,CLSW
	ORM IOS,DEVIOS(DDB)
	LDB TEM,CLSTP
	PUSHJ P,TW
	JFCL
	PUSHJ P,GETIDX
	JRST NOCONN
	POP P,AC2
	MOVSI AC1,CLSR
	ORB AC1,IMPSTB-1(AC3)
	POPJ P,

; ROUTINE TO SEND AN ALLOCATION
; ENTER WITH NUMBER OF BITS OF ALLOCATION HE HAS LEFT IN AC3,
; AND NUMBER OF MESSAGES HE HAS IN AC2

SNDBAL:
	PUSH P,TAC
	PUSH P,TAC1
	PUSH P,AC1
	MOVNI TAC1,(AC3)	; PUT BIT ALLOCATION IN TAC1
	ADD TAC1,NHBA(DDB)	; CONVERT TO NUMBER OF BITS HE NEEDS
	MOVNI TAC,(AC2)		; AND MESSAGE ALLOCATION IN TAC
	ADD TAC,NHMA(DDB)	; CONVERT TO NUMBER OF MESSAGES HE NEEDS
	PUSHJ P,IMPGET
	JRST NOCORE
	SETZM TDATA(AC1)
	SETZM TDATA+1(AC1)
	SETZM TDATA+2(AC1)
	PUSHJ P,UURIDX
	JRST NOCONN
	DPB TAC1,[POINT 32,TDATA+3(AC1),31]
	ADDM TAC1,HBA(DDB)	; INCREMENT BIT ALLOCATION
	DPB TAC,[POINT 16,TDATA+2(AC1),31]
	ADDM TAC,HMA(DDB)	; ADD THAT IN TO HIS MESSAGE ALLOCATION
	MOVE TAC,IMPSTB-1(AC3)	; IS THE SOCKET STILL OPEN?
	TLC TAC,RFCS!RFCR	; MAKE SURE THE SOCKET IS REALLY OPEN
	TLNN TAC,RFCS!RFCR	; IF NOT, LEAVE NOW
	TLNE TAC,CLSS!CLSR
	JRST SNDPOP		; NO, DON'T SEND ANY MORE CONTROL COMMANDS
	MOVEI TAC,ALL
	DPB TAC,OPCDP
	MOVE TAC,LNKTAB-1(AC3)
	DPB TAC,OLINKP
	ANDCMI TAC,377
	DPB TAC,ELINKP
	MOVEI TAC,10
	DPB TAC,SIZEP
	DPB TAC,COUNTP
	PUSHJ P,UUOQ
SNDPPX:
	POP P,AC1
	POP P,TAC1
	POP P,TAC
	POPJ P,

SNDPOP:
	PUSHJ P,IMPREL		; CONNECTION CLOSED, RELEASE STORAGE AND LEAVE
	JRST SNDPPX

; ROUTINE TO CHECK AND SEND INITIAL ALLOCATION
; MUST BE CALLED AT UUO LEVEL ONLY

INIALL:
	SKIPE NHMA(DDB)		; IS THERE A NOMINAL ALLOCATION YET?
	JRST CHKENF		; YES, SEE IF IT HAS BEEN SENT YET
	MOVEI AC2,DEFBAL	; GIVE DEFAULT BIT ALLOCATION
	MOVEM AC2,NHBA(DDB)
	LSH AC2,-1
	MOVEM AC2,NHBA2(DDB)
	MOVEI AC2,DEFMAL	; AND A BUNCH OF MESSAGES
	MOVEM AC2,NHMA(DDB)
	LSH AC2,-1
	MOVEM AC2,NHMA2(DDB)
CHKENF:
	MOVE AC3,HBA(DDB)	; PICK UP CURRENT BIT ALLOCATION
	ADD AC3,BIIL(DDB)	; ADD IN AMOUNT IN INPUT LIST
	MOVE AC2,HMA(DDB)	; SAME FOR MESSAGE ALLOCATION
	ADD AC2,MIIL(DDB)
	CAML AC3,NHBA2(DDB)	; IS BIT ALLOCATION LESS THAN HALF DEPLETED?
	CAMGE AC2,NHMA2(DDB)	; OR MESSAGE ALLOCATION?
	PUSHJ P,SNDBAL		; YES, SEND HIM SOME MORE
	POPJ P,

; ROUTINE TO SEND OUT A SEND-SIDE CLS FROM UUO LEVEL
; CALL WITH DDB SET UP

USCLS:
	PUSHJ P,IMPGET
	JRST NOCORE
	PUSHJ P,UUSIDX
	JRST IMPREL
	SETZM BAL(DDB)		; NOTE NO MORE ALLOCATION
	SETZM MAL(DDB)
USCLS1:
	MOVE AC2,LNKTAB-1(AC3)
	ANDI AC2,177400
	LSH AC2,14		; PUT HOST NUMBER IN PROPER SLOT
	PUSHJ P,MCLSB		; MAKE UP A CLOSE BLOCK
	MOVE AC2,IMPLS-1(AC3)	; PUT IN OUR SOCKET NUMBER
	PUSH P,AC2		;SAVE SOCKET NUMBER
	PUSHJ P,PSOCK1
	MOVE AC2,IMPFS-1(AC3)	; PUT IN HIS SOCKET NUMBER
	PUSHJ P,PSOCK2
	MOVSI AC2,CLSS		; HAS CLOSE ALREADY BEEN SENT?
	TDNE AC2,IMPSTB-1(AC3)
	JRST [SUB P,[1,,1]
	      JRST IMPREL]	; YES, RELEASE STORAGE AND LEAVE
	PUSHJ P,CSTAT		; NO, SET CLS SENT BIT
	PUSHJ P,UUOQ		; AND SEND OUT THE CLS
	POP P,AC2		;GET BACK SOCKET NUMBER
	PUSHJ P,GETIDX		;AND INDEX
	JRST NOCONN		;ARGGGGHHH!!!
	POPJ P,

; RECEIVE SIDE CLS AT UUO LEVEL
; CALL WITH DDB SET UP

URCLS:
	PUSHJ P,IMPGET
	JRST NOCORE
	PUSHJ P,UURIDX
	JRST IMPREL
	JRST USCLS1
;: IMPUUO[J17,SYS] EOF.
;: IMPINT[J17,SYS]
COMMENT ⊗   VALID 00014 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	SUBTTL IMP INTERRUPT-LEVEL DRIVERS - JAM, SEPT '71
C00005 00003	 INPUT BEGINS BY COMING TO HERE. READ THE 72-BIT LEADER THEN
C00008 00004	 INPUT ROUTINE, READ SUCCESSIVE WORDS AND ZERO OUT BYTES IN LAST WORD
C00010 00005	 WE GET HERE IF AT INTERRUPT LEVEL WE HAVE A WORD AND NO BUFFER TO PUT IT IN
C00012 00006	 WE GET HERE WHEN INPUT IS DONE.
C00013 00007	 ROUTINE TO SET THE WORD COUNT IN THE LAST BUFFER AND
C00015 00008	 ROUTINE TO SET UP THE BYTE POINTER AND WORD COUNT FOR A BUFFER
C00017 00009	 CLOCK LEVEL ROUTINE TO GET A SPARE BLOCK
C00019 00010	 MAIN OUTPUT LOOP
C00023 00011	 ROUTINE TO QUEUE A MESSAGE FOR OUTPUT.
C00025 00012	 ROUTINE TO SET THE OUTPUT WORD COUNT AND BYTE POINTER
C00027 00013	 INPUT INTERRUPT COMES HERE
C00029 00014	BEND IMPSER
C00030 ENDMK
C⊗;

SUBTTL IMP INTERRUPT-LEVEL DRIVERS - JAM, SEPT '71

; CONO BITS . . .

TEST←←100000		; ENTER TEST MODE (DOES ANAL-CRANIAL INVERSION)
STRIN←←040000		; START INPUT, SETS STOP, CLEARS INPUT END
I32←←020000		; SET INPUT BYTE SIZE TO 32B IF IDPIEN SET
O32←←010000		; SET OUTPUT BYTE SIZE TO 32B IF ODPIEN SET
CLRST←←004000		; CLEAR STOP AFTER INPUT BIT
CLRWT←←002000		; CLEAR WAITING TO INPUT BIT
STROUT←←000200		; START OUTPUT
FINO←←000100		; FINISH OUTPUT (LAST BIT HAS BEEN SENT)
IEPIEN←←000040		; ENABLE CHANGE OF INPUT END INTERRUPT CHANNEL
IDPIEN←←000020		; ENABLE CHANGE OF INPUT BYTE SIZE AND INPUT DONE INTERRUPT CHANNEL
ODPIEN←←000010		; ENABLE CHANGE OF OUTPUT BYTE SIZE AND OUTPUT DONE INTERRUPT CHANNEL

ISTART←←STRIN!CLRWT!IEPIEN!IDPIEN!IMPCHN

; CONI BITS . . .

RDY←←200000		; IMP READY
TEST←←100000		; ENTER TEST MODE (DOES ANAL-CRANIAL INVERSION)
IMPERR←←040000		; IMP ERROR
IDONE←←020000		; INPUT DONE
IEND←←010000		; INPUT END.
ODONE←←004000		; OUTPUT DONE

; INPUT BEGINS BY COMING TO HERE. READ THE 72-BIT LEADER THEN
; SET BYTE SIZE AND READ REST OF MESSAGE.

↑IBEGIN:
	PUSHJ P,SETUP		; SET UP BYTE POINTER AND COUNT
	JRST IHANG		; NO FREE STORAGE, HANG AND WAIT FOR IT
	CONI IMP,AC3
	BLKI IMP,IMPBKO		; READ FIRST WORD
	JFCL
	MOVE AC1,IMPICUR	; SET TOP BLOCK OF INPUT
	MOVEM AC1,IMPITOP
	TRNE AC3,IEND		; IS THAT ALL THE IMP HAS FOR US?
	JRST INPDONE		; YES, GO PUT LIST ON ILIST
	CONO IMP,CLRWT		; CLEAR THE WAIT FLAG AND READ NEXT WORD
	PUSHJ P,ISYNC
SECOND:
	CONI IMP,AC3
	BLKI IMP,IMPBKO		; GET SECOND WORD
	JFCL
	TRNE AC3,IEND		; DONE YET?
	JRST INPDONE
	MOVE AC1,IMPITOP	; PICK UP ADDRESS OF BLOCK CONTAINING LEADER
	LDB AC2,SIZEP		; PICK UP BYTE SIZE OF TRANSMISSION
	SETOM IMPIFM		; ASSUME 36-BIT MODE
	SKIPG AC3,BPW(AC2)	; PICK UP BITS PER WORD FOR THIS BYTE SIZE
	MOVEI AC3,44		; IF ILLEGAL BYTE SIZE, IT DOESN'T MATTER
	CAIN AC3,40
	SETZM IMPIFM
	IDIVM AC3,AC2		; NUMBER OF BYTES/WD IN AC2
	MOVEI AC3,(AC2)
	LDB AC2,COUNTP
	IDIVI AC2,(AC3)		; # WORDS IN AC2, # BYTES IN LAST WORD IN AC3
	MOVEM AC2,IMPINW
	SETZM IMPIMS		; PREPARE FOR INTEGRAL NUMBER OF WORDS
	JUMPE AC3,INPLOP	; INTEGRAL NUMBER OF WORDS GETS A ZERO MASK
	LDB AC2,SIZEP
	MOVNS AC2		; GET MASK FOR LAST WORD
	IMULI AC2,(AC3)
	MOVSI AC1,400000
	ASH AC1,1(AC2)		; WE HAVE NOW SPREAD THE BIT OVER THE BYTES
	MOVEM AC1,IMPIMS	; AND THAT IS THE MASK

; INPUT ROUTINE, READ SUCCESSIVE WORDS AND ZERO OUT BYTES IN LAST WORD

INPLOP:
	MOVEI AC1,CLRWT!CLRST!IDPIEN!IEPIEN!IMPCHN
	SKIPN IMPIFM		; WHAT BYTE SIZE?
	ORI AC1,I32		; 32, SET BIT
	CONO IMP,(AC1)
	PUSHJ P,ISYNC
INP1:
	CONI IMP,AC3
	BLKI IMP,IMPBKO
	JFCL
	SOSL IMPINW		; LAST WORD YET?
	JRST INPET		; NO, PROCEED ALONG
	HRRZ AC2,IMPBKO
	MOVE AC1,IMPIMS		; YES, PICK UP MASK
	ANDM AC1,(AC2)		; ZERO OUT BYTES IN LAST WORD
	SETZM IMPIMS		; AND ZERO ALL SUCCESSIVE WORDS
INPET:
	TRNE AC3,IEND
	JRST INPDONE
	SKIPGE IMPBKO		; HAS THE COUNT OVERFLOWED?
	JRST INPLOP		; NO, GO BACK FOR NEXT WORD
	MOVEI AC1,CLRWT!IDPIEN!IEPIEN!IMPCHN
	SKIPN IMPIFM		; IN WHICH CASE, WAIT AFTER NEXT WORD
	ORI AC1,I32
	CONO IMP,(AC1)
	PUSHJ P,ISYNC
	PUSHJ P,SETUP
	JRST IDHANG
	JRST INP1

; WE GET HERE IF AT INTERRUPT LEVEL WE HAVE A WORD AND NO BUFFER TO PUT IT IN

IHANG:
	SETOM IMPITOP		;FLAG TO GETSPARE IN CASE 1 WD MSG
	PUSHJ P,HANG
	JRST IHEWAIT
	MOVE AC1,IMPICUR
	MOVEM AC1,IMPITOP	;SET UP POINTER TO FIRST BLOCK OF MSG
	JRST SECOND		; GO PICK UP THE NEXT WORD

IDHANG:
	PUSHJ P,HANG
	JRST IHEWAIT
	JRST INP1		; GO FINISH FILLING BUFFER

HANG:
	AOS NHANGS
	CONI IMP,AC1
	DATAI IMP,IMPHELP
	SETOM IMPHLF
	TRNE AC1,IEND
	POPJ P,
	MOVEI AC1,IEPIEN!IDPIEN
	SKIPN IMPIFM
	ORI AC1,I32		; CLEAR PI CHANS SO WON'T INTERRUPT
	CONO IMP,(AC1)
	PUSHJ P,ISYNC
	PUSHJ P,HLPWRD
	AOS (P)
	JRST GETSPARE		;WE JUST USED THE SPARE, TRY TO GET A NEW ONE

; ROUTINE TO PICK UP SAVED WORD AND PLACE IT IN BUFFER

HLPWRD:
	MOVE AC1,[XWD 1,1]	; BUMP THE IOWD
	ADDB AC1,IMPBKO		; BOTH HALVES
	MOVE AC2,IMPHELP	; PICK UP SAVED WORD
	SETZM IMPIHD		; CLEAR INPUT-END FLAG
	SETZM IMPHLF		; CLEAR SAVED WORD
	MOVEM AC2,(AC1)		; PLACE IT IN BUFFER
	POPJ P,

; WE GET HERE WHEN INPUT IS DONE.

INPDONE:

	PUSHJ P,IFINISH		; SET WORD COUNT IN LAST BUFFER AND PUT IT ON ILIST
	CONO IMP,ISTART		; START THE IMP LISTENING FOR INPUT
INIWAIT:

	PUSHJ P,ISYNC
	JRST IBEGIN		; START A NEW MESSAGE

; GET HERE WHEN WE INPUTTED THE LAST WORD INTO IMPHELP AND THERE
; IS NO BUFFER FOR IT. CLOCK LEVEL WILL CALL IFINISH THEN
; START THE IMP UP LISTENING AGAIN.

IHEWAIT:

	SETOM IMPIHD		; NOTE THAT THE WORD IN IMPHELP IS THE LAST WORD
	CONO IMP,IDPIEN!IEPIEN	; MAKE SURE WE DON'T INTERRUPT AGAIN
	JRST INIWAIT

; ROUTINE TO SET THE WORD COUNT IN THE LAST BUFFER AND
; TAG THE ENTIRE BUFFER LIST ONTO ILIST

IFINISH:

	AOS NMESIN		; BUMP NUMBER OF MESSAGES RECEIVED
	MOVE AC1,IMPICUR	; PICK UP POINTER TO CURRENT BUFFER
	SETZM IMPICUR		; MAKE SURE NOBODY IS HOME, SO SETUP WON'T LINK ONTO A NON-EX BLOCK
	HLRE AC2,IMPBKO		; PICK UP WORD COUNT REMAINING
	ADD AC2,TLEN(AC1)	; GET LENGTH OF CURRENT BUFFER
	MOVEM AC2,TWC(AC1)	; USE THAT AS THE WORD COUNT
	MOVE AC1,IMPITOP	; PICK UP FIRST BLOCK OF MESSAGE
	SKIPN AC2,ILIST		; ANYTHING IN THE INPUT LIST?
	JRST IFINI1		; NO, PUT US AS THE FIRST AND LAST ELEMENT
	MOVSS AC2
	HRLM AC1,TLINK(AC2)	; LINK US ON TO THE LAST ELEMENT
IFINI2:
	HRLM AC1,ILIST		; MAKE US THE LAST ELEMENT
	HRRZS TLINK(AC1)	; CLEAR OUR CDR
	POPJ P,

IFINI1:
	HRRM AC1,ILIST		; MAKE US THE FIRST ELEMENT
	JRST IFINI2

; ROUTINE TO SET UP THE BYTE POINTER AND WORD COUNT FOR A BUFFER
; IF THERE IS A LIST, IT APPENDS THE NEW BUFFER TO THE END OF THE LIST.
; SKIP RETURNS IF THERE WAS A BUFFER. IF NOT, NO SKIP AND PUT IN
; CLOCK REQUEST TO GET A BUFFER.

SETUP:
	PUSHJ P,SETUP0
	JRST NOSPARE		; NO FREE STORAGE, PLANT CLOCK REQUEST, TAKE FAILURE RETURN
	PUSHJ P,GETSPARE	; GET A NEW SPARE BLOCK
	JRST CPOPJ1		; WE WON THIS TIME

SETUP0:
	SETZ AC1,
	EXCH AC1,IMPSPARE
	JUMPE AC1,CPOPJ		; NO FREE STORAGE, GIVE FAILURE RETURN
	SETZM TLINK(AC1)
	MOVN AC2,TWC(AC1)	; PICK UP LENGTH OF DATA PORTION OF BLOCK
	HRLI AC1,(AC2)		; PUT NEGATIVE WORD COUNT BESIDE DATA POINTER
	SKIPE AC2,IMPICUR	; IS THERE ALREADY A LIST GOING?
	HRRM AC1,TLINK(AC2)	; YES, APPEND US TO IT
	HRRZM AC1,IMPICUR	; SET US AS CURRENT BLOCK
	ADDI AC1,TDATA-1	; MOVE TO JUST BEFORE DATA PORTION
	MOVEM AC1,IMPBKO	; PUT IN BLKO WORD
	JRST CPOPJ1

; CLOCK LEVEL ROUTINE TO GET A SPARE BLOCK

GETSP:
	SETZM IMPCLN		; NOTE CLOCK REQUEST SATISFIED
	SKIPE IMPDEAD		; IS THERE ANY IMP?
	POPJ P,			; NO, FORGET IT
GETSPARE:

	PUSHJ P,IMPGET		; SEE IF THERE IS A BLOCK AVAILABLE
	JRST NOSPARE
	EXCH AC1,IMPSPARE
	SKIPE AC1		; WAS THERE ALREADY ONE?
	PUSHJ P,IMPREL		; YES, GIVE IT BACK
	SKIPN IMPHLF		; IS SOMEONE WAITING FOR IT?
	POPJ P,			; NO, LEAVE NOW
	PUSHJ P,SETUP0		; YES, SET UP BYTE POINTER AND COUNT
	JRST NOSPARE
	SKIPN IMPIHD		; IS IT THE LAST WORD?
	JRST GETSP1		; NO, JUST CLEAR THE WAIT FLAG AND GO
	PUSHJ P,HLPWRD		; PUT LAST WORD IN BUFFER
	MOVE AC1,IMPICUR
	SKIPGE IMPITOP
	MOVEM AC1,IMPITOP	;SET UP POINTER TO FIRST BLK OF MSG IF FROM IHANG
	PUSHJ P,IFINISH		; PUT LIST ON ILIST
	CONO IMP,ISTART		; START THE IMP LISTENING AGAIN
	JRST GETSPARE		; NOW GET A SPARE AGAIN

GETSP1:
	SETZM IMPHLF
	MOVEI AC1,CLRWT!ODPIEN!IDPIEN!IMPCHN
	SKIPN IMPIFM
	ORI AC1,I32
	CONO IMP,(AC1)		; START IMP GOING AGAIN, SET UP PI CHANNELS
	POPJ P,

; PLANT A CLOCK REQUEST TO COME BACK AND LOOK FOR FREE STORAGE

NOSPARE:

	SETO AC1,
	EXCH AC1,IMPCLN
	JUMPN AC1,CPOPJ
	MOVE AC1,[XWD GETSP,0]
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	POPJ P,

; MAIN OUTPUT LOOP

IMPOL:
	MOVEI AC2,ODPIEN!IMPCHN
NXTTFR:
	SKIPN IMPOFM
	ORI AC2,O32
	CONO IMP,(AC2)
	BLKO IMP,IMPOBK
	JFCL
	PUSHJ P,OSYNC
↑OBEGIN:
	SETOM IMPOACT		; NOTE THAT WE ARE STILL ACTIVE
	SOSN IMPOFC		; DECREMENT COUNT OF WORDS LEFT UNTIL 32-BIT MODE
	SETZM IMPOFM		; SWITCH TO 32-BIT MODE
	SKIPG IMPOBK		; DECREMENT COUNT OF WORDS LEFT IN BUFFER
	JRST IMPOL
NXTBLK:
	MOVE AC1,IMPOCUR	; PICK UP POINTER TO CURRENT BLOCK
	SKIPG AC2,RSTHST	; ANY MORE RESETS YET TO BE SENT?
	JRST NOTRST		; NO, RELEASE THIS BLOCK
	SOS AC2,RSTHST		; YES, COUNT DOWN AND LOAD NEW HOST #
	DPB AC2,SRCP		; PUT NUMBER OF NEXT HOST TO BE RESET INTO BLOCK
	CONO IMP,FINO		; WHOLE RESET HAS BEEN SENT
	PUSHJ P,OSYNC
	MOVE AC1,IMPOCUR	; GET BACK THE POINTER TO THE BLOCK
	JRST IMPOD1		; NOW USE SAME BLOCK TO SEND NEXT RESET

NOTRST:
	HRRZ AC2,TLINK(AC1)
	MOVEM AC2,IMPOCUR
	PUSHJ P,IMPREL		; RELEASE JUST EMPTIED BLOCK
	SKIPN AC1,IMPOCUR	; IS THERE A NEXT BLOCK?
	JRST IMPODN		; NO, OUTPUT DONE
	PUSHJ P,SETCNT		; YES, SET UP COUNT AND BYTE POINTER
	JRST IMPOL		; START IT GOING

IMPODN:
	CONO IMP,FINO		; TELL IMP THE LAST BIT HAS BEEN SENT
	PUSHJ P,OSYNC
	AOS NMESOU		; BUMP NUMBER OF MESSAGES TRANSMITTED
	SKIPN AC1,OLIST		; ANYTHING ELSE IN QUEUE?
	JRST OWAIT		; NO, WAIT FOR OUTPUT TO BEGIN
	PUSHJ P,LEGAL		; IS IT A LEGAL BLOCK?
	JRST [	SETZM OLIST	; NO, FLUSH THE ENTIRE OUTPUT LIST
		JRST OWAIT]	; AND PRETEND IT IS EMPTY
	HLRZ AC2,TLINK(AC1)	; YES, PICK UP FIRST ELEMENT
	HRRM AC2,OLIST
	SKIPN AC2
	SETZM OLIST
	HRRZM AC1,IMPOCUR
IMPOD1:
	PUSHJ P,SETMOD		; SET 32 OR 36 BIT MODE
	PUSHJ P,SETCNT
	MOVEI AC2,STROUT!ODPIEN!IMPCHN
	JRST NXTTFR

DONOP1:
	CONO IMP,STROUT!ODPIEN!IMPCHN
	DATAO IMP,[BYTE (8) 4]	;NOP
	PUSHJ P,OSYNC
DONOP:
	CONO IMP,FINO
	PUSHJ P,OSYNC
	SOSLE NOPCNT
	JRST DONOP1
OWAIT:
	SETZM IMPOACT		; WE ARE NO LONGER ACTIVE
	CONO IMP,ODPIEN		; CLEAR PI CHANNEL SO WE HEAR NO EVIL
	PUSHJ P,OSYNC		; WAIT FOR CLOCK LEVEL TO START US UP
	JRST OBEGIN

; ROUTINE TO QUEUE A MESSAGE FOR OUTPUT.
; ENTER WITH MESSAGE IN AC1

QOUT:
	PUSHJ P,LEGAL		; REASONABLE BLOCK?
	POPJ P,			; NO, LEAVE NOW
	CONO PI,IMPOFF
	SKIPN IMPOACT		; IS OUTPUT IN PROGRESS?
	JRST QIDLE		; NO, START IT BY HAND.
	PUSH P,AC2
	SKIPN AC2,OLIST		; PUT THIS MESSAGE ON THE END OF THE OUTPUT LIST
	JRST QNOLIST
	MOVSS AC2
	HRLM AC1,TLINK(AC2)
QOXIT:
	HRLM AC1,OLIST
	POP P,AC2
	HRRZS TLINK(AC1)
	CONO PI,IMPON
	POPJ P,

QNOLIST:

	HRRM AC1,OLIST
	JRST QOXIT

; GET HERE WHEN THE OUTPUT SIDE OF THE IMP IS IDLE

QIDLE:
	CONO PI,IMPON		; NO NEED TO BOTHER WITH INTERLOCKING
	SETOM IMPOACT
	MOVEM AC1,IMPOCUR
	PUSH P,AC3
	PUSHJ P,SETMOD		; SET UP COUNT OF NUMBER OF WORDS IN 36B MODE
	PUSHJ P,SETCNT		; SET UP BYTE POINTER AND COUNT
	MOVEI AC3,MAXCNT	; SET UP OUTPUT TIMEOUT
	MOVEM AC3,IMPOCT
	POP P,AC3
	CONO PI,IMPOFF
	CONO IMP,STROUT!ODPIEN!IMPCHN
	BLKO IMP,IMPOBK
	JFCL
	CONO PI,IMPON
	POPJ P,

; ROUTINE TO SET THE OUTPUT WORD COUNT AND BYTE POINTER

SETCNT:
	MOVN AC2,TWC(AC1)	; PICK UP SIZE OF BLOCK
	HRLI AC2,TDATA-1(AC1)	; PUT IN ONE BEFORE DATA PORTION OF BUFFER
	MOVSM AC2,IMPOBK	; PLACE IN OUTPUT BLKO WORD
	POPJ P,

; ROUTINE TO DO SOFTWARE RELOCATION ON ADDESS IN TAC1
; PUTS RESULT IN DSER

DOLOC:
	HRRZI DSER,(TAC1)	; MOVE USER ADDRESS TO DSER
	TRNN DSER,400000	; UPPER SEGMENT ADDRESS?
	JRST EOREL		; NO, USE PROG
	PUSH P,TEM
	LDB TEM,PSEGN		; YES, PICK UP REL. OF UPPER
	HRRZ TEM,JBTADR(TEM)
	ADDI DSER,-400000(TEM)
	POP P,TEM
	POPJ P,

EOREL:
	ADDI DSER,(PROG)
	POPJ P,

; ROUTINE TO SET THE COUNT OF THE NUMBER OF WORDS IN 36B MODE

SETMOD:
	LDB AC2,SIZEP
	MOVEI AC3,2
	CAIN AC2,44		; UNLESS MOVE IS 36B, USE 32B
	SETO AC3,
	MOVEM AC3,IMPOFC	; SET NUMBER OF WORDS IN 36B
	SETOM IMPOFM		; WE ALWAYS START IN 36B MODE
	POPJ P,

; INPUT INTERRUPT COMES HERE

↑IMPINT:
	CONSO IMP,770		; ANY CHANNEL?
	JRST IMPOTS		; NO, CAN'T BE US
	MOVEM AC1,IMPAC1
	MOVEM AC2,IMPAC2
	MOVEM AC3,IMPAC3
	EXCH PID,IMPPID
	EXCH P,IMPIPD
	JRST @IMPIDSP

ISYNC:
	POP P,IMPIDSP
	EXCH P,IMPIPD
ACREST:
	MOVE AC1,IMPAC1
	MOVE AC2,IMPAC2
	MOVE AC3,IMPAC3
	EXCH PID,IMPPID
	JEN @IMPCHL

; OUTPUT INTERRUPTS COME HERE

↑IMPOUT:
	CONSO IMP,7
	JRST IMPCTS
	MOVEM AC1,IMPAC1
	MOVEM AC2,IMPAC2
	MOVEM AC3,IMPAC3
	HRLOI AC3,377777
	MOVEM AC3,IMPOCT
	EXCH PID,IMPPID
	EXCH P,IMPOPD
	JRST @IMPODSP

OSYNC:
	POP P,IMPODSP
	MOVEI AC3,MAXCNT
	SKIPL IMPOACT
	HRLOI AC3,377777
	MOVEM AC3,IMPOCT
	EXCH P,IMPOPD
	JRST ACREST

; GET HERE ON ERROR BIT

↑IMPERB:
	MOVEM AC1,IMPAC1
	MOVEI AC1,IDPIEN!IMPCHN
	SKIPN IMPIFM
	ORI AC1,I32
	CONO IMP,(AC1)		; CLEAR ERROR BIT
	MOVE AC1,IMPAC1
	AOS IMPECT		; NOTE ANOTHER ERROR BIT DETECTED
	JEN @IMPCHL

BEND IMPSER
;: IMPINT[J17,SYS] EOF.
;: LPTSER[J17,SYS]
COMMENT ⊗   VALID 00020 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	BEGIN LPTSER 
 SUBTTL LINE PRINTER SERVICE ROUTINE
C00005 00003	 LPT PARAMETER ASSIGNMENTS
C00007 00004	   LPT SERVICE DISPATCH TABLE
C00008 00005	 INITIALIZE LINE PRINTER - CALLED FOR 200 RESTARTS
C00011 00006	 LPT OUTPUT CODE, LPT MAY BE RUNNING NOW
C00014 00007	 SEE IF USER HAS A FREE BUFFER TO BE FILLING
C00016 00008	 COME HERE IF LINE PRINTER IS HUNG
C00019 00009	 THIS PART OF THE PROGRAM BRINGS A BUFFERLOAD INTO SYSTEM CORE
C00021 00010	 TRANSFER BUFFERLOAD CHARACTER BY CHARACTER
C00023 00011	 ROUTINE TO DEPOSIT ONE BYTE IN THE SYSTEM BUFFER
C00026 00012	LPTMCR:	PUSH PDP,A		 SAVE CURRENT CHARACTER
C00027 00013	 BASIC LEVEL DEPOSIT BYTE AND WRAP AROUND POINTER
C00028 00014	 CHARACTER CONVERSION TABLE
C00029 00015	 MORE CHARACTER TABLE, CHARACTERS 51 TO 123
C00030 00016	 MORE CHARACTER CONVERSION TABLE, CHARACTERS 124 TO 177
C00031 00017		SUBTTL LPTSER - JAM 25 SEPT 1968 - INTERRUPT LEVEL ROUTINES
C00035 00018	 COME HERE WHEN THERE IS NOT A FULL WORD TO BE PRINTED
C00036 00019	LPTCRF:	CONO	LPT,LPTCHB+LPTDON+LPTALT	SET ALT FLAG
C00038 00020	 THIS PART HANDLES THE ERROR SYSTEM
C00040 ENDMK
C⊗;

BEGIN LPTSER 
 SUBTTL LINE PRINTER SERVICE ROUTINE
; NEW LINE PRINTER SERVICE ROUTINES - JAM 25 SEPT 68
; NEVER SETS IOACT BIT IN IOS
; DOES CHARACTER CONVERSION EXCEPT WHEN 100 BIT IN RH OF IOS IS ON
; FEATURES INTERNAL BUFFERING
; USERS BUFFERS ARE NOT ENTIRELY EMPTIED UNTIL HE DOES THE 'CLOSE' UUO

; LPT PARAMETER ASSIGNMENTS

; LPT CONTROL REGISTER
	LPTSTR←←100000		;"PRESS START" AFTER IO RESET
	LPTALT←←4000		; LAST CHAR WAS 177 (HARDWARE BIT)
	LPTCLR←←2000		; CLEAR LPT HARDWARE REGISTERS!
	LPTDON←←100		; ENABLE LPT DONE FLAG
	LPTERR←←400		; ENABLE LPT ERROR INTERRUPT
	LPTLOV←←1000		; LINE OVERFLOW, WON'T OCCUR
	LPTCHB←←LPTCHN*11	; PUTS PI CHANNEL NUMBER IN READY
				; INTERRUPT AND ERROR INTERRUPT SPOTS
	LPTCLB←←LPTCHN+200	; CLEAR CHANNEL

; ACCUMULATOR DEFINITIONS . . .
	A←TAC
	B←TAC1
	C←AC1
	D←DAT
	COUNT←AC2
	POINTR←AC3

; RH OF LPT IOS WORD
	LPTNCC←←100		; SET BY USER TO INHIBIT CHARACTER CONVERSION
	HNGTRP←←200		; USER WANTS ERROR RETURN ON HUNG LPT.
	DELBIT←←400		; LAST CHAR. BEFORE CONO-ING LPT OFF WAS 177

; LH OF LPT IOS WORD
	LPTEN1←←200		; NEAR END OF LPT ACTIVITY FLAG
	LPTDNG←←400		; DANGLING 177 FLAG
	LPTERF←←4000		; ERROR BUBBLING UP FROM INTERRUPT LEVEL
	LPTEN2←←20000		;RELEASE BIT.

; STORAGE PARAMETERS
	↑LPTCPL←←=120		; NUMBER OF CHARACTERS PRINTED PER LINE

;   LPT SERVICE DISPATCH TABLE

	JRST LPTINI		;INITILIZE
	JRST LPTCLT		;LPT HUNG TIMEOUT. SET ERROR BIT IN IOS FOR LPTOUT TO SEE.
↑LPTDSP:
	JRST LPTREL		;RELEASE LPT
	JRST LPTCLS		;CLOSE
	JRST LPTOUT		;OUTPUT
	JRST ILLINP		;INPUT

; INITIALIZE LINE PRINTER - CALLED FOR 200 RESTARTS

LPTINI:
	CONO	LPT,LPTSTR	; SET LPT START FLAG
	SETOM	LPTBG1		;SET FLAG DENOTING FIRST LPT OPERATION
LPTI.1:
	MOVEI	IOS,0
	CONO	LPT,LPTCLR	;CLEAR HARDWARE REGISTERS.
	HLLZS	LPTCON		;CLEAR PI DISPATCH ADDRESS FOR NOW
	PUSHJ	P,LPTINZ	; INITIALIZE BYTE POINTERS
	SETZM	LPTIBF		;SET TO ZERO OUT INTERNAL BUFFER
	MOVE	TAC,[XWD LPTIBF,LPTIBF+1]
	BLT	TAC,LPTDCN
	POPJ	P,		; RETURN TO SENDER, ADDRESS UNKNOWN
				; NO SUCH NUMBER, NO SUCH ZONE
LPTBI:
	POINT 7,LPTIBF		; LPTUBP - UUO LEVEL SYSTEM BUFFER BYTE POINTER
	LPTIBF			; LPTIBP - INTERRUPT LEVEL POINTER
	5*LPTBLN		; LPTCC - TOTAL NUMBER OF FREE CHARACTERS IN SYSTEM BUFFER
	LPTCPL			; LPTLCC - CHARACTER POSITION IN LINE

; LINE PRINTER CLOSE CODE

LPTCLS:
	HRLZI IOS,IOEND		; SET OUR PRIVATE 'LAST UUO' FLAG
	ORB IOS,DEVIOS(DEVDAT)	; OR IN BIT TO HONEST IOS
	TLNN IOS,LPTERF		; ARE WE HUNG?
	JRST OUT		; NO, DO LOTS OF OUTPUTS
	MOVSI IOS,LPTERF
	ANDCAB IOS,LPTIOS	; CLEAR ERROR BIT
	PUSHJ PDP,LPTHN		; CALL THE HUNG ROUTINE
	JRST OUT		; NOW DO SOME OUTPUTS

; INITIALIZE IOS AND BYTE POINTERS
; AND ALL THE CRAZY COUNTS

LPTINZ:
	MOVE	TAC,[XWD LPTBI,LPTUBP]
	BLT	TAC,LPTLCC		;BLT IN POINTERS AND COUNTS
	ANDI	IOS,HNGTRP!LPTNCC!17	;CLEAR ALL BUT MODE&SPECIAL BITS
	TLO	IOS,IO			;
	MOVEM	IOS,LPTIOS		;AND STORE IOS
	SETZM	LPTDCN
	POPJ	P,

LPTREL:
	TLNE IOS,IOBEG		;HAVE WE DONE ANYTHING YET
	JRST LPTI.1		;NO
	HRLZI IOS,LPTEN2!IO	;TELL SEVICE ROUTINE
	PUSHJ PDP,LPTO3		;HE WILL SET THE WHEELS IN MOTION
	PUSHJ PDP,WSYNC		;TREAD WATER A WHILE
	JRST LPTI.1		;REFRESHING ISN'T IT.

; LPT OUTPUT CODE, LPT MAY BE RUNNING NOW

LPTOUT:
	TLZE IOS,IOBEG		; FIRST UUO?
	PUSHJ PDP,LPTINZ		;INITIALIZE LPT TABLES AND IOS
	TRZE IOS,IODERR		; HAS LPT BEEN HUNG?
	JRST UNHANG		; YES, UNHANG IT
	CONSO LPT,LPTERR		;CATCH ERRORS NOW!
	TLZE IOS,LPTERF		; CHECK FOR INTERRUPT LEVEL ERROR
	JRST LPTHNG		; HANG USER UNTIL IT IS FIXED
	PUSHJ PDP,LPTSET	; SEE IF WE CAN LOAD SYSTEM CORE
	JRST LPTO1		; SYSTEM BUFFER EMPTY, RETURN TO USER
	TLNN IOS,IOEND		; IS THIS THE LAST UUO?
	JRST LPTO2		; NO, START LPT AND RETURN TO USER

LPTIOW:
	MOVEI A,LPTLOV+LPTERR+LPTDON
	HRLZI IOS,IO+IOW	; SET IOS BITS TO SAY HE IS IN IO WAIT
	LDB C,PDVTIM		; PICK UP HUNG COUNT TIME
	DPB C,PDVCNT		; DEPOSIT IT, INITIATE HUNG COUNTING
	CONO PI,LPTOFF		; DO OUR DIRTY WORK WITH CHANNEL 5 OFF
	HRRM A,LPTCON		; SET UP DISPATCH BITS
	OR IOS,DEVIOS(DEVDAT)	; PICK UP OUR IOS
	MOVEI A,0		; ASSUME NO ALT!
	TRZE IOS,DELBIT		; SHOULD BIT BE SET?
	TRO A,LPTALT		; YES
	TLON IOS,DEVSBB		; START LINE PRINTER IF IT IS NOT RUNNING
	CONO LPT,LPTCHB+LPTDON(A); SET ITS INTERRUPT CHANNEL AND ASK FOR DONE INTERRUPT
	MOVEM IOS,DEVIOS(DEVDAT)
	CONO PI,LPTON		; THE LPT WILL INTERRUPT IMMEDIATELY
	PUSHJ PDP,WSYNC		; DROP HIM INTO IO WAIT
	JRST LPTOUT		; TRY ANOTHER OUTPUT WHEN WE RETURN


; SEE IF USER HAS A FREE BUFFER TO BE FILLING
; RETURN TO HIM IF HE DOES, PUT HIM IN IO WAIT IF HE DOESN'T

LPTO2:
	PUSHJ PDP,DEVCR		; CHECK RING USE BIT
	JRST LPTIOW		; IF BUSY, PUT HIM IN IO WAIT

	HRLZI IOS,IO		; OTHERWISE, JUST START UP LPT
LPTO3:
	MOVEI A,LPTLOV+LPTERR+LPTDON
	LDB C,PDVTIM		; PICK UP HUNG COUNT TIME
	DPB C,PDVCNT		; DEPOSIT IT, INITIATE  HUNG COUNTING
	CONO PI,LPTOFF		; SHUT OFF LPT CHANNEL
	HRRM A,LPTCON		; SET UP INTERRUPT DISPATCH CONI BITS
	OR IOS,DEVIOS(DEVDAT)	; PICK UP OUR OWN IOS
	MOVEI A,0		; ASSUME NOT BIT
	TRZE IOS,DELBIT		; TRUE?
	TRO A,LPTALT		; NO, SET BIT
	TLON IOS,DEVSBB		; START LPT IF NEEDED
	CONO LPT,LPTCHB+LPTDON(A); GIVE IT A PAIR OF CHANNELS AND A DONE BIT
	MOVEM IOS,DEVIOS(DEVDAT)
	CONO PI,LPTON		; RESTORE CHANNEL 5
	POPJ PDP,		; RETURN TO USER, ADDRESS UNKNOWN
				; NO SUCH NUMBER, NO SUCH ZONE!!

; COME HERE IF THE SYSTEM BUFFER IS EMPTY

LPTO1:
	TLNN IOS,IOEND		; IS THIS THE LAST UUO?
	POPJ PDP,		; NO, EXIT TO USER, STAGE LEFT
	HRLZI IOS,IOEND		; AND NOW, ZERO THIS BIT FOR GOOD
	ANDCAB IOS,LPTIOS
	TLNE IOS,IOBEG		; IS THIS REALLY THE BEGINNING?
	POPJ PDP,		; YES, EXIT
	HRLZI IOS,IO+LPTEN1	; TELL INTERRUPT SERVICE ROUTINES TO PRINT A CR-FF
	JRST LPTO3		; START LPT AND LEAVE


; COME HERE IF LINE PRINTER IS HUNG

LPTHNG:
	TRNE IOS,HNGTRP		;IS HE REQUESTING ERROR RETURN ON HUNG LPT
	JRST LPTHN1		;YES
	PUSHJ PDP,LPTHN		; HANG USER
	JRST LPTOUT		; TRY AGAIN

LPTHN:
	PUSHJ PDP,HNGSTP	; PRINT OUT "DEVICE LPT OK?" AND HANG USER
UNHANG:
	MOVE IOS,[XWD LPTERF,IODERR]	; SET TO CLEAR THE ERROR FLAGS
	MOVEI A,LPTLOV+LPTERR+LPTDON
	CONO PI,LPTOFF		; SHUT OFF LPT
	HRRM A,LPTCON		; SET UP CONI BITS
	ANDCAB IOS,DEVIOS(DEVDAT)
	TLO IOS,DEVSBB		; SYSTEM BUFFER WILL NOW BE BUSY
	MOVEI A,0		; ASSUME NO BIT
	TRZE IOS,DELBIT		; TRUE?
	TRO A,LPTALT		; NO, SET BIT
	CONO LPT,LPTCHB+LPTDON(A); START UP LPT
	MOVEM IOS,DEVIOS(DEVDAT)
	CONO PI,LPTON		; RESTORE PI CHANNEL
	LDB C,PDVTIM		; RESET HUNG COUNT
	DPB C,PDVCNT
	JRST LPTOUT		; DO SOME MORE OUTPUTS

LPTCLT:
	HRLZI IOS,LPTERF	; KILL THE ERROR BIT
	CONO PI,LPTOFF		; WITH LPT OFF
	ORB IOS,LPTIOS		; SET ERROR BIT FOR UUO-LEVEL ROUTINES TO SEE
	TLZ IOS,DEVSBB		; SYSTEM BUFFER IS NO LONGER BUSY
	MOVEI DEVDAT,LPTDDB	; GET DDB ADDRESS FOR SETIOD
	TLZE IOS,IOW		; ARE WE IN IO WAIT?
	PUSHJ PDP,STTIOD	; YES, TAKE US OUT (PUT INTO TQ)
	MOVEM IOS,LPTIOS	; RESTORE IOS
	CONO PI,LPTON		; RESTORE PI CHANNEL
	JRST CPOPJ1		; SKIP, FORCE HNGCHK TO IGNORE US

LPTHN1:
	TRO IOS,IODERR		;GIVE HIM A DEVICE ERROR BIT
	IORB IOS,LPTIOS
	POPJ P,

; THIS PART OF THE PROGRAM BRINGS A BUFFERLOAD INTO SYSTEM CORE

LPTSET:
	PUSHJ PDP,DEVSTU	; SET UP COUNT AND POINTR TO POINT AT THE DATA IN HIS BUFFER
	JRST LPTSE2		; THIS BUFFER HAS ALREADY BEEN EMPTIED!
	CAILE COUNT,LPTBLN	; IS THE COUNT GREATER THAN THE SIZE OF THE WHOLE DAMN BUFFER?
	JRST BTLERR		; YES, KILL THE BASTARD!
	IMULI COUNT,5		; CHANGE WORD COUNT INTO CHARACTER COUNT
	MOVE A,COUNT		; SEE IF WE CAN FIT A BUFFER IN NOW
	IMULI A,3		; COMPARE FREE SPACE WITH WORST CASE
	CAML A,LPTCC		; SEE IF THERE IS SPACE
	JRST LPTSE2		; NO, PERFORM EXIT MAGIC
	PUSHJ PDP,LPTBF		; TRANSFER DATA TO THE SYSTEM BUFFER
	PUSHJ PDP,ADVBFE	; ADVANCE THE BUFFER DOWN THE RING
	JRST LPTSE2		; NO MORE BUFFERS, EXIT, STAGE LEFT
	JRST LPTSET		; SEE IF WE CAN SQUEEZE IN ANOTHER BUFFER

LPTSE2:
	MOVE A,LPTCC		; SEE IF WE HAVE TRANSFERRED ANYTHING
	CAIGE A,5*LPTBLN-4	; BY COMPARING WITH FULL COUNT
	AOS (PDP)
	POPJ PDP,

; TRANSFER BUFFERLOAD CHARACTER BY CHARACTER
; DO CHARACTER CONVERSION IF USER WANTS IT

LPTBF:
	SOJL COUNT,CPOPJ	; EXIT IF COUNT IS EXHAUSTED.
	ILDB A,POINTR		; PICK UP BYTE FROM USER
	TRNE IOS,LPTNCC		; DOES HE WANT CONVERSION?
	JRST LPTB3		; NO, SKIP IT

	CAIN A,134		; IS THIS THAT GODDAMN CHARACTER?
	JRST LPTB2		; YES, CUE UP TWO 177'S
	MOVE A,LPTCTB(A)	; PICK UP CORRECT CHARACTER FROM CONVERT TABLE
LPTB1:
	PUSHJ PDP,LPTDPB	; DEPOSIT BYTE IN SYSTEM CORE
	JRST LPTBF

LPTB2:
	MOVEI A,177		; CUE UP TWO CONSEC. 177'S
	PUSHJ PDP,LPTDPB
	MOVEI A,177		; ROUTINE DOESN'T ALWAYS PRESERVE A
	JRST LPTB1

LPTB3:
	HLL A,LPTCTB(A)		; PICK UP HIS DISPATCH BITS
	JRST LPTB1

; ROUTINE TO DEPOSIT ONE BYTE IN THE SYSTEM BUFFER
; AND UPDATE ALL THE CRAZY COUNTS INVOLVED

LPTDPB:
	MOVE IOS,DEVIOS(DEVDAT)	; DO WE HAVE A DANGLING DELETE?
	TLNE IOS,LPTDNG		; WAS LAST A SPECIAL?
	JRST LPTD2		; YES!
	CAIE A,177		; NO, IS THIS ONE?
	JRST LPTD1		; NO, JUST REG CHAR.
	TLO IOS,LPTDNG		; SET FLAG FOR NEXT TIME
	MOVEM IOS,DEVIOS(DEVDAT)
	POPJ P,
LPTD2:
	PUSHJ PDP,LPTCCH	; YES, SEE IS IT IS A CONTROL CHARACTER
LPTD1:
	HLRZ D,A
	SKIPE D			; DOES THIS CHAR HAVE A DISPATCH ADDRESS?
	JRST LPTD7		; YES, IT WILL TAKE CARE OF ITSELF
	SKIPG LPTLCC		; NO, HAVE WE OVERFLOWED THE LINE?
	PUSHJ PDP,LPTMCR	; YES, MAKE A CRLF

LPTD7:
	TLNN IOS,LPTDNG		; NEED WE SEND A 177 FIRST?
	JRST LPTD7A		; NO
	PUSH P,A
	MOVEI A,177
	PUSHJ P,LPTDB		; SEND 177
	POP P,A
LPTD7A:
	PUSHJ PDP,LPTDB		; OTHERWISE, DEPOSIT CHARACTER AND UPDATE COUNTS
	CAIN A,11
	JRST LPTD11		;SPECIAL DISPATCH FOR TAB
	HLRZS A			; PUT THE DISPATCH ADDRESS IN THE RH
	JUMPN A,(A)		; STRANGE CHARACTER, DISPATCH TO SEPARATE ROUTINE
LPTD5A:
	SOS LPTLCC		; NORMAL CHARACTER, DECREMENT COUNT
LPTD5:
	MOVSI IOS,LPTDNG	; ZERO OUT THE DANGLING 177 BIT
	ANDCAB IOS,DEVIOS(DEVDAT)
	POPJ PDP,

LPTDV:
	TLNN IOS,LPTDNG		; IS THIS A VERTICAL CHAR?
	JRST LPTD5		; YES
	JRST LPTD5A		; JUST ANOTHER CHAR!

LPTD15:
	TLNE IOS,LPTDNG		; IS IT REALLY A CR
	JRST LPTD5A		; NO, JUST REG CHAR.
	MOVEI A,LPTCPL		; RESET COUNT TO #CHARS PER LINE
	MOVEM A,LPTLCC
	JRST LPTD5		; EXIT, AND ZERO DANGLING 177 BIT

LPTD11:
	SOS D,LPTLCC		; HOW FAR TO NEXT TAB STOP(AT LEAST ONE).
	ANDCMI D,7		; MAYBE MORE
	TLNN IOS,LPTDNG		; WHEN PRECEEDED BY 177 IS JUST GAMMA, NOT TAB
	MOVEM D,LPTLCC		; THIS FAR!
	JRST LPTD5


LPTMCR:
	PUSH PDP,A		; SAVE CURRENT CHARACTER
	MOVEI A,15		; MAKE A CRLF
	PUSHJ PDP,LPTDB
	MOVEI A,12
	PUSHJ PDP,LPTDB
	MOVEI A,LPTCPL		; RESET LINE COUNT
	MOVEM A,LPTLCC
	POP PDP,A
	POPJ PDP,

LPTCCH:
	HRRZ D,A
	CAIE D,20		;SAME AS V. TAB
	CAIN D,22		;	"
	HRLI A,LPTD5
	CAIE D,23		;	"
	CAIN D,24		;	"
	HRLI A,LPTD5
	CAIN D,21		;LINE FEED OVER PAGE BOUNDARIES
	HRLI A,LPTD5
	POPJ PDP,

; BASIC LEVEL DEPOSIT BYTE AND WRAP AROUND POINTER

LPTDB:
	CONO PI,LPTOFF		; SHUT OFF LINE PRINTER A SEC.
	MOVE B,LPTUBP		; PICK UP BYTE POINTER
	IBP B			; INCREMENT IT
	HRRZ C,B		; NOW GET ADDRESS PART
	CAIL C,LPTIBF+LPTBLN	; CHECK FOR WRAP AROUND
	MOVE B,[POINT 7,LPTIBF,6]
	DPB A,B			; DEPOSIT THE CHARACTER
	MOVEM B,LPTUBP		; REPLACE THE BYTE POINTER
	SOSG LPTCC		; UPDATE CHARACTER COUNT
	JSP DAT,UERROR		;BLAST THE BASTARD!
	CONO PI,LPTON		; SPEED UP THE LPT
	POPJ PDP,

; CHARACTER CONVERSION TABLE

LPTCTB:
	XWD LPTD5,0		; NULL, DOESN'T AFFECT POSITION ON LINE
	1
	2
	3
	4
	5
	6
	7
	10
	11			; HORIZONTAL TAB, SCREWS UP LINE POSITION
	XWD LPTDV,12		; LINE FEED, DOESN'T AFFECT POSITION
	XWD LPTDV,13		; VERTICAL TAB
	XWD LPTDV,14		; FORM FEED
	XWD LPTD15,15		; CARRIAGE RETURN, ZEROS COUNT
	16
	17
	20
	21
	22
	23
	24
	25
	26
	27
	137			; 137←30
	31
	134			; 134←32
	33
	34
	35
	36
	37
	40
	41
	42
	43
	44
	45
	46
	47
	50

; MORE CHARACTER TABLE, CHARACTERS 51 TO 123

	51
	52
	53
	54
	55
	56
	57
	60
	61
	62
	63
	64
	65
	66
	67
	70
	71
	72
	73
	74
	75
	76
	77
	140			; 140←100
	101
	102
	103
	104
	105
	106
	107
	110
	111
	112
	113
	114
	115
	116
	117
	120
	121
	122
	123


; MORE CHARACTER CONVERSION TABLE, CHARACTERS 124 TO 177

	124
	125
	126
	127
	130
	131
	132
	133
	134
	135
	32			; 32←136
	30			; 30←137
	100			; 100←140
	141
	142
	143
	144
	145
	146
	147
	150
	151
	152
	153
	154
	155
	156
	157
	160
	161
	162
	163
	164
	165
	166
	167
	170
	171
	172
	173
	176			; 176←174
	175
	175			; 175←176
	177

	SUBTTL LPTSER - JAM 25 SEPT 1968 - INTERRUPT LEVEL ROUTINES
; THIS PART IS ENTIRELY AUTONOMUS AND DOES NOT TRY TO
; TICKLE THE USER'S CORE, BECAUSE IT ISN'T THERE!

↑LPTINT:
	JSR LPTSAV		; SAVE ACCUMULATORS AND SET RETURN ADDRESS
	CONSZ LPT,LPTLOV	; LINE OVERFLOW?
	JRST LPTLOI
	MOVEI DEVDAT,LPTDDB	; SET UP DEVICE DATA BLOCK ADDRESS FOR SETIOD AND PDVTIM
	MOVE IOS,LPTIOS		; LET'S SEE WHAT THE UUO-LEVEL ROUTINES ARE TRYING TO TELL US
	CONSZ LPT,70		; IS THE ERROR CHANNEL DEASSIGNED?
	CONSO LPT,LPTDON	; OR MAYBE THIS IS REALLY AN ERROR?
	JRST LPTERI		; GO CHECK IT OUT
	CONSZ LPT,LPTERR	; IS LPT TURNED OFF?
	JRST LPTERH		; YES, FORCE HUNG DEVICE MESSAGE

	MOVE A,LPTCC		; FIRST, IS THERE ANYTHING TO PRINT
	CAIL A,5*LPTBLN		; COMPARE WITH TOTAL COUNT
	JRST LPTOF		; NOTHING TO PRINT, SHUT OFF LPT

	SKIPN	LPTBG1		;IS THIS THE FIRST INTERRUPT?
	JRST	LPTIN3		;NO.
	DATAO	LPT,[BYTE (7) 15,177,20]	;YES. HERE WE SEND A TOP OF DOUBLE FORM
	SETZM	LPTBG1				;AVOID THIS NEXT TIME
	JRST	LPTCF1				;GO DISMISS THIS INTERRUPT

LPTIN3:
	CAIE A,4*LPTBLN		; CHECK FOR NEARLY EMPTY
	JRST LPTIN2		; NOT NEARLY EMPTY, CONTINUE NORMALLY
	TLZE IOS,IOW		; ARE WE IN AN IO WAIT?
	PUSHJ PDP,STTIOD	; YES, GET US OUT!
LPTIN2:
	LDB C,PDVTIM		; PICK UP HUNG COUNT TIME
	DPB C,PDVCNT		; DEPOSIT IT, INITIATE HUNG COUNTING
	SKIPN A,LPTDCN		; SEE IF WE TRANSMIT LESS THAN 5 CHARS THIS TIME
	MOVEI A,5		; WE WILL PRINT 5 CHARACTERS
	SETZM LPTDCN		; INDICATE 5 CHARACTERS NEXT TIME
	ADD A,LPTCC		; ADD IN COUNT
	CAILE A,5*LPTBLN	; COMPARE WITH TOTAL COUNT
	JRST LPTIN1		; IF TOO LARGE, THERE IS NOT A MULTIPLE OF 5 CHARS
	MOVEM A,LPTCC		; STORE CHAR. COUNT
	DATAO LPT,@LPTIBP	; SEND WORD TO LINE PRINTER
	SETZM @LPTIBP		; ZERO THAT WORD TO AVOID CONFUSION
	AOS A,LPTIBP		; OTHERWISE THERE IS, AND WE CAN INCREMENT OUT POINTER
	CAIL A,LPTIBF+LPTBLN	; CHECK FOR BUFFER OVERFLOW . . .
	MOVEI A,LPTIBF		; AND RESET POINTER IF SO
	MOVEM A,LPTIBP		; AND RE-STORE POINTER FOR NEXT TIME
	POPJ PDP,		; SO LONG, BEEN GOOD TO SERVE YOU

; COME HERE WHEN THERE IS NOT A FULL WORD TO BE PRINTED

LPTIN1:
	TLNN IOS,LPTEN1		; IS THIS THE LAST WORD IN BUFFER?
	JRST LPTOF		; NO, FORGET IT
	DATAO LPT,@LPTIBP	; SEND PARTIAL WORD
	SETZM @LPTIBP		; AND ZERO IT FOR POSTERITY
	SUBI A,5*LPTBLN		; GET NUMBER OF CHARS WE WILL TRANSMITT NEXT TIME
	MOVEM A,LPTDCN		; PUT IT HERE FOR FUTURE REFERENCE
	MOVEI A,5*LPTBLN	; RESET COUNT TO MAXIMUM
	MOVEM A,LPTCC
	POPJ PDP,		; NO WORRY ABOUT WRAP-AROUND EITHER

LPTCRF:
	CONO	LPT,LPTCHB+LPTDON+LPTALT	;SET ALT FLAG
	DATAO	LPT,[BYTE(7) 20,177,20,177,20]	;3 TOP OF DOUBLE FORMS
	SETZM	LPTBG1
	JRST	LPTCF1		;NO NEED TO ADVANCE FORM AT THE START

LPTCF2:
	SETOM	LPTBG1		; MAKE CR-FF ON NEXT OUTPUT.
LPTCF1:
	LDB	C,PDVTIM	; PICK UP HUNG COUNT TIME, DEFINED IN LOWCOR
	DPB	C,PDVCNT	; DEPOSIT IT, INITIATE HUNG COUNTING
LPTXIT:
	MOVEM	IOS,LPTIOS	; STORE IOS IN LPT DDB
	POPJ	P,		; AND EXIT, CHANNEL 5

LPTOF:
	TLZE IOS,LPTEN2		; HAVE WE GIVEN TERMINAL 5 FF'S
	JRST LPTCRF		; GO DO IT AND RETURN IMMEDIATELY
	TLZE IOS,LPTEN1		; IS THIS THE END
	JRST LPTCF2		; YES - ARRANGE TO MAKE FF'S NEXT
	PUSHJ P,LPTERH		; CLEAR LPT (PRESERVING DELETE BIT]
	TLZE IOS,IOW		; ARE WE IN AN IO WAIT?
	PUSHJ PDP,STTIOD	; YES, CHANGE TO WAIT SATISFIED!
	TLZ IOS,DEVSBB		; SYSTEM BUFFER IS NO LONGER BUSY
	JRST LPTXIT		; EXIT

; COME HERE IF WE FIND THE LPT IS NOT ON
; JUST CLEAR LPT AND WAIT FOR HUNG DEVICE MESSAGE

LPTERH:
	HLLZS LPTCON
	CONSZ LPT,LPTALT	; IS DELETE FLAG CURRENTLY SET?
	TRO IOS,DELBIT		; YES, REMEMBER IT!
	MOVEM IOS,LPTDDB+DEVIOS	; IN MEMORY TOO
	CONO LPT,0
	POPJ P,

; THIS PART HANDLES THE ERROR SYSTEM

LPTERI:
	CONSO LPT,70		; IS THE ERROR CHANNEL ASSIGNED?
	JRST LPTER1		; NO, GO REASSIGN IT AND CONTINUE
	MOVEI A,0		; ASSUME NO BIT
	TRZE IOS,DELBIT		; TRUE?
	TRO A,LPTALT		; NO, SET BIT
	CONO LPT,LPTCLB+LPTDON(A); YES, DEASSIGN IT
	MOVEM IOS,LPTDDB+DEVIOS
	MOVEI A,LPTDON		; SET TO INTERRUPT ONLY WHEN DONE
LPTER2:
	HRRM A,LPTCON		; TELL INTERRUPT SERVICE ABOUT IT
	POPJ PDP,

LPTER1:
	CONI LPT,A		; GET CURRENT CONDITIONS, EVEN THOUGH I KNOW EXACTLY WAT THEY ARE
	ANDI A,300		; MASK OUT THE RIGHT ONES
	CONO LPT,LPTCHB(A)	; RESTORE ALL CONO BITS
	MOVEI A,LPTDON+LPTERR+LPTLOV
	JRST LPTER2		; AND PRETEND NOTHING EVER HAPPENED

LPTLOI:
	CONI LPT,A		; GET LPT BITS
	TRZ A,LPTLOV		; KILL LINE OVERFLOW BIT
	CONO LPT,(A)		; GIVE THEM BACK
	DATAO LPT,[BYTE (7) 15,12]
	POPJ PDP,

BEND LPTSER
;: LPTSER[J17,SYS] EOF.
;: PTPSER[J17,SYS]
COMMENT ⊗   VALID 00017 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	BEGIN	PTPSER 
 SUBTTL	PTPSER - PAPER TAPE PUNCH SERVICE ROUTINES
C00006 00003	 PTP SERVICE DISPATCH TABLE
C00007 00004	 INITIALIZE CODE, RESET ALL REGISTERS
C00009 00005	 ARE YOU HUNG UP? AH, ER, ARE YOU HUNG UP? HUNG UP? HUNG UP? HUNG UP? HUNG UP?     HUNG UP?        HUNG UP?
C00011 00006	 2-PROCESSOR ROUTINES
C00012 00007	 ROUTINE TO SET BITS IN IOS AND START DEVICE
C00015 00008	 CLOCK INTERRUPT ROUTINES FOR PTP
C00017 00009	 OUTPUT ROUTINES ARE DIVIDED INTO PARTS AND KINDS, DEPENDING ON
C00019 00010	 IN THIS MODE, WE BRING 1 CHAR PER WORD IN AND PACK 4 TO A WORD
C00022 00011	 THIS IS FOR REAL BINARY MODE, WITH CHECKSUMS AND ALL
C00024 00012	 HERE, WE TRY TO FIT THE USER'S BUFFER INTO SYSTEM CORE
C00027 00013	 COME HERE IF WE HAVE TO DO 2 SEPARATE BLT'S
C00029 00014	 THIS ROUTINE SETS UP THE CRAZY DISPATCHES FOR EACH OF THE VARIOUS MODES OF OPERATION
C00033 00015	 INTERRUPT SERVICE ROUTINES - OBOYOBOYOBOY!
C00036 00016	 TYPE 2 - PUNCH PARITY AND DELETES AFTER CR, FF, VT AND  HT
C00038 00017	 LAST PAGE - PUNCH FEED HOLES, SHUT OFF PTP
C00042 ENDMK
C⊗;

BEGIN	PTPSER 
 SUBTTL	PTPSER - PAPER TAPE PUNCH SERVICE ROUTINES
; ROUTINES DESIGNED TO SERVE DUAL-PROCESSOR PUNCH SYSTEM

; PARAMETER ASSIGNMENTS . . .

; ACCUMULATORS
	A←TAC
	B←TAC1
	C←AC1
	D←DAT
	COUNT←AC2
	POINTR←AC3

; IOS BITS
	PTPFT←←200		; FEED AFTER EVERY BUFFERLOAD IS PUNCHED
	PTPEN1←←2000		; LAST BUFFERLOAD, FEED WHEN DONE
	PTPPDN←←4000		; PUNCH DELETE CODE NEXT
	PTPERR←←10000		; DEVICE PTP HUNG BIT
	PTPBG1←←20000		; SPECIAL 2ND LEVEL IOBEG FLAG

; CONO BITS . . .
	PTPDON←←10		; DONE FLAG
	PTPNOT←←100		; 'OUT OF TAPE' FLAG


; PTP SERVICE DISPATCH TABLE

	JRST PTPINI		; INITIALIZE
	JRST PTPCLT		; HUNG TIME OUT, SET ERROR BIT
↑PTPDSP:
	JRST PTPREL
	JRST PTPCLS		; CLOSE
	JRST PTPOUT		; OUTPUT
	JRST ILLINP		; INPUT ?????

PTPREL:
	MOVSI IOS,DEVSBB+PTPERR
	ANDCAM IOS,PTPIOS
	POPJ PDP,

; INITIALIZE CODE, RESET ALL REGISTERS

PTPINI:
	MOVE A,[XWD PTPIBP,PTPIBP+1]
	SETZM PTPIBP		; SET UP BLT POINTER TO ZERO PTPDDB
	BLT A,PTPCSC		; FROM DEVOAD TO END OF PTPDDB
	SYNINI PTPCSC		; CLEAR CONTROL CELLS TOO
	SKIPE P2NUM		; DO WE HAVE A 2-PROCESSOR SYSTEM?
	SETOM PTPMOD		; SET THE MODE FLAG IF WE DO
	CONO PTP,0		; SETTLE PTP CONTROL REGISTER
	HLLZS	PTPCN1
	HLLZS	PTPCN2
	MOVEI	TAC,PTPCN1	;ASSUME P1
	SKIPE	PTPMOD		;P1?
	MOVEI	TAC,PTPCN2	;NO. USING P2
	MOVEM	TAC,PTPCON	;SET ADDRESS OF INTERRUPT CHAIN CONSZ
	POPJ	P,

; CLOSE CODE

PTPCLS:
	SETZ A,			; SET THE 'LAST UUO' BIT IN IOS
	HRLZI IOS,IOEND		; THIS BIT
	PUSHJ PDP,PTPSOS	; THIS ROUTINE HANDLES THAT
	JRST OUT

; PTP OUTPUT CODE

PTPOUT:
	TLNE IOS,IOBEG		; FIRST UUO?
	TLZ IOS,PTPERR		; YES, ZERO HUNG DEVICE BIT
	TLNE IOS,PTPERR		; CHECK FOR HUNG DEVICE
	JRST PTPHNG
PTPO2:
	TLZE IOS,IOBEG		; FIRST OUTPUT?
	JRST PTPSUD		; YES, FIGURE OUT CONFIGURATION NOW
PTPO1:
	JRST @PTPUDS		; EACH MODE HAS A DIFFERENT ROUTINE


; ARE YOU HUNG UP? AH, ER, ARE YOU HUNG UP? HUNG UP? HUNG UP? HUNG UP? HUNG UP?     HUNG UP?        HUNG UP?

PTPHNG:
	PUSHJ PDP,HNGSTP	; PRINT 'DEVICE PTP OK?' AND HANG HIM UP
	SETZ IOS,		; DON'T SET ANYTHING
	HRLZI A,PTPERR+DEVSBB	; GOTTA CLEAR  ERROR FLAG NOW
	PUSHJ PDP,PTPSOD	; AFTER IT'S OVER, START UP AGAIN
	JRST PTPO2

; COME HERE IF THE CLOCK TICKS

PTPCLT:
	MOVEI DEVDAT,PTPDDB	; SET UP THIS FOR SETIOD
	HRLZI IOS,PTPERR	; ERROR BIT WE WANT TO SET
	SKIPE P2NUM		; IS P2 ACTIVE?
	JRST PTPCL1		; YES, DO SOMETHING
	CONO PI,PTPOFF		; SHUT OFF PTP
	ORB IOS,PTPIOS		; OR IN ERROR BIT
	TLZE IOS,IOW		; ARE WE IN AN IO WAIT?
	PUSHJ PDP,STTIOD	; YES, GET US OUT!
	MOVEM IOS,PTPIOS	; RESTORE IOS
	CONO PI,PTPON		; SPEED UP PTP, EVEN THOUGH IT IS HUNG
	JRST CPOPJ1		; SKIP RETURN, DON'T EXCITE HNGCHK

PTPCL1:
	MOVEI B,1		; WE ARE P1
	PSYNC PTPCSC		; GET CONTROL OF IOS
	ORB IOS,PTPIOS		; OR IN ERROR BIT
	TLZE IOS,IOW		; ARE WE IN IO WAIT?
	PUSHJ PDP,STTIOD	; YES, GET US OUT!!
	MOVEM IOS,PTPIOS	; RESTORE IOS
	AOS (PDP)		; SET TO SKIP RETURN
	MOVEI B,1		; RESTORE WHAT SETIOD CLOBBERED
	XSYNC PTPCSC		; RELEASE CONTROL OF IOS
	POPJ PDP,

; 2-PROCESSOR ROUTINES
; SET AND CLEAR BITS IN IOS
; PUT BITS YOU WANT SET IN IOS, BITS YOU WANT CLEARED IN A (IN TAC)

PTPSOS:
	SKIPE PTPMOD		; ARE WE IN 1 OR 2 PROCESSOR MODE
	JRST PTPS1		; 2-PROCESSORS, HARDER
	CONO PI,PTPOFF		; SLOW DOWN PTP
	ANDCAM A,PTPIOS		; ZERO OUT BITS IN A
	ORB IOS,PTPIOS		; OR BITS BACK IN
	CONO PI,PTPON		; SPEED UP PTP
	POPJ PDP,

PTPS1:
	MOVEM A,PTPPTR		; SAVE THIS ACCUMULATOR
	MOVEI B,1		; WE ARE P1
	PSYNC PTPCSC		; GET CONTROL OF IOS
	OR IOS,PTPIOS		; OR IN IOS BITS
	ANDCM IOS,PTPPTR	; TAKE OUT REQUESTED BITS
	MOVEM IOS,PTPIOS	; RESTORE IOS
	XSYNC PTPCSC
	POPJ PDP,

; ROUTINE TO SET BITS IN IOS AND START DEVICE

PTPSTD:
	SETZB A,IOS		; START DEVICE, SET NO IOS BITS
PTPSOD:
	OR IOS,[XWD IO,0]	; FIRST, OR IN OUTPUT BIT
	LDB C,PDVTIM		; AND SET HUNG COUNT
	DPB C,PDVCNT
	SKIPE PTPMOD		; ARE WE RUNNING 1 OR 2 PROCESSORS TODAY?
	JRST PTPSD1		; 2 PROCESSORS
	MOVEI B,PTPDON+PTPNOT	; ASK FOR INTERRUPTS UPON DONE OR OUT OF PAPER
	CONO PI,PTPOFF		; SHUT OF PTP IF IT IS RUNNING
	OR IOS,PTPIOS		; PUT BITS INTO IOS
	ANDCM IOS,A		; TAKE BITS OUT
	TLOE IOS,DEVSBB		; IS THE PTP ALREADY RUNNING?
	JRST PTPSD2		; YES, SKIP IT
	HRRM B,@PTPCON		; SET INTERRUPT LOCATION
	CONO PTP,PTPDON+PTPCHN	; ASK FOR A DONE INTERRUPT, SET PI CHANNEL
PTPSD2:
	MOVEM IOS,PTPIOS	; RESTORE IOS
	CONO PI,PTPON		; SPEED UP PTP, WILL INTERRUPT NOW
	POPJ PDP,

PTPSD1:
	MOVEM A,PTPPTR		; SAVE THE BITS WE ARE TO CLEAR
	PSYNC PTPCSC		; GET CONTROL OF IOS
	OR IOS,PTPIOS
	ANDCM IOS,PTPPTR	; CLEAR APPROPRIATE BITS
	TLON IOS,DEVSBB		; SET DEVICE RUNNING NOW BIT.
	SETOM PTPACT		; ASK P2 TO START PTP SINCE IT'S NOT ALREADY ON.
	MOVEM IOS,PTPIOS	; RESTORE IOS
	XSYNC PTPCSC		; RELEASE CONTROL OF IOS
	POPJ PDP,

; ROUTINE TO SET BITS IN IOS, START DEVICE, AND WAIT FOR
; DEVICE TO FINISH

PTPIOW:
	SETZB A,IOS
PTPSOW:
	PUSHJ PDP,PTPSOD	; STORE IOS BITS AND START DEVICE
	JRST WSYNC		; WAIT FOR DEVICE TO FINISH

; CLOCK INTERRUPT ROUTINES FOR PTP


;PDP-10 HERE WHEN PDP-6 HAS FINISHED BUFFER
↑PTPP1:	SETZM	PTPSID		;CLEAR REQUEST
	MOVEI DEVDAT,PTPDDB	; GET ADDRESS OF DEVICE DDP FOR SETIO
	JRST STTIOD		; SET IO WAIT SATISFIED BIT

;PDP-6 HERE WHEN PDP-10 HAS SET PTPACT
↑PTPP2:	MOVE TAC,PTPACT		; ARE WE TO START THE DEVICE FOR P1?
	JUMPE TAC,CPOPJ
	SETZM PTPACT		; YES, FLAG IT STARTED
	MOVEI DEVDAT,PTPDDB	; SET UP DEVDAT FOR PDVTIM
	CONO PI,PTPOFF		; SHUT OFF PTP
	HRLZI IOS,IO		; SET OUTPUT BIT IN IOS
	OR IOS,PTPIOS
	MOVEI C,PTPDON+PTPNOT	; ASK FOR INTERRUPTS UPON DONE OR OUT OF PAPER
;	TLOE IOS,DEVSBB		; IS PTP ALREADY RUNNING?
;	JRST PTPP2A		; YES, QUIT NOW
	MOVEM IOS,PTPIOS	; NO, STORE IOS
	CONO PTP,PTPDON+PTPCHN	; AND ASK FOR DONE INTERRUPT FROM PTP
	HRRM C,@PTPCON		; SET UP CONSO LOCATION
PTPP2A:
	CONO PI,PTPON		; RESTORE PI CHANNEL
	LDB C,PDVTIM		; RESET HUNG COUNT
	DPB C,PDVCNT
	POPJ PDP,

; OUTPUT ROUTINES ARE DIVIDED INTO PARTS AND KINDS, DEPENDING ON
; MODE OF OPERATION AND OTHER SUCH STUFF

PTPK1:
	MOVEI A,5		; SET UP CHARS PER WORD AS 5, ASCII MODE
	CAIA
PTPK3:
	MOVEI A,6		; BINARY MODE, 6 PER WORD
	MOVEM A,PTPCPW		; CHARACTERS PER WORD
PTPK1F:
	PUSHJ PDP,DEVSTU	; SET UP COUNT AND POINTR TO USER'S CORE
	JRST PTPK1A
	PUSHJ PDP,PTPBBI	; BLT BUFFER INTO SYSTEM CORE
	JRST PTPK1B		; NO ROOM IN THE INN . . .
	PUSHJ PDP,ADVBFE	; FIT AS MANY BUFFERS IN NOW AS IS POSSIBLE
	JRST PTPK1A
	JRST PTPK1F

PTPK1B:
	PUSHJ PDP,PTPIOW	; ASK TO START DEVICE AND WAIT
	JRST PTPK1F

PTPK2A:

PTPK1A:
	SKIPGE PTPBCN		; IS SYSTEM BUFFER EMPTY?
	JRST PTPK1C		; NO, START DEVICE AND LEAVE
	TLNN IOS,IOEND		; LAST UUO?
	POPJ PDP,		; NO, LET HIM GIVE ANOTHER ONE
PTPK1D:
	SETZ A,			; SET THE 'PTP DISCONNECT' BIT IN IOS
	HRLZI IOS,PTPEN1	; TELLS INTERRUPT SERVICE TO FEED A LITTLE
	JRST PTPSOD		; START DEVICE AND LEAVE

PTPK1C:
	TLNE IOS,IOEND		; LAST UUO?
	JRST PTPK1D		; YES, GO START DEVICE
	PUSHJ PDP,DEVCR		; DOES HE HAVE ANOTHER BUFFER TO FILL
	JRST PTPIOW		; NO, WAIT FIRST AND THEN LEAVE
	JRST PTPSTD		; START DEVICE AND LEAVE


; IN THIS MODE, WE BRING 1 CHAR PER WORD IN AND PACK 4 TO A WORD
; IN THE SYSTEM BUFFER

PTPK2:
	PUSHJ PDP,DEVSTU	; SET UP POINTR TO USER BUFFER
	JRST PTPK2A		; NOTHING THERE, LEAVE
	CAILE COUNT,PTPBLN	; IF'N HE'S ASK'N MORE'N WE GOT . . .
	JRST BTLERR		; FUCK'M!
	MOVN A,PTPBCN		; IS THERE ROOM IN THE INN?
	ADD A,COUNT		; ADD IN NUMBER OF WORDS TO BE TRANSFERRED
	CAIL A,4*PTPBLN		; COMPARE WITH TOTAL CHAR COUNT
	JRST PTPK2B		; CAN'T DO IT, LEAVE
	MOVSI A,(<POINT =8,0>)	; SET UP POINTER TO SYSTEM BUFFER
	HLLZ B,PTPUBP		; GET POINTER THAT IS ALREADY THERE
	JUMPN B,.+2		; IF NOT ALREADY SET UP . . .
	HLLM A,PTPUBP		; SET IT UP!!
	MOVEI B,1
	PSYNC PTPCSC

	MOVE B,PTPUBP		; BRING UP TO AN ACCUMULATOR FOR SPEED
PTPK2C:
	MOVE A,B		; CHECK FOR WRAP-AROUND
	IBP A
	HRRZS A			; GET THE NEXT POINTED TO ADDRESS
	CAIL A,PTPBUF+PTPBLN	; RUN OFF END OF BUFFER?
	MOVE B,[POINT =8,PTPBUF]

	MOVE A,(POINTR)		; PICK UP CHARACTER (WORD)
	IDPB A,B		; PACK INTO SYSTEM BUFFER
	SOS PTPBCN		; UPDATE CHARACTER COUNT
	AOJ POINTR,		; UPDATE USER CORE POINTER
	SOJG COUNT,PTPK2C	; LOOP AROUND

	MOVEM B,PTPUBP		; STORE THIS BACK FOR NEXT TIME
	MOVEI B,1
	XSYNC PTPCSC
	PUSHJ PDP,ADVBFE	; LOAD IN ANOTHER BUFFER IF POSSIBLE
	JRST PTPK2A		; NOT POSSIBLE, EXIT
	JRST PTPK2		; GO THROUGH THE ENTIRE BIT AGAIN

PTPK2B:
	PUSHJ PDP,PTPIOW	; START DEVICE AND WAIT UNTIL IT IS FINISHED
	JRST PTPK2		; THEN TRY AGAIN!!


; THIS IS FOR REAL BINARY MODE, WITH CHECKSUMS AND ALL
; BLT IN A SINGLE BUFFER, PUNCH IT, THEN PUNCH CHECKSUM AND FEEDER
; AFTER EVERY SINGLE BUFFERLOAD!

PTPK4:
	HRRZ TAC1,PTPADR	; SET UP ADDRESS
	PUSHJ PDP,CKS12		; CALCULATE CHECKSUM OF BUFFER
	ADDI TAC1,@PTPADR	; GET ADDRESS OF FIRST WORD OF DATA
	HLLM TAC,@TAC1		; PUT THE CHECKSUM NEXT TO THE WORD COUNT
	PUSHJ PDP,DEVSTU	; SET UP POINTR AND COUNT
	JRST PTPK4A		; NO BUFFERS TO EMPTY?
	AOJ COUNT,		; FUDGE BY ONE TO LEAVE ROOM FOR CHECKSUM AND WORD COUNT WORD
	SOJ POINTR,		; BACK POINTER UP BY ONE TOO
	MOVEI A,6		; BINARY MODE, 6 CHARS PER WORD
	MOVEM A,PTPCPW
	PUSHJ PDP,PTPBBI	; BRING IN A SINGLE BUFFER
	JSP DAT,UERROR		; THERE BETTER BE ROOM!!
	SKIPGE PTPBCN		; ANYTHING IN BUFFER?
	JRST PTPK4B		; YES, PUNCH IT
PTPK4C:
	PUSHJ PDP,ADVBFE	; NO, IS THERE ANOTHER BUFFER?
	POPJ PDP,		; NO, LET HIM FILL ONE
	JRST PTPK4		; YES, BRING IT IN

PTPK4A:
	TLNE IOS,IOEND		; LAST UUO?
	JRST PTPK1D		; YES, SHUDDER!
	POPJ PDP,		; NO, LET HIM FILL SOME BUFFERS

PTPK4B:
	HRLZI IOS,PTPFT		; THIS IS A 'FEED-WHEN-TERMINATING' SITUATION
	SETZ A,			; SO TELL THE INTERRUPT SERVICE ABOUT IT
	PUSHJ PDP,PTPSOW	; START DEVICE AND WAIT FOR IT TO STOP
	JRST PTPK4C		; LOOP BACK AGAIN AND AGAIN


; HERE, WE TRY TO FIT THE USER'S BUFFER INTO SYSTEM CORE

PTPBBI:
	JUMPE COUNT,CPOPJ1	; ZERO-LENGTH BUFFER IS AN AUTOMATIC SUCCESS
	CAILE COUNT,PTPBLN	; SEE IF HE WANTS MORE THAN WE CAN GIVE
	JRST BTLERR		; YES, SCREW HIM!
	MOVEI B,1
	SKIPE PTPMOD		; FAST OR SLOW MODE?
	JRST PTPZZ0
	CONO PI,PTPOFF	; FAST MODE, DO CONO DIRECTLY
	JRST PTPZZ1
PTPZZ0:
	PSYNC PTPCSC
PTPZZ1:
	MOVE A,PTPIBP		; PICK UP INTERRUPT LEVEL BYTE POINTER
	IBP A			; THIS IS TO GET THE DISTANCE, IN WORDS, BETWEEN THE TWO POINTERS
	HRRZS A			; WHICH IS THE NUMBER OF AVAILABLE WORDS IN THE BUFFER
	MOVEI B,PTPBUF+PTPBLN	; WE ALSO NEED THE DISTANCE TO THE END OF THE BUFFER
	SUB B,PTPUBP		; FOR WRAP-AROUND PURPOSES
	SUB A,PTPUBP		; DISTANCE BETWEEN POINTERS
	JUMPLE A,PTPBB6		; POINTER WRAP-AROUND, SPECIAL CASE
PTPBB5:
	CAMGE A,COUNT		; SEE IF THERE IS ULTIMATLY ROOM
	JRST PTPBB7		; NO, FAILURE
	JUMPE B,PTPBB2		; IF ZERO, IT IS A SPECIAL CASE
	HRLZ C,POINTR		; SET UP BLT WORD. SOURCE IS USER CORE
	HRR C,PTPUBP		; DESTINATION IS SYSTEM CORE
	CAMLE COUNT,B		; NOW WE DECIDE WHETHER WE MUST WRAP AROUND
	JRST PTPBB1		; YES, GO WRAP IT UP
	HRRZ B,PTPUBP		; NO, GET LAST WORD TO BE TRANSFERRED
	ADD B,COUNT		; BY ADDING THE SOURCE AND THE COUNT
	BLT C,-1(B)		; AND SUBTRACTING ONE AT INDEX TIME
	ADDM COUNT,PTPUBP	; UPDATE BUFFER CHARACTER POINTER
PTPBB3:
	IMUL COUNT,PTPCPW	; UPDATE BUFFER CHARACTER COUNT TOO
	SUB COUNT,PTPBCN	; SUBTRACT OFF CURRENT COUNT
	MOVNM COUNT,PTPBCN	; CORRECT SIGN AND STORE
	AOS (PDP)		; SET TO SKIP, SUCCESS
PTPBB7:
	SKIPE PTPMOD
	JRST PTPZZ3
	CONO PI,PTPON
	POPJ PDP,
PTPZZ3:
	XSYNC PTPCSC
	POPJ PDP,

; COME HERE IF WE HAVE TO DO 2 SEPARATE BLT'S

PTPBB1:
	BLT C,PTPBUF+PTPBLN-1	; FIRST BLT, TO END OF SYSTEM BUFFER
PTPBB2:
	MOVE C,COUNT		; PICK UP WORD COUNT
	SUB C,B			; THIS IS NUMBER OF WORDS LEFT TO TRANSFER
	ADDI B,(POINTR)		; THIS IS PLACE TO START TRANSFERRING FROM
	HRLZS B			; SWAP IT
	HRRI B,PTPBUF		; DESTINATION IS START OF BUFFER
	BLT B,PTPBUF-1(C)	; TRANSFER REMAINDER OF BUFFER
	HRROI C,-PTPBLN(COUNT)	; WORD COUNT, WRAPPED AROUND
	ADDM C,PTPUBP		; UPDATE POINTER
	JRST PTPBB3

; COME HERE IF THE DIFFERENCE OF THE TWO POINTERS IS NEGATIVE

PTPBB6:
	JUMPN A,.+2		; IF NON-ZERO, NOTHING TO WORRY ABOUT
	SKIPN PTPBCN		; ZERO. HMMM. IF COUNT IS NOT ZERO, THEN THERE IS NO ROOM IN THE INN!!
	ADDI A,PTPBLN		; ADD IN TOTAL BUFFER LENGTH
	JRST PTPBB5

; THIS ROUTINE SETS UP THE CRAZY DISPATCHES FOR EACH OF THE VARIOUS MODES OF OPERATION

PTPSUD:
	PUSHJ PDP,PTPINI	; INITIALIZE TABLES
	ANDI IOS,117		; LEAVE ONLY THE MODE BITS IN IOS
	TLO IOS,IO+PTPBG1	; SET OUTPUT BIT AND FEED BIT
	MOVEM IOS,DEVIOS(DEVDAT)
	LDB A,PIOMOD		; PICK UP MODE BITS, BOTTOM 4 BITS IN IOS
	JUMPE A,PTPSKA		; MODES 0 AND 1 ARE IDENTICAL
	CAIN A,1
	JRST PTPSKA
	CAIN A,10		; MODE 10 - IMAGE MODE, 1 BYTE PER WORD
	JRST PTPSKB
	CAIN A,13		; MODE 13 - BINARY, NO CHECKSUMMING
	JRST PTPSKC
	CAIN A,14		; MODE 14 - BINARY WITH CHECKSUMMING
	JRST PTPSKD
	JSP DAT,UERROR		; IT REALLY CAN'T GET HERE.  - CAN IT?

PTPSKA:
	MOVEI A,PTPK1		; UUO LEVEL KIND 1
	MOVE C,[POINT 7,PTPBUF]	; 7-BIT BYTES AT INTERRUPT LEVEL
	MOVEI B,PTPT2		; INTERRUPT LEVEL TYPE 2
	TRNE IOS,100		; CHECK FOR ALTERNATE MODES
	MOVEI B,PTPT1		; INT. LEVEL TYPE 1 - NON-PARITY 8TH HOLE, NO DELETES AFTER TABS
PTPSKE:
	MOVEM A,PTPUDS		; UUO-LEVEL DISPATCH ADDRESS
	MOVEM B,PTPIDS		; INTERRUPT-LEVEL DISPATCH ADDRESS
	MOVEM C,PTPIBP		; INTERRUPD-LEVEL BYTE POINTER
	MOVEI A,PTPBUF		; SET UP UUO-LEVEL BUFFER POINTER
	MOVEM A,PTPUBP		; NOT A BYTE POINTER, JUST AN ADDRESS
	SETZM PTPBCN		; BUFFER IS EMPTY, CLEAR COUNT
	JRST PTPO1		; RETURN TO OUTPUT ROUTINE

PTPSKB:
	MOVEI A,PTPK2		; UUO LEVEL KIND 2, PACK USER BUFFER INTO SYSTEM BUFFER
	MOVEI B,PTPT3		; INT LEVEL TYPE 3, 8-BIT BYTES
	MOVE C,[POINT =8,PTPBUF]
	JRST PTPSKE

PTPSKC:
	MOVEI A,PTPK3		; UUO LEVEL KIND 3, BINARY MODES
	MOVEI B,PTPT1		; INT. LEVEL TYPE 1, PUNCH 8TH HOLE
	MOVE C,[POINT 6,PTPBUF]	; 6-BIT BYTES, 6 TO A WORD
	TRNE IOS,100		; THIS EFFECTS THE ANAL-CRANIAL INVERSION
	MOVEI B,PTPT3		; THIS MEANS DON'T PUNCH 7TH OR 8TH HOLE AT ALL
	JRST PTPSKE

PTPSKD:
	TRNE IOS,100
	JRST PTPSKC		; 100 BIT HERE MEANS SOMETHING ENTIRELY DIFFERENT
	MOVEI A,PTPK4		; UUO LEVEL KIND 4, CHECKSUMM A LOT
	MOVEI B,PTPT1		; INT. LEVEL TYPE 1, PUT IN 8TH HOLE ALWAYS
	MOVE C,[POINT 6,PTPBUF]	; SET FOR 6-BIT BYTES
	JRST PTPSKE


; INTERRUPT SERVICE ROUTINES - OBOYOBOYOBOY!

↑PTPINT:
	JSR @PTPSAV		; SAVE ACCUMULATORS FIRST
	MOVEI DEVDAT,PTPDDB	; SET UP DEVDAT FOR EVERYBODY'S BENEFIT
	SKIPE PTPFCN		; ANY FEED COUNT LEFT?
	JRST PTPFED		; GO PUNCH A FEED HOLE OR TWO
	MOVEI B,2		; WE ARE P2
	SKIPN PTPMOD		; MUST WE SYNCHRONIZE?
	JRST PTPZZ2		; NO, SKIP IT
	PSYNC PTPCSC
PTPZZ2:
	MOVE IOS,PTPIOS		; WE HAVE TO INSPECT THIS FIRST
	TLZE IOS,PTPBG1		; IS THIS THE FIRST BUFFERLOAD?
	JRST PTPF1		; YES, WE SHOULD PUNCH FEED FIRST
	TLZE IOS,PTPPDN		; DO WE HAVE A DANGLING DELETE?
	JRST PTPIDN		; YES, GO PUNCH IT
	SKIPN PTPBCN		; IS THERE ANYTHING IN THE SYSTEM BUFFER?
	JRST PTPOF		; NO, QUIT AND GO HOME
	AOS PTPBCN		; DECREMENT CHAR COUNT
	MOVE D,PTPIBP		; PICK UP BYTE POINTER
	IBP D			; INCREMENT POINTER TO CHECK FOR WRAP-AROUND
	HRRZ C,D		; GET ADDRESS PORTION
	CAIL C,PTPBUF+PTPBLN	; IS BYTE POINTER OUT OF RANGE?
	HRRI D,PTPBUF		; YES, RESET ADDRESS TO START OF BUFFER
	LDB C,D			; PICK UP CHARACTER
	MOVEM D,PTPIBP		; REPLACE BYTE POINTER
	JRST @PTPIDS		; AND PUNCH IT CORRECTLY

PTPT1:
	ORI C,200		; TYPE 1 - ALWAYS PUNCH 8TH HOLE
PTPT3:
	DATAO PTP,C		; TYPE 3 - NO MODIFICATION AT ALL
	LDB C,PDVTIM		; SET HUNG COUNT
	DPB C,PDVCNT
PTPXIT:
	MOVEM IOS,PTPIOS	; THIS PROCESSOR OWNS IOS
	SKIPN PTPMOD
	POPJ PDP,
	XSYNC PTPCSC
	POPJ PDP,

; TYPE 2 - PUNCH PARITY AND DELETES AFTER CR, FF, VT AND  HT

PTPT2:
	JUMPE C,PTPT3		; TYPE 2 - PARITY AND DELETES AFTER THESE CHARACTERS
	CAIE C,15		; C.R. RATES A DELETE
	CAIN C,11		; V.T. RATES A DELETE FOR THE LOSING ASR35
	TLO IOS,PTPPDN		; PUNCH DELETE NEXT TIME AROUND
	CAIN C,13		; V.T.
	TLO IOS,PTPPDN
	CAIN C,14		; F.F. MEANS PUNCH A LOT OF FEED
	JRST PTP2A
PTP2B:
	MOVE D,C		; NOW COMPUTE PARITY ON THE CHARACTER
	IMULI D,200401		; MAKE 3 COPIES OF THE NUMBER
	AND D,[11111111]	; MAKES ONE COPY OF EACH BIT, EVERY 3RD BIT. NUMBER IS NOW SPREAD OUT
	IMUL D,[11111111]	; ADD UP BITS IN LH
	TLNE D,10		; NOW, DO WE NEED PARITY?
	IORI C,200		; YES, INSERT IT
	JRST PTPT3		; AND PUNCH CHAR

PTP2A:
	MOVNI D,30		; PUNCH 30 FEED HOLES
	MOVEM D,PTPFCN		; SET THIS IN OUR REGISTER
	JRST PTP2B		; AND RETURN TO CALCULATE PARITY


; LAST PAGE - PUNCH FEED HOLES, SHUT OFF PTP

PTPF2:
	MOVNI C,30		; PUNCH 30 HOLES FOR MODE 14
	CAIA
PTPF1:
	MOVNI C,100		; STANDARD INITIAL AND FINAL FEED
	MOVEM C,PTPFCN		; INTO FEED COUNT REGISTER
	MOVEM IOS,PTPIOS	; STORE IOS
	SKIPN PTPMOD
	JRST PTPFED
	XSYNC PTPCSC		; SLOW MODE, RELEAS CONTROL OF IOS
PTPFED:
	AOS PTPFCN		; DECREMENT FEED COUNT
	DATAO PTP,[0]		; GIVE IT A FEED WORD
	LDB C,PDVTIM		; SET HUNG COUNT
	DPB C,PDVCNT
	POPJ PDP,		; AND LEAVE

PTPIDN:
	MOVEI C,377		; PUNCH A DELETE, FLAG HAS BEEN CLEARED
	JRST PTPT3

PTPOF:
	TLZE IOS,PTPEN1		; OH MAMA, CAN THIS REALLY BE THE END?
	JRST PTPF1		; IT IS, FEED BEFORE LEAVING
	TLZE IOS,PTPFT		; IS THIS THE 'FEED WHEN TERMINATING' BIT?
	JRST PTPF2		; YES, DO IT
	CONO PTP,0		; CLEAR PTP REGISTERS
	HLLZS @PTPCON		; DON'T CONFUSE INTERRUPT SERVICE DISPATCHES
	SKIPE PTPMOD		; ARE WE IN FAST OR SLOW MODE?
	JRST PTPOF1		; SLOW MODE, SET A FLAG FOR P1 TO SEE
	TLZE IOS,IOW		; ARE WE IN AN IO WAIT?
	PUSHJ PDP,STTIOD	; YES, SET IO DONE
PTPOF2:
	TLZ IOS,DEVSBB		; CLEAR BUSY FLAG, ALTHOUGH NOONE LOOKS AT IT
	SETZM PTPBCN		; BUFFER IS NOW EMPTY, MARK IT AS SUCH!
	JRST PTPXIT

PTPOF1:
	TLZE IOS,IOW		; ARE WE IN AN IO WAIT?
	SETOM PTPSID		; YES, ASK TO CALL SETIOD FOR US
	JRST PTPOF2

BEND PTPSER
;: PTPSER[J17,SYS] EOF.
;: PTRSER[J17,SYS]
COMMENT ⊗   VALID 00005 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN PTRSER 
 SUBTTL PTRSER	PAPER TAPE READER SERVICE, J. SAUTER, 11-NOV-68
C00003 00003	UUO DISPATCH TABLE:
C00009 00004	PAPER TAPE READER INTERRUPT.
C00013 00005	P1 CLOCK LEVEL AND HUNG TIMEOUT CODE
C00019 ENDMK
C⊗;

BEGIN PTRSER 
 SUBTTL PTRSER	PAPER TAPE READER SERVICE, J. SAUTER, 11-NOV-68

;PTR CONTROL REGISTER
POWER←←400		;POWER ON ON PDP-6, NOT EOT ON PDP-10.
BINARY←←40		;BINARY MODE.
BUSY←←20		;PTR IS BUSY READING A WORD.
DONE←←10		;PTR HAS A WORD.

;SPECIAL ASCII CHARACTERS:
NULL←←200		;NULL CHARACTER
RUBOUT←←377		;RUBOUT.

;SPECIAL BITS IN LH OF IOS:
PTRPOW←←200000		;PTR HAS (HAD) POWER ON.
PTRNPW←←100000		;PTR DOESN'T HAVE POWER ON FOR FIRST OPERATION.
STOPTR←←40000		;HUNG TIMEOUT ASSUMES EOF.

;UUO DISPATCH TABLE:
	JRST	PTRINI		;INITIALIZE.
	JRST	PTRHNG		;HUNG  TIMEOUT.
↑PTRDSP:
	JRST	PTRXRL		;RELEASE.
	POPJ	P,		;CLOSE.
	JRST	ILLOUT		;OUTPUT

;INPUT UUO
PTRINP:
	PSYNC	PTRCSC
	PUSHJ	P,SETACT	;SET IOACT.
	TLNN	IOS,IOBEG	;FIRST TIME?
	JRST	@PTRIN1		;NO.
	TLO	IOS,IOFST	;YES.  SET UP THINGS.
	TLZ	IOS,PTRPOW
	PUSHJ	P,SETBYT	;SET UP TAC.
	MOVEM	TAC,PTRPTR	;SAVE FOR INTERRUPT ROUTINES.
PTRIN5:
	TLZN	IOS,PTRNPW	;HAS THE LOSER FLAG BEEN SEEN ALREADY?
	JRST	@PTRIN1		;TO PTRP1U FOR 1 PROCESSOR, OR PTRP2U FOR TWO.
;HERE ON SECOND INPUT AFTER FIRST INPUT DISCOVERED POWER OFF ON THE PDP-6 READER
	PUSHJ	P,CLRACT	;CLEAR IO ACTIVE
	XSYNC	PTRCSC		;RELEASE SYNCHRONIZER.
	PUSHJ	P,HNGSTP	;PRINT DEVICE PTR OK? AND STOP JOB.
	JRST	PTRINP

PTRP2U:
	PUSHJ	P,STOIOS	;STORE IOS.
	SETOM	PTRACT		;REQUEST P2 TO START READER.
	JRST	XPOPJ		;DESYNCHRONIZE AND EXIT

;HERE AT P2 CLOCK LEVEL
↑PTRP2:	MOVE	TAC,PTRACT	;P2 START REQUEST?
	JUMPE	TAC,CPOPJ	;NO.
	PSYNC	PTRCSC		;SYNCHRONIZE.
	SETZM	PTRACT		;INDICATE REQUEST GRANTED.
	MOVEI	DDB,PTRDDB	;SET UP DDB AND IOS.
	MOVE	IOS,DEVIOS(DDB)
	TLZE	IOS,STOPTR	;
	JRST	PTRYRL		;HUNG TIMEOUT REQUESTS THAT THE READER STOP.
PTRP1U:

PTRIN2:
	TLZN	IOS,IOBEG		;FIRST TIME?
	JRST	PTRIN3			;NO.
	CONSZ	PTR,POWER		;YES.  POWER ON?
	TLOA	IOS,PTRPOW		;YES.
	JUMPN	PID,PTRIN4		;POWER OFF ON PDP-6 READER.
	SKIPA	TAC1,[PTRCHN!BUSY]	;SET TAC1 WITH CONO START
PTRIN3:
	MOVEI	TAC1,PTRCHN!DONE	;SET TAC1 WITH CONO CONTINUE
	PUSHJ	P,STOIOS		;STORE IOS, RESET HUNG COUNT.
	LDB	TAC,PIOMOD		;GET MODE.
	CAIE	TAC,IB			;IMAGE BINARY?
	CAIN	TAC,B			;OR BINARY?
	TRO	TAC1,BINARY		;YES.  SET READER INTO BINARY MODE.
	MOVEM	TAC1,PTRSTR		;REMEMBER FOR INTERRUPT LEVEL.
	MOVEI	TAC,DONE		;WAIT FOR DONE FLAG.
	CONO	PI,PTROFF
	SETZM	PTRDSC			;SET NOT PTR DISCONNECTING.
	HRRM	TAC,@PTRCON		;SET UP BITS.
	CONSO	PTR,7			;SKIP IF READER IS RUNNING!
	CONO	PTR,@PTRSTR		;READER IDLE.  KICK IT.
	CONO	PI,PTRON
	CONSZ	PTR,POWER		;WE SHOULD SEE POWER OR TAPE BY NOW.
	JRST	XPOPJ			;DESYNCRONIZE AND RETURN.
PTRIN4:
	TLO	IOS,PTRNPW!IOBEG	;FLAG NO POWER AVAILABLE
	TLZN	IOS,STOPTR
	SETOM	PTRADV			;FLAG THE PDP-10
	PUSHJ	P,STOIOS		;STORE IOS
	JUMPN	PID,XPOPJ
	JRST	PTRIN5			;HANG ON THE PDP-10

PTRINI:
	SYNINI	PTRCSC		;INITIALIZE SYNCHRONIZER CELLS.
;DETERMINE WHICH PROCESSOR TO USE.  IF ONE PROCESSOR IS A
;PDP-6, USE IT.  IF P2 DOES NOT EXIST, USE P1, OTHERWISE,
;USE P2.
	MOVEI	AC1,PTRP1U	;ASSUME P1
	MOVEI	AC2,PTRCN1
	HRRZ	TAC,P2NUM	;GET NUMBER OF P2 (=6 OR =10)
	CAIN	TAC,6		;IS IT A PDP-6?
	JRST	USEP2		;YES. USE IT.
	JUMPE	TAC,USEP1	;IF THERE IS NO P2, USE P1.
	HRRZ	TAC,P1NUM	;GET NUMBER OF P1.
	CAIN	TAC,6		;IS IT A PDP-6?
	JRST	USEP1		;YES. USE IT.
USEP2:
	MOVEI	AC1,PTRP2U
	MOVEI	AC2,PTRCN2
USEP1:
	MOVEM	AC1,PTRIN1	;SET DISPATCH FOR INPUT UUO'S
	MOVEM	AC2,PTRCON	;SET ADDRESS FOR CONSZ BITS.
	HLLZS	PTRCN1
	HLLZS	PTRCN2

PTRXRL:
	SETZM	PTRDDB+DEVIOS	;CLEAR READER STATUS.  RELEASE UUO.
↑PTRREL:			;ALSO CALLED FROM SYSINI
	CONO	PTR,0		;STOP READER, DISCONNECT IT FROM PI
	HLLZS	@PTRCON
	POPJ	P,

PTRYRL:
	PUSHJ	P,IOSET
	JRST	PWROFF		;SIMULATE POWER OFF.

;PAPER TAPE READER INTERRUPT.
↑PTRINT:
	SKIPL	PTRDSC		;SKIP DATAI IF WE ARE DISCONNECTING.
	DATAI	PTR,PTRCHR	;READ CHAR FROM READER.
	JSR	@PTRSAV		;SAVE ACCUMULATORS.
	PSYNC	PTRCSC
	MOVEI	DDB,PTRDDB	;SET UP REGISTERS
	PUSHJ	P,IOSET
	MOVE	IOS,DEVIOS(DDB)
	CONSO	PTR,POWER	;POWER ON?
	JRST	PWROFF		;NO.
	TLON	IOS,PTRPOW	;POWER IS ON NOW, WAS IT BEFORE?
	JRST	PTRXIT		;POWER IS ON FOR THE FIRST TIME.
	SKIPE	PTRDSC		;IS PTR BEING DISCONNECTED?
	JRST	PTRDIS		;YES. DO IT.
	MOVE	DAT,PTRCHR	;GET CHARACTER.
PTRIN0:
	TRNE	IOS,B		;BINARY MODE?
	JRST	PTRI0		;YES. (MODES 10,13,14)
	IORI	DAT,200		;IGNORE PARITY.
	CAIE	DAT,NULL	;NULL CHARACTER?
	CAIN	DAT,RUBOUT	;OR RUBOUT?
	JRST	PTRXIT		;YES.  IGNORE CHAR AND START READING NEXT.
PTRI0:
	PUSHJ	P,STODAT	;STORE DATA IN BUFFER.
	JFCL			;CHECKSUM ERROR.
	JRST	PTRI1		;BLOCK COMPLETE.
	MOVEM	ITEM,DEVCTR(DDB);INCOMPLETE.  STORE ITEM.
PTRXIT:

PTRXT1:
	PUSHJ	P,STOIOS	; STORE IOS, RESET HUNG COUNT
XPOPJ:
	XSYNC	PTRCSC
	POPJ	P,		;DISMISS INTERRUPT.

;MORE I-LEVEL ROUTINES.
PWROFF:
	TLZ	IOS,PTRPOW	;NOTE THAT READER IS OFF.
	TLO	IOS,IOEND+IOBEG
	PUSHJ	P,PTRREL	;SHUT IT OFF!
	LDB	TAC,PIOMOD	;GET MODE.
	CAIE	TAC,B		;CHECKSUM-BINARY?
	JRST	PTREI		;NO.
	TLNN	IOS,IOFST	;INCOMPLETE BLOCK?
	TRO	IOS,IOIMPM	;YES. COMPLAIN.
	PUSHJ	P,CLRACT	;CLEAR I/O ACTIVE BIT.
	JRST	PTRI1A		

;BLOCK INCOMPLETE
PTREI:
	PUSHJ	P,STOSQD	;TRUNCATE BUFFER, STORE W.C.
	JFCL			;FALL INTO PTRI1
;BLOCK COMPLETE.
PTRI1:
	MOVEM	ITEM,DEVCTR(DDB);STORE ITEM COUNT.
PTRI1A:
	JUMPE	PID,PTRI2	;NO. ONE PROCESSOR
	SETOM	PTRDSC		;MUST DISCONNECT PTR
	TLZN	IOS,STOPTR
	SETOM	PTRADV		;REQUEST BUFFER ADVANCE.
	JRST	PTRXT1		;RELEASE CONTROL OF IOS AND DISMISS

PTRI2:
	TLO	IOS,IOFST	;(SINGLE PROCESSOR)
	TLZE	IOS,IOW		;UNWAIT THE JOB.
	PUSHJ	P,SETIOD	;IF NEEDED.
	TLNE	IOS,PTRPOW	;POWER OFF?
	PUSHJ	P,ADVBFF	;NOT POWER OFF, ADVANCE BUFFERS
	JRST	PTRI3		;NO MORE BUFFER SPACE.
	JRST	PTRXIT		;START READER, STORE IOS, AND  DISMISS INTERRUPT.

PTRI3:
	PUSHJ	P,CLRACT	;NO BUFFER SPACE. CLEAR IOACT.
	SETOM	PTRDSC		;REQUST PTR DISCONNECT.
	JRST	PTRXT1		;RELEASE SYNCHRONIZER. DISMISS INTERRUPT.

PTRDIS:
	JUMPN	PID,PTRDS1
	SKIPG	@PTRADR		;BUFFER FREE?
	JRST	PTRDS1		;NO. MUST DISCONNECT.
	DATAI	PTR,DAT
	JRST	PTRIN0		;INPUT CHARACTER AND PROCESS AS NORMAL.

PTRDS1:
	PUSHJ	P,PTRREL	;STOP PTR.
	JRST	PTRXT1		;DISMISS INTERRUPT

;P1 CLOCK LEVEL AND HUNG TIMEOUT CODE

PTRHNG:
	MOVE	TAC,PTRIN1
	CAIN	TAC,PTRP1U
	POPJ	P,			;ON PDP-10 I DON'T UNDERSTAND HANGS.
	PSYNC	PTRCSC			;SYNCHRONIZE.
	MOVE	IOS,PTRDDB+DEVIOS	;GET IOS
	TLZN	IOS,PTRPOW		;HAVE WE SEEN POWER ON?
	JRST	XPOPJ			;NO. LET IT HANG.
	TLON	IOS,STOPTR!IOEND	;MAKE PTR STOP. PRETEND END OF TAPE.
	AOS	(P)			;SET SKIP RETURN TO AVOID HUNG PTR MESSAGE
	MOVEM	IOS,PTRDDB+DEVIOS	;STORE IOS
	SETOM	PTRACT			;KICK PDP-6
	JRST	XPOPJ			;RELEASE SYNCHRONIZER AND WAIT FOR PDP-6.


;HERE AT P1 CLOCK LEVEL
↑PTRP1:	SETZM	PTRADV		;CLEAR REQUEST
	PSYNC	PTRCSC
	MOVEI	DDB,PTRDDB	;LOAD UP REGISTERS.
	MOVE	IOS,DEVIOS(DDB)
	TLNE	IOS,PTRNPW
	TRO	IOS,IOIMPM	;READING WITHOUT READER ON.
	TLO	IOS,IOFST	;NEXT ITEM WILL BE FIRST OF A BUFFER.
	TLZE	IOS,IOW		;IS JOB WAITING FOR PTR?
	PUSHJ	P,SETIOD	;YES.  UNWAIT IT.
	LDB	J,PJOBN		;SET J
	MOVE	PROG,JBTADR(J)	;
	PUSHJ	P,ADVBFF	;ADVANCE BUFFERS.
	JRST	PTRP1A		;OUT OF BUFFER SPACE.
	TLNE	IOS,IOEND!PTRNPW ;END OF FILE OR ERROR?
	JRST	PTRP1A		;YES. STOP READER.
	PUSHJ	P,STOIOS	;STORE IOS.
	SETOM	PTRACT		;ACTIVATE PTR.
	JRST	XPOPJ		;RELEASE SYNCHRONIZER AND RETURN

PTRP1A:
	PUSHJ	P,CLRACT	;CLEAR IOACTIVE, DON'T RESTART THE READER
	JRST	XPOPJ

BEND PTRSER
;: PTRSER[J17,SYS] EOF.
;: ADCSER[J17,SYS]
COMMENT ⊗   VALID 00024 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00004 00002	BEGIN	ADCSER	
SUBTTL NEW AD/DA SERVICE ROUTINE
C00006 00003	 UUO DISPATCH TABLE FOR ADC
C00007 00004	 ADC MTAPE UUO. SETS PARAMETERS.
C00010 00005	 ADC DUMP MODE INPUT ROUTINE
C00013 00006	 ADC HUNG TIMEOUT, ADHUNG, ADC INITIALIZE CODE, ADCINI, ADC RELEASE, ADCREL
C00015 00007	 ADCP2 - PDP-6'S CLK LEVEL ROUTINE FOR THE ADC
C00017 00008	 ADCP2 CONT - STARTUP CODE, SET `RUN' FLAG, CHECK FOR IO SYNC
C00019 00009	 ADCP1 - PDP-10'S CLOCK ROUTINES FOR THE ADC
C00021 00010	 ADC INTERRUPT ROUTINES, ADCIST FOR SPURIOUS, ADCINT FOR NORMAL
C00024 00011	 ADC INTERRUPT ROUTINES, ADCRCY FOR RECYCLING INPUT
C00025 00012	 ADC INTERRUPT ROUTINES - ADCSMD, SWITCH MODES FROM CYCLE TO NORMAL
C00028 00013	 ADC INTERRUPT ROUTINES - ADCILA, ADCW, ADCWK, ADCILI, END OF XFR
C00031 00014	 UUO DISPATCH TABLE FOR DAC
C00032 00015	 DAC MTAPE UUO. SETS PARAMETERS.
C00034 00016	 DAC DUMP MODE OUTPUT ROUTINE
C00037 00017	 DAC HUNG ROUTINE, DAHUNG, DAC INITIALIZE ROUTINE, DACINI, RELEASE, DACREL
C00038 00018	 DACP2 - PDP-6'S CLK LEVEL ROUTINE FOR THE DAC
C00041 00019	 DACP1 - PDP-10'S CLOCK ROUTINES FOR THE DAC
C00042 00020	 DAC INTERRUPT ROUTINES, DACIST FOR SPURIOUS, DACINT FOR NORMAL
C00044 00021	 DAC INTERRUPT ROUTINES - WAKEUP AND `RUN' FLAG BUSINESS
C00046 00022	 ROUTINE MAKES UP A CONO WORD FROM MTAPE SPECS
C00049 00023	 ADRCHK - ROUTINE TO ADDRESS CHECK AN IOWD, CHKUUO - CHECKS UUO ADDR
C00051 00024	 END OF IT ALL
C00052 ENDMK
C⊗;

BEGIN	ADCSER	
SUBTTL NEW AD/DA SERVICE ROUTINE
;JAM 2-10-74

; IOS BITS, RH

CYCDON←←20	; CIRCULATION DONE
IOSYNC←←40	; SYNCHRONIZE AD AND DA AT STARTUP
CONT←←100	; CONTINUOUS MODE (NO WAIT AFTER DMP MODE COMMAND)
CYCLE←←200	; CIRCULATE INPUT MODE
LOST←←2000	; LOST. MEANS DATA MISSED.
IOAFT←←4000	; IOSYNC∧CYCLE∧IOAFT ⊃ START OUTPUT AFTER
		;    RECYCLE DONE, NOT BEFORE.
ERRMSK←←IOIMPM!IODTER!IODERR!IOBKTL

; CONO BITS

FILT←←200000	; 2-BIT FILTER NUMBER GOES HERE
RUNB←←100000
MPX←←040000	; ALTERNATE INPUT (ADC ONLY)
FLOAT←←040000	; 9-BIT FLOATING INCREMENTAL MODE (DAC ONLY)
.16BIT←←020000	; HALFWORD MODE (LEFT ADJUSTED)
.12BIT←←010000	; COMPATIBILITY MODE
SPEED←←100	; 3-BIT SPEED NUMBER GOES HERE
QUAD←←40
STEREO←←20
MONO←←10

; CONI BITS - ADC

DATARQ←←40
BUFFUL←←20
ADLOST←←10

; CONI BITS - DAC

BUFRDY←←4000
INTRQ←←2000
DALOST←←1000

; CODES THAT GO IN P2 CELLS (ADCP2L, DACP2L)

STCODE←←1	; STARTUP. IOWD IN XXXNBK
KLCODE←←2	; CLEAR.

; CODES THAT GO IN P1 CELLS (ADCP1L, DACP1L)

WKCODE←←1	; WAKE UP JOB
ERCODE←←2	; ERROR. (ADDRESS CHECK)

; UUO DISPATCH TABLE FOR ADC

	JRST ADCINI	; SYSTEM STARTUP
	JRST ADHUNG	; HUNG TIME OUT
↑ADCDSP:JRST ADCREL	; RELEASE
	POPJ P,		; CLOSE OUTPUT
	JRST UUOERR	; BUFFERED OUTPUT
	JRST ILLINP	; BUFFERED INPUT
	JRST CPOPJ1	; ENTER
	JRST CPOPJ1	; LOOKUP
	JRST UUOERR	; DMP MODE OUTPUT
	JRST ADCIN	; DMP MODE INPUT
	POPJ P,		; USETO
	POPJ P,		; USETI
	POPJ P,		; UGETF
	JRST CPOPJ1	; RENAME
	POPJ P,		; CLOSE INPUT
	POPJ P,		; UTPCLR
	JRST ADCMTP	; MTAPE

; ADC MTAPE UUO. SETS PARAMETERS.
; EFFECTIVE ADDRESS POINTS TO THREE WORD BLOCK
; FIRST WORD (RH SAME AS DAC)
;  	<RECYCLE END THRESHHOLD>,,SPEED*1000+PACK*100+NCHANS
;       <R.E. THRESH> IS LEFT ADJUSTED, 12 OR 16 BIT 2'S COMP NUMBER
;		WHEN INPUT SAMPLE EXCEEDS THAT, WE END RECYCLING
;	SPEED = 0	6.4 KC		IS PER CHANNEL RATE
;		1	12.8 KC
;		2	25.6 KC
;		3	51.2 KC		MAX FOR ADC. DAC GOES ON UP.
; SECOND WORD (SAME AS DAC)
;	<ADDR FOR ERR CODES>,,<ADDR FOR `RUN' FLAG>
;	<`RUN' FLAG IS `SETOM'ED WHILE ADC IS RUNNING AND ZEROED WHEN
; 		ADC IS SHUT OFF
; THIRD WORD (NOT USED IN DAC)
;	<INPUT SELECT>,,<ADDR TO PUT RECYCLE IOWD>
;	<INPUT SELECT> IS CURRENTLY ONE BIT, THE SIGN BIT. MEANS `MPX'
;	<ADDR . . .> IS WHERE WE PUT THE RECYCLE IOWD WHEN
;		THE INPUT SAMPLE HAS EXCEEDED THE THRESHHOLD AND WE
;		THUS SWITCH BUFFERS

ADCMTP:
	TLZN IOS,IOBEG		; FIRST UUO?
	JRST ADCFST
	MOVEM IOS,ADCIOS
	PUSHJ P,ADCINI		; CLEAR OUT DDB
ADCFST:
	PUSHJ P,CHKUUO		; ADDRESS CHECK EFFECTIVE ADDR OF UUO
				; LEAVES LAST WD OF CORE IMAGE IN AC1,
				; RH OF UUO IN AC2
	ADDI AC2,2		; DO SO WITH END OF TABLE TOO
	CAILE AC2,(AC1)
	JRST ADRERR
	MOVE TAC,@UUO		; PICK UP THRESH,,PARAMS
	HLLZM TAC,ADCTHR	; SET THRESHHOLD
	PUSHJ P,SETCNO		; SET UP CONO WORD IN TAC1
	MOVEM AC2,ADCWPS	; SAVE # WORDS PER SECOND
	TRNE TAC1,4*SPEED	; IS SPEED>3
	JRST ILLSPD		; YES, IS ERROR.
	TRNE TAC1,MPX		; FLOAT MODE FOR ADC?
	JRST ILLMOD		; IS ERROR
	ADDI UUO,1		; BUMP TO ERR CODE WORD
	MOVE AC1,@UUO
	HLRZM AC1,ADCERA	; SET ERROR CODE ADDRESS
	HRLI AC1,PROG		; SET PROG IN INDEX FIELD
	MOVEM AC1,ADCRUN	; RUN FLAG ADDRESS
	HLLM AC1,ADCERA
	ADDI UUO,1
	SKIPGE @UUO		; IS MPX BIT ON?
	ORI TAC1,MPX		; YES
	MOVEM TAC1,ADCCNO	; STORE CONO WORD
	POPJ P,			; ALL DONE

; ADC DUMP MODE INPUT ROUTINE

ADCUW:
	TRNE IOS,ERRMSK
	POPJ P,			; LEAVE ON ERRORS
	PUSHJ P,WSYNC		; SINCE IOACT IS ON, WILL WAIT
ADCIN:
	TLZN IOS,IOBEG		; FIRST UUO?
	JRST ADCNFS
	MOVEM IOS,ADCIOS
	PUSHJ P,ADCINI		; CLEAR OUT DDB
ADCNFS:
	SKIPE ADCNBK		; IS THERE ANOTHER BLOCK?
	JRST ADCUW		; YES, WAIT FOR IT TO END
	PUSHJ P,CHKUUO		; ADDRESS CHECK RH OF UUO
	SKIPE TAC,@UUO		; PICK UP IOWD
	TLNN TAC,777777		; ANY WORD COUNT?
	JRST ADCXIT		; NOTHING THERE. GO HOME.
	PUSHJ P,ADRCHK		; ADDRESS CHECKS IOWD IN TAC
	JRST ADRERR		; ILLEGAL. STOP JOB AND DIE
	MOVEI IOS,IOACT
	PSYNC ADCCSC
	ORB IOS,ADCIOS		; LOCK US IN CORE
	XSYNC ADCCSC
	ADDI TAC,(PROG)		; RELOCATE IT NOW
	MOVEM TAC,ADCNBK
	HLRO AC1,TAC		; PICK UP -WC
	MOVN AC1,AC1		; MAKE IT POSITIVE
	IDIV AC1,ADCWPS		; GET # SECONDS
	ADDI AC1,5		; A FEW EXTRA FOR GOOD MEASURE
	CAILE AC1,77		; SATURATE AT 6 BITS
	MOVEI AC1,77
	DPB AC1,PDVTIM		; MAKE THIS THE NEW HUNG TIME
	SKIPE ADCBKI		; IS THERE AN XFR IN PROGRESS?
	JRST ADCXIT		; YES. LEAVE NOW
	TRNE IOS,IOSYNC		; ARE WE SYNCHRONIZING?
	SKIPE DACBKO		; YES, IS XFR RUNNING THERE?
	JRST ADCSTR		; NOT SYNC OR XFR ALREADY RUNNING ON DAC
	SKIPN DACNBK		; IS THERE AN XFR QUEUED?
	JRST ADCSHT		; NO, PUT US DOWN AND HANG. SET HUNG TIME.
ADCSTR:
	MOVEI TAC,STCODE	; NO, START ADC AND LEAVE
	MOVEM TAC,ADCP2L	; PLACE WHERE P2 WILL SEE IT
ADCXIT:
	TRNE IOS,CONT		; CONTINUOUS MODE?
	SUB P,[XWD 1,1]		; YES, RETURN UPLEVEL ONE
	POPJ P,

ADCSHT:
	MOVEI TAC,77		; SET HUNG TIME TO MAXIMUM
	DPB TAC,PDVTIM
	JRST ADCXIT

; ADC HUNG TIMEOUT, ADHUNG, ADC INITIALIZE CODE, ADCINI, ADC RELEASE, ADCREL

ADHUNG:
	SKIPN ADCNOH		; IF DEBUGGING, DON'T RE-INITIALIZE YET
ADCREL:
	PUSHJ P,ADCCLR
	MOVEI DDB,ADCDDB
HUNG:
	MOVEI IOS,IOACT
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	ANDCAB IOS,DEVIOS(DDB)
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	TLNN IOS,IOW
	JRST HFTST
	MOVSI IOS,IOW
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	ANDCAB IOS,DEVIOS(DDB)
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	LDB J,PJOBN
	PUSHJ P,STTIOD		; BRING HIM OUT OF IO WAIT
HFTST:
	SKIPE ADCNOH		; ARE WE IN NO-HANG (DEBUGGING) MODE?
	AOS (P)			; SKIP RETURN MEANS NO KILL
	POPJ P,

ADCCLR:
	MOVEI TAC,KLCODE
	MOVEM TAC,ADCP2L	; TELL P2 TO CLEAR ADC
	JRST ADCJST

; ADCP2 - PDP-6'S CLK LEVEL ROUTINE FOR THE ADC

↑ADCP2:	SKIPN TAC,ADCP2L
	POPJ P,			; SOMEBODY SCREWED UP!
	SETZM ADCP2L
	JRST @P2LDSP-1(TAC)

P2LDSP:
	ADCST		; STARTUP
	ADCKL		; KILL

ADCKL:
	CONO ADC,0	; THIS IS EASY ENOUGH
ADCINI:
	SETZM ADCZB
	MOVE TAC,[XWD ADCZB,ADCZB+1]
	BLT TAC,ADCZND-1
ADCJST:
	MOVEI TAC,ADCIST
	HRRM TAC,ADCJMP
	POPJ P,

ADCST:
	MOVEI DDB,ADCDDB
	CONO DCB,200000		; KILL OLD AD IF RUNNING
	CONO AD,4000		; OTHERWISE, WILL LOOP IN P2CH1
	MOVSI TAC,(<JFCL>)
	HLLM TAC,ADJMP		; KILL JUMP TO OLD AD ROUTINES
	MOVE TAC,[JSR ADCCHL]	; MAKE SURE CHAN LOC IS SET UP RIGHT
	MOVEM TAC,40+<ADCCHN*2>
	CONO PI,ADCON
	SKIPN TAC,ADCNBK
	JRST ADCKL
	LDB TAC1,PDVTIM		; SET TIME COUNT
	DPB TAC1,PDVCNT
	MOVEM TAC,ADCBKI
	SETZM ADCNBK
	MOVEI TAC1,ADCINT	; PRETEND IT IS A NORMAL INTERRUPT
	MOVE IOS,ADCIOS
	TRNE IOS,CYCLE
	TRNE IOS,CYCDON
	JRST ADCSCN
	MOVEI TAC1,ADCRCY	; SET TO RECYCLE
	MOVEM TAC,ADCRCB	; STORE IOWD HERE ALSO FOR RECYCLING
ADCSCN:
	HRRM TAC1,ADCJMP	; SET JUMP LOCATION

; ADCP2 CONT - STARTUP CODE, SET `RUN' FLAG, CHECK FOR IO SYNC

	MOVEI TAC,WKCODE	; WAKE UP JOB IF PENDING ALREADY
	MOVEM TAC,ADCP1L
	HRRZ TAC,ADCRUN		; MUST SET THIS IF TIME TO GO
	JUMPE TAC,ADCTSS
	LDB J,PJOBN
	SKIPN PROG,JBTADR(J)
	JRST ADCACK		; ADDRESS CHECK. GIVE ERROR.
	HLRZ AC1,PROG
	CAIG TAC,(AC1)
	CAIG TAC,JOBPFI
	JRST ADCACK
	SETOM @ADCRUN		; SET `RUN' FLAG
ADCTSS:
	TRNE IOS,IOSYNC		; ARE WE TRYING TO SYNCHRONIZE?
	SKIPE DACBKO		; YES, IS THE OTHER GUY RUNNING?
	JRST ADCTCN		; NOT SYNCHRO OR IS RUNNING
	TRNE IOS,IOAFT		; SYNC AFTER CYCLE?
	TRNN IOS,CYCLE		; YES, IS HE CYCLING?
	JRST ADCDCS
	TRNN IOS,CYCDON		; YES, IS CYCLING DONE?
	JRST ADCTCN		; NO, START US UP, BUT SAVE DAC FOR LATER
ADCDCS:
	SKIPN DACNBK		; WELL, IS HE PENDING? (BETTER BE)
	PUSHJ P,DACST		; YES, START HIM UP
				; UNDEFINED STATE HERE OF NOT PENDING
				; PROBABLY SHOULD BE SOME KIND OF ERROR
ADCTCN:
	CONO ADC,@ADCCNO	; START IT UP
	POPJ P,

ADCACK:
	MOVEI TAC,ERCODE	; PROPAGATE ADDRESS CHECK BACK TO HIM
	MOVEM TAC,ADCP1L
	JRST ADCKL

; ADCP1 - PDP-10'S CLOCK ROUTINES FOR THE ADC

↑ADCP1:	SKIPN TAC,ADCP1L
	POPJ P,
	SETZM ADCP1L
	MOVEI DDB,ADCDDB
	JRST @ADCP1D-1(TAC)

ADCP1D:
	WKM
	ADCERM

WKM:
	MOVE IOS,DEVIOS(DDB)
	LDB J,PJOBN
	TLNN IOS,IOW		; IS HE WAITING?
	POPJ P,			; NO, FORGET IT
	MOVSI IOS,IOW
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	ANDCAB IOS,DEVIOS(DDB)	; CLEAR WAIT BIT
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	JRST STTIOD

ADCERM:
	SETZM ADCBKI		; KILL ANY WAITING XFR
ERM:
	LDB J,PJOBN
	MOVEI IOS,IOACT
	PSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	ANDCAB IOS,DEVIOS(DDB)
	XSYNC1 <HRRZ TAC,DEVCMR(DDB)>
	PUSHJ P,TTYERP
	PUSHJ P,INLMES
	ASCIZ /
ILLEGAL ADDRESS FOR ADC-DAC
↑C
./
	PUSHJ P,TTYSTC
	JRST ESTOP		; STOP HIM PERMANANTLY

; ADC INTERRUPT ROUTINES, ADCIST FOR SPURIOUS, ADCINT FOR NORMAL

↑ADCIST:CONO ADC,0
	AOS ADCSTI		; COUNT NUMBER OF SPURIOUS INTERRUPTS
	JEN @ADCCHL		; DISMISS INTERRUPT

↑ADCINT:BLKI ADC,ADCBKI		; BRING IN NEXT WORD
	JRST ADCDON		; COUNT OVERFLOW
	JEN @ADCCHL		; GO BACK FOR MORE

ADCDON:
	JSR ADCSAV		; GET US SOME ACS
ADCSTU:
	MOVEI DDB,ADCDDB
	CONSO ADC,ADLOST	; DATA MISSED?
	JRST ADCNDM
	MOVEI IOS,LOST
	PSYNC ADCCSC		; YES, SET LOST BIT (NOT REALLY AN ERROR)
	ORB IOS,ADCIOS
	XSYNC ADCCSC
ADCNDM:
	SKIPN TAC,ADCNBK	; IS THERE ANOTHER XFR WAITING?
	JRST ADCWK		; NO MORE, STOP ADC
	MOVEM TAC,ADCBKI
	PUSHJ P,ADCICH		; ANY WORDS?
	LDB TAC,PDVTIM		; PICK UP HUNG TIME
	DPB TAC,PDVCNT		; USE THIS AS HUNG COUNT
	SETZM ADCNBK
	SKIPN ADCBKI
	JRST ADCSTU		; ALL DONE (???) GO THROUGH AGAIN
	JRST ADCW		; WAKE HIM UP AND LEAVE

ADCICH:
	CONSO ADC,DATARQ
	POPJ P,
	BLKI ADC,ADCBKI		; BRING IN NEXT WORD
	JRST [SETZM ADCBKI	; COUNT OVERFLOW
	      POPJ P,]
	JRST ADCICH		; OK, CHECK FOR ANOTHER ONE

; ADC INTERRUPT ROUTINES, ADCRCY FOR RECYCLING INPUT

↑ADCRCY:MOVEM TAC,ADCTAC
	BLKI ADC,ADCBKI		; GET NEXT WORD
	JRST ADCRDN		; COUNT OVERFLOW
	MOVE TAC,ADCBKI
	MOVM TAC,(TAC)		; PICK UP WORD WE JUST READ IN
	CAMLE TAC,ADCTHR	; IS IT GREATER THAN THRESHHOLD?
	JRST ADCSMD		; YES, SWITCH MODES INTO NORMAL
	MOVE TAC,ADCTAC
	JEN @ADCCHL		; NO, GO ON

ADCRDN:
	SKIPN TAC,ADCRCB	; PICK UP IOWD
	JRST ADCILI		; NOTHING THERE, HELP!
	MOVEM TAC,ADCBKI
	LDB TAC,[POINT 6,ADCDDB+DEVCHR,17]	; PDVTIM
	DPB TAC,[POINT 6,ADCDDB+DEVCHR,11]	; PDVCNT
	MOVE TAC,ADCTAC
	JEN @ADCCHL

; ADC INTERRUPT ROUTINES - ADCSMD, SWITCH MODES FROM CYCLE TO NORMAL

ADCSMD:
	MOVE TAC,ADCTAC
	JSR ADCSAV		; GET US SOME ACS
	MOVEI DDB,ADCDDB
	LDB J,PJOBN
	MOVE PROG,JBTADR(J)	; PICK UP HIS PROT-RELOC
	MOVEI TAC,ADCINT	; SET TO GO TO REGULAR PLACE ON INTERRUPT
	HRRM TAC,ADCJMP
	SKIPE ADCNBK		; IF THERE IS ANOTHER BLKI WD, THEN
	PUSHJ P,ADCCHK		; CHECK FOR NEXT WORD READY
	MOVEI IOS,CYCDON	; NOTE RECYCLING DONE
	CONSZ ADC,ADLOST	; DATA MISSED?
	ORI IOS,LOST		; YES, SET BIT
	PSYNC ADCCSC
	ORB IOS,ADCIOS
	XSYNC ADCCSC
	HRLZ AC1,PROG		; SET AC1 TO POINT TO END OF CORE IMAGE
	SKIPE ADCNBK		; IF THERE IS ANOTHER BLKI WD, THEN
	PUSHJ P,ADCCHK		; CHECK FOR NEXT WORD READY
	HRRZ TAC,ADCRCW		; IS THERE A PLACE TO PUT THE RECYCLE WD?
	JUMPE TAC,ADCISH	; NO, GO ON WITH REGULAR XFR
	CAIL TAC,JOBPFI
	CAILE TAC,(AC1)
	JRST ADCILA		; ADDRESS CHECK.
	MOVE TAC,ADCBKI
	SUBI TAC,(PROG)
	MOVEM TAC,@ADCRCW	; GIVE USER THE BLKI POINTER
	SKIPE ADCNBK		; IF THERE IS ANOTHER BLKO WD, THEN
	PUSHJ P,ADCCHK		; CHECK FOR NEXT WORD READY
ADCISH:
	TRNE IOS,IOSYNC		; ARE WE SYNCHRONIZING IO?
	TRNN IOS,IOAFT		; IF SO, IS IT AFTER RECYCLE DONE?
	JRST ADCSTU		; NO, JUST GO ON WITHOUT COMMENT
	SKIPE DACNBK		; IS THERE A WAITING TRANSFER?
	SKIPE DACBKO		; AND NO CURRENT TRANSFER?
	JRST ADCSTU
	SKIPE ADCNBK		; CHECK FOR WORD READY
	PUSHJ P,ADCCHK		; READ IT IN IF READY
	PUSHJ P,DACST		; CALL DAC STARTUP CODE
	SKIPE ADCNBK		; CHECK FOR WORD READY
	PUSHJ P,ADCCHK		; READ IT IN IF READY
	JRST ADCSTU

ADCCHK:
	CONSO ADC,DATARQ	; DOES IT HAVE A WORD FOR US?
	POPJ P,			; NO, FORGET IT
	BLKI ADC,ADCNBK		; YES, BRING IT IN VIA NEXT PTR
	JRST [SETZM ADCNBK	; NO MORE, NOTE EMPTY IOWD
	      POPJ P,]
	JRST ADCCHK		; GO BACK AND CHECK FOR MORE

; ADC INTERRUPT ROUTINES - ADCILA, ADCW, ADCWK, ADCILI, END OF XFR

ADCW:
	MOVEI TAC,WKCODE	; DURING XFR TO JUST WAKE UP JOB
	JRST ADCSTC

ADCWK:
	MOVEI TAC,WKCODE	; HERE AT END OF XFR TO KILL ADC AND WAKE JOB
	JRST ADCZ

ADCILI:
	MOVE TAC,ADCTAC		; RESTORE SAVED AC
	JSR ADCSAV		; GET US SOME ACS
ADCILA:
	MOVEI TAC,ERCODE
	PSYNC ADCCSC
	MOVEI IOS,IODERR	; MAKE SURE NO FURTHER TRANSFERS
	ORM IOS,ADCIOS
	XSYNC ADCCSC
ADCZ:
	SETZM ADCBKI		; ABORT NEXT TRANSFERS
	SETZM ADCNBK
	CONO ADC,0
	MOVEI TAC1,ADCIST	; MAKE SURE STRAY INTERRUPTS GET TRAPPED
	HRRM TAC1,ADCJMP
	HRRZ TAC1,ADCRUN	; DOES HE WANT TO KNOW ABOUT THIS?
	JUMPE TAC1,ADCCIA	; NO, FORGET IT
	LDB J,PJOBN		; PICK UP JOB NUMBER
	SKIPN PROG,JBTADR(J)	; AND PROT-RELOC FOR JOB
	JRST ADCCHI		; NONE THERE. OOPS!
	HLRZ AC1,PROG
	CAIL TAC1,JOBPFI
	CAILE TAC1,(AC1)
	JRST ADCCHI
	SETZM @ADCRUN		; CLEAR HIS RUNNING FLAG
ADCCIA:
	MOVEI IOS,IOACT		; UNLOCK HIM FROM CORE
	PSYNC ADCCSC		; DO THIS AFTER ADDRESS CHECK
	ANDCAB IOS,ADCIOS	; ON THE OFF CHANCE THAT HE MIGHT
	XSYNC ADCCSC		; HAVE DISSAPEARED IN THE INTERIM
ADCSTC:
	MOVEM TAC,ADCP1L
	POPJ P,

ADCCHI:
	MOVE IOS,ADCIOS
	SETZM ADCRUN		; MAKE SURE WE DON'T LOOP
	TLNE IOS,ERRMSK
	JRST ADCSTC		; JUST GET ON WITH IT
	JRST ADCILA		; NO ERRORS YET, GIVE HIM ADDRESS CHECKD

; UUO DISPATCH TABLE FOR DAC

	JRST DACINI	; SYSTEM STARTUP
	JRST DAHUNG	; HUNG TIME OUT
↑DACDSP:JRST DACREL	; RELEASE
	POPJ P,		; CLOSE OUTPUT
	JRST UUOERR	; BUFFERED OUTPUT
	JRST ILLINP	; BUFFERED INPUT
	JRST CPOPJ1	; ENTER
	JRST CPOPJ1	; LOOKUP
	JRST DACOUT	; DMP MODE OUTPUT
	JRST ILLINP	; DMP MODE INPUT
	POPJ P,		; USETO
	POPJ P,		; USETI
	POPJ P,		; UGETF
	JRST CPOPJ1	; RENAME
	POPJ P,		; CLOSE INPUT
	POPJ P,		; UTPCLR
	JRST DACMTP	; MTAPE

; DAC MTAPE UUO. SETS PARAMETERS.
; EFFECTIVE ADDRESS POINTS TO TWO WORD BLOCK
; FIRST WORD (RH SAME AS ADC)
;  	0,,SPEED*1000+PACK*100+NCHANS
;	SPEED = 0	6.4 KC		IS PER CHANNEL RATE
;		1	12.8 KC
;		2	25.6 KC
;		3	51.2 KC
;		4	102.4 KC
;		5	204.8 KC
; SECOND WORD (SAME AS ADC)
;	<ADDR FOR ERR CODES>,,<ADDR FOR `RUN' FLAG>
;	<`RUN' FLAG IS `SETOM'ED WHILE DAC IS RUNNING AND ZEROED WHEN
; 		DAC IS SHUT OFF

DACMTP:
	TLZN IOS,IOBEG		; FIRST UUO?
	JRST DACNFS
	MOVEM IOS,DACIOS	; NOT BUSY BY DEFINITION (OR BUG!)
	PUSHJ P,DACINI		; CLEAR OUT IMPORTANT STUFF
DACNFS:
	PUSHJ P,CHKUUO		; ADDRESS CHECK EFFECT. ADDR. OF UUO
	ADDI AC2,1		; CHECK END OF TABLE TOO
	CAILE AC2,(AC1)
	JRST ADRERR
	MOVE TAC,@UUO		; PICK UP 0,,PARAMS
	PUSHJ P,SETCNO		; SET UP CONO WORD IN TAC1
	MOVEM AC2,DACWPS	; SAVE # WORDS PER SECOND
	MOVEM TAC1,DACCNO	; STORE CONO WORD
	ADDI UUO,1		; BUMP TO ERR CODE WORD
	MOVE AC1,@UUO
	HLRZM AC1,DACERA	; SET ERROR CODE ADDRESS
	HRLI AC1,PROG		; SET PROG IN INDEX FIELD
	MOVEM AC1,DACRUN	; RUN FLAG ADDRESS
	HLLM AC1,DACERA
	POPJ P,			; ALL DONE

; DAC DUMP MODE OUTPUT ROUTINE

DACW:
	TRNE IOS,ERRMSK
	POPJ P,			; LEAVE ON ERRORS
	PUSHJ P,WSYNC		; WAIT FOR NEXT XFR DONE
DACOUT:
	TLZN IOS,IOBEG		; FIRST UUO?
	JRST DACNOF
	MOVEM IOS,DACIOS
	PUSHJ P,DACINI
DACNOF:
	SKIPE DACNBK		; IS THERE ANOTHER BLOCK WAITING?
	JRST DACW		; YES, GO WAIT FOR IT
	PUSHJ P,CHKUUO		; ADDR CHECK
	SKIPE TAC,@UUO		; PICK UP IOWD
	TLNN TAC,777777		; ANYTHING THERE?
	JRST ADCXIT		; NO, EXIT NOW
	PUSHJ P,ADRCHK		; ADDRESS CHECK THE IOWD
	JRST ADRERR		; ILLEGAL. STOP JOB AND PRINT MESSAGE
	MOVE IOS,[IO,,IOACT]
	PSYNC DACCSC
	ORB IOS,DACIOS
	XSYNC DACCSC
	ADDI TAC,(PROG)
	MOVEM TAC,DACNBK
	HLRO AC1,TAC		; PICK UP -WC
	MOVN AC1,AC1		; MAKE IT POSITIVE
	IDIV AC1,DACWPS		; MAKE INTO # SECONDS
	ADDI AC1,5		; 5 MORE FOR GOOD MEASURE
	CAILE AC1,77		; SATURATE AT 6 BITS
	MOVEI AC1,77
	DPB AC1,PDVTIM		; AND THIS IS THE NEW HUNG TIME
	SKIPE DACBKO		; IS THERE AN XFR IN PROGRESS?
	JRST ADCXIT		; YES, WE CAN LEAVE NOW
	TRNE IOS,IOSYNC		; ARE WE SYNCHRONIZING?
	SKIPE ADCBKI		; YES, IS ADC ALREADY RUNNING?
	JRST DACSTR		; NOT SYNC OR XFR ALREADY RUNNING
	SKIPN ADCNBK		; NOT RUNNING, XFR QUEUED?
	JRST ADCSHT		; NOT QUEUED, WAIT FOR IT. SET HUNG TIME TO MAX.
DACSTR:
	MOVEI TAC,STCODE	; START DAC AND LEAVE
	MOVEM TAC,DACP2L	; PLACE WHERE P2 WILL SEE IT
	JRST ADCXIT		; LEAVE, WAIT OR NO

; DAC HUNG ROUTINE, DAHUNG, DAC INITIALIZE ROUTINE, DACINI, RELEASE, DACREL

DAHUNG:
	SKIPN ADCNOH		; IF DEBUGGING, DON'T CLEAR OUT DAC YET
DACREL:
	PUSHJ P,DACCLR
	MOVEI DDB,DACDDB
	JRST HUNG		; COMMON ROUTINE FOR ADC-DAC

DACCLR:
	MOVEI TAC,KLCODE
	MOVEM TAC,DACP2L	; TELL P2 TO CLEAR DAC
	JRST DACJST

; DACP2 - PDP-6'S CLK LEVEL ROUTINE FOR THE DAC

↑DACP2:	SKIPN TAC,DACP2L
	POPJ P,
	SETZM DACP2L
	JRST @P2DDSP-1(TAC)

P2DDSP:
	DACST		; STARTUP
	DACKL		; KILL

DACKL:
	CONO DAC,0
DACINI:
	SETZM DACZB
	MOVE TAC,[XWD DACZB,DACZB+1]
	BLT TAC,DACZND-1
DACJST:
	MOVEI TAC,DACIST
	HRRM TAC,DACJMP
	POPJ P,

DACST:
	MOVEI DDB,DACDDB
	CONO DCB,200000		; KILL OLD AD IF RUNNING
	CONO AD,4000		; OTHERWISE, WILL LOOP IN P2CH1
	MOVSI TAC,(<JFCL>)
	HLLM TAC,ADJMP		; KILL JUMP TO OLD AD ROUTINES
	MOVE TAC,[JSR DACCHL]	; MAKE SURE CHAN LOC IS SET UP RIGHT
	MOVEM TAC,40+<DACCHN*2>
	CONO PI,DACON		; MAKE SURE SOMEBODY'S LISTNING
	SKIPN TAC,DACNBK
	JRST DACKL
	LDB TAC1,PDVTIM		; START COUNTING NOW
	DPB TAC1,PDVCNT
	MOVEM TAC,DACBKO	; THIS SET PREVENTS LOOPING THROUGH ADCST
	SETZM DACNBK
	MOVEI TAC,DACINT	; IT IS A NORMAL INTERRUPT
	MOVE IOS,DACIOS
	HRRM TAC,DACJMP		; SET JUMP LOCATION
	MOVEI TAC,WKCODE	; WAKE UP JOB IF PENDING ALREADY
	MOVEM TAC,DACP1L
	HRRZ TAC,DACRUN		; SEE IF HE WANTS US TO FLAG HIM
	JUMPE TAC,DACTSS	; NO, PROCEED
	LDB J,PJOBN
	SKIPN PROG,JBTADR(J)
	JRST DACACK		; ADDRESS CHECK. GIVE ERROR.
	HLRZ AC1,PROG
	CAIG TAC,(AC1)
	CAIG TAC,JOBPFI
	JRST DACACK
	SETOM @DACRUN		; SET `RUN' FLAG
DACTSS:
	TRNE IOS,IOSYNC		; ARE WE TRYING TO SYNCHRONIZE?
	SKIPE ADCBKI		; YES, IS THE OTHER GUY RUNNING?
	JRST DACTCN		; NOT SYNCHRO OR IS RUNNING
	SKIPN ADCNBK		; WELL, IS HE PENDING? (BETTER BE)
	PUSHJ P,ADCST		; YES, START HIM UP
				; UNDEFINED STATE HERE OF NOT PENDING
				; PROBABLY SHOULD BE SOME KIND OF ERROR
DACTCN:
	CONO DAC,@DACCNO	; START IT UP
	POPJ P,

DACACK:
	MOVEI TAC,ERCODE	; SEND HIM BACK AN ADDRESS CHECK
	MOVEM TAC,DACP1L
	JRST DACKL

; DACP1 - PDP-10'S CLOCK ROUTINES FOR THE DAC

↑DACP1:	SKIPN TAC,DACP1L
	POPJ P,			; SHOULDN'T HAPPEN
	SETZM DACP1L
	MOVEI DDB,DACDDB
	JRST @DACP1D-1(TAC)

DACP1D:
	WKM
	DACERM

DACERM:
	SETZM DACBKO		; KILL WAITING XFR
	JRST ERM

; DAC INTERRUPT ROUTINES, DACIST FOR SPURIOUS, DACINT FOR NORMAL

↑DACIST:CONO DAC,0
	AOS DACSTI		; COUNT NUMBER OF SPURIOUS INTERRUPTS
	JEN @DACCHL

DACINT:
	BLKO DAC,DACBKO		; SEND OUT NEXT WORD
	JRST DACDON		; COUNT OVERFLOW
	JEN @DACCHL		; GO BACK FOR MORE

DACDON:
	JSR DACSAV
	MOVEI DDB,DACDDB
	CONSO DAC,DALOST	; DATA MISSED?
	JRST DACNDM
	MOVEI IOS,LOST
	PSYNC DACCSC
	ORB IOS,DACIOS
	XSYNC DACCSC
DACNDM:
	SKIPN TAC,DACNBK	; ANOTHER ONE WAITING?
	JRST DACWK		; NO MORE. WAKE UP USER AND LEAVE.
	MOVEM TAC,DACBKO
	PUSHJ P,DACCHK
	LDB TAC,PDVTIM
	DPB TAC,PDVCNT		; RESET HUNG TIME
	SETZM DACNBK
	SKIPN DACBKO
	JRST DACWK		; IF OVERFLOWED IN MEANTIME, FLUSH XFR NOW
	MOVEI TAC,WKCODE	; SET TO WAKE HIM UP (CHECKS IOW IN P1)
	JRST DACSTC

DACCHK:
	CONSO DAC,INTRQ		; REQUESTING INTERRUPT?
	POPJ P,			; NO, FORGET IT
	BLKO DAC,DACBKO		; YES, SEND OUT NEXT WORD
	JRST [SETZM DACBKO	; FLAG OVERFLOW
	      POPJ P,]
	JRST DACCHK		; SUCCESS, LOOP BACK FOR NEXT WORD

; DAC INTERRUPT ROUTINES - WAKEUP AND `RUN' FLAG BUSINESS

DACWK:
	MOVEI TAC,WKCODE
DACZ:
	SETZM DACBKO
	SETZM DACNBK
	CONO DAC,0
	MOVEI TAC1,DACIST
	HRRM TAC1,DACJMP
	HRRZ TAC1,DACRUN
	JUMPE TAC1,DACCIA
	LDB J,PJOBN		; PICK UP JOB NUMBER
	SKIPN PROG,JBTADR(J)	; AND PROT-RELOC OF JOB
	JRST DACCIA		; NONE THERE!! OOPS!
	HLRZ AC1,PROG
	CAIL TAC1,JOBPFI
	CAILE TAC1,(AC1)
	JRST DACCHI
	SETZM @DACRUN
DACCIA:
	MOVEI IOS,IOACT		; UNLOCK JOB
	PSYNC DACCSC
	ANDCAB IOS,DACIOS
	XSYNC DACCSC
DACSTC:
	MOVEM TAC,DACP1L
	POPJ P,

DACCHI:
	MOVE IOS,DACIOS
	SETZM DACRUN
	TLNE IOS,ERRMSK
	JRST DACSTC
	MOVEI TAC,ERCODE
	PSYNC DACCSC
	MOVEI IOS,IODERR
	ORM IOS,DACIOS
	XSYNC DACCSC
	JRST DACZ

; ROUTINE MAKES UP A CONO WORD FROM MTAPE SPECS
; SPECS ARE IN RH TAC
; RETURNS CONO WORD IN TAC1
; USES AC1, AC3 AS TEMP
; RETURNS WORDS PER SECOND IN AC2
; = SPEED*1000+PACK*100+NCHANS
; NCHANS = 1 FOR MONO	(2-BIT NUMBER)
;	 = 2 FOR STEREO
;	 = 0,3 FOR QUAD
; PACK = 0,3 FOR 12 BIT  (2-BIT NUMBER)
;      = 1 FOR 16 BIT (HALFWORD MODE)
;      = 2 FOR FLOATING PT. INCREMENTAL
; SPEED = 0 FOR 6.4 KC	(3-BIT NUMBER)
;       = 1 FOR 12.8 KC
;       = 2 FOR 25.6 KC
;       = 3 FOR 51.2 KC
;       = 4 FOR 102.4 KC
;       = 5 FOR 204.8 KC

SETCNO:
	MOVEI TAC1,QUAD!RUNB!ADCCHN	; ADC AND DAC RUN ON SAME CHANNEL
	LDB AC1,[POINT 2,TAC,35]
	CAIN AC1,1
	XORI TAC1,MONO!QUAD
	CAIN AC1,2
	XORI TAC1,STEREO!QUAD
	LDB AC1,[POINT 2,TAC,29]
	MOVE AC3,SAMPW(AC1)	; PICK UP # SAMPS PER WD
	ORI TAC1,_12BIT
	CAIN AC1,1
	XORI TAC1,_12BIT!_16BIT
	CAIN AC1,2
	XORI TAC1,_12BIT!FLOAT
	LDB AC1,[POINT 3,TAC,26]
	CAIN AC1,1
	ORI TAC1,1*FILT
	CAIN AC1,2
	ORI TAC1,2*FILT
	CAIL AC1,3
	ORI TAC1,3*FILT
	TRNE TAC1,STEREO
	ADDI AC1,1
	TRNE TAC1,QUAD
	ADDI AC1,2
	CAILE AC1,5
	JRST ILLSPD
	MOVE AC2,SPTAB(AC1)	; PICK UP SPEED IN SAMPLES/SEC
	IDIVI AC2,(AC3)		; GET WDS/SEC IN AC2
	DPB AC1,[POINT 3,TAC1,29]
	POPJ P,

ILLSPD:
	JSP TAC,UUOMES
	ASCIZ /
ILLEGAL SPEED PARAMETER FOR AD-DA
UUO/

SAMPW:
	3 
 2 
 4 
 3
SPTAB:
	=6400 
 =12800 
 =25600 
 =51200 
 =102400 
 =204800

; ADRCHK - ROUTINE TO ADDRESS CHECK AN IOWD, CHKUUO - CHECKS UUO ADDR
; CALL WITH IOWD IN TAC
; SKIPS IF OK
; PROG MUST BE SET UP
; USES TAC1 AND AC1

ADRCHK:
	MOVEI TAC1,(TAC)
	HLRZ AC1,PROG
	CAIL TAC1,JOBPFI	; MUST BE ABOVE PROTECTED AREA
	CAILE TAC1,(AC1)
	POPJ P,			; OUT OF BOUNDS, GIVE ERROR RETURN
	HLRO TAC1,TAC
	MOVNS TAC1		; MAKE IT POSITIVE
	ADDI TAC1,(TAC)
	CAIL TAC1,JOBPFI
	CAILE TAC1,(AC1)
	POPJ P,
	JRST CPOPJ1

; CHKUUO
; DOESN'T RETURN IF BAD
; PROG MUST BE SET UP
; PUTS RH OF UUO IN AC2
; PUTS LAST WD IN CORE IMAGE ADDRESS IN AC1

CHKUUO:
	HLRZ AC1,PROG
	MOVEI AC2,(UUO)
	CAIG AC2,(AC1)
	CAIG AC2,JOBPFI
	JRST ADRERR
	POPJ P,

; END OF IT ALL

BEND ADCSER
;: ADCSER[J17,SYS] EOF.
;: ELFSER[J17,SYS]
COMMENT ⊗   VALID 00018 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	IFN ELFNUM <SUBTTL ELFSER	PDP-11 SERVICE
C00005 00003	10/11 interface definitions
C00008 00004	Console control box definitions
C00010 00005	SPS41 definitions
C00011 00006	Service dispatch table, DDB definitions
C00013 00007	System initialization, interrupt code, RELEAS, hung code.
C00017 00008	Dump-mode I/O: ELFDOU, ELFDIN
C00020 00009	MTAPE UUO calling sequence and dispatch, SETIOS routine.
C00023 00010	USETI, USETO, UGETF UUO's
C00025 00011	MTAPE's: INTWAI, PEEK
C00029 00012	MTAPE FILL
C00031 00013	Funny MTAPE functions: EXAMINE, DEPOSIT, REG EXAM, REG DEP, PROGRAM START
C00033 00014	Read routines: RDB, RDW
C00036 00015	Write routines: WTB, WTW, POKE11
C00038 00016	Common subroutines for RDB and WTB: RELIOW, UPDADR
C00041 00017	Common routines: WDONE, DOCON
C00044 00018		USET,SETCON, DLAY
C00046 ENDMK
C⊗;

IFN ELFNUM <SUBTTL ELFSER	PDP-11 SERVICE
BEGIN ELFSER - 15 MAY 74 - BO

CBOX←←0		;Nonzero if the control box exists
SPS41←←0	;SPS exists, but we don't have anything to do with it yet.
NEWCNI←←0	;1 when Rubin installs the BUS INIT CONI bit.

IFNDEF DBG11 <DBG11←←0>		;Nonzero for debugging in user-IOT mode.

COMMENT⊗	DEVIOS bits

18 IOIMPM
19 IODERR	Interface detected an error
20 IOBKTL	ADRS ERR from an EXAMINE or DEPOSIT.

21 IODEND	Interface got NXM
22		Interface couldn't get the bus
23 IOACT

24		BUS INIT going on (NEWCNI)
25		Bad parity
26		Interface is hung

27
28		Interface still has the UNIBUS (grab mode)
29		No retry on errors.

30 IOCON
31 IOWC

32:35 MODE	Modes 16-17 are legal.

Bit 19 is set by the interrupt routine.

Bits 20:22 and 24:29 are set (from a CONI) at the end of each dump-mode
transfer.  All of these bits are for the user's information only - they
don't affect the operation of the interface.
⊗

HNGBIT←←1000
NOTRY←←100
INTREQ←←400000		;Attention bit in LH(DEVIOS)

;10/11 interface definitions

;CONO bits

SETADR←←400000		;If 1, set address from bits 19:35.
			;If 0, the other bits have these meanings:

IRESET←←100000		;Reset the interface
CLRINT←←40000		;Clear the interrupt conditions
IGNPAR←←20000		;Ignore parity on input
STOPIT←←10000		;Stop data transfers
DOIT←←4000		;Start data transfers
WRITE←←2000		;0 ⊃ read, 1 ⊃ write
GRAB←←1000		;Don't let go of the bus
SGNEXT←←400		;Extend sign of inputs
;	Data packing mode:
  ONEWD←←0		;16 bits right-adjusted in a word
  TWOWD←←100		;16 bits right-adj in each halfword
  TWOWDR←←200		;32 bits right-adjusted
  TWOWDL←←300		;32 bits left-adjusted
;	Bits 30-32 are the PI channel for special interrupts,
SCHN←←ELFCHN⊗3
;	33-35 the channel for data transfer interrupts.
DCHN←←ELDCHN

;CONI bits, left half

SPINT←←400000		;Special interrupt (reason in bits 18-23)
;	Bits 1:17 are the contents of the Unibus address register.


;CONI bits, right half

IREQ←←400000		;The 11 requested an interrupt
;	Errors in the data transfer:
ADRERR←←200000		;ADRS ERR from a console operation
			;(set by software, not a CONI)
NXM11←←100000		;No response to the address from the bus
BUSTO←←40000		;Couldn't get the bus
BINIT←←20000		;BUS INIT in progress
PARBAD←←10000		;Bad parity
;	Status of current transfer:
BUSY←←4000		;Working on it
DONE←←2000		;This causes a Data Transfer interrupt.
;	Bits 26:35 (from GRAB on) are the same as set in the
;	last CONO.

NTRY←←=10		;No. of retries for BUSTO or hung interface

;Console control box definitions

HCOR←←100000		;First NXM address in the 11.

IFN CBOX <	These locations are on the Unibus.

DEFINE WADDR(ADR){ADR⊗-1}	;Translate byte to word address

CREG←←WADDR(777170)	;Comm register 1
IREG←←WADDR(777172)	;Comm register 2 (causes IREQ when written)
SREG←←WADDR(777174)	;Switches 15:00 (write), data lights (read)
FREG←←WADDR(777176)	;Function register

;FREG bits:	15:14 (w) switch register 17:16
;		12:11 (w) address display mode
			PPHY←←00000
			KRND←←04000
			KRNI←←10000
			CPHY←←14000
			SUPD←←20000
			SUPI←←24000
			USRD←←30000
			USRI←←34000

;		5 (w) S-INST/S-CYCLE
			SINST←←00
			SCYCL←←40

;		4 (w) HALT/ENABLE
			ENABL←←00
			HALT ←←20

;		3:0 (pw) spring-loaded switches
			LADR ←←01
			EXAM ←←02
			DEP  ←←03
			REXAM←←04
			RDEP ←←05
			START←←06
			CONT ←←07
			INT4 ←←10
			INT5 ←←11
			INT6 ←←12
			INT7 ←←13

;		Bit 0 (r) ADRS ERR
			ADRERR←←1

PSWD←←WADDR(777776)	;Program Status word
STKLIM←←WADDR(777774)	;Kernel stack limit

>;IFN CBOX

;SPS41 definitions

IFN SPS41 <

MCR0←←WADDR(765000)		;Bit function if 1 (write):

	EXT←←2		;IOP external
	WBE←←4		;Enable writes into memories
	PMENB←←10	;Enable writes into program memories
	CHNENB←←20	;Enable channels 1-17
	ISINT←←40	;IS internal
	INIT←←1000	;Initialize all interfaces, halt the IS

	EXTERN←←EXT+WBE+PMENB+CHNENB
	INTERN←←WBE+PMENB+CHNENB+ISINT

MCR1←←MCR0 + 1

	COFF←←1		;Master clock off (stop)
	ENAB←←2		;Enable Unibus access to box memories

	STOP41←←COFF+ENAB

MCR2←←MCR1 + 1

	ONESTP←←1	;Single step anything in internal mode

MCR3←←MCR2 + 1
>;IFN SPS41

;Service dispatch table, DDB definitions

	JRST ELFINI		;Initialization
	JRST ELFHNG		;Hung
↑ELFDSP:
	JRST ELFREL		;Release
	POPJ P,			;Close
	JRST UUOERR		;Out UUO
	JRST UUOERR		;In UUO
	JRST CPOPJ1		;Enter
	JRST CPOPJ1		;Lookup
	JRST ELFDOU		;Dump-mode output
	JRST ELFDIN		;Dump-mode input
	JRST ELFUSO		;USETO
	JRST ELFUSI		;USETI
	JRST ELFGTF		;UGETF
	JRST CPOPJ1		;RENAME
	POPJ P,			;Close input
	POPJ P,			;UTPCLR
	JRST ELFMTA		;MTAPE

;Locations in the DDB, starting at ELFLOC

DEFINE D(X) {X←L
L←←L+1}
L←←ELFLOC-ELFDDB

D INTCNI	;CONI from interrupt routine
D USOUT		;<output CONO>,,<output bus address>
D USIN		;<input CONO>,,<input bus address>
D UIOWD		;User's IOWD, in case of shuffling during BUS INIT wait.

;System initialization, interrupt code, RELEAS, hung code.

;First UUO after INIT will call ELFINI to set the default values of the USET's.

ELFIN0:
	MOVEM	IOS,DEVIOS(DDB)			;Special entry for USET and UGETF.
ELFREL:
						;RELEAS re-initializes.
ELFINI:
	CONO	D11,IRESET+CLRINT		;Make sure no interrupts can happen.
	MOVE	TAC,[XWD DOIT+SCHN,SETADR]	;Set up the USET words to the
	MOVEM	TAC,USIN(DDB)			;default mode.
	MOVE	TAC,[XWD WRITE+DOIT+SCHN,SETADR]
	MOVEM	TAC,USOUT(DDB)
	POPJ	P,


ELFCLS:
	CONO	D11,STOPIT+SCHN		;MTAPE 4 turns off GRAB mode.
	CONI	D11,TEM			;(used to be CLOSE until JBR
	TRZ	TEM,GRAB		;found a problem with that).
	MOVEI	IOS,200
	ANDCAB	IOS,DEVIOS(DDB)
	JRST	CPOPJ1

IFE DBG11 <
;Special interrupt - error or IREQ

↑ELFINT:
	JSR	ELFSAV			;Get some AC's
	MOVEI	DDB,ELFDDB
	MOVE	DAT,DEVMOD(DDB)
	TRNE	DAT,ASSPRG		;Is the interface INITed?
	JRST	ELFIN1
	CONO	D11,IRESET+CLRINT	;No.  Ignore the spurious interrupt,
	POPJ	P,			;fix it so it won't happen again.

ELFIN1:
	CONI	D11,INTCNI(DDB)
	CONO	D11,CLRINT+SCHN		;clear the interrupt condition.

IFN CBOX <
	MOVE	DAT,INTCNI(DDB)		;Save the status for the I/O routine.
	TRNN	DAT,IREQ		;Did the 11 request this interrupt?
	POPJ	P,			;No.  There must be a transfer in progress.
					;The I/O routine will notice that BUSY and
					;DONE are clear.
	MOVSI	IOS,DEVSBB
	ANDCA	IOS,DEVIOS(DDB)		;Clear the I/O active indicator,
	TLO	IOS,INTREQ		;set flag saying this interrupt happened.
	LDB	J,PJOBN
	TLZE	IOS,IOW			;Is the job waiting for this interrupt?
	PUSHJ	P,SETIOD		;Yes.  Let it continue.
	MOVEM	IOS,DEVIOS(DDB)
>;IFN CBOX
	POPJ	P,
>;IFE DBG11

;Hung timeout

IFN CBOX <
ELFHNG:
	CONO	PI,ELFOFF	;Prevent interference from interrupt routine.
	TLZ	IOS,DEVSBB
	TLZE	IOS,IOW		;If the job was waiting for an interrupt,
	PUSHJ	P,SETIOD	;let it run.
	MOVEM	IOS,DEVIOS(DDB)
	CONO	PI,ELFON
	JRST	CPOPJ1
>;CBOX
IFE CBOX <ELFHNG: POPJ P,>

;Dump-mode I/O: ELFDOU, ELFDIN

ELFDOU:
	TLZE IOS,IOBEG
	PUSHJ P,ELFINI
	MOVE TAC,USOUT(DDB)
	XCTR XR,[MOVE DAT,(UUO)]
	PUSHJ P,WTB
	JFCL			;LET USER INSPECT FAILING STATUS
	TLO TEM,SETADR
	HLRM TEM,USOUT(DDB)
	JRST SETIOS

ELFDIN:
	TLZE IOS,IOBEG
	PUSHJ P,ELFINI
	MOVE TAC,USIN(DDB)
	XCTR XR,[MOVE DAT,(UUO)]
	PUSHJ P,RDB
	JFCL
	TLO TEM,SETADR
	HLRM TEM,USIN(DDB)
	JRST SETIOS

;MTAPE UUO calling sequence and dispatch, SETIOS routine.

COMMENT⊗	Calling sequence:

	MTAPE CHN,ADR
	<error return>
	<success return>

ADR:
	BYTE (9)CODE,MODE(18)BUSADR
	<data>

CODE specifies the function.  MODE and BUSADR work the same way as in USETI.
<data> is either the thing to be sent or the result that is read.
⊗

;Dispatch table

IFE CBOX <MTMIN←←1
	MTTBL←.-MTMIN>
IFN CBOX <MTMIN←←0
MTTBL:
	MTP0>
	FILL11
	PEEK11
	POKE11
	ELFCLS
IFN CBOX <	EXAMI
		DEPOS
		REXAMI
		RDEPOS>
MTMAX←←.-MTTBL

ELFMTA:
	TLZE	IOS,IOBEG
	PUSHJ	P,ELFINI
	XCTR	XR,[MOVE TAC1,(UUO)]	;Get the code word,
	LDB	TAC,[POINT 9,TAC1,8]	;Pull out the function code.
	IOR	TAC1,[XWD SETADR,SETADR];fix it so SETCON does the right thing.
IFN MTMIN <CAIL TAC,MTMIN>
	CAILE	TAC,MTMAX
	JRST	UUOERR			;Out of bounds is an illegal UUO.
	PUSHJ	P,@MTTBL(TAC)		;Do your thing,
	CAIA
	AOS	(P)

SETIOS:
	MOVEM	IOS,DEVIOS(DDB)
	MOVEI	IOS,0			;Set up the resulting IOS bits...
	LDB	AC1,[POINT 3,TEM,21]	;NXM, BUSTO
	DPB	AC1,[POINT 3,IOS,22]
	TRZ	TEM,DONE
	LDB	AC1,[POINT 5,TEM,26]	;PARBAD, BUSY, GRAB.
	DPB	AC1,[POINT 5,IOS,28]
	TRNE	TEM,NXM11+BUSTO+PARBAD+BUSY+ADRERR
	TRO	IOS,IODERR		;OR the bad ones into IODERR.
	IORB	IOS,DEVIOS(DDB)
	POPJ	P,

;USETI, USETO, UGETF UUO's

COMMENT⊗
	UGETF CHN,ADR
	<always returns here>

ADR:
	<USETI word>	;Returns results here in the right format for
	<USETO word>	;a subsequent USET to use.
⊗

ELFGTF:
	TLZE IOS,IOBEG
	PUSHJ P,ELFIN0
	MOVE TAC,USIN(DDB)
	PUSHJ P,GETF
	MOVE TAC,USOUT(DDB)

GETF:
	LDB TAC1,[POINT 4,TAC,11]
	TLNE TAC,IGNPAR
	TRO TAC1,20
	MOVS TAC1,TAC1
	TLO TAC1,400000
	HRR TAC1,TAC
	XCTR XW,[MOVEM TAC1,(UUO)]
	AOS UUO
	POPJ P,

COMMENT⊗
	USETI CHN,ADR or USETO CHN,ADR
	<always returns here>

ADR:
	XWD MODE,BUSADR

If bit 0 of C(ADR) is on, sets the data transfer mode for the corresponding
direction of transfer from bits 13:17 (IGNPAR, GRAB, SGNEXT, packing mode).
If bit 18 is one, sets the bus address for the next dump-mode transfer from
bits 19:35.  This address gets updated at the end of each block transfer
to point to the next word after the block.
⊗

ELFUSI:
	TLZE IOS,IOBEG
	PUSHJ P,ELFIN0
	MOVE TAC,USIN(DDB)
	PUSHJ P,USET
	MOVEM TAC,USIN(DDB)
	POPJ P,

ELFUSO:
	TLZE IOS,IOBEG
	PUSHJ P,ELFIN0
	MOVE TAC,USOUT(DDB)
	PUSHJ P,USET
	MOVEM TAC,USOUT(DDB)
	POPJ P,

;MTAPE's: INTWAI, PEEK

;MTAPE opcode 0: INTWAIT.  If the elf has requested an interrupt,
;do a PEEK CREG.  Otherwise:
;If bits 30:35 of the instruction are 0, direct return with no errors indicated.
;If bits 30:35 = 77, go into IOWQ until the elf interrupts, then PEEK CREG.
;Other bit combinations: set the hung timer to that many seconds, go into
;IOWQ until it interrupts or the time runs out.  If the interrupt happens,
;do a PEEK CREG; if it times out, take the direct return with the HUNG DEVIOS
;bit on.

IFN CBOX <
MTP0:
	TLZE	IOS,INTREQ	;Has it interrupted?
	JRST	INTIN		;Yes.  Do the peek.
	MOVEI	TEM,0		;No.  Clear error return bits in case...
	TRCN	TAC1,77		;Does he want to wait?
	POPJ	P,		;No wait.  Just return.
	TRCN	TAC1,77		;He does.  Did he specify infinite time?
	TRZ	TAC1,77		;Yes.  Clear the hung timer.
	DPB	TAC1,PDVCNT	;No.  Set the hung timer.
	CONO	PI,ELFOFF	;Avoid interference...
	MOVE	IOS,DEVIOS(DDB)	;make sure the interrupt hasn't happened.
	TLZE	IOS,INTREQ
	JRST	INTIN0
	MOVSI	IOS,DEVSBB	;OK, we're sure now.
	IORM	IOS,DEVIOS(DDB)	;Set the I/O busy indicator,
	CONO	PI,ELFON
	PUSHJ	P,WSYNC		;wait until something happens.

	MOVEI	TEM,0		;We wake up.  Clear the error indications.
	MOVE	IOS,DEVIOS(DDB)
	TLZE	IOS,INTREQ	;Did the desired interrupt happen?
	JRST	INTIN
	TRO	IOS,HNGBIT	;No.  The hung time ran out.
	POPJ	P,

INTIN0:
	CONO	PI,ELFON
INTIN:
	HRRI	TAC1,SETADR+CREG;Set up a PEEK CREG.
	TLNN	TAC1,TWOWDL
	TLO	TAC1,TWOWD	;Fall into the PEEK routine.
>;IFN CBOX

;Peek at one or two words in the 11's memory.

PEEK11:
	MOVSI	TAC,DOIT+SCHN		;Set up the CONO.
	PUSHJ	P,SETCON
	PUSHJ	P,RDW			;Read one word in the specified mode.
	POPJ	P,			;Error return.
	XCTR	XW,[MOVEM DAT, 1(UUO)]	;Success.  Give it to the user.
	JRST	CPOPJ1

;MTAPE FILL

;Fill a block with a constant

FILL11:
	TLZ TAC1,3			;Packing mode 0 (ONEWD)
	MOVSI TAC,WRITE+DOIT+SCHN	;Set up the initial CONO.
	PUSHJ P,SETCON
	XCTR XR,[MOVE DAT,1(UUO)]	;LH(DAT)=# of words, RH=thing to fill with.
	MOVE AC2,[XWD -NTRY,FILLR]	;Set up the retry address.
FILL0:
	HLRZ TAC1,DAT
	JUMPE TAC1,CPOPJ1
FILL1:
	PUSHJ P,DOCON			;Start the interface in write mode.
FILL2:
	CONSO D11,DONE
	JSP AC1,WDONE
	DATAO D11,DAT			;When ready, write the data.
	SOJG TAC1,FILL2			;Repeat until the block is filled.
	JRST WTBE			;End just like any write.

FILLR:
	AOJ TAC1,			;Retry needed.  Back up the count.
	MOVS TAC1,TAC1
	HRR TAC1,DAT
	CAMN DAT,TAC1			;Did any data go through successfully?
	JRST FILL0
	SUB TAC1,DAT			;Yes.  Update the count of words
	ADD DAT,TAC1			;remaining,
	MOVN TAC1,TAC1
	MOVS TAC1,TAC1
	ADD TAC1,TAC			;move the bus address up to the one
	TRO TAC1,SETADR			;that failed.
	HRR TAC,TAC1
	JRST FILL0

;Funny MTAPE functions: EXAMINE, DEPOSIT, REG EXAM, REG DEP, PROGRAM START

IFN CBOX <

EXAMI:
	PUSHJ	P,LDADR
	POPJ	P,
	MOVEI	DAT,HALT+CPHY+EXAM
RDIT:
	PUSHJ	P,WTW
	POPJ	P,
	PUSHJ	P,RDLGTS
	POPJ	P,
	XCTR	XW,[HLREM DAT,1(UUO)]
	JRST	CPOPJ1

REXAMI:
	PUSHJ	P,LRADR
	POPJ	P,
	MOVEI	DAT,HALT+REXAM
	JRST	RDIT

DEPOS:
	PUSHJ	P,LDADR
	POPJ	P,
	MOVEI	DAT,HALT+CPHY+DEP
WRTIT:
	XCTR	XR,[HRL DAT,1(UUO)]
	PUSHJ	P,WTW
	POPJ	P,

RDLGTS:
	MOVE	TAC,[XWD DOIT+SCHN,SETADR+SWREG]
	TRZ	TAC1,SETADR
	PUSHJ	P,SETCON
	PUSHJ	P,RDW
	POPJ	P,
	TRNN	DAT,1
	JRST	CPOPJ1
	TRO	TEM,ADRERR
	POPJ	P,

RDEPOS:
	PUSHJ	P,LRADR
	POPJ	P,
	MOVEI	DAT,HALT+RDEP
	JRST	WRTIT

LRADR:
	MOVEI	DAT,CPHY+HALT+LADR
	DPB	TAC1,[POINT 4,DAT,17]
	JRST	ADRLOD

LDADR:
	MOVEI	DAT,CPHY+HALT+LADR
	DPB	TAC1,[POINT 15,DAT,16]
	LDB	TAC,[POINT 2,TAC1,20]
	DPB	TAC,[POINT 2,DAT,16]
ADRLOD:
	MOVE	TAC,[XWD WRITE+TWOWD+DOIT+SCHN,SETADR+SWREG]
	TLNE	TAC1,20
	TLO	TAC,GRAB
	JRST	WTW

PSTART:
	MOVEI	DAT,HALT+START
	MOVE	TAC,[XWD WRITE+DOIT+SCHN,SETADR+FREG]
	PUSHJ	P,WTW
	POPJ	P,
	PUSHJ	P,LDADR
	POPJ	P,
	MOVE	TAC,[XWD WRITE+DOIT+SCHN,SETADR+FREG]
	MOVEI	DAT,START
	PUSHJ	P,WTW
	POPJ	P,
	JRST	RDLGTS

>;IFN CBOX

;Read routines: RDB, RDW

;Read a block.  Enter with initial CONO bits in TAC, user IOWD in DAT.
;Skips on success, returns final CONI in TEM whether or not the read succeeded.

RDB:
	MOVE AC2,[XWD -NTRY,RDBR]	;Retry address = RDBR.
	ADD DAT,[1,,0]			;Bugger the word count by one
	PUSHJ P,RELIOW			;(the last word takes special handling).
	JUMPGE DAT,RDBONE		;If only one word, don't do BLKO's
RDB1:
	PUSHJ P,DOCON			;Start the operation.
RDB2:
	CONSO D11,DONE			;Loop is CONSO, BLKI, JRST RDB2
	JSP AC1,WDONE			;as long as no errors happen.
	BLKI D11,DAT
	JRST RDBE			;Exit for last word.
	JRST RDB2

RDBR:
	PUSHJ P,UPDADR			;Retry in middle of block - update
	JRST RDB1			;starting addresses.

RDBER:
	PUSHJ P,UPDADR			;Retry on last word -
RDBONE:
	PUSHJ P,DOCON			;restart the transfer.
RDBE:
	HRRI AC2,RDBER			;Last word: change retry address.
	JSP AC1,WDONE			;wait for the read to finish,
	CONI D11,TEM			;get the resulting status,
	CONO D11,SETADR			;then set the bus adr to 0.
	DATAI D11,1(DAT)		;Read the data.
	JRST CPOPJ1

;The DATAI makes the interface take another sequential read cycle and hang with
;DONE on waiting for another DATAI.  Thus it stays active, and if GRAB is set
;the bus stays grabbed.  We get the status in before the last DATAI for that
;reason, and set the address to 0 to minimize the chance of errors in the dummy
;cycle.

;Read one word.  Enter with the CONO bits in TAC.  Returns the word read in DAT.
;Skips on success, returns final CONI in TEM whether or not the read succeeded.

RDW:
	MOVE AC2,[XWD -NTRY,.+1]	;Set up retry address and count.
	PUSHJ P,DOCON			;Start the read,
	JSP AC1,WDONE			;wait for it.
	CONI D11,TEM			;Same kind of terminal messing around
	CONO D11,SETADR			;as at RDBE, for the same reason.
	DATAI D11,DAT
	JRST CPOPJ1

;Write routines: WTB, WTW, POKE11

;Write a block.  Same sequence as RDB.

WTB:
	MOVE AC2,[XWD -NTRY,WTBR]	;Retry address = WTBR.
	PUSHJ P,RELIOW			;Get relocated IOWD.
WTB1:
	PUSHJ P,DOCON			;Start the operation.
WTB2:
	CONSO D11,DONE			;If we're lucky, the loop
	JSP AC1,WDONE			;takes three instructions
	BLKO D11,DAT			;(CONSO, BLKO, JRST).
	JRST WTBE			;Ends like any other write.
	JRST WTB2

WTBR:
	SUB DAT,[1,,1]			;Retry needed - back up the IOWD
	PUSHJ P,UPDADR			;to the address that failed,
	JRST WTB1			;update the starting address.

;Change one or two words (POKE UUO).

POKE11:
	MOVSI TAC,WRITE+DOIT+SCHN	;Set up the CONO.
	PUSHJ P,SETCON
	XCTR XR,[MOVE DAT,1(UUO)]	;Get the data to poke him with,

;Write one word.  Enter with CONO in TAC, word to send in DAT.
;Same return convention as WTB.

WTW:
	MOVE AC2,[XWD -NTRY,.+1]	;Retry loc and counter.
	PUSHJ P,DOCON			;Start the write, then
	JSP AC1,WDONE			;when the interface is ready,
	DATAO D11,DAT			;send the data.
WTBE:
	JSP AC1,WDONE			;Wait for it to finish and
	CONI D11,TEM			;return the resulting CONI.
	JRST CPOPJ1

;Common subroutines for RDB and WTB: RELIOW, UPDADR

;Common routine for updating the bus address for RDB and WTB in case of
;a retry in the middle of a block.  This routine will not work if a block
;wraps around core, but that should never happen.

UPDADR:
	SUB DAT,TAC1			;How many words were sent before the error?
	JUMPE DAT,UPDAD2		;None means bypass a lot of screwing around.
	HRLI AC2,-NTRY			;Otherwise, reset the retry counter.
	ADDM DAT,UIOWD(DDB)		;Update the user's IOWD.
	HRRZ AC3,DAT			;Now for the Unibus address...
	TLNE TAC,TWOWDL			;in all modes except 0,
	LSH AC3,1			;2 PDP-11 words per word.
	ADD TAC,AC3
UPDAD2:
	ADD DAT,TAC1			;Get back the resultant IOWD.
	TLNN TEM,NXM11			;If we were asleep from a Unibus INIT,
	POPJ P,
	SKIPA DAT,UIOWD(DDB)		;pick up the user's IOWD and relocate it.

;Relocate a user IOWD in DAT.  Sets up TAC1 and UIOWD(DDB) in case of retry.

RELIOW:
	MOVEM DAT,UIOWD(DDB)		;Save the user's IOWD.
	MOVEI TAC1,1(DAT)		;The first location involved...
	PUSHJ P,RELOCA			;relocate it. (Clobbers AC1)
	JRST UADRER			;Oops.
	TLNN TAC,WRITE
	JUMPL TAC1,UADRER		;Check for write protection.
	HRRI DAT,-1(TAC1)		;Here's the relocated base address.
	HLRE TAC1,DAT			;Now compute the ending address.
	MOVM TAC1,TAC1
	ADD TAC1,UIOWD(DDB)		;User's ending address
	TLNN TAC,WRITE			;If reading,
	ADDI TAC1,1			;unbugger the word count.
	PUSHJ P,RELOCB			;Check that address. (uses ac1)
	JRST UADRER
	MOVE TAC1,DAT			;All happy.  Save the resulting IOWD.
	POPJ P,

;Common routines: WDONE, DOCON

;Wait, error check, and retry routine.  Called with JSP AC1,WDONE

WDONE:
	CONSZ	D11,DONE		;If this bit is on,
	JRST	(AC1)			;everything is happy.
	MOVEI	AC3,=10			;We're going to delay a little while...
WDONE1:
	CONI	D11,TEM
	TRNN	TEM,BUSY		;Until either BUSY goes off
	JRST	WDONE2
	SOJG	AC3,WDONE1		;or the time runs out.
	CONO D11,IRESET+CLRINT+STOPIT	;It ran out.  Unhang the interface
	JRST	WDONE4			;and retry.

WDONE2:
	TRNE TEM,DONE			;BUSY went off.  If DONE is on, we're OK.
	JRST (AC1)			;Otherwise, an interrupt happened.
IFE DBG11 <MOVE TEM,INTCNI(DDB)>	;Get the bits that caused the interrupt.
IFN CBOX <	TRNE TEM,IREQ		;If it was requested by the 11,
		JRST (AC2)>		;we get a free retry.
	TRNE TEM,BUSTO
	JRST WDONE5
IFN NEWCNI <	TRNE TEM,NXM11
		TRNN TEM,BINIT
		CAIA>
IFE NEWCNI <	TRNE TEM,NXM11>
	TRNE IOS,NOTRY
WDONE3:
	POPJ P,
	SOJ AC2,
	AOBJP AC2,WDONE3
	JRST DLAY

WDONE4:
	TRNE IOS,NOTRY
	POPJ P,
WDONE5:
	SOJ AC2,
	AOBJN AC2,1(AC2)
	POPJ P,

;This little routine does the CONO's to start a data transfer.

DOCON:
	CONO D11,(TAC)			;Set the bus address from RH(TAC),
	HLR AC1,TAC
IFN DBG11 <TRZ AC1,77>		;Don't enable PI's if debugging
	CONO D11,(AC1)			;Start the operation from LH(TAC).
	POPJ P,

;	USET,SETCON, DLAY

;Common routine for USET's

USET:
	XCTR XR,[MOVE TAC1,(UUO)]	;Falls into SETCON.

;Routine to set the CONO and address bits, as for USETI
;TAC contains old combination, TAC1 the changes.

SETCON:
	JUMPGE TAC1,SETC1
	HLRZ AC1,TAC1
	DPB AC1,[POINT 4,TAC,11]
	TRNE AC1,20
	TLO TAC,IGNPAR
SETC1:
	TRNE TAC1,400000
	HRR TAC,TAC1
	POPJ P,

;Delay for one clock tick.  Call with JSP AC2,DLAY.  Clobbers AC1 and AC3.

DLAY:

IFN DBG11 <
	MOVEI AC3,0
	SLEEP AC3,
>;IFN DBG11
IFE DBG11 <
	PUSH P,TAC
	PUSH P,TAC1
	PUSH P,AC2
	PUSH P,TEM
	MOVEI TAC,1
	PUSHJ P,SLEEPT
	POP P,TEM
	POP P,AC2
	POP P,TAC1
	POP P,TAC
>;IFE DBG11
	JRST (AC2)

BEND ELFSER
>;IFN ELFNUM
;: ELFSER[J17,SYS] EOF.
;: DPYSER[J17,SYS]
COMMENT ⊗   VALID 00125 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00014 00002	SUBTTL III DISPLAY PACKAGE - D. POOLE - NOV 1968
C00016 00003	 BYTE POINTERS INTO BITS THAT SAY SIZE SET BY USER OR UUO
C00018 00004	COMMENT   THE FOLLOWING IS SYSTEM START TIME INITIALIZING CODE.
C00021 00005	 THIS ROUTINE MAKES UP A PROGRAM HEADER AND LINE EDITOR BUFFER.
C00026 00006	 MORE INITIALIZE CODE FOR A NEW PROGRAM-LINED-BUFFER THING
C00028 00007	 NOW SET UP THE POINTERS IN THE TABLES TO GET THE DP STARTED
C00031 00008	GETTING NEW DATA DISC CHANNEL. FIRST DESELECT AVAILABLE MSG,
C00033 00009	 ENTER HERE AT CLOCK LEVEL WITH LINE NUMBER IN TAC TO
C00036 00010		PUSHJ P,DPYKFS		GIVE ALL THE CORE BACK
C00039 00011	 WE GET HERE TO PLANT ANOTHER CLOCK REQUEST TO COME BACK
C00041 00012	 HERE ARE THE INTERRUPT ROUTINES FOR RUNNING THE DP.
C00044 00013	HERE WE HAVE AND ERROR - - PRINT A MESSAGE AND CHECK THE SYSTEM!
C00047 00014	 DP INTERRUPT CODE - RESTART PROGRAM, LOOP AROUND OF NEXT DPY, STOP DP, SET AVAILABLE MESSAGE
C00049 00015	PPINIT		PAGE PRINTER STUFF
C00052 00016		SETZM PPDD(DAT)		 ASSUME III UNTIL PROVEN OTHERWISE
C00055 00017	 FREE STORAGE HANDLER FOR PAGE PRINTER
C00057 00018	BELOW IS THE PROTOTYPICAL P. OF P. CONTROL BLOCK.
C00062 00019	TYO, DPYTYO.
C00067 00020	 WE GET HERE IF THE LAST CHARACTER WAS A LF AND WE ARE AT THE LEFT MARGIN
C00071 00021	PR1ECR:	JUMPGE DAT,PR1EC1	 IS THIS A DD?
C00075 00022	BEGIN EXTBUF	MAKE MORE ROOM IN THE DISPLAY BUFFER.
C00079 00023	 WE GET HERE UPON GLITCHING ON A DATA DISC DISPLAY
C00082 00024	 THESE ARE UTILITY ROUTINES USED BY THE PAGE PRINTER
C00085 00025	 HANDY ROUTINE TO GET POINTER TO TEXT FROM LINE NUMBER IN AC3
C00086 00026	 WE GET HERE IF THE POINTERS DON'T AGREE
C00087 00027	 ROUTINE TO CONVERT THE POSITION VECTOR INTO A DATA DISK
C00088 00028	FBLK:	PUSH P,AC1		FREE SOME BLOCKS FROM P.P.
C00091 00029	PPOUT:  WE GET HERE WHEN IT IS TIME TO OUTPUT PART OF A PIECE OF PAPER TO THE DISK.
C00093 00030	A SIMPLE MESSAGE PRINTER. JSA ITEM,ERRP WITH
C00094 00031	HERE ARE UUO LEVEL ROUTINES FOR MANIPULATING THE PAGE PRINTER.
C00097 00032	MORE PP ROUTINES.
C00101 00033	PPSEL <N>  MAKES P. OF P. <N> THE CURRENT ONE AND TURNS IT ON.
C00104 00034	 ROUTINE TO WAIT FOR TYPEOUT TO FINISH
C00105 00035	PPYPOS Y MAKES THE CURRENT P OF P START AT Y COORD. Y.
C00108 00036	 WE GET HERE WHEN THE APPEARANCE OF THE PAGE HAS CHANGED ENOUGH
C00110 00037	 ROUTINE TO ERASE PARTS OF DATA DISK SCREEN
C00112 00038	 HERE IS A ROUTINE TO MOVE THE LINE POINTER TABLE AROUND
C00114 00039	PPXSIZ <N>B26 ! <M>  SETS CURRENT P OF P TO HAVE N GLITCHES OF M LINES.
C00117 00040	CLKSER	THIS IS DPYSER'S OWN PRIVATE CLOCK QUEUER.
C00120 00041	 THIS ROUTINE QUEUES UP ANOTHER WHO LINE REQUEST.
C00123 00042	 ROUTINE TO FREE AN ENTIRE LIST OF BLOCKS, LINKED UP THROUGH LINK
C00125 00043	UUO LEVEL UTILITY ROUTINES AND DISPATCHERS.
C00128 00044	MORE GENERAL UUO ROUTINES.
C00129 00045	 ROUTINE TO RESET A DISPLAY. CLEARS PAGE PRINTER AND PIECES OF GLASS.
C00132 00046	 CALLED FROM <ESC>N IN LINE EDITOR BY A CLOCK REQUEST
C00134 00047	 CALLED FROM <ESC>L IN LINE EDITOR. SETS LINES/GLITCH
C00136 00048	 SET PAGE PRINTER HOLD COUNTS. GIVE LINE COUNT IN BITS 18-26 AND
C00138 00049	 THIS ROUTINE GIVES THE USER A NICE LITTLE TABLE OF DATA ABOUT HIS
C00142 00050	 PPINFO CONT - RUN DOWN LIST OF PP CTRL BLOCKS
C00144 00051	 THIS IS THE ROUTINE FOR A UUO WHICH SETS YOUR LINE EDITOR'S VERTICAL
C00146 00052	FREEL FREES A LIST OF BLOCKS POINTED TO BY AC1, AND UPDATES
C00147 00053	UPG IS THE DEMOCRATIC UUO WHICH ALLOWS ALL MEN,
C00150 00054		MOVN TAC1,UCHN		LENGTH OF USERS CODE.
C00153 00055	MORE OF UPG.
C00155 00056	 RST WITH NO PARAM BITS ON IS A NOOP -- ALLOW ANY ARGUMENT
C00157 00057	 DATA DISC PROGRAM HANDLER
C00161 00058	 HERE WE ARE, READY TO SET THE CHANNEL ADDRESS OF HIS DATA DISC PROGRAM
C00164 00059	 GET HERE TO LOOK AT A USER'S COMMAND WORD AND SEE IF THERE IS A CHANNEL SELECT
C00166 00060	CHANNEL ADDRESS CHECKING. HE CAN WRITE ON HIS OWN SCREEN,
C00168 00061	PGSET  SETS UP REQUESTED PIECE OF GLASS.
C00170 00062	 THIS IS THE DPY ERROR ROUTINE. IT TYPES OUT THE PC IN TAC1 ON
C00172 00063	↑↑UPGMVM:PUSHJ P,UPGMV		DO `MOVEM' INTO P OF G: TAKE CARE OF PRELIMINARIES.
C00175 00064	↑↑PGIOT:
C00178 00065	 THIS UUO GETS INFORMATION FROM THE SYSTEM ABOUT THE USER'S PIECES
C00180 00066	DPYTYP IS CALLED AT CLOCK LEVEL TO TYPE SOME CHRS. FROM A 
C00183 00067	 HERE WE ARE AT CLOCK LEVEL WITH (SUPPOSEDLY) DAT SET TO
C00187 00068	 ROUTINE TO TYPE CTY ERROR MESSAGE ON ILLEGAL LINE NUMBER
C00189 00069	 ROUTINE, CALLED FROM CLOCK CALL WITH LINE NUMBER IN DAT, TO CONTINUE PAGE PRINTER
C00192 00070	 COME HERE FOR DATA DISK TO SEE IF IT IS END OF LINE OR GLITCH TIME.
C00193 00071	SUBTTL DATA DISK SERVICE ROUTINE - JAM, DEC. 1970
C00196 00072	 CLOCK LEVEL QUEING SCHEME. PLANTS TASKS IN QUEUE AND LEAVES.
C00200 00073	 WE GET HERE AT CLOCK LEVEL IN THE MIDDLE OF QUEUEING UP A WHOLE SCREEN REQUEST.
C00203 00074	 WE GET HERE TO QUEUE UP A ONE LINE REQUEST.
C00206 00075	 THIS ROUTINE QUEUES UP AN ERASURE REQUEST FOR THE LINE EDITOR <ESC>C COMMAND
C00209 00076	 HERE LIES A ROUTINE TO QUEUE UP A WHOLE PAGE TRANSFER WHEN NOT GLITCHING
C00212 00077	 HERE IS THE MIGHTY LINE EDITOR AND CURSOR GENERATOR.
C00214 00078	 HERE WE SET UP THE CURSOR POSITION AND START ON THE DECISION TREE
C00217 00079	 WE GET HERE IF THE VERTICAL POSITION OF THE LINE EDITOR HAS NOT CHANGED.
C00220 00080	 LINE EDITOR DECISION TREE. WE GET HERE IF THE LINE EDITOR CURSOR HAS NOT
C00223 00081	 EVERYBODY COMES HERE TO EXIT
C00225 00082	 THIS ROUTINE QUEUES UP A LINE EDITOR TEXT REQUEST
C00227 00083	 THIS ROUTINE ERASES THE OLD SECOND LINE OF THE LINE EDITOR
C00229 00084	 THIS ROUTINE ERASES THE OLD CURSOR
C00231 00085	 THESE ROUTINES QUEUE UP THE VARIOUS COMBINATIONS OF CURSORS THAT MAY ARISE.
C00233 00086	QBLOCK	  HERE IS THE MAGIC SCHEDULING QUEUE ROUTINE
C00236 00087	 HERE WE SEE IF THE TASK IS AN EASY OUTSIDER.
C00239 00088	 HERE WE SCAN THE QUEUE SYSTEM LOOKING FOR A FRAME WITH SOME FREE LINES
C00242 00089	 WE GET HERE IF THE TASK IS ENTIRELY OUT OF BOUNDS
C00244 00090	 WE GET HERE WHEN THERE IS NO QUEUE AT ALL.
C00246 00091	 HERE IS A ROUTINE THAT MOVES ON TO THE NEXT FRAME, IF THERE IS NO NEXT
C00252 00092	 HERE LIES THE INCREDIBLE INTERRUPT-LEVEL ROUTINES!
C00254 00093	 ALL THE I-LEVEL ROUTINES RETURN TO HERE WHEN THEY ARE DONE
C00256 00094	 THIS ROUTINE IS CALLED AT CLOCK LEVEL WITH A LIST OF TASKS THAT
C00257 00095	 THIS ROUTINE TAKES A TASK OUT OF THE QUEUE AND WAKES UP ANYONE IF
C00260 00096	 PAGE PRINTER TRANSFERS
C00264 00097	PPXFR3:	MOVEI AC1,DDCW(DAT)	 PICK UP ADDRESS OF START OF TRANSFER
C00266 00098	 HERE IS THE ERASE CODE.
C00268 00099	 CURSOR TRANSFERS.
C00271 00100	 THIS ROUTINE MAKES UP THE CODE FOR A CURSOR.
C00273 00101	 LINE EDITOR TRANSFERS
C00276 00102	 WE GET HERE WHEN THE TRANSFER IS DONE OR ABORTED.
C00278 00103	 WHOLE SCREEN ERASURE AND AVAILABLE MESSAGE
C00281 00104	 USER DATA DISC PROGRAM . . .
C00284 00105	 ALL TRANSFERS COME BACK TO HERE WHEN THEY ARE DONE OR TIMED OUT
C00286 00106	 DATA DISC NON-EX MEM TYPEOUT, ACCUMULATOR SAVER, AND CLOCK TIMEOUT ROUTINES
C00288 00107	 WE GET HERE IF WE GET AN INTERRUPT FROM THE DATA DISK AND
C00289 00108	DEFINITIONS FOR DATA DISC ALLOCATION
C00291 00109	INITIALIZATION FOR DATA DISC ALLOCATION AND VIDEO SWITCH
C00294 00110	ALL-PURPOSE DD CHANNEL DIDDLING UUO:
C00296 00111	RELEASE CHANNEL C(TAC)
C00298 00112	GET CHAN SPECIFIED BY TAC(31-35) IF FREE
C00300 00113	ROUTINE TO THROW ALL SPIES OFF PRIVATE CHANNEL.
C00303 00114	SET STATUS OF CONSOLE CHANNEL
C00306 00115	ALL-PURPOSE VDS DIDDLING UUO:
C00309 00116	VDMAP2:	HLL TAC,VDDSP(AC1)
C00311 00117	VDSET:	PUSHJ P,VDWCHK
C00313 00118	ROUTINE TO BLESS BITS ABOUT TO BE TURNED ON FOR PRIVACY VIOLATION
C00315 00119	SUBTTL WHO LINE GENERATOR--R. HELLIWELL--6/APR/70
C00318 00120	↑WHOSER:MOVE	DAT,TIME
C00323 00121	WHOSIX:	MOVEI	AC2,6			CHARACTER COUNT
C00326 00122	THIS IS THE PART WE ALWAYS UPDATE.
C00331 00123	 THIS ROUTINE SETS UP A NEW WHO TABLE FROM A PIECE OF FREE STORAGE
C00334 00124	WLRET:	MOVE 	AC3,[POINT 7,WTEND+5(AC1),20]
C00339 00125	↑WHOSYS:
C00346 ENDMK
C⊗;

SUBTTL III DISPLAY PACKAGE - D. POOLE - NOV 1968
COMMENT ⊗
	THESE ARE THE GLORIOUS, WORLD-SAVING III DISPLAY
ROUTINES.  FOR THEIR FIRST TRICK, THEY WILL IMPERSONATE
W. F. WEIHER, THUS STARTING THE PROGRAM ON A NOTE OF
LIGHT HUMOR.

⊗

BEGIN DPYSER

↓CHR←TEM	;SAME AS CHREC IN SCNSER

;; NOW SOME DISPLAY OPCODES AND MACROS FOR GENERATING DP INSTRS.

DISJMP←←20	;DP JMP INSTR. OPCODE.
DISJMS←←4	; JMS (STORES TWO WORDS)
DISJSR←←24	; STORES ONLY RETURN ADDR.
DISRST←←14	;RESTORE.
DISSEL←←10	;SELECT.
DISNOP←←14	;ACTUALLY RST, BUT A GOOD NOP WITH ALL BITS OFF.

DEFINE LVW(X,Y,TYPE,MODE,BRT,SIZ)	;ASSEMBLES A LONG VECTOR.
  { MVW1 (MODE,TYPE,BRT,SIZ)	;TWIDDLE PARAMS.
	BYTE (11)<X>,<Y>(3)B,S(2)MD,TT(3)3 }	;ASSEMBLE INSTR.
DEFINE MVW1 (M,T,BRT,SIZ)
 {IFIDN {M}{A}{MD←1;}MD←0	;MODE = `A' FOR ABSOLUTE.
  IFIDN {T}{I}{TT←2;}TT←0	;TYPE = `I' FOR INVISIBLE.
  IFIDN {BRT}{}{B←0;}B←BRT	;BRT = 0 IF OMITTED.
  IFIDN {SIZ}{}{S←0;}S←SIZ	;SAME FOR SIZ.
}
DEFINE ERMS (X) {JSA ITEM,ERRP
POINT 7,[ASCIZ ⊗X
⊗]
}
DEFINE CW (C1,B1,C2,B2,C3,B3) {<BYTE (8)<B1>,<B2>,<B3>(3)<C1>,<C2>,<C3>>!4}
GLOBAL DDTAB,JB2SWP	;STUPID FAIL

; BYTE POINTERS INTO BITS THAT SAY SIZE SET BY USER OR UUO

SIZSBU:
	POINT 1,GWORD(DDB),0	; IF 1, SAYS LINES/GLITCH OR GLITCHES/PAGE SET BY USER LAST
POSSBU:
	POINT 1,GWORD(DDB),1	; SAYS Y-POS. SET BY USER COMMAND (RATHER THAN UUO)
LHCSBU:
	POINT 1,GWORD(DDB),2	; SAME FOR LINE HOLD COUNT
GHCSBU:
	POINT 1,GWORD(DDB),3	; SAME FOR GLITCH HOLD COUNT
HLINES:
	POINT 9,GWORD(DDB),17	; POINTS TO NUMBER OF LINES BEFORE HOLDING
HGLTCH:
	POINT 9,GWORD(DDB),26	; POINTS TO NUMBER OF GLITCHES BEFORE HOLDING
;	POINT 9,GWORD(DDB),35	; CHAR WHICH ACTIVATED LINED

; NORMAL VALUES FOR THE PAGE PRINTER

NGSIII←←14		; GLITCHES/PAGE FOR III DISPLAYS
NGSDD←←4		; GLITCHES/PAGE FOR DD DISPLAYS
NLSIII←←2		; LINES/GLITCH FOR III
NLSDD←←11		; LINES/GLITCH FOR DD
YPIII←←600		; Y-POSITION FOR III
YPDD←←660		; Y-POSITION FOR DD
↑NDDSPQ←←60		;# SPARE DD QUEUE BLOCKS (TIRED OF BEING SCREWED -REG)


COMMENT ⊗  THE FOLLOWING IS SYSTEM START TIME INITIALIZING CODE.
 	MUCH OF IT IS IN TEMPORARY FORM.
⊗

↑DWPINI:  
	MOVEI	AC1,2		;INITIALIZE COMMON DD CURSOR BUFFER
	MOVEM	AC1,DDCURS+2	;BY PROPAGATING A ZERO GRAPHICS WORD DOWN IT
	MOVE	AC1,[XWD DDCURS+2,DDCURS+3]
	BLT	AC1,DDCURS+21	;ALL THE WAY (TOO BAD THAT SOME PEOPLE CAN'T COUNT)
	MOVEI TAC,DPYNUM
	MOVEM TAC,DRUNCT	;INIT. PTR. TO NEXT DPY TO RUN.
	HRLOI TAC,377777
	MOVEM TAC,DDCNT
	SETZM FSWTHD		;CLEAR FS WAIT LIST.
	SETZM FSWT2H		;AND THE WAIT LIST WAIT LIST.
	SETZM DDSTART		; CLEAR ALL THE DATA DISK FLAGS
	SETZM DDRUN
	SETZM STRTBL		; ZERO OUT ALL THE IMPORTANT TABLES
	MOVE TAC,[XWD STRTBL,STRTBL+1]
	BLT TAC,LETAB+DPYNUM+DDNUM-1
	SETOM DXFLAG		;START DP ON FIRST CLOCK TICK.
	MOVE TAC,[POINT 36,CLKQUE-1,35]
	MOVEM TAC,CLKQ		;INIT. CLOCK QUEUE PTR.
	MOVE TAC,[IOWD LCPDL,CLKPD]	;..ALSO CLOCK PDL.
	MOVEM TAC,DPYPDL
	MOVSI TAC,770000	; RESTORE AVAILABLE MESSAGES
	HLLM TAC,DPYAVL+1
	HLLM TAC,WHOSEL		; SYSTEM WHO LINE FOR ALL AVAILABLE IIIS
	MOVSI TAC,77		; DESELECT EVERYONE
	HLLM TAC,DPYHLD		; HOLDING MESSAGE TOO
IFN FTOIKB, < CONO KBD,SCNCHN >		;GIVE INTERRUPT CHANNEL TO KEYBOARD SCANNER.
	CONO DDD,10
	PUSHJ P,DDINI
	JRST WHOINI

DWPERR:
	PUSHJ P,DISMES
	ASCIZ /CATASTROPHIC ERROR FROM DPYSER
/
DPYATL:
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

; THIS ROUTINE MAKES UP A PROGRAM HEADER AND LINE EDITOR BUFFER.
; IT EXPECTS THE LINE NUMBER IN TAC1. PRESERVES ALL OTHER ACCUMULATORS.
; SKIPS UPON SUCCESS. IF FAILURE, WILL PLANT A CLOCK REQUEST AND
; TRY TO GET ONE LATER.

↑DPYMAKE:
	SKIPE LETAB-DPYL0(TAC1)	; DO WE ALREADY HAVE A PROGRAM HEADER?
	JRST CPOPJ1		; YES, GIVE SUCCESS RETURN
	PUSH P,TAC
	PUSH P,DAT
	PUSH P,DDB
	PUSH P,AC1
	PUSH P,AC2
	PUSH P,AC3
	MOVNI TAC,1
	HLL TAC1,LINTAB(TAC1)
	TLNN TAC1,DDDLIN
	JRST DPYM1
	MOVSI TAC,400100-DDL0(TAC1)
	PUSHJ P,DDAGET	;FIRST MAKE SURE WE HAVE A CHANNEL FOR DD
	JRST DPYXTL	;GO DIRECTLY TO JAIL
	ANDI TAC,-1
DPYM1:
	MOVEI AC3,DHFS
	PUSHJ P,SFSGET
	JRST DPYM8
	HRRZ DDB,AC1
	SETZM (AC1)		; FIRST, ZERO THE THING OUT
	HRLZ AC2,AC1
	HRRI AC2,1(AC1)
	MOVE AC3,AC1
	BLT AC2,DPYLEN-1(AC3)
	MOVEI AC2,DISRST!60	; NOW SET UP THE STARTUP WORD TO RESTORE THE POSITION VECTOR
	HRLI AC2,PRGSAV(AC1)	; THAT WAS STORED LAST TIME THE DPY WAS STOPPED
	MOVEM AC2,(AC1)
	HRLI AC2,LEB+1(AC1)	; THE LINE EDITOR DOES THIS TOO
	MOVEM AC2,LEPPV+4(AC1)
	SETZM LEB(AC1)
	HRLI AC2,LEB(AC1)	; SET UP THE LINE EDITOR CALL
	HRRI AC2,DISJMS
	MOVEM AC2,LEJMS(AC1)
	HRRI AC2,DISJMP		; FILL UP THE LINE EDITOR BUFFER WITH RETURN JUMPS
	MOVEM AC2,LEBUF(AC1)
	HRLI AC2,WHOCALL(AC1)	; MAKE RESTART POINT JUMP BACK TO WHO LINE CALL
	MOVEM AC2,RTJMP(AC1)
	HRLI AC2,LEBUF(AC1)	; NOW BLT THE RETURN JUMP ALL OVER THE
	HRRI AC2,LEBUF+1(AC1)	; LINE EDITOR BUFFER.
	BLT AC2,LEHPOS-1(AC1)
	MOVSI AC3,(TAC)
	HRRI AC3,-DPYL0(TAC1)
	MOVEM AC3,PRGNUM(DDB)
	PUSHJ P,PPINIT		;GET PAGE PRINTER SET UP FOR EACH DPY.
	JRST DPYM7
	PUSHJ P,PPSET
	JUMPGE TAC,DPYM2
	MOVNI AC3,-DPYL0(TAC1)
	MOVE AC2,[BYTE (12)0,7777,DISSEL]
	MOVEM AC2,PSELC(DDB)
	MOVSI AC2,400040	; NOW MAKE UP SELECT WORD
	LSH AC2,(AC3)		; PUT A BIT IN THE FIRST TWO 12-BIT FIELDS
	XOR AC2,[77770000]	; COMPLEMENT THE SECOND FIELD
	ORI AC2,DISSEL
	MOVEM AC2,PSELA(DDB)	; AND THIS IS OUR SELECT WORD
	MOVEM AC2,PSELB(DDB)	; AND OUR SPARE SELECT WORD
	AND AC2,[77B5]		; MASK OUT ALL BUT SELECT BIT
	ANDCAM AC2,DPYAVL+1	; DESELECT THIS CONSOLE FROM AVAILABLE MESSAGE
	ANDCAM AC2,WHOSEL	; DESELECT THIS CONSOLE FROM SYSTEM WHOLINE
	LSH AC2,-=12		; PUT BIT IN 'RESET' FIELD
	ORM AC2,DPYAVL+1	; BE SURE TO RESET THIS CONSOLE TOO
	ORM AC2,WHOSEL		; BE SURE TO RESET THIS CONSOLE TOO
	MOVE AC2,[LVW (-5,-14)]	; MAKE A CURSOR FOR THE LINE EDITOR
	MOVEM AC2,LEPPV+1(DDB)
	MOVE AC2,[LVW (12,0)]
	MOVEM AC2,LEPPV+2(DDB)
	MOVE AC2,[LVW (-5,14)]
	MOVEM AC2,LEPPV+3(DDB)
	MOVE AC2,[LVW (0,0,I)]	; NOW A NULL VECTOR FOR THE LEFT MARGIN
	MOVEM AC2,LELMARG(DDB)

; MORE INITIALIZE CODE FOR A NEW PROGRAM-LINED-BUFFER THING

DPYM3:
	MOVEI AC2,LEBUF+BUFL-4(DDB)
	MOVEM AC2,MAXPT(DDB)	; MAKE UP POINTER TO END OF LINE EDITOR BUFFER
	MOVNI AC1,24000/BLKSIZ	; 24000 WORDS MAXIMUM TOTAL PROGRAMS
	MOVEM AC1,BLKTOT(DDB)	;HOW MANY MORE BLOCKS EACH USER GETS.
	HRRZI TAC,-DPYL0(TAC1)
	MOVEI AC1,DISNOP
	MOVEM AC1,WHOCALL(DDB)	;NO WHO LINE YET.
	MOVEM AC1,LEPOS(DDB)	; NORMAL VERTICAL POSITION
	MOVEM AC1,PGCALL(DDB)	;NO PG'S.
	MOVEM AC1,LEPPV(DDB)
	MOVEI AC1,400000
	MOVEM AC1,PRGACT(DDB)	;P OF P 0 ACTIVE.
	MOVEM AC1,USRACT(DDB)
	MOVEI AC1,3		; BUMP NUMBER OF SPARE FREE BLOCKS
	ADDM AC1,DPYFS+SPFSN
	ADDM AC1,SPFSNT

; NOW SET UP THE POINTERS IN THE TABLES TO GET THE DP STARTED
; AND STOPPED ON THIS PROGRAM

	HRL AC2,DDB		; NOW INITIALIZE ALL THE APPROPRIATE TABLES
	HRRI AC2,DISJMP		; THIS LITTLE JUMP GOES TO DPYTAB
	HRLI AC3,PRGSTP(DDB)
	HRRI AC3,DISJMS		; THIS LITTLE JUMP GOES TO STPTBL
	HRLI AC1,PSELB(DDB)
	HRRI AC1,DISJMP		; AND THIS LITTLE JUMP WENT WEE WEE WEE
	MOVEI DAT,LETAB(TAC)	;Give the header a pointer to
	MOVEM DAT,LETBPT(DDB)	; its LETAB entry.
	MOVEI DAT,PSELA(DDB)
	CONO PI,PIOFF		; ALL THE WAY INTO RSTTBL
	SKIPE LETAB(TAC)	; DID SOMEONE SNEAK IN UNDER US?
	JRST DPYM5
	HRRZM DDB,LETAB(TAC)	; INITIALIZE LINE EDITOR TABLE TOO
	CONO PI,PION
	CAIL TAC,DPYNUM
	JRST DPYXIT		;THAT'S ALL FOR DD
	MOVEM DAT,SELTBL(TAC)
	MOVEM AC3,STPTBL(TAC)	;IN THIS ORDER
	MOVEM AC1,RSTTBL(TAC)	;WE SHOULDN'T NEED
	MOVEM AC2,STRTBL(TAC)	;TO KEEP PI'S OFF
DPYXIT:
	AOS -6(P)		;WE HAVE WON
DPYXTL:
	POP P,AC3
	POP P,AC2
	POP P,AC1
	POP P,DDB
	POP P,DAT
	POP P,TAC
	POPJ P,

DPYM5:
	CONO PI,PION
	CAIL TAC,DPYNUM
	JRST DPYM6
	PUSHJ P,DPYKFS		;III - JUST RET FS
	JRST DPYXIT

DPYM6:
	HRRZM DDB,DPRLSF(DDB)	;DD - DEFER FS RET FOR DDWIPE
	MOVSI TAC,100-DDL0(TAC1)
	HLR TAC,PRGNUM(DDB)
	PUSHJ P,DDREL		;BUT GIVE BACK CHNL NOW
	JRST DPYXIT

DPYM7:
	PUSHJ P,DPYKF2		;RET HDR
DPYM8:
	JUMPL TAC,DPYXTL
	HRLI TAC,100-DDL0(TAC1)
	PUSHJ P,DDREL		;RELEASE DD CHNL
	JRST DPYXTL

↑PPSET:	HRRZM  DDB,HEDPTR(AC1)	;MAKE PP0 CONT. BLK. POINT AT HEADER.
	HRLI AC1,DISJMP		;ASSEMBLE JMP TO PP 0.
	MOVSM AC1,PPCALL(DDB)	;HAVE HEADER CALL THE PP.
	HRRZM AC1,CURPP(DDB)	;MAKE P OF P 0 THE CURRENT ONE.
	MOVEI AC3,PPCALL+1(DDB)	;RETURN ADDR. TO HEADER FROM PP.
	HRLM AC3,PPRJMP(AC1)	;PUT IN PP RETURN JMP.
	POPJ P,

;GETTING NEW DATA DISC CHANNEL. FIRST DESELECT AVAILABLE MSG,
;THEN ERASE CHANNEL, THEN SELECT CONSOLE TO CHANNEL.

DPYM2:
	MOVE AC2,AVLBIT
	HRLI DDB,DDWIPE
	CONO PI,SCNOFF
	ANDCAB AC2,VDMAP-DDL0(TAC1)
	MOVEM AC2,VDTMP(DDB)
	CONO PI,PIOFF
	IDPB DDB,CLKQ
	CONO PI,PION!SCNON
	JRST DPYM3

;HERE AT CLOCK LEVEL (CAN'T CALL QBLOCK FROM CH5)
DDWIPE:
	SKIPE DDB,DPRLSF(DAT)
	JRST DPYKFS		;DPYMAKE WAS ABORTED - RET FS NOW
	PUSHJ P,GETQ
	HRRZ AC2,CURPP(DAT)
	ADDI AC2,PPENQ
	MOVEM AC2,QCOUNT(AC1)
	AOS (AC2)	;WILL HOLD UP BOTH DPLED & DPYTYP
	HRLI DAT,DDMAP
	MOVEM DAT,QWAKE(AC1)
	JRST LEERS3

;HERE AFTER ERASE IS FINISHED. NOW THAT CHANNEL IS CLEAN, WE LET HIM SEE IT.
DDMAP:
	HLRZ AC1,PRGNUM(DAT)
	HRRZ TAC,PRGNUM(DAT)
	SUBI TAC,DPYNUM
	PUSHJ P,VDSTRB
	IORM AC3,VDTMP(AC2)
	PUSHJ P,VDOUT
	MOVEI DAT,DDL0(TAC)
	JRST DPYTYP		;IN CASE PP XFER WAS FLUSHED

; ENTER HERE AT CLOCK LEVEL WITH LINE NUMBER IN TAC TO
; FLUSH A DPY BUFFER, IF THAT IS WHAT IS CALLED FOR.

↑DPYKIL:CAIL TAC,DPYNUM+DDNUM
	JRST DPYKER
	SKIPE AC1,LETAB(TAC)
	SETZM LECLIN(AC1)	; CLEAR FLAG THAT SAYS CLOCK REQUEST IS IN
	SKIPN TTYTAB+DPYL0(TAC)	; FIRST, IS TTYSER THROUGH WITH IT?
	SKIPG AC1,LETAB(TAC)
	POPJ P,			; NO, LEAVE IT AROUND
	SKIPE LEACT(AC1)	; HAS THE LINE EDITOR BEEN ACTIVE IN THE LAST MINUTE?
	JRST DPYKI9		; YES, WAIT ANOTHER MINUTE
	SKIPN LEENQ2(AC1)	; IF HE'S REFRESHING OR HELPING,
	SKIPE LEENQ(AC1)	; OR IF HIS LINE EDITOR IS IN THE QUEUE
	JRST DPYKI7		; PLANT ANOTHER CLOCK REQUEST TO KEEP US AROUND
	HLRZ AC2,PPCALL(AC1)	; OR IF HE HAS ANY PIECE OF PAPER QUEUED
DPYKI8:
	SKIPE PPENQ(AC2)	; ANYTHING IN QUEUE?
	JRST DPYKI7
	HRRZ AC2,LINK(AC2)	; PICK UP POINTER TO NEXT PIECE OF PAPTER CONTROL BLOCK
	JUMPN AC2,DPYKI8	; LOOP BACK IF ANY
	HRRZ DDB,AC1
	CAIL TAC,DPYNUM
	HRLI DDB,400000	;SET DD FLAG
	PUSHJ P,PGCLR		; CLEAR ANY AND ALL PIECES OF GLASS
	CONO PI,PIOFF
	SKIPN TTYTAB+DPYL0(TAC)	; ONE LAST CHECK!
	SKIPG LETAB(TAC)
	JRST DPYKI3
	SETZM LETAB(TAC)
	JUMPL DDB,DPYKL1
	SETZM RSTTBL(TAC)
	SETZM STPTBL(TAC)
	SETZM STRTBL(TAC)
DPYKL1:
	CONO PI,PION
	HRRZ AC2,DDB
	SKIPA J,JOBNM1
DPYKML:
	SETZM DPYMAP+1(J)		;CLEAR GUY MAPPED TO US
	CAIE AC2,@DPYMAP(J)
	SOJG J,.-1
	SOJGE J,DPYKML

	PUSHJ P,DPYKFS		;GIVE ALL THE CORE BACK
	JUMPGE DDB,DPYK11	;JUST DIDDLE SELECT FOR III
DPYK10:
	MOVSI TAC,100-DPYNUM(TAC)
	HLR TAC,PRGNUM(DDB)
	PUSHJ P,DDREL
	MOVEI AC1,(TAC)
	LDB TAC,[220600,,TAC]
	PUSHJ P,VDBIT
	ANDCAB AC3,VDMAP(TAC)
	JUMPN AC3,VDOUT		;FORGET AVAIL MSG IF SOMETHING ELSE ON SCREEN
	MOVE AC3,AVLBIT
	IORM AC3,VDMAP(TAC)
	JRST VDOUT

DPYK11:
	MOVNS TAC
	MOVSI AC1,400000	; PUT A BIT IN THE CONSOLE SELECT POSITION
	LSH AC1,-=12(TAC)	; PUT IT IN THE RESET PART FIRST
	ANDCAM AC1,DPYAVL+1	; DON'T RESET US
	ANDCAM AC1,WHOSEL	; DON'T RESET US FOR WHOLINE EITHER
	LSH AC1,=12		; PUT IT IN THE SELECT POSITION
	ORM AC1,DPYAVL+1	; SELECT THIS CONSOLE
	ORM AC1,WHOSEL		; SELECT THIS CONSOLE FOR SYS WHO LINE
	POPJ P,			; BYE NOW.

DPYKI3:
	CONO PI,PION
	POPJ P,

DPYKFS:
	MOVNI AC2,3
	MOVEI AC3,DPYFS
	PUSHJ P,SFSREL		;GIVE BACK SPARE TEXT BLOCKS
	HLRZ DAT,PPCALL(DDB)
	JUMPE DAT,DPYKF2	;NO PAGE PRINTER
DPYKF1:
	MOVE AC1,FBLKPT(DAT)
	PUSHJ P,FREEL		;RELEASE TEXT BLOCKS
	HRRZ AC1,PTB(DAT)
	JUMPE AC1,.+2
	PUSHJ P,FSGIVE		;& LINE POINTER TABLE
	MOVE AC1,DAT
	HRRZ DAT,LINK(DAT)	;GET POINTER TO NEXT P. OF P.
	PUSHJ P,UGIVFS		;BECAUSE THIS ONE'S GOING AWAY
	JUMPN DAT,DPYKF1	;KEEP GOING IF MORE
DPYKF2:
	MOVEI AC1,(DDB)
	JRST UGIVFS		;NOW RETURN HEADER

; WE GET HERE TO PLANT ANOTHER CLOCK REQUEST TO COME BACK
; LATER TO TRY AND KILL THE DAMN THING.

DPYKI9:
	SETZM LEACT(AC1)	; CLEAR THE ACTIVE FLAG
	SKIPA AC3,DPYKRQ
DPYKI7:
	MOVE AC3,[XWD DPYKILL,1]
	SETO AC2,		; SET FLAG SAYING THERE IS A CLOCK REQUEST IN
	EXCH AC2,LECLIN(AC1)
	JUMPL AC2,CPOPJ		; IF THERE ALREADY IS A CLOCK REQUEST IN, DON'T BOTHER TO SET ANOTHER
	LSH TAC,=12		; SHIFT LINE NUMBER OVER TO DATA POSITION
	ADD TAC,AC3		; HAVE US COME BACK HERE IN 1 TICK
	CONO PI,PIOFF
	IDPB TAC,CLOCK(PID)
	CONO PI,PION
	POPJ P,

; THIS ROUTINE PRINTS AN ERROR MESSAGE WHEN THE GIVEN
; LINE NUMBER IS ILLEGAL.

DPYKER:
	PUSH P,TAC		; SAVE THE ILL NUMBER
	PUSHJ P,DISERR		; GIVE OUR ERROR MESSAGE
	[ASCIZ /ILLEGAL LINE NUMBER AT DPYKILL - /]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	POP P,TAC
	POPJ P,

↑DPYKRQ:	DPYKIL,,=15*=60	;TIME TO WAIT BEFORE KILLING CONSOLE

; HERE ARE THE INTERRUPT ROUTINES FOR RUNNING THE DP.



↑DPYINT:
BEGIN DPYINT

DP←←430		;DEVICE NO. OF DISPLAY PROCESSOR.
DPYCHL←CH3;;replaced;;DPYCHL←<FOR @$ QQ←DPYCHN,DPYCHN {CH$QQ}>	;PI CHANNEL 3 IS WHERE IT'S AT.
DPCONB←←40	;THE `CONTINUE' BIT FOR THE  DP.
DPNULL←←0
DPNXM←←2000	; THE NON-EX MEM BIT
DPINT←←4000	; INTERRUPT REQUEST
DPSTOP←←200	; SET NOT RUNNING
DPCHK←←400	; ERROR CHECK FLAG

	CONSO DP,400000		;IS IT REALLY STOPPED ?
	JEN @DPYCHL		;NO. 
	EXCH TAC,DRUNCT		;GET NO. OF DPY WHICH HAS BEEN ON.
	SKIPN STPTBL(TAC)	; STOP HIM HERE ONLY IF HE HAS A STOP TABLE
	JRST NOSTOP
	DATAO DP,STPTBL(TAC)	;STOP DP AT RIGHT PRGM HEADER.
	MOVEM TAC1,@SELTBL(TAC)
	CONI DP,TAC1		;SAVE CURRENT SELECTION FOR NEXT TIME
	HRRI TAC1,DISSEL
	EXCH TAC1,@SELTBL(TAC)
NOSTOP:
	CONSZ DP,DPNXM!DPCHK	; HIT A NON-EX MEM OR ERROR CHECK?
	JRST DPERR		; YES, PROCESS IT
L6:
	SOJL TAC,L1		;NEXT PRGM TO RUN. (6 PRGMS ALWAYS ARE RUNNING)
L5:
	CONSO DP,400000		;MAKE SURE HE FINISHED STOPPING
	JRST L5
	SKIPE RSTTBL(TAC)	;DOES HE WANT TO START FROM THE FRONT ?
	JRST L2			;YES.
	SKIPN STRTBL(TAC)	; IS THERE A PROGRAM THERE?
	JRST L7
	DATAO DP,STRTBL(TAC)	;NO.  START HIM AT NORMAL PLACE.
L3:
	EXCH TAC,DRUNCT		;PUT THINGS BACK.
	ROT 44
	CONO DP,DPCONB+DPYCHN+740000+1000	;START DP AND CLEAR MASKS.
	JEN @DPYCHL		;RETURN TO WHOMEVER.

;HERE WE HAVE AND ERROR - - PRINT A MESSAGE AND CHECK THE SYSTEM!

DPERR:
	EXCH P,APRPDL+P1PID	; GET A STACK
	PUSHACS			; GET US SOME AC'S
	MOVEI PID,P1PID
	MOVEM TAC,SAVTAC		;SAVE DP #
	CONI DP,DPCNI		;GET SOME BITS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ/DP ERROR.
CONI BITS = /]
	DISARG LOC,DPCNI
	[ASCIZ/
DPY# = /]
	DISARG LOC,SAVTAC
	-1
	MOVE AC3,SAVTAC
	SKIPN AC3,STPTBL(AC3)
	JRST NOADDR
	HLRZS AC3
	HLRZ AC3,(AC3)		;GET MA
	PUSHJ P,DISERR
	[ASCIZ/    MA = /]
	DISARG LOC,AC3
	[ASCIZ/
/]
	-1
	CAILE AC3,1
	CAMLE AC3,RMEMSIZ	;IS IT LEGAL?
	JRST ADDRCK
	PUSHJ P,DISERR
	[ASCIZ\MA-2/   \]
	DISARG OCT,-2(AC3)
	[ASCIZ\
MA-1/   \]
	DISARG OCT,-1(AC3)
	[ASCIZ\
MA/     \]
	DISARG OCT,(AC3)
	-1
	JRST NOADDR
ADDRCK:
	PUSHJ P,DISMES
	ASCIZ/NON-EX ADDRESS/
NOADDR:
	PUSHJ P,DISMES
	ASCIZ/


/
	PUSHJ P,SYSFIX		;CHECK SYSTEM FOR CLOBBERING
	JFCL			;OK
	JFCL			;NOT OK
	SKIPN DEBMOD		;DOES HE WANT TO LOOK AT IT?
	JRST NODPLK		;NO
	SETOM DISFLAG
	PUSHJ P,DISFLUSH	;FORCE OUT THE REST
	PUSHJ P,DDTCALL		;AND CALL DDT
NODPLK:

	MOVEI TAC,DPYNUM-1	;RESTART ALL DISPLAYS
L8:
	SKIPN DDB,LETAB(TAC)
	JRST L9			; IF NONE THERE, LOOP
	HRLI DDB,PSELB(DDB)	; ARRANGE TO RESTART AT TOP AGAIN
	HRRI DDB,DISJMP
	MOVEM DDB,RSTTBL(TAC)
L9:
	SOJGE TAC,L8		; GET THEM ALL!
	POPACS			; GET BACK AC'S
	EXCH P,APRPDL+P1PID	; AND WHATEVER WAS IN P
	JRST L6			; AND DO NEXT GUY

; DP INTERRUPT CODE - RESTART PROGRAM, LOOP AROUND OF NEXT DPY, STOP DP, SET AVAILABLE MESSAGE

L2:
	DATAO DP,RSTTBL(TAC)	;START GUY AT BEGINNING OF HIS PRGM.
	SETZM RSTTBL(TAC)	;...THIS TIME ONLY.
	JRST L3

L1:
	SKIPE DPYHOL		; HAS THE HOLDING MESSAGE GONE OUT YET?
	JRST L1A		; YES, CONTINUE WITH OUR BUSINESS
	SETOM DPYHOL
	DATAO DP,[XWD DPYHLD,DISJMP]
	JRST L3

L1A:
	SETZM DPYHOL
	MOVEI TAC,DPYNUM-1	;WE'VE RUN `EM ALL.
	SETZM DPYARN		; NOTE THAT THEY HAVE ALL BEEN RUN
	AOSE DSFLAG		;HAS CLOCK TICKED ?
	AOJA TAC,L4		;NO. IT'S NOT YET TIME TO START OVER.
	JRST L5

L4:
	CONO DP,DPNULL		;SHUT DOWN THE DP.
	EXCH TAC,DRUNCT
	JEN @DPYCHL

L7:
	SKIPE DPYARN		; HAS THE 'CONSOLE AVAILABLE' MESSAGE GONE OUT YET?
	JRST L6			; YES
	SETOM DPYARN		; NO, IT WILL.
	DATAO DP,[XWD DPYAVL,DISJMP]
	JRST L3			; GO START UP DP AND LEAVE

BEND DPYINT

;PPINIT		PAGE PRINTER STUFF

COMMENT  ⊗	THIS IS THE ABODE OF THE FEARSOME PAGE PRINTER.
	IT ALLOWS EACH LUCKY USER (IF HE IS OBEDIENT) TO HAVE
	UP TO 16 PIECES OF PAPER (OR REASONABLE FACSIMILE
	THEREOF), ON ANY OF WHICH HE CAN TYPE AND DRAW IN
	DIVERSE WAYS, AND WHICH CAN BE ROLLED BACKWARD AND
	FORWARD AND DISPLAYED SEPARATELY OR IN ARBITRARY
	COMBINATION WITH OTHER DISPLAYS.
		EACH PIECE OF PAPER CONSISTS OF A LINKED
	SET OF BLKS FROM FREE STORAGE AND ONE CONTROL BLOCK,
	ALSO FROM FREE STORAGE. THE CONTROL BLOCK IS LINKED
	TO THE PROGRAM HEADER AND TO THE CONTROL BLOCKS FOR ANY
	OTHER PIECES OF PAPER BELONGING TO THE SAME PROGRAM.
⊗

OUTNUM←←1	;THIS MANY BLOCKS AT ONCE GET PUT ON DISK.
LINELN←←=88	;NO. OF CHARS. PER LINE.
DDLINELN←←=84	; SAME AS ABOVE FOR DATA DISK
CBLKBT←←1;	;MAGIC CODE BITS FOR THE (HO, HO) RELOCATING GARBAGE COLLECTOR.
TBLKBT←←4
FBLKBT←←2

↑PPINIT:	   		;INITIALIZE A PAGE PRINTER WITH PIECE OF PAPER 0.
	PUSHJ P,PPFSGET		;GET A BLOCK OF FREE STORAGE.
	POPJ P,			; NO FREE STORAGE, GIVE ERROR RETURN
	HRR AC3,AC2		;MAKE BLT POINTER.
	HRRZ DAT,AC2
	HRLI AC3,PPMODL
	BLT AC3,BLKSIZ-1(AC2)	;INIT. THE CONTROL BLK. BY COPYING THE PROTOTYPE INTO IT.
	PUSHJ P,PPFSGET		;GET A BLOCK FOR FIRST PART OF PRGM.
	JRST PPI1		; NO FREE STORAGE, RELEASE PREVIOUS BLOCKS AND GIVE ERROR RETURN
	MOVEM AC2,CBLKPT(DAT)	;MAKE IT CURRENT BLOCK...
	MOVEM AC2,FBLKPT(DAT)	;.. AND FIRST BLOCK IN CORE...
	MOVEM AC2,TBLKPT(DAT)	;... AND TOP BLK BEING DISPLAYED.
	HRRM AC2,PPTR1(DAT)	;MAKE BYTE POINTER FOR TYPING POINT
	SOS PPTR1(DAT)		;ONE BEFORE BOTTOM OF BLOCK.
	HRLM AC2,TPJMP(DAT)	;FIX UP JMP TO PRGM IN CONT. BLK.
	HRLI AC3,TPJMP+1(DAT)	;RETURN ADDR. FROM PRGM. TO CONT. BLK.
	HRRI AC3,DISJMP
	MOVEM AC3,(AC2)		;PUT RETURN JMP IN FIRST WORD OF PRGM.
	HRLZM DAT,LINK(AC2)	;BACKWARD LINK OF PRGM. POINTS TO CONT. BL.K.
	SETZM LINK(DAT)		;ONLY ONE CONT. BLOCK.

	SETZM PPDD(DAT)		; ASSUME III UNTIL PROVEN OTHERWISE
	MOVEI AC3,LPFS		; GET SOME FREE STORAGE FOR THE
	PUSHJ P,SFSGET		; LINE POINTER TABLE
	JRST PPI3
	MOVEM AC1,PTB(DAT)	; SAVE ADDRESS OF BEGINNING OF BLOCK
	ADDI AC1,=20		; BUMP ADDRESS TO VISIBLE SCREEN PART
	HRRM AC1,PTRB(DAT)
	MOVE AC2,PPTR1(DAT)	; INITIALIZE FIRST WORD OF POINTER TABLE
	ADD AC1,VPOS(DAT)	; GET ADDRESS OF FIRST POINTER TO BE USED
	MOVEM AC2,(AC1)		; TO POINT TO FIRST OF TEXT
	MOVEM AC2,1(AC1)	; SAME FOR DD
	JUMPL TAC,PPFXT		;DONE FOR III
	SETOM PPDD(DAT)
	MOVEI AC1,11		; SET NUMBER OF LINES IN A GLITCH TO 8
	MOVEM AC1,DEL(DAT)
	MOVEM AC1,DELCNT(DAT)
	MOVEI AC1,4		; AND NUMBER OF GLITCHES TO 4, SUCH THAT WE GET
	MOVEM AC1,PGSIZ(DAT)	; 32 LINES TO A SCREEN AND DON'T DO A WHOLE PAGE REFRESH TOO OFTEN
	MOVEM AC1,VPOS(DAT)
	MOVEM AC1,LLW(DAT)
	MOVEM AC1,GLW(DAT)
	SETZM DDSAV(DAT)	; CLEAR EXTRA SAVED WORDS
	MOVE AC1,[CW 1,46,2,0,3,2]
	DPB TAC,[POINT 8,AC1,15]
	MOVEM AC1,DDCW(DAT)
	MOVEI AC2,DDLINELN	; SET OUR OWN LINE LENGTH
	MOVEM AC2,LNLNGT(DAT)
	MOVNM AC2,DPHPOS(DAT)	; INITIALIZE THE HORIZONTAL POSITION COUNTER
	MOVE AC1,[LVW -777,YPDD,I,A,2,2]
	MOVEM AC1,PPOSV(DAT)
	SETZM TPJMP+1(DAT)
	SETZM TPJMP+2(DAT)
	MOVE AC1,[CW 3,2,4,0,5,0]
	MOVEM AC1,TPJMP+4(DAT)
PPFXT:
	MOVE AC1,DAT
	JRST CPOPJ1

; WE GET HERE MOSTLY IF A REQUEST FOR FREE STORAGE FOR THE PAGE PRINTER FAILS

PPI3:
	HRRZ AC1,CBLKPT(DAT)	; RETURN FIRST PIECE OF TEXT
	PUSHJ P,FSGIVE
PPI1:
	HRRZ AC1,DAT		; AND RELEASE CONTROL BLOCK ITSELF
	JRST FSGIVE		; TAKE ERROR RETURN FROM PPINIT

; FREE STORAGE HANDLER FOR PAGE PRINTER

PPFSGE:
	MOVE AC2,AC1
	MOVEI AC3,PPFS
	AOS (P)
	PUSHJ P,SFSGET
	SOS (P)
	EXCH AC2,AC1
	POPJ P,

;;UGETFS IS FOR GETTING FREE STG. AT UUO LEVEL.

CGETFS:
	AOSA BLKTOT(DDB)
UGFS2:
	PUSHJ P,CLKWAT		;WAIT FOR SOME FS TO APPEAR.
↑UGETFS:			;;GET A BLOCK OF FREE STG. FROM JAM.
	MOVEI AC3,DPYFS
	PUSHJ P,SFSGET
	SKIPE AC1,SPWUUF(PID)	;WE ARE AT CLOCK LEVEL AND THERE'S NO FREE STG.
	POPJ P,
	SKIPN AC1,INTACT(PID)	; OR AT USER INTERRUPT LEVEL
	JRST UGFS2		;OOPS, NONE THERE, AND WE ARE NOT IN SPACEWAR MODE.
	POPJ P,

; ROUTINE TO RELEASE FREE STORAGE BLOCKS

CGIVFS:
	SOS BLKTOT(DDB)		;DECR. COUNT OF USED BLOCKS...
↑UGIVFS:
	CONO PI,PIOFF
	MOVE AC2,FSWT2H	;FREE THE BLOCK IN AC1.
	HRRZM AC1,FSWT2H
	HRRM AC2,LINK(AC1)
	CONO PI,PION
	AOS FSW2C
	POPJ P,

;GET A DD Q BLOCK
GETQ:
	PUSH P,AC3
	MOVE AC3,[SETZ DDFS]	;NO SKIP
	PUSHJ P,SFSGET
	POP P,AC3
	POPJ P,

UGETF2:
	PUSHJ P,CLKWAT
UGETF1:
	PUSHJ P,FSGET
	SKIPE AC1,SPWUUF(PID)	;TOO BAD WE HAVE TO DUPLICATE ALL THIS SHIT
	POPJ P,
	SKIPN AC1,INTACT(PID)
	JRST UGETF2
	POPJ P,

;BELOW IS THE PROTOTYPICAL P. OF P. CONTROL BLOCK.

DEFINE X (A,B) {A←←.-PPMODL
		B
		}
PPMODL:
  

X PPOSV,{LVW  -777,YPIII,I,A,2,2}	;POS VECTOR
X TPJMP, DISJMP		;JMP TO FIRST BLOCK OF PAGE BEING DISPLAYED.
	LVW (7,-17,I)	;NOW DRAW THE CURSOR.
	LVW -5,-10
X ↑DDCW,<LVW 12,0>
	LVW -5,10
	LVW (-7,7,I)
X PPRJMP, DISJMP	;JMP BACK TO HEADER OR ON TO NEXT CONT. BLK.

X HEDPTR, 0		;POINTER BACK TO PRGM HEADER.
X OUTCNT,OUTNUM		;BLOCKS REMAINING BEFORE DISK OUTPUT.
X PPNO,0		;NONO. OF THIS P. OF P.
X ↑DPHPOS,-LINELN	;CHARS. LEFT BEFORE END OF THIS LINE.
X CNT1,0		;CHARS. REMAINING  BEFORE EXTENSION NEEDED.
X PPTR1,{POINT 7,0,35}	;CURRENT POINTER FOR PRINTING ON THIS PIECE OF PAPER.
X SPTR1,0		; SAVED POINTER FOR ZEROING OUT SPACE BEFORE CR
X WCNT,-INITWC		;FREE WORDS LEFT IN CURRENT BLOCK.
X CBLKPT,0		;BOTTOM OF CURRENT BLOCK.
X TBLKPT,0		;FIRST BLOCK CURRENTLY DISPLAYED (AT TOP OF SCREEN)
X FBLKPT,0		;FIRST BLOCK STILL IN CORE.
X DEL,2			; NO. OF LINES IN A GLITCH.
X DELCNT,2		;LINES REMAINING IN CURRENT GLITCH.
X GLCNT,1		;CURRENT SIZE OF PAGE IN GLITCHES.
X PGSIZ,14		;NOMINAL SIZE OF PAGE IN GLITCHES.
X PTBEG,0		; INCREMENT INTO LINE POINTER TABLE
X DDSPT,0		;POINTS TO SAVED WORD FROM FIRST REFRESHED LINE (DD)
X DDSAV,0		;SAVED WORD FROM FIRST REFRESHED LINE (DD)
	0
X (↑VPOS,3)		;LINE NUMBER OF CURRENT LINE
X LLW,3			; LAST LINE WRITTEN
X PTRB,<XWD AC3,0>	;POINTS TO TABLE OF BYTE POINTERS TO THE FIRST OF EACH LINE (DD)
X PTB,0			; ACTUAL TABLE ADDRESS
X VP,0			; VERTICAL POSITION ARGUEMENT TO QDD
X SC,0			; ARGUEMENT TO QDD FOR COUNT FIELD ADDRESS
X DPYCHR,0		; FLAG SAYING AT LEAST ONE CHARACTER HAS BEEN TYPED
X LSTCHR,12		; LAST CHARACTER DEPOSITED INTO BUFFER
X GLW,3			; GREATEST LINE WRITTEN, FOR ERASING WHEN WE GLITCH
X PPDD,0		; DATA DISK FLAG
X GLTCH,0		; FLAG THAT SAYS THE PAGE PRINTER HAS GLITCHED
X PPINV,0		; FLAG INDICATING PAGE PRINTER POINTERS ARE BEING MODIFIED
X PPENQ,0		; NUMBER OF TASKS THIS PAGE PRINTER HAS IN THE DD QUEUE
X PPNQT,0		; COUNT DOWN FOR NON-PAGE PRINTER REQUESTS
X PPVIRG,-1		; INDICATES VIRGIN PAGE PRINTER
X ↑LNLNGT,LINELN	;LINELENGTH FOR THIS GUY.


; ALL DISPLAY PROGRAM SPACE IS TAKEN FROM A FREE
;  STORAGE AREA CONSISTING OF FIXED SIZE BLOCKS.  THE
; FOLLOWING PARAMETERS RELATE TO THOSE BLOCKS.

↓BLKSIZ←←<<LNLNGT+5+1>!<TRIVIAL-1>>-1	;BLOCK SIZE. THIS IS ARBITRARY, BUT ≥36
↑BLKSIZ←←BLKSIZ
↓LINK ←← BLKSIZ-1	;LINKS IN LAST WD OF BLK: XWD BACK,FORWARD
↓BLKBTS ←← LINK-1	;MAGIC TYPE BITS FOR BLK GO HERE.
↓GCINFO ←← BLKBTS-1	;INFO FOR THE (HYPOTHETICAL) GARBAGE COLLECTOR
FSBSIZ←←BLKSIZ-2	;BLKSIZ FOR OUTSIDE WORLD.
↑FSLINK←←LINK
↓CNT←←GCINFO-2		;MAX. NO. OF `GLITCHES' PER PAGE.
INITWC←←GCINFO-2	;THIS MANY WORDS/BLOCK AVAILABLE FOR PROGRAM.

;TYO, DPYTYO.

;TYO: CHARACTER IN CHR, DAT POINTS TO P.OF P. CONTROL BLOCK.

;???PRINT IS CALLED WITH A BYTE PTR. IN TAC AND A
;POSITIVE CHAR. COUNT IN TAC1 AND DAT POINTING TO CONTROL BLOCK.


↑↑DPYTYO:
	MOVE DAT,CURPP(DDB)	; PICK UP POINTER TO PAGE PRINTER CONTROL BLOCK
	HLL DAT,DDB		; PUT IN DD BIT
	JRST TYO

TYOTAC:
 ILDB CHR,TAC		;PRINT NEXT CHR IN STRING POINTED TO BY TAC.
TYO:
	MOVE	AC1,LSTCHR(DAT)	; PICK UP LAST CHARACTER TYPED
	CAIN	AC1,177		;IF A DELETE ON DATA DISC
	JUMPL	DAT,DELNOW	;ON DD, <DELETE><CHR> IS A SINGLE NORMAL GRAPHIC.
	JUMPE	CHR,CPOPJ	;DON'T PRINT NULLS.
	JUMPGE	AC1,TYO0	;JUMP UNLESS THE LAST THING WE DID WAS INVENT CRLF.
	CAIN	CHR,15		;A CR AFTER WE INVENTED A CRLF?
	POPJ	P,		;YES. SUPPRESS IT.
	MOVEI	AC1,12		;MAKE IT LOOK LIKE THE LAST CHARACTER WAS LF.
	MOVEM	AC1,LSTCHR(DAT)	;SET IT.
	CAIN	CHR,12		;CHARACTER IS LF?
	POPJ	P,		;YES. SUPPRESS THAT TOO.
				;NOW IT LOOKS LIKE NORMAL CHARACTER, LSTCHR SET.

TYO0:
	SETOM DPYCHR(DAT)	; NOTE THAT ANOTHER CHARACTER HAS BEEN TYPED
	CAIN CHR,15		; IS IT A CR ?
	JRST PR1ECR		; YES, GO SERVICE IT
	CAIE AC1,12		; WAS LAST CHARACTER A LF?
	JRST TYO1		; NO
	JUMPG DAT,TYO1		; IF III, WE CAN SKIP ALL THIS BULLSHIT

;ON DD. FIRST CHARACTER AFTER LF.
	MOVE AC1,DPHPOS(DAT)	; WELL, ARE WE AT THE BEGINNING OF THE LINE?
	ADD AC1,LNLNGT(DAT)
	JUMPE AC1,TYO4		; YES, THERE MUST HAVE BEEN A CR FIRST.
	PUSH P,CHR		; SAVE OUR CHARACTER
	PUSH P,AC1		; SAVE THE COUNT (I.E., COLUMN NUMBER.)
	MOVEI CHR,15		; TYPE A CR FIRST
	DPB CHR,SPTR1(DAT)	; REPLACE LF WITH CR
	MOVEI CHR,12		; PUT OUR LF BACK
	SOS VPOS(DAT)
	PUSHJ P,PUTCH1
	PUSHJ P,EOLSET		; STORE THE POSITION OF OUR NEW LF
	MOVEI CHR,40		; THEN PAD OUT THE LINE
;TYPE A BUNCH OF SPACES TO SIMUALTE A BARE LINE FEED.
TYO5:
	PUSHJ	P,PUTCH1	;SEND A SPACE.
	SOSLE	(P)		;DECREMENT THE SPACE COUNT.
	JRST	TYO5		;LOOP SPACING.
	SUB	P,[1,,1]	;ADJUST STCK TO REMOVE SPACE COUNT.
	POP	P,CHR		;RESTORE CHARACTER. FALL INTO TYO1

TYO1:
	CAIN CHR,12		; OR A  LINE FEED ?
	JRST PR1EOL		;YES.
	JUMPGE DAT,TYO2		; IF III, JUST PUT THE CHARACTER IN THE BUFFER
	MOVE AC1,DPHPOS(DAT)	; ARE WE AT THE LEFT MARGIN?
	ADD AC1,LNLNGT(DAT)
	JUMPN AC1,TYO2		; NO
	MOVE AC1,LSTCHR(DAT)	; YES, WAS LAST CHARACTER A LF?
	CAIN AC1,12
	JRST TYO2
	PUSH P,CHR		; NO, PUT ONE IN!
	MOVEI CHR,12
	PUSHJ P,PUTCH1
	PUSHJ P,EOLSET		; STORE LINE POINTER
	SOSG DELCNT(DAT)	; TIME TO GLITCH YET?
	PUSHJ P,PREOGL		; YES, DO IT.
	POP P,CHR
TYO2:
	CAIN CHR,11		; TAB?
	PUSHJ P,PR1TAB		; YES, GO EXPAND IT.
	PUSHJ P,PUTCH1		; PUT CHARACTER INTO BUFFER
TYO7:
	MOVEM CHR,LSTCHR(DAT)	; SAVE LAST CHARACTER
	CAIN	CHR,177		;IS THIS A DELETE?
	JUMPL	DAT,.+3		;YES. FOR DD AVOID CHANGING THE H.POSITION.
	AOSL DPHPOS(DAT)	;UPDATE HORIZONTAL POS.
	JRST PRCR		;OVER END OF LINE..  INSERT CR LF.
	MOVE AC1,[CW 0,0,3,2,3,2]
	SKIPGE DAT		; IF WE ARE A DD
	MOVEM AC1,TPJMP+1(DAT)	; AND THE LINE DOESN'T END WITH CRLF, PUT IN AN EXECUTE
	POPJ P,

; WE GET HERE IF THE LAST CHARACTER WAS A LF AND WE ARE AT THE LEFT MARGIN
TYO4:
	CAIE CHR,12		; IS THIS CHARACTER A LF?
	JRST TYO2		; NO, JUST DUMP THE CHARACTER IN THE BUFFER
	PUSHJ P,PR1EC2		; YES, PUT IN A SPACE, CR, AND A LF
	MOVEI CHR,12		; PICK UP A LF
	JRST PR1EOL

;PRINT SINGLE CHAR. FROM CHR., WITH NO SPEC. CHAR. CHECKING.
PUTCH1:
	SOSG CNT1(DAT)
	PUSHJ P,EXTBUF		;GO EXTEND BUFFER.
	IDPB CHR,PPTR1(DAT)
	POPJ P,

;DD. LAST CHARACTER WAS A DELETE. THIS CHARACTER WILL MAKE AN ORDINARY GRAPHIC.
DELNOW:
	PUSHJ P,PUTCH1		;PUT CHARACTER IN BUFFER
	IORI CHR,200		;MAKE IT SPECIAL SO WE WON'T COMPARE EQUAL TO IT
	JRST TYO7


;WE GET HERE TO PRINT SPACES FOR A TAB
PR1TAB:
 PUSHJ P,PUTCH1		;HANDLE A TAB. FIRST PRINT THE TAB.
	MOVEI CHR," "		;NOW OUTPOOT RIGHT NO. OF SPACES.
	SETCM AC1,DPHPOS(DAT)	;GET CURRENT POS. ON LINE..
	SUB AC1,LNLNGT(DAT)	; MAKE TABS START IN COLLUMN 8
	ANDI AC1,7		;GET NO. OF SPACES TO NEXT MULTIPLE OF 8 BOUNDARY.
	ADDM AC1,DPHPOS(DAT)	;UPDATE HIM.
PR1TB1:
	PUSH P,AC1		; SAVE OUR COUNT
	PUSHJ P,PUTCH1		;NOW EMIT A SPACE.
	POP P,AC1
	SOJGE AC1,PR1TB1	;..AND SOME MORE, IF APPROPRIATE.
	MOVEI CHR,11		;WE WILL FINISH OFF WITH ANOTHER TAB..
	POPJ P,

;STICK A CRLF IN TO BREAK UP LONG LINES
PRCR:
	MOVEI CHR,15		;PRINT A CR.
	PUSHJ P,PUTCH1
	MOVEI CHR,12		;NOW INVENT A LINE FEED.
	PUSHJ P,SETLL		; RESET DPHPOS
	PUSHJ	P,PR1EOL	;GO DO THE END-OF-LINE BIT
	SETOM	LSTCHR(DAT)	;FLAG THAT WE INVENTED CRLF HERE.
				;(DPYTYP WILL WAIT FOR LINE BEFORE SENDING MORE)
	POPJ	P,

PR1ECR:
	JUMPGE DAT,PR1EC1	; IS THIS A DD?
	SETZM TPJMP+1(DAT)	; IF SO, THE LINE WILL BE ACTIVATED, SO KILL THE EXECUTE
	MOVEI AC1,12		; WAS THE LAST CHARACTER A LF
	CAME AC1,LSTCHR(DAT)
	JRST PR1EC1
	MOVN AC3,DPHPOS(DAT)	; PICK UP THE HORIZONTAL POSITION
	CAMN AC3,LNLNGT(DAT)	; ARE WE AT THE BEGINNING OF THE LINE?
	JRST PR1EC2		; YES, NO NEED FOR ANY MORE CR'S
	SOS VPOS(DAT)
	DPB CHR,SPTR1(DAT)	; PUT THE CR IN OVER THE LF
	PUSHJ P,SETLL		; RESET DPHPOS
	MOVEI CHR,12
	PUSHJ P,PUTCH1		; STICK THE LF IN
	MOVEM CHR,LSTCHR(DAT)	; SAVE IT
	JRST EOLSET		; DO THE END-OF-LINE BIT

PR1EC1:
	MOVN AC3,DPHPOS(DAT)	; NOW (SIGH) SEE IF WE ARE AT THE LEFT MARGIN!
	CAMN AC3,LNLNGT(DAT)
	POPJ P,			; IF SO, FLUSH THIS CR
	PUSHJ P,SETLL		; RESET DPHPOS
PR1EC3:
	PUSHJ P,PUTCH1		; YES, DUMP ONE OF THEM
	MOVEM CHR,LSTCHR(DAT)
	POPJ P,

; WE GET HERE IF THE LAST CHARACTER WAS A LF AND WE ARE AT THE LEFT MARGIN
PR1EC2:
	MOVEI CHR,40		; PRINT A SPACE SO THE LINE WILL GET ERASED
	PUSHJ P,PUTCH1
	MOVEI CHR,15
	JRST PR1EC3

; HERE ON LF
PR1EOL:
	SKIPGE DAT		; IS THIS A DD?
	SETZM TPJMP+1(DAT)	; YES, NO NEED FOR AN EXECUTE AT THE END OF THE BUFFER.
PR1EO1:
	MOVEM CHR,LSTCHR(DAT)	; SAVE THIS CHARACTER
	PUSHJ P,PUTCH1		;HERE AT END OF LINE. PRINT LINE FEED.
	PUSHJ P,EOLSET		; YES, SET VERTICAL POSITION AND SAVE BYTE PTR
	SOSLE DELCNT(DAT)	;ARE WE AT THE TOP OF A GLITCH ?
	POPJ P,			;NO. GO BACK.
PREOGL:
	MOVE AC3,DEL(DAT)	;GET NO. OF LINES PER GLITCH..
	MOVEM AC3,DELCNT(DAT)	;.. AND INIT. THE COUNT.
	AOS AC1,GLCNT(DAT)	;UPDATE SIZE OF PAGE.
	CAMG AC1,PGSIZ(DAT)	;IS IT TOO BIG ?
	POPJ P,			; NOT YET.
	JRST GLITCH		; YES, MOVE IT UP SOME

;INITIALIZE LENGTH OF THE LINE AT CR.
SETLL:
	MOVN AC1,LNLNGT(DAT)	;GET -LINELENGTH.
	MOVEM AC1,DPHPOS(DAT)	;RESET HORIZONTAL POS.
	POPJ P,

BEGIN EXTBUF	;MAKE MORE ROOM IN THE DISPLAY BUFFER.

↑EXTBUF: EXCH AC1,PPTR1(DAT)	;GET BYTE POINTER.
L2:
	MOVN AC2,WCNT(DAT)	;HOW MANY WORDS LEFT IN THIS BLOCK ?
	JUMPE AC2,GBLK		;IF NONE, GET A NEW BLOCK.
	CAILE AC2,10		;IF FEWER THAN 8, USE THAT  NO.
	MOVEI AC2,10		;..ELSE USE 8 WORDS.
	ADDM AC2,WCNT(DAT)	;DECREMENT THE COUNT.
	MOVE AC3,AC2
	ASH AC3,2		;MULTIPLY BY 5 RAPIDLY.
	ADD AC3,AC2
	MOVEM AC3,CNT1(DAT)	;THAT'S THE NEW CHAR. COUNT, FOLKS.
	MOVE AC3,1(AC1)		;PICK UP THE JMP AT CURRENT END OF BUFFER..
	ADDI AC1,1(AC2)		;GET NEW POS. FOR IT...
	MOVEM AC3,(AC1)		;.. AND PUT IT THERE.
	MOVEI AC3,1		;MANUFACTURE A NULL CHAR. WORD...
L1:
	SUBI AC1,1		;AND FILL THE NEWLY AVAILABLE AREA OF THE
	MOVEM AC3,(AC1)		;BUFFER WITH IT.
	SOJG AC2,L1
	SUBI AC1,1
	TLZ	AC1,760000		;BUG FIX REG RPH 24 JUL 72
	EXCH AC1,PPTR1(DAT)	;RESTORE THINGS TO THEIR RIGHTFUL PLACES.
	POPJ P,

GBLK:
  ;;GET ANOTHER BLOCK FROM FREE STORAGE FOR PRGM.
	AOSLE BLKTOT(DDB)	;INC. HIS COUNT OF BLOCKS USED.
	PUSHJ P,FBLK		;OOPS, TOO MANY. FREE SOME.
	PUSHJ P,GETFS		;GET ANOTHER BLOCK FROM FREE STORAGE.
	HRR AC1,AC2		;MAKE THE BYTE PTR. POINT THERE.
	EXCH AC2,CBLKPT(DAT)	;UPDATE CURRENT BLK. PTR (AND GET OLD ONE).
	MOVEI AC3,CBLKBT	;GC BIT FOR `CURRENT PP BLOCK'...
	ANDCAM AC3,BLKBTS(AC2)	;..TURN IT OFF IN OLD BLOCK.
	MOVEM AC3,BLKBTS(AC1)	;.. AND PLACE IN NEW ONE.
	MOVE AC3,GCINFO(AC2)	;GIVE NEW BLK. SAME GC CODE AS
	MOVEM AC3,GCINFO(AC1)	; OLD ONE.
	MOVNI AC3,INITWC	;SET UP NO. OF FREE WORDS IN NEW BLOCK.
	MOVEM AC3,WCNT(DAT)
	MOVE AC3,INITWC(AC2)	;PICK UP RETURN JMP FROM END OF OLD BLK..
	MOVEM AC3,(AC1)		;.. AND PUT IN FIRST WORD OF NEW ONE.
	HRRM AC1,LINK(AC2)	;MAKE FORWARD LINK OF OLD ONE POINT AT NEW ONE.
	HRLM AC1,INITWC(AC2)	;MAKE JMP AT END OF OLD ONE POINT AT NEW ONE.
	HRLZM AC2,LINK(AC1)	;BACKWARD LINK OF NEW ONE TO OLD ONE...
	SOJA AC1,L2		;JIGGLE NEW BYTE PTR. A BIT AND PROCEDE.

BEND EXTBUF

; WE GET HERE UPON GLITCHING ON A DATA DISC DISPLAY
; IN THIS CASE, WE SEE IF THERE ARE ANY BLOCKS ABOVE THE
; CURRENT SCREEN. IF SO, WE CAN FREE THEM UP.

GLITCH:
	SOS GLHCNT(DDB)		; BUMP COUNT OF GLITCHES TO GO UNTIL HOLD
	MOVN AC3,DEL(DAT)	; MOVE POINTERS DOWN BY THIS AMOUNT
	SETOM GLTCH(DAT)	; MARK THE FACT THAT WE HAVE GLITCHED
	SETOM PPINV(DAT)	; NOTE THAT POINTERS ARE BEING CHANGED
	ADDM AC3,VPOS(DAT)	; UPDATE VERTICAL POSITION BY NUMBER OF LINES IN GLITCH
	PUSHJ P,PTMOVE		; MAGIC CIRCULAR ROUTINE
	SETZM PPINV(DAT)	; POINTERS ARE OK NOW
GLTCH3:
	PUSHJ P,POSLIN		; PICK UP LINE NUMBER OF TOP OF PAGE
	CAMLE AC3,VPOS(DAT)	; IS THERE ANYTHING ON THE SCREEN AT ALL?
	MOVE AC3,VPOS(DAT)	; NOT YET, USE LAST POSITION WRITTEN IN
	PUSHJ P,GLNADR		; GET ADDRESS OF TEXT
	HRRZ AC1,TBLKPT(DAT)	; PICK UP THE POINTER TO THE CURRENT FIRST PAGE
	HRRZI AC3,BLKSIZ-1(AC1)	; GET ADDRESS OF END OF THAT BLOCK
	CAIL AC2,(AC1)		; NOW, ARE WE INSIDE THAT FIRST BLOCK?
	CAILE AC2,(AC3)
	JRST GLTCH4		; NO, FREE UP SOME BLOCKS
	ADDI AC2,1		; MAKE POINTER TO TOP OF PAGE
	HRLM AC2,TPJMP(DAT)	; POINT JUMP TO THERE
PR1EL4:
	SOS AC1,GLCNT(DAT)	;IS IT SMALL ENOUGH NOW ?
ADJSIZ:
 CAMLE AC1,PGSIZ(DAT)
	JRST GLITCH		;NO. GLITCH IT SOME MORE.
	POPJ P,

CNTWRP:
 MOVEI AC3,CNT		;WRAP A POINTER AROUND THE GLITCH TABLE.
	MOVEM AC3,@-2(AC2)
	JRST (AC2)

GLTCH4:
	PUSHJ P,PR1FRE		; GO FREE UP AT LEAST ONE
	JRST GLTCH3		; SEE IF WE CAN DO SOME MORE

; THESE ARE UTILITY ROUTINES USED BY THE PAGE PRINTER
; THIS FIRST ROUTINE IS CALLED AT THE END OF THE LINE THAT
; GOES OFF THE SCREEN ON DATA DISK. WE REPACK THE WORD
; SUCH THAT THE POINTER POINTS TO THE NEXT WORD. THIS WAY
; THE I-LEVEL ROUTINES CAN REPLACE THE ENTIRE WORD WITH
; A JUMP INTO THE PAGE PRINTER CONTROL BLOCK TO KEEP IT
; FROM READING MORE TEXT WHICH WOULD BE OFF THE SCREEN.

EOLSET:
	MOVE AC1,PPTR1(DAT)	; PICK UP POINTER TO LF
	MOVEM AC1,SPTR1(DAT)	; SAVE IT
	SKIPGE DAT
	SETZM TPJMP+1(DAT)	; SINCE TEXT ENDS WITH A CRLF, NO EXECUTE IS NEEDED
	LDB AC1,[POINT 6,PPTR1(DAT),5]
	SUBI AC1,1		; ARE THERE ANY SPACES LEFT IN THE WORD?
	IDIVI AC1,7		; THIS GETS NUMBER OF CHARACTERS LEFT IN AC1
	JUMPE AC1,EOLSE3	; IF NONE LEFT, GO ON.
	PUSH P,AC1		; PUT IN THAT MANY NULLS
	SETZ CHR,
EOLSE2:
	PUSHJ P,PUTCH1		; FILL OUT WORD WITH NULLS.
	SOSLE (P)		; ENOUGH?
	JRST EOLSE2		; NO, GO DO ANOTHER ONE.
	SUB P,[XWD 1,1]
EOLSE3:
	MOVE AC3,VPOS(DAT)	; WE ARE NOW ON THE NEXT LINE. BUMP VERTICAL POSITION COUNTER.
	ADDI AC3,1		; DON'T BUMP IN CORE UNTIL WE HAVE POINTER PLANTED
	CAMLE AC3,GLW(DAT)	; IS THIS FURTHER DOWN THAN THE PRESENT MAXIMUM LINE WRITTEN?
	MOVEM AC3,GLW(DAT)	; YES, BUMP NUMBER OF MAXIMUM LINE WRITTEN
	PUSHJ P,GLNADR		; PICK UP POINTER INTO LINE TABLE
	MOVE AC2,PPTR1(DAT)	; NOW PICK UP THE POINTER
	MOVEM AC2,@PTRB(DAT)	; PUT IT INTO LINE POINTER TABLE INDEXED BY LINE NUMBER
	AOS VPOS(DAT)		; NOW UPDATE VERTICAL POSITION
	MOVEI CHR,12		; FAKE UP SOMETHING FOR ERRP (AGGG!)
	POPJ P,

; HANDY ROUTINE TO GET POINTER TO TEXT FROM LINE NUMBER IN AC3
; RETURNS POINTER IN AC1.

GLNADR:
	ADD AC3,PTBEG(DAT)	; ADD IN INCREMENT
GLNAD2:
	CAMGE AC3,[-=20]	; UNDERFLOW?
	JRST GLNAD1		; YES, BOOST IT
GLNAD4:
	CAIL AC3,=60		; OVERFLOW?
	JRST GLNAD3		; YES, BRING IT BACK INTO RANGE
	HRRZ AC2,PTRB(DAT)	; PICK UP POINTER
	SUBI AC2,=20
	CAME AC2,PTB(DAT)	; IS IT WHAT IT IS SUPPOSED TO BE?
	JRST GLNAD5		; NO, ERROR
GLNAD6:
	HRRZ AC2,@PTRB(DAT)	; PICK UP POINTER
	POPJ P,

GLNAD1:
	ADDI AC3,=80
	JRST GLNAD2

GLNAD3:
	SUBI AC3,=80
	JRST GLNAD4

; WE GET HERE IF THE POINTERS DON'T AGREE

GLNAD5:
	PUSHACS
	PUSHJ P,DISERR
	[ASCIZ ⊗SOMEBODY CLOBBERED PTRB!!  - ⊗]
	DISARG	OCT,<PTRB(DAT)>
	[ASCIZ ⊗
⊗]
	-1
	POPACS
	HRRZ AC2,PTB(DAT)	; PICK UP THE (HOPEFULLY) CORRECT POINTER
	CAML AC2,MEMSIZ
	CAML AC2,RMEMSIZ
	JRST GLNAD7
	ADDI AC2,=20
	HRLI AC2,AC3		; SET TO INDEX BY AC3
	MOVEM AC2,PTRB(DAT)
	JRST GLNAD6

GLNAD7:
	HRRZ AC2,PTRB(DAT)
	SUBI AC2,=20
	CAML AC2,MEMSIZ
	CAML AC2,RMEMSIZ
	JRST HELPX
	HRRZM AC2,PTB(DAT)
	JRST GLNAD6

HELPX:
	PUSHJ P,DISERR
	[ASCIZ ⊗HELP! - CAN'T FIX IT
⊗]
	-1
	SETOM DISFLAG
	PUSHJ P,DISFLUSH
	JRST AUTOLOAD

; ROUTINE TO CONVERT THE POSITION VECTOR INTO A DATA DISK
; LINE NUMBER. GOES FROM 1 TO 40.

POSLIN:
	LDB AC3,[POINT 11,PPOSV(DAT),21]
	TRNE AC3,1⊗=10		; EXTEND SIGN BIT
	OR AC3,[-1⊗=10]		; BY ORING IN BITS
	SKIPN PPDD(DAT)		; IS THIS A DATA DISC DISPLAY?
	JRST POSLI1		; NO, USE SEPARATE ROUTINE
POSLI2:
	IMULI AC3,=20
	ASH AC3,-=9		; THIS GIVES A NUMBER FROM -=19 TO =20
	MOVNS AC3		; FOR DD, ASCENDING LINE NUMBERS GO DOWN THE SCREEN
	ADDI AC3,=20		; WE NOW HAVE A NUMBER FROM 1 TO =40 IN AC3
	POPJ P,

POSLI1:
	IMULI AC3,=12		; III ONLY HAS 24 LINES ON THE SCREEN
	ASH AC3,-=9
	MOVNS AC3
	ADDI AC3,=12
	POPJ P,

FBLK:
	PUSH P,AC1		;FREE SOME BLOCKS FROM P.P.
FB1:
	MOVE AC1,GLCNT(DAT)
	SKIPLE BLKTOT(DDB)	;DID WE FREE ENOUGH BLOCKS ?
	CAIG AC1,1		;LESS THAN 1 GLITCH ON SCREEN ?
	JRST POPAJ		;YES. RESTORE AC1 AND RETURN.
	PUSHJ P,GLITCH		;MOVE PAPER ONE GLITCH.
	JRST FB1

PR1FRE:
 MOVE AC2,TBLKPT(DAT)	;WE HAVE FINISHED WITH ANOTHER BLOCK. GET PTR. TO IT.
	MOVEI AC1,TBLKBT	;CODE BIT FOR GC MEANING `TOP BLK OF PAGE'
	ANDCAM AC1,BLKBTS(AC2)	;TURN IT OFF IN OLD TOP BLK.
	HRRZ AC2,LINK(AC2)	;GET FORWARD PTR. (TO NEW TOP BLK.)
	CAML AC2,MEMSIZ
	CAML AC2,RMEMSIZ
	JRST PR1ERR		; GROSS ERROR!
PR1ER2:
	MOVEM AC2,TBLKPT(DAT)
	IORM AC1,BLKBTS(AC2)
	SOSG OUTCNT(DAT)	;HAVE WE ENOUGH UNUSED BLOCKS FOR A DISK OUTPUT ?
	PUSHJ P,PPOUT		;YES. GET RID OF THEM.
	POPJ P,

PR1ER3:
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/FIND A WIZARD OR RELOAD
/
	PUSHJ	P,DISFLU
	PUSHJ	P,DDTCALL
	POPACS
	HALT	AUTOLOAD

PR1ERR:
	HRRZ	AC3,PRGNUM(DDB)
	PUSHACS
	PUSH	P,AC3
	PUSH	P,AC2
	PUSHJ	P,DISMES
	ASCIZ	/BAD POINTER AT PR1FRE: /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/,  TTY = /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	POPACS
	MOVEI	AC1,=20*=40/INITWC
	MOVE	AC3,CBLKPT(DAT)
PR1ER1:
	MOVEI	AC2,(AC3)
	HLRZ	AC3,LINK(AC3)
	CAML	AC3,MEMSIZ
	CAML	AC3,RMEMSIZ
	JRST	PR1ER3
	CAME	AC3,TBLKPT(DAT)
	SOJG	AC1,PR1ER1
	JUMPLE	AC1,PR1ER3
	MOVE	AC3,TBLKPT(DAT)
	HRLM	AC2,LINK(AC3)
	MOVEI	AC1,TBLKBT
	JRST	PR1ER2

PPOUT:
  ;WE GET HERE WHEN IT IS TIME TO OUTPUT PART OF A PIECE OF PAPER TO THE DISK.
	MOVEI AC3,OUTNUM	;NO. OF BLOCKS TO PUT OUT.
	MOVEM AC3,OUTCNT(DAT)	;RESET IT.
	MOVE AC1,FBLKPT(DAT)	;POINTER TO  FIRST BLK IN CORE.
	SKIPA AC2,AC1
	HRRZ AC2,LINK(AC2)	;GO TO NEXT BLOCK.
	SOJG AC3,.-1		;GO TO LAST BLOCK TO BE OUTPUT.
;;SINCE CROCKISH R. SAUNDERS HAS NO DISK CODE YET, WE JUST RETURN THE BLOCKS TO FREE STORAGE.
	HRRZ AC3,LINK(AC2)	;NEXT BLK.
	HRRZM AC3,FBLKPT(DAT)	;MAKE FBLKPT POINT TO NEW FIRST BLOCK IN CORE.
	HRLM DAT,LINK(AC3)	;MAINTAIN REV LINK
	SETZM LINK(AC2)		;ZERO LINK IN LAST BLOCK TO BE FREED.
↑SETRST:PUSHJ P,FREEL		;FREE THE BLOCKS.
↑↑WHORST:
	SKIPN III(DDB)		;IS IT AN III?
	POPJ P,			;NO.
PPRST:
	HRRZ AC3,PRGNUM(DDB)	;GET PROGRAM NUMBER
	MOVEI AC2,PSELB(DDB)	;YES. INVENT A RESTARTING JMP FOR IT AND
	HRLI AC2,DISJMP		; PLACE IN RSTTBL SO PRGM WILL GET STARTED AT
	MOVSM AC2,RSTTBL(AC3)	;AT ITS BEGINNING NEXT TIME.
	POPJ P,

;A SIMPLE MESSAGE PRINTER. JSA ITEM,ERRP WITH
;BYTE PTR. TO TEXT FOLOWING THE JSA .

↑ERRP2:	HLRZ DAT,PPCALL(DDB)	;GET P OF P 0.
	HLL DAT,DDB		; COPY OVER THE DD FLAG IF ANY
	PUSHACS			; SAVE ALL OUR ARGUEMENTS
	MOVE J,JOB(PID)
	PUSHJ P,PPCLR		; RESET THE PAGE PRINTER
	MOVE J,-17+J(P)
	MOVE TAC,(ITEM)		;GET BYTE POINTER TO MESSAGE.
ERRP3:
	CONO PI,SCNOFF		;TURN OFF RPH
	PUSHJ P,TYOTAC		;TYPE A CHAR.
	CONO PI,SCNON		;TURN ON RPH
	JUMPN CHR,ERRP3		;LOOP UNTIL FIRST NULL CHAR.
	POPACS
	JRA ITEM,1(ITEM)

;;HERE ARE UUO LEVEL ROUTINES FOR MANIPULATING THE PAGE PRINTER.

;;THESE ROUTINES ARE ENTERED WITH STANDARD UUO LEVEL
;; SETUP OF AC'S UUO AND ITEM, WITH
;; DDB (≡DEVDAT) POINTING TO DPY PROGRAM HEADER.


;;PPFIND FINDS PIECE OF PAPER INDICATED BY (UUO); CREATES IT IF NECESSARY.
;; RETURNS WITH DAT POINTING TO P. OF P. CONTROL BLOCK.

PPFND1:
 HLL DAT,DDB		; PICK UP DD FLAG BIT
	HLRZ AC2,PPCALL(DDB)	;GET PTR. TO FIRST P. OF P.
	HRRZ TAC,UUO		;NO. OF PIECE WE ARE LOOKING FOR.
	CAIL TAC,20		;BETTER NOT BE TOO HIGH.
	JRST PPFER		;LOSE, LOSE.
PFL2:
	HRRM AC2,DAT		;LOOK AT NEXT P. OF PAPER.
	CAMN TAC,PPNO(DAT)	;IS IT THE ONE WE WANT ?
	POPJ P,			;YES.
	HRRZ AC2,LINK(DAT)	;GET LINK TO NEXT ONE.
	JUMPN AC2,PFL2		;LOOP IF THERE IS A NEXT ONE.
	POPJ P,

PPFND:
	PUSHJ P,PPFND1		;FIND INDICATED P OF P.
	JUMPN AC2,CPOPJ		;RETURN IF IT EXISTS.
	PUSH P,DAT		; SAVE POINTER TO LAST PROGRAM HEADER
	PUSH P,TAC		; SAVE NUMBER OF DESIRED PIECE OF PAPER
	HLRE TAC,PRGNUM(DDB)	; PICK UP DPY NUMBER FOR PPINIT
	PUSHJ P,PPINIT		;IT DOESN'T. MAKE A NEW PIECE APPEAR.
	JSP UUO,DWPERR		; NOT THERE, GHASTLY ERROR
	POP P,PPNO(AC1)		;MAKE IT HAVE RIGHT NO.
	POP P,DAT		; GET BACK POINTER TO LAST PIECE OF PAPER
	HRRM AC1,LINK(DAT)	;LINK IT TO OTHER PIECES.
	HRLZM DAT,LINK(AC1)	;PUT IN ITS BACKWARD LINK.
	HRRZM DDB,HEDPTR(AC1)	;GIVE IT PTR. TO PRGM. HEAD.
	MOVE AC3,PPRJMP(DAT)	;GET LINKING (I. E. RETURN) JMP FROM LAST P OF P...
	MOVEM AC3,PPRJMP(AC1)	;GIVE IT TO NEW PIECE...
	HRLM AC1,PPRJMP(DAT)	;.. AND MAKE LAST PIECE CALL NEW ONE.
	MOVEM AC1,DAT
	HLL DAT,DDB		; PUT IN TYPE BITS
	POPJ P,

PPFER:
	;PRINT H. S. MESSAGE.
	ERMS {ILLEGAL PIECE OF PAPER}
	JRST UUOERR		;NOW GIVE STANDARD JUNK AND STOP JOB.

;;MORE PP ROUTINES.


PPSEL1:
 PUSHJ P,PPFND		;LOCATE P. OF P. INDICATED BY UUO.
	HRRZM DAT,CURPP(DDB)	;MAKE IT THE CURRENT ONE.
	MOVEI UUO,400000	;PREPARE TO ACTIVATE IT,
	MOVN TAC,PPNO(DAT)	; BY GENERATING PARAM. FOR
	LSH UUO,(TAC)		;CALL ON PPACT.
	POPJ P,

PPREL:
	TRNN UUO,-1		;FLUSH PP WHOSE NUMBER IS IN UUO (RIGHT)
	POPJ P,			;BUT NOT IF IT'S PP ZERO
	PUSHJ P,PPFND1		;FIND P OF P
	JUMPE AC2,CPOPJ		;SAVE SOME TIME IF THERE IS NONE
	PUSH P,DDB
	PUSHJ P,PPWAIT		; WAIT FOR ANY TYPEOUT TO FINISH BEFORE FLUSHING PAGE
	POP P,DDB
	PUSHJ P,PPFND1		;NOW SEE IF P OF P IS STILL THERE
	JUMPE AC2,CPOPJ		;RETURN IF NOT.
	MOVE AC1,LINK(DAT)	;SIGH.  GET FWD AND BWD LINKS FROM CTRL. BLK.
	TRNE AC1,-1		;UNLESS CTRL. BLK IS LAST ONE,
	HLLM AC1,LINK(AC1)	;..UPDATE BWD LINK OF NEXT ONE.
	MOVSS AC1
	HLRM AC1,LINK(AC1)	;NOW FWD LINK OF PREVIOUS ONE (AREN'T LINKED LISTS FUN ?)
	MOVE AC3,PPRJMP(DAT)	;TAKE LINKING JMP FROM THIS BLK...
	MOVEM AC3,PPRJMP(AC1)	;..AND GIVE IT TO PREVIOUS ONE.
	JUMPG DAT,PPREL3	; DON'T ERASE IF III, WILL BE DONE AUTOMATICALLY
	PUSHJ P,POSLIN		; GET FIRST LINE NUMBER OF PAGE
	PUSH P,AC3
	PUSH P,GLW(DAT)		; ERASE ALL THE WAY TO THE LAST LINE
	SOS (P)
	PUSHJ P,PPERS
	SUB P,[XWD 2,2]		; NORMALIZE THE STACK
PPREL3:
	MOVEM	DDB,LINK(DAT)	;SINCE WE ARE LINKED OUT, WE CAN USE THIS TO
				;SAVE DDB IN CASE OF A CLOCK CALL LATER
PPREL4:
	MOVE	DDB,LINK(DAT)	;MAKE SURE DDB IS SET UP
	SKIPN	PPENQ(DAT)	;ANYTHING HAPPENING HERE?
	SKIPE	PPNQT(DAT)
	JRST	CLKREL		;YES, DON'T RELEASE IT UNTIL IT IS DONE
	MOVE	AC1,DAT		;NOW FREE THE CTRL BLK.
	PUSHJ	P,CGIVFS
	MOVE	AC1,FBLKPT(DAT)	;ALSO FREE THE PROGRAM BLOCKS.
	PUSHJ	P,FREEL
	HRRZ	AC1,PTB(DAT)	;GIVE BACK TABLE OF END OF LINE POINTERS
	PUSHJ	P,FSGIVE
PPREL2:
	HRRZ AC1,DAT
	CAME AC1,CURPP(DDB)	;HAVE WE JUST DELETED SELECTED P OF P ?
				;USED TO BE CAMN DCS/RPH
	POPJ P,
	MOVEI UUO,0		;YES. SELECT PP 0.
	JRST PPSELN

CLKREL:
	HRLI	DAT,PPREL4
	JRST	DPYTIM

;;PPSEL <N>  MAKES P. OF P. <N> THE CURRENT ONE AND TURNS IT ON.

PPSEL:
	PUSHJ P,PPWAIT		; WAIT FOR TYPEOUT TO FINISH
	PUSHJ P,PRGFND
	POPJ P,			; NO DPY HERE, JUST IGNORE
PPSELN:
	PUSHJ P,PPSEL1		;FIND IT, SELECT IT AND FALL INTO PPACT.

;;PPACT X TURNS P OF P'S ON AND OFF ACCORDING TO BITS IN X;
;;  BIT N+18 CORRESPONDS TO P. OF P. N.

PPACT:
	MOVEI AC1,DISJMP	;JMP OPCODE FOR DPY.
	MOVEI AC2,DISNOP
	HLRZ AC3,PPCALL(DDB)	;GET FIRST P OF P.
PACTL1:
	MOVE TAC,UUO		;MAKE COPY OF THE X BITS.
	ROT TAC,@PPNO(AC3)	;GET BIT FOR THIS P OF P INTO 18.
	HRRM AC2,TPJMP(AC3)	;ASSUME BIT IS OFF.
	TRNE TAC,400000		;IS IT ?
	HRRM AC1,TPJMP(AC3)	;NO. ACTIVATE THE P OF P.
	MOVE TAC1,PRGACT(DDB)	; PICK UP CURRENT ACTIVATION BITS
	ROT TAC1,@PPNO(AC3)	; PUT BIT FOR THIS DISPLAY IN B18
	XOR TAC1,TAC		; ARE THEY DIFFERENT?
	TRNE TAC1,400000
	JRST PACTL2		; YES, MARK IT AS VIRGIN IF APPEARING, ERASE IF DISSAPEARING
PACTL3:
	HRRZ AC3,LINK(AC3)	;GET NEXT P OF P HEADER.
	JUMPN AC3,PACTL1	;LOOP IF THERE IS ONE.
	HRRM UUO,PRGACT(DDB)	;ALL DONE. RECORD NEW STATE OF ACTIVATION.
	POPJ P,

PACTL2:
	TRNN TAC,400000		; NOW, ARE WE APPEARING OR DISSAPEARING?
	JRST PACTL4		; DISSAPEARING, GO ERASE SCREEN
	SETOM PPVIRG(AC3)	; APPEARING, NOTE A VIRGIN SCREEN
	JRST PACTL3

PACTL4:
	SKIPE PPVIRG(AC3)	; IS THERE ANYTHING THERE?
	JRST PACTL3		; NO, NOTHING TO ERASE
	PUSH P,DAT		; SAVE PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVE DAT,AC3		; MAKE US THE ONE
	PUSHJ P,POSLIN		; GET BOUNDS OF PAGE IN LINE NUMBERS
	PUSH P,AC3		; THAT IS FIRST LINE
	PUSH P,GLW(DAT)		; CURRENT LINE IS LAST LINE
	SOS (P)
	PUSHJ P,PPERS		; CAUSE ERASURE TO HAPPEN
	SUB P,[XWD 2,2]
	MOVE AC3,DAT		; PUT PAGE PRINTER CONTROL BLOCK ADDRESS BACK
	POP P,DAT
	MOVEI AC1,DISJMP
	MOVEI AC2,DISNOP
	JRST PACTL3

; ROUTINE TO WAIT FOR TYPEOUT TO FINISH

PPWAIT:
	CONSZ PI,77400		; CAN'T DO THIS AT INTERRUPT LEVEL
	POPJ P,
	MOVE ITEM,JOB
	MOVE DDB,JBTLIN(ITEM)	;FIND GUY'S TTY.
	CAME DDB,[-1]		; IS HE DETATCHED?
	SKIPN DDB,TTYTAB(DDB)	; GET TTY DDB, DOES HE EXIST?
	POPJ P,			; HMM. WELL, BE THAT WAY!
	MOVE TAC,DEVIOS(DDB)
	TLNN TAC,TOIP
	POPJ P,
	PUSHJ P,DDTWAT		; WAIT FOR THE TYPEOUT TO TERMINATE
	MOVE ITEM,JOB(PID)
	POPJ P,

;;PPYPOS Y MAKES THE CURRENT P OF P START AT Y COORD. Y.

PPYPOS:
 SETZ AC1,
	DPB AC1,POSSBU		; NOTE Y-POSITION SE BY UUO
	PUSHJ P,POSLIN		; GET LINE NUMBER OF CURRENT LINE
	PUSH P,AC3		; AND PUSH IT
	PUSH P,GLW(DAT)		; SAVE BOTTOM OF PAGE
PPYPO1:
	SETOM PPINV(DAT)	; NOTE POINTERS ARE BEING CHANGED
	DPB UUO,[POINT 11,PPOSV(DAT),21]	;PUT NEW Y COORD. INTO POSITION VECTOR
	PUSHJ P,POSLIN		; NOW PICK UP POSITION COLUMN
	MOVE AC1,AC3
	MOVE AC2,AC3
	MOVN AC3,-1(P)
	ADD AC3,AC1		; UPDATE VERTICLE POSITION
	JUMPE AC3,PPYPO3	; IF NO DIFFERENCE, WE DON'T HAVE TO MOVE LINE POINTER TABLE
	MOVEM AC2,LLW(DAT)	; MAKE SURE WE START AT THE LOGICAL TOP OF PAGE
	PUSHJ P,PTMOVE		; MOVE POINTERS
	ADDM AC3,VPOS(DAT)
	SETZM PPINV(DAT)	; NOTE POINTERS ARE VALID NOW
	JUMPGE DAT,PPYPO3	; IF III, LEAVE NOW
	JUMPN AC3,PPYPO2	; IF WE ARE MOVING DOWN, WE HAVE TO ERASE EXPLICITLY
PPYPO4:
	SUB P,[XWD 2,2]		; OTHERWISE, WE CAN PRETEND WE ARE GLITCHING AND
REFPAG:
	JUMPGE DAT,CPOPJ	; LEAVE IF III
	PUSH P,DAT		; SAVE THE POINTER TO THE PAGE PRINTER CONTROL BLOCK
	HRRZ DAT,HEDPTR(DAT)	; PUT DPY PROGRAM HEADER ADDRESS IN DAT
	PUSHJ P,LERFP		; GET IT DONE AUTOMATICALLY.
	POP P,DAT		; GET BACK OUR PAGE PRINTER CONTROL BLOCK ADD
	POPJ P,

PPYPO3:
	SUB P,[XWD 2,2]		; RESTORE THE STACK
	SETZM PPINV(DAT)	; POINTERS ARE OK NOW
	POPJ P,

; WE GET HERE WHEN THE APPEARANCE OF THE PAGE HAS CHANGED ENOUGH
; SO THAT THE PAGE HAS TO BE REFRESHED.

PPYPO2:
	ADDM AC3,GLW(DAT)	; UPDATE THE NUMBER OF THE LAST LINE WRITTEN
	HRRZ AC1,TPJMP(DAT)	; PICK UP JUMP TO TEXT
	SKIPN PPVIRG(DAT)	; DON'T ERASE A VIRGIN SCREEN!
	CAIN AC1,DISNOP		; IS IT REALLY A JUMP?
	JRST PPYPO4		; NO, DON'T WRITE ON IT
	MOVE AC2,(P)		; PICK UP FINISHING LINE OF TRANSFER
	SUB AC2,-1(P)		; GET LENGTH OF PAGE
	MOVM AC1,AC3		; GET MAGNITUDE OF TRAVEL
	CAML AC1,AC2
	JRST PPYPO5		; IF TRAVEL LARGER THAN PAGE, ERASE ENTIRE PAGE
	SUB AC2,AC1		; OTHERWISE, ERASE ONLY NON-OVERLAPPED PART
	MOVN AC1,AC2
	SKIPG AC3		; IF GOING UP,
	JRST PPYPDN		; THEN ERASE FROM THE MIDDLE DOWN TO THE BOTTOM
	ADDM AC1,(P)
	SOS (P)
PPYPO5:
	PUSHJ P,PPERS
	JRST PPYPO4

PPYPDN:
	ADDM AC2,-1(P)
	JRST PPYPO5

; ROUTINE TO ERASE PARTS OF DATA DISK SCREEN
; CALL WITH STARTING LINE OF ERASURE AT -2(P)
; ENDING LINE AT -1(P)

PPERS:
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ANOTHER ONE
	POP P,TAC		; GET BACK THE ADDRESS OF THE FIRST ONE
	MOVE AC2,-2(P)		; PICK UP STARTING LINE OF TRANSFER
	MOVE AC3,-1(P)		; AND ENDING LINE OF TRANSFER
	CAMGE AC3,AC2		; IF THE FINISHING LINE IS ABOVE THE STARTING LINE . . .
	MOVE AC3,AC2		; THEN ONLY ERASE ONE LINE
	HRLM AC2,QLINE(AC1)	; MAKE THIS THE STARTING LINE NUMBER OF THE ERASURE
	HRLM AC2,QLINE(TAC)
	HRRM AC3,QLINE(AC1)
	HRRM AC3,QLINE(TAC)
	HRLM DAT,(AC1)		; PUT IN PAGE PRINTER CONTROL BLOCK ADDRESS
	HRLM DAT,(TAC)
	MOVEI AC2,ERASE		; CALL THE ERASE CODE
	HRRM AC2,(AC1)
	HRRM AC2,(TAC)
	SETZM QFIELD(TAC)	; MAKE THE FIRST TASK GO OUT ON THE FIRST FIELD
	SETOM QFIELD(AC1)	; AND THE SECOND TASK GO OUT ON THE SECOND FIELD
	SETZM QCOUNT(TAC)	; NOTE THAT WE DON'T CARE TO BE AWAKENED
	SETZM QCOUNT(AC1)
	PUSH P,TAC		; SAVE THE ADDRESS OF ONE OF THE BLOCKS
	PUSHJ P,QBLOCK		; QUEUE THE BLOCK
	POP P,AC1		; GET BACK THE ADDRESS OF THE OTHER
	JRST QBLOCK		; QUEUE IT UP TOO

; HERE IS A ROUTINE TO MOVE THE LINE POINTER TABLE AROUND
; IN A CIRCULAR FASHION, SO AS NOT TO LOSE ANY POINTERS.
; CALL WITH NUMBER OF LINES TO BE MOVED IN AC3. NEGATIVE
; MEANS SCREEN IS MOVING UP, POSITIVE MEANS IT IS MOVING DOWN.
; NUMBER IS ASSUMED TO BE -=79 TO =79

PTMOVE:
	PUSH P,AC3		; SAVE COUNT
	MOVNS AC3
	ADD AC3,PTBEG(DAT)	; ADD IN TO CURRENT INCREMENT
PTMOV2:
	CAIL AC3,=80		; IS THE INCREMENT OUT OF RANGE?
	JRST PTMOV1		; YES, BRING IT BACK IN
PTMOV4:
	SKIPGE AC3		; SAME FOR NEGATIVE
	JRST PTMOV3
	MOVEM AC3,PTBEG(DAT)
	POP P,AC3
	POPJ P,

PTMOV1:
	SUBI AC3,=80
	JRST PTMOV2

PTMOV3:
	ADDI AC3,=80
	JRST PTMOV4

;;PPXSIZ <N>B26 ! <M>  SETS CURRENT P OF P TO HAVE N GLITCHES OF M LINES.

PPXSIZ:
 
	SETZ AC1,
	DPB AC1,SIZSBU		; NOTE THAT PAGE SIZE SET BY UUO
	MOVE AC1,GLCNT(DAT)	; PICK UP NUMBER OF GLITCHES SO FAR ON THIS PAGE
	IMUL AC1,DEL(DAT)	; MULTIPLY BY NUMBER OF LINES IN PER GLITCH
	SUB AC1,DELCNT(DAT)	; ADD IN NUMBER OF LINES SO FAR IN LAST GLITCH
	PUSH P,AC1		; AND SAVE THIS
	LDB AC1,[POINT 9,UUO,26]	;NO. OF GLITCHES REQUESTED.
	LDB AC2,[POINT 9,UUO,35]	;NO. OF LINES/GLITCH.
	IMUL AC2,AC1		;TOTAL SIZE OF REQUESTED PAGE, IN LINES.
	CAIG AC2,1		; MUST END UP 2 OR MORE LINES LONG
	JRST PPX1
	MOVEI AC3,=40		; DATA DISK TAKES 40 LINES
	CAIG AC2,(AC3)		;MORE THAN 25 LINES ?
	CAILE AC1,CNT		;TOO MANY GLITCHES ?
	JRST PPXERR		;YES. LOSE.
PPX2:
	MOVEM AC1,PGSIZ(DAT)	;UPDATE GLITCHES/PAGE.
	DPB UUO,[POINT 9,DEL(DAT),35]	;UPDATE GLITCH SIZE.
	POP P,AC1		; GET NUMBER OF LINES ON PAGE
	IDIV AC1,DEL(DAT)	; SEE HOW MANY NEW GLITCHES THAT MAKES
	MOVEM AC1,GLCNT(DAT)	; THIS IS OUR NEW GLITCH COUNT
	AOS GLCNT(DAT)		; MAKE IT GO FROM 1 TO PGSIZ
	SUB AC2,DEL(DAT)	; MAKE INTO NUMBER OF LINES TO GO
	MOVNM AC2,DELCNT(DAT)	; SET NUMBER OF LINES TO GO IN CURRENT GLITCH
	MOVE AC1,GLCNT(DAT)	; PICK UP NUMBER OF GLITCHES ON THIS PAGE
	PUSHJ P,ADJSIZ		;.. AND GO ADJUST TO NEW SIZE.
	JRST REFPAG		; REFRESH NEW PAGE

PPXERR:
	CONSZ PI,77400
	JRST POPAJ
	ERMS {ILLEGAL PAGE SIZE SPEC.}
	JRST UUOERR

PPX1:
	MOVEI UUO,2		; GIVE HIM A MINIMUM SIZE PAGE
	MOVEI AC1,1
	JRST PPX2

;;CLKSER	;THIS IS DPYSER'S OWN PRIVATE CLOCK QUEUER.

↑DPYCLK:  ;HERE FROM CLKSER EVERY TICK.
	HGMAC(35)
	SKIPE AC1,FSWTHD	;ANYTHING IN THE FREE STG. WAIT LIST ?
	PUSHJ P,FREE		;YES. GO PUT IT ON FREE STG. LIST.
	CONO PI,PIOFF		;...PEOPLE MAY USE FSWT2H AT INT. LEVEL...
	MOVE AC1,FSWT2H		;MOVE THINGS UP FROM THE SECOND-LEVEL WAIT LIST.
	MOVEM AC1,FSWTHD
	SETZM FSWT2H
	CONO PI,PION
	MOVE AC1,FSW2C
	MOVEM AC1,FSWC
	SETZM FSW2C
	HGMAC(36)
	SKIPLE WHOPTR		; IF NEW WHO JUST UPDATED, SEND IT OUT NOW
	PUSHJ P,WHOQUE		; YES, QUEUE UP A REQUEST
	HGMAC(37)
	EXCH P,DPYPDL		;YES. GET OUR OWN PDL.
	SETOM CLKLVL		;FLAG THAT WE ARE AT CLOCK LEVEL.
	AOSN WTFLG		;ARE WE IN A WAIT ?
	POPJ P,			;YES. RETURN TO THE WAITING ROUTINE.
	SKIPN @CLKQ		;ANY REQUESTS IN THE CLK QUEUE ?
	JRST CLKRTN		;NO. SEE HOW LITTLE TIME WE HAVE WASTED !!
	HRRZ TAC,CLKQ		;GET PTR. TO CURRENT END OF QUEUE.
	MOVEM TAC,CLKQTMP	;SAVE IT.
CLKL1:
	CONO PI,PIOFF		;NO INTERRUPTS, PLEASE.
	MOVE DAT,@CLKQ		;GET LAST REQUEST FROM QUEUE.
	SOS CLKQ		;MOVE POINTER BACK BY 1.
	EXCH DAT,(TAC)		;PICK UP THE REQUEST WE ARE SERVICING..
	CONO PI,PION		;(DIDN'T SEE A THING, DID YOU ?)
	HLRZ TAC,DAT
	PUSHJ P,(TAC)		;..AND SERVICE IT, ALREADY.
	HGMAC(37)		;IN CASE SERVICE ROUTINE CHANGED HGCODE
	SOS TAC,CLKQTMP		;NOW GET PTR. TO NEXT LOWER ONE..
	CAIL TAC,CLKQUE		;ARE WE AT BOTTOM OF QUEUE ?
	JRST CLKL1		;NO. BACK FOR MORE.
CLKRTN:
 EXCH P,DPYPDL		;PUT BACK THE RIGHT PDL.
	SETZM CLKLVL		;NO LONGER IN CLOCK LEVEL CODE.
	POPJ P,

; THIS ROUTINE QUEUES UP ANOTHER WHO LINE REQUEST.
; ONLY ONE LINE IS QUEUED UP EVERY 12. TIX OR SO.
; CALLED FROM DPYCLK WHEN WHOPTR>0

WHOQUE:
	MOVNI	AC3,2
	EXCH	AC3,WHOPTR	;PICK UP NUMBER OF WHO LINE JUST UPDATED
				;SET WHOPTR TO -2 TO AVOID RE-ENTERING HERE.
				;WHOWRT WILL AOS WHOPTR FOR EACH FIELD DONE.
				;WHOPTR=0 ALLOWS WHOSER TO MAKE A NEW WHO LINE
	MOVEI DAT,0
	CAIN	AC3,DDAVLU	; AVLCHN FLAG
	JRST	WHOQ2
	SKIPE	DAT,FRETAB(AC3)	; PICK UP ADDRESS OF WHO DATA
	SKIPN	AC2,LETAB(AC3)	; PICK UP ADDRESS OF DPY PROGRAM HEADER
	JRST	WHOQ1		; LEAVE IF NONE THERE
	MOVE	AC2,CURPP(AC2)	; GET ADDRESS OF PAGE PRINTER CONTROL BLOCK
	MOVE	AC2,DDCW(AC2)	; PICK UP COMMAND WORD
	SKIPN	DAT,FRETAB(AC3)	; PICK UP ADDRESS OF WHO LINE
	JRST	WHOQ1		; LEAVE IF NONE THERE
	MOVEM	AC2,(DAT)	; PLACE IT IN THE WHO CODE
WHOQ2:
	PUSHJ	P,GETQ
	MOVEM	AC3,QHPOS(AC1)	; SAVE THE DPY NUMBER HERE
	HRLI	DAT,WHOWRT
	MOVSM	DAT,(AC1)
	SETZM	QFIELD(AC1)	;ON FIELD ZERO
	MOVE	AC2,[XWD 1,2]	;ON TOP TWO LINES
	CAIN	AC3,DDAVLU
	MOVE	AC2,AVLLN
	MOVEM	AC2,QLINE(AC1)
	SETZM	QCOUNT(AC1)
	PUSH	P,AC3		;SAVE THE DPY NUMBER
	PUSHJ	P,QBLOCK	;QUEUE UP THIS FIELD'S WORTH.
	PUSHJ	P,GETQ
	POP	P,QHPOS(AC1)	;STORE THE DPY NUMBER
	MOVSM	DAT,(AC1)
	SETOM	QFIELD(AC1)	;FIELD 1
	MOVE	AC2,[XWD 1,2]
	CAIN	AC3,DDAVLU
	MOVE	AC2,AVLLN
	MOVEM	AC2,QLINE(AC1)
	SETZM	QCOUNT(AC1)
	JRST	QBLOCK

WHOQ1:
	SETZM	WHOPTR		;HERE TO FLUSH THE WHO LINE REQUEST
	POPJ	P,		;WHOPTR MUST BE CLEARED.

; ROUTINE TO FREE AN ENTIRE LIST OF BLOCKS, LINKED UP THROUGH LINK
; ENTER WITH TOP OF LIST IN TAC

FREE:
	JUMPE AC1,CPOPJ
	CAML AC1,MEMSIZ
	CAML AC1,RMEMSIZ
	POPJ P,
	HRRZ TAC,LINK(AC1)	;GET LINK BEFORE GIVING BACK FREE STORAGE
	PUSHJ P,SFSGIV
	DPYFS
	MOVE AC1,TAC		;LOOP FOR NEXT BLOCK
	JRST FREE

GETFS:
	PUSH P,AC1
	PUSHJ P,UGETFS		;GET A BLOCK OF FREE STG. (IN AC2).
	MOVE AC2,AC1
POPAJ:
	POP P,AC1
	POPJ P,

CLKWAT:
	CONSZ PI,77000
	JRST ARRRGH
	MOVEM 17,SVAC+17
	MOVEI 17,SVAC		;SAVE ALL AC'S.
	BLT 17,SVAC+16
	SETOM WTFLG		;SET WAIT FLAG FOR CLK SERVICE.
	PUSHJ P,CLKRTN		;GO AWAY FOR A TICK.
	MOVSI 17,SVAC		;RESTORE THEM.
	BLT 17,17
	POPJ P,

ARRRGH:
	PUSHACS
	PUSHJ P,DISDAT
	PUSHJ P,DISMES
	ASCIZ /AT CLKWAT IN CH5!!!!!
/
	PUSHJ P,DISFLU
	SKIPN DEBMOD
	JRST AUTOLO
	POPACS
	PUSHJ P,DDTCAL
	JRST .-1	;BETTER NOT RETURN WITH POPJ

;;UUO LEVEL UTILITY ROUTINES AND DISPATCHERS.

;;PRGFND  FINDS DPY PRGM FOR JOB IN ITEM.

PRGF2:
	MOVE DDB,PTYJOB-PTYL0(DDB)	;GET JOB WHICH OWNS PTY.
	SKIPA DDB,JBTLIN(DDB)		;USE HIS DPY, IF ANY.
PRGF1:
	MOVE DDB,JBTLIN(ITEM)		;GET `TTY' LINE NO. FOR JOB., IF ANY.
	TLNE DDB,PTYLIN			;IS GUY CONNECTED TO A PTY ?
	JUMPG DDB,PRGF2			;YES, UNLESS HE IS DETACHED.
	HRRZ AC1,DDB
	AOJE DDB,CPOPJ1			;IF DETACHED (=-1) OR NOT A DPY (BIT 0 OFF), GIVE ERROR RETURN.
	TLNN DDB,DISLIN!DDDLIN		; IS THIS A DPY OF SOME SORT?
	JRST CPOPJ1			; NO, ERROR
	HRRZ DDB,LETAB-DPYL0-1(DDB)	;GET PTR. TO PRGM HEADER.
PRGF3:
	HRRZ AC1,PRGNUM(DDB)		; PICK UP DPY NUMBER
	CAIL AC1,DPYNUM			; IS IT A DATA DISK DISPLAY?
	TLO DDB,400000			; YES, MARK IT WITH THE SIGN BIT
	POPJ P,

PRGFND:
	SKIPN DDB,DPYMAP(ITEM)	;IS GUY CONNECTED TO SOMEONE ELSE'S DPY ?
	PUSHJ P,PRGF1		;NO. FIND ONE OF HIS OWN.
	JRST CPOPJ1		;SUCCESS RETURN
PRGFER:
	CONSO PI,77400		; WHAT LEVEL ARE WE?
	POPJ P,			; IF AT UUO LEVEL, ERROR RETURN
	CONSZ PI,400		; IS IT CH7?
	SKIPN SPWUUF(PID)	; YES, ARE WE IN SPW MODE?
	JRST PRGFE1		; NO TO EITHER, GIVE ERROR MESSAGE
	POPJ P,			; YES, SAME AS UUO LEVEL

PRGFE1:
	PUSHJ P,DISERR		; OTHERWISE, ORDER-1 DISASTER
	[ASCIZ ⊗ILLEGAL JOB NUMBER AT PRGFND NOT AT UUO LEVEL
⊗]
	-1
	JRST DPYATL

DDFND:
	PUSHJ P,PRGFND		; USE PRGFND
	CAIA
	JRST CPOPJ1
	CAIE UCHN,3		; DDFND CALLED ONLY FROM PGIOT WITH UCHN SETUP
	POPJ P,			; ONLY THE DD UUO IS LEGAL
	MOVEI AC3,DPYLEN
	PUSHJ P,UFSGET
	MOVE DDB,AC1
	SETOM DPRLSF(DDB)
	SETOM PRGNUM(DDB)
	SETZM PRGCNT(DDB)	; CAN'T BE ANY OVERLAP IN PROGRESS - RPH 10-5-72
	TLO DDB,400000
	JRST CPOPJ1		; SUCCESS

;;MORE GENERAL UUO ROUTINES.

↑PPIOT:	PUSHJ P,PRGFND		;FIND APPROPRIATE DPY PRGM.
	POPJ P,			;IGNORE IF NOT DISPLAY
	MOVE DAT,CURPP(DDB)	;GET PTR. TO CURRENT P OF P.
	HLL DAT,DDB		; PUT IN FLAG BIT
	CAIG UCHN,MPPIOT	;DOES FUNCTION EXIST ?
	JRST @PPIOTX(UCHN)	;YES.
	JRST UUOERR

DEFINE UUOS{FOR X IN(PPSEL,PPACT,<DPYPOS,,PPYPOS>,<DPYSIZ,,PPXSIZ>,PPREL,PPINFO,LEYPOS,PPHLD)}
; UUOMAC PPIOTX,PPIOT
PPIOTX:
0+PPSEL
0+PPACT
0+PPYPOS
0+PPXSIZ
0+PPREL
0+PPINFO
0+LEYPOS
0+PPHLD
UUOCNT←←.-PPIOTX
PPIOT UUOCNT-1,UUOLNK
↑↑UUOLNK←←.
SIXBIT/PPSEL/
SIXBIT/PPACT/
SIXBIT/DPYPOS/
SIXBIT/DPYSIZ/
SIXBIT/PPREL/
SIXBIT/PPINFO/
SIXBIT/LEYPOS/
SIXBIT/PPHLD/
MPPIOT←←UUOCNT-1

; ROUTINE TO RESET A DISPLAY. CLEARS PAGE PRINTER AND PIECES OF GLASS.
ORG DPYCLR;;adjustment
↑DPYCLR:JUMPN UCHN,DPYFOO	;NON-ZERO AC FIELD MEANS SELECT OTHER DPY.
↑DPYRST:SETZM DPYMAP(ITEM)
	PUSHJ P,PRGF1		;FIND DPY PRGM FOR JOB IN ITEM.
	SKIPA			;FOUND. WE WILL RESET IT TO INITIAL STATE.
	POPJ P,			;NO PRGM.
	PUSHJ P,PGCLR		;FIRST FLUSH ALL PIECES OF GLASS.
↑PPCLR:	MOVEI UUO,17		;NOW ALL PIECES OF PAPER EXCEPT 0.

; PPREL SELECTS P OF P 0 (UUO←0) IF IT RELEASES A P OF P
;   WHICH IS CURRENTLY SELECTED, AND NOT 0, SO.....
	PUSH P,UUO		;PPREL MAY CLOBBER UUO.
PPC1:
	PUSHJ P,PPREL		;RELEASE P OF P.
	SOSE UUO,(P)		;NEXT
	JRST PPC1		;YES
	SUB P,[XWD 1,1]		;ADJUST STACK
				;ALL THIS TO HELP DCS. 5/27/70
	HLL DAT,DDB		; PUT IN FLAG BIT FOR DD
	PUSH P,DDB		; SAVE PROGRAM HEADER ADDRESS
	PUSHJ P,PPSEL		;SELECT P OF P 0.
PPC2:
	MOVE DDB,(P)		; PICK UP PROGRAM HEADER
	SETZ UUO,		; CLEAR LINE EDITOR POSITION
	PUSHJ P,LEYPOS
	SETZ UUO,
	PUSHJ P,PPHLD		; RESET HOLDING STATUS
	MOVEI UUO,YPIII		;MAKE P OF P 0 START AT TOP OF SCREEN
	SKIPGE DDB,(P)		; PICK UP PROGRAM HEADER ADDRESS, SKIP IF NOT DATA DISC
	MOVEI UUO,YPDD		; DATA DISK STARTS ON THE THIRD LINE
	PUSHJ P,PPYPOS
	MOVEI UUO,NGSIII*1000+NLSIII		;MAKE IT RIGHT SIZE.
	POP P,DDB
	JUMPGE DDB,PPXSIZ
	MOVEI UUO,NGSDD*1000+NLSDD
	PUSHJ P,PPXSIZ
	HRRZ TAC,PRGNUM(DDB)
	SUBI TAC,DPYNUM
	PUSHJ P,VDRST1
	JRST VDOUT

; CALLED FROM <ESC>N IN LINE EDITOR BY A CLOCK REQUEST

↑PPNSET:
	PUSHJ P,SETPHD		; SET UP DDB AND DAT PROPERLY
	PUSH P,[PPNST1]
	PUSH P,DDB
	JRST PPC2

PPNST1:
	SETO AC1,		; MARK SIZE AND Y-POSITION SET BY USER
	DPB AC1,SIZSBU
	DPB AC1,POSSBU
	POPJ P,

SETPHD:
	HRRZ DDB,DAT		; PUT PROGRAM HEADER ADDRESS IN DDB
	SKIPN III(DDB)		; SEE IF WE ARE A DATA DISK DISPLAY
	TLO DDB,400000		; IF SO, SET DATA DISK FLAG
	MOVE DAT,CURPP(DDB)
	HLL DAT,DDB
	POPJ P,

; CALLED FROM <ESC>G IN LINE EDITOR. SETS NUMBER OF GLITCHES

↑PPGSET:
	PUSHJ P,SETPHD
	MOVEI AC3,NGSIII
	SKIPG DAT
	MOVEI AC3,NGSDD
	SKIPN UUO,LEARG(DDB)	; PICK UP NUMBER OF GLITCHES REQUESTED
	MOVE UUO,AC3
	LSH UUO,=9		; PUT IN LH OF RH
	ADD UUO,DEL(DAT)
PPGST1:
	PUSHJ P,PPXSIZ		; SET IT
	SETO AC1,
	DPB AC1,SIZSBU		; NOTE SIZE WAS SET BY USER
	POPJ P,

; CALLED FROM <ESC>L IN LINE EDITOR. SETS LINES/GLITCH

↑PPLSET:
	PUSHJ P,SETPHD
	MOVEI AC3,NLSIII
	SKIPG DAT
	MOVEI AC3,NLSDD
	MOVE UUO,PGSIZ(DAT)
	LSH UUO,=9
	SKIPN AC2,LEARG(DDB)
	MOVE AC2,AC3
	ADD UUO,AC2
	JRST PPGST1

; CALLED FROM <ESC>Y IN LINE EDITOR. SETS Y POSITION

↑PPYSET:
	PUSHJ P,SETPHD
	MOVEI AC3,YPIII
	MOVE UUO,LEARG(DDB)
	JUMPL DDB,PPYDD
	MOVEI AC3,YPIII
	IMUL UUO,[-30]
	ADDI UUO,770+30
PPYS2:
	CAIL UUO,1000
	MOVEI UUO,(AC3)		;SET TO NORM ON ZERO (NULL) ARG
	PUSHJ P,PPYPOS
	SETO AC1,
	DPB AC1,POSSBU
	POPJ P,

PPYDD:
	MOVEI AC3,YPDD
	LSH UUO,7
	IDIV UUO,[-5]
	ADDI UUO,1000
	JRST PPYS2

; SET PAGE PRINTER HOLD COUNTS. GIVE LINE COUNT IN BITS 18-26 AND
; GLITCH COUNT IN 27-35. HIGH ORDER BIT OF FIELD ON MEANS DO NOT SET.

PPHLD:
	SETZ AC1,
	TRNE UUO,1B18		; DOES HE WANT TO SET LINE COUNT?
	JRST PPHLD1		; NO, SKIP IT
	DPB AC1,LHCSBU		; NOTE SET BY UUO
	LDB AC2,[POINT 8,UUO,26];used to say 25 instead of 26--ME 8-19-73
	DPB AC2,HLINES		; SET INTO PROGRAM HEADER
	SKIPN AC2		; ZERO MEANS DON'T HOLD AT ALL
	SETO AC2,		; WHICH IS SIGNIFIED BY -1
	MOVEM AC2,LHCNT(DDB)	; START IT GOING NOW
PPHLD1:
	TRNE UUO,1B27		;used to say 1b26--ME 8-19-73
	JRST PPHLD2		; NOW GO UNHOLD US
	DPB AC1,GHCSBU
	LDB AC2,[POINT 8,UUO,35]
	DPB AC2,HGLTCH
	SKIPN AC2
	SETO AC2,
	MOVEM AC2,GLHCNT(DDB)
PPHLD2:
	SETZ AC1,
	EXCH AC1,DPHOLD(DDB)
	JUMPE AC1,CPOPJ
	HRRZ AC1,PRGNUM(DDB)
	ADD AC1,[XWD UNHOLD,DPYL0]
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	POPJ P,

; THIS ROUTINE GIVES THE USER A NICE LITTLE TABLE OF DATA ABOUT HIS
; PAGE PRINTER. THE TABLE IS =20 WORDS LONG. THE FIRST WORD IS
; XWD <POG ACT BITS>,<PP ACT BITS> WHICH ARE IN PPACT OR PGACT FORMAT.
; THE SECOND WORD IS THE NUMBER OF THE PIECE OF PAPER CURRENTLY SELECTED.
; THE THIRD WORD IS THE LINE EDITOR POSITION IN THE RH, BIT ZERO IS
; THE PAGE COLOR, AND BIT 1 SAYS WHETHER <ESC>C HAS BEEN TYPED SINCE YOU
; LAST GAVE THIS UUO, BIT 2 IS ON IF YOU ARE A DATA DISK DISPLAY.
; THE FOURTH THROUGH THE 19.TH WORDS ARE XWD <Y-POS>,<NG*1000+LPG> WHERE
; NG IS THE NUMBER OF GLITCHES AND LPG IS THE NUMBER OF LINES PER GLITCH.
; THIS IS CLEVERLY ARRANGED SO THAT A PPYPOS UUO WITH THE ARGUEMENT
; IN THE LH OF THIS WORD FOLLOWED BY A PPXSIZ WITH THE ARGUEMENT IN
; THE RH OF THIS WORD COMPLETELY RESTORES THAT PAGE.
; THE 20TH WORD IS A COPY OF GWORD. B0 MEANS PAGE PRINTER SIZE SET LAST
; BY USER COMMAND RATHER THAN BY UUO, B1 FOR Y-POSITION, B2 FOR LINE HOLD COUNT,
; AND B3 FOR GLITCH HOLD COUNT. BITS 9-17 HAVE THE ACTUAL LINE HOLD COUNT
; AND BITS 18-25 HAVE THE ACTUAL GLITCH HOLD COUNT. ZERO IF NOT BEING USED.

↑PPSPY:	HRR UUO,TAC		;VERSION OF PPINFO FOR ANOTHER JOB'S DPY
	HLRE ITEM,TAC		;ARG IS JOB#,,OUTPUT BLOCK ADDR
	JUMPL ITEM,PPSPY1	; OR - LINE # IN LH
	JUMPE ITEM,CPOPJ	;NON-SKIP RETURN IF NO JOB OR NO DPY
	CAILE ITEM,JOBN
	POPJ P,
	MOVE AC1,JBTSTS(ITEM)
	TLNN AC1,JNA
	POPJ P,
	PUSHJ P,PRGF1		;DON'T USE PRGFND TO FLANK DPYMAP HACK
PPSPY2:
	SKIPA DAT,CURPP(DDB)	;PRGF1 SKIP RETURNS ON FAILURE
	POPJ P,			;NO DISPLAY
	HLL DAT,DDB
	AOS (P)			;OK, SET SKIP RETURN AND DROP THROUGH

PPINFO:
	MOVE AC1,PRGACT(DDB)	; PICK UP HIS ACTIVATION BITS
	XCTR	XW,[MOVEM AC1,(UUO)]
	MOVE AC1,PPNO(DAT)	; GET CURRENT PIECE OF PAPER NUMBER
	XCTR	XW,[MOVEM AC1,1(UUO)]
	LDB AC1,[POINT 11,LEPOS(DDB),21]
	TRNE AC1,1⊗=10		; EXTEND SIGN BIT
	ORI AC1,-1⊗=10
	MOVE AC2,DDCW(DAT)	; PUT IN BLACK-WHITE BIT
	TLNE AC2,(1B5)
	TLO AC1,(1B0)
	SETZ AC2,		; PUT IN <ESC>C BIT
	EXCH AC2,LECC(DDB)
	SKIPE AC2
	TLO AC1,(1B1)
	JUMPGE DDB,.+2		;DD OR III?
	TLO AC1,(1B2)		;DD, TURN ON BIT
	XCTR	XW,[MOVEM AC1,2(UUO)]
	ADDI UUO,3
IFE 1,<
	HRL AC1,UUO		; NOW ZERO OUT THE TABLE
	HRRI AC1,1(UUO)
	XCTR XW,[SETZM (UUO)]
	XCTR XRW,[BLT AC1,17(UUO)]
>
IFN 1,<
	MOVEI AC1,17(UUO)
PPINF0:
	XCTR XW,[SETZM (AC1)]
	CAIE AC1,(UUO)
	SOJA AC1,PPINF0
>

; PPINFO CONT - RUN DOWN LIST OF PP CTRL BLOCKS

	HLRZ AC1,PPCALL(DDB)	; PICK UP POINTER TO FIRST PAGE PRINTER CONTROL BLOCK
PPINF1:
	LDB AC2,[POINT 11,PPOSV(AC1),21]
	TRNE AC2,1⊗10		; SPREAD SIGN BIT ALL DOWN WORD
	OR AC2,[-1⊗10]
	LSH AC2,=9		; MOVE IT OVER
	ADD AC2,PGSIZ(AC1)	; PUT IN THE NUMBER OF GLITCHES
	LSH AC2,=9
	ADD AC2,DEL(AC1)	; AND THE NUMBER OF LINES PER GLITCH
	MOVE AC3,PPNO(AC1)	; PICK UP THE PIECE OF PAPER NUMBER
	ADD AC3,UUO
	XCTR	XW,[MOVEM AC2,(AC3)]	; GIVE HIM THE WORD
	HRRZ AC1,LINK(AC1)	; PICK UP LINK TO NEXT PAGE PRINTER CONTROL BLOCK
	JUMPN AC1,PPINF1	; LOOP AROUND IF THERE IS ONE
	MOVE AC1,GWORD(DDB)	; PICK UP GARBAGE DUMP WORD
	XCTR	XW,[MOVEM AC1,=19-3(UUO)]
	POPJ P,

PPSPY1:
	MOVMS ITEM		;NEGATIVE ARG TO PPSPY IS LINE #
	MOVE DDB,LINTAB(ITEM)
	TLNN DDB,DISLIN!DDDLIN
	POPJ P,
	HRRZ DDB,LETAB-DPYL0(DDB)
	JUMPE DDB,CPOPJ		;NO DDB
	PUSHJ P,PRGF3		;SETS UP DD BIT IN DDB
	JRST PPSPY2

; THIS IS THE ROUTINE FOR A UUO WHICH SETS YOUR LINE EDITOR'S VERTICAL
; POSITION. THE EFFECTIVE ADDRESS OF THE UUO IS SAID POSITION IN
; PPYPOS FORMAT. Y-POSITION OF ZERO IS VERBOTTEN AND MEANS RETURN TO
; THE BOTTOM OF THE PAGE PRINTER.

LEYPOS:
	MOVE AC1,[BYTE (11)<-777>,0(3)0,0(2)1,2(3)3]
	TRNN UUO,-1		; IS THE POSITION ZERO?
	SKIPA AC1,[DISNOP]	; YES, PUT A NO-OP IN
	DPB UUO,[POINT 11,AC1,21]
	MOVEM AC1,LEPOS(DDB)	; PUT IT IN BEFORE THE LINE EDITOR CALL
	JUMPG DAT,CPOPJ
	SETO AC1,		; QUEUE UP A LINE EDITOR REQUEST TO GET IT REPOSITIONED
	EXCH AC1,LECLK(DDB)
	JUMPN AC1,CPOPJ
	HRR AC1,DDB
	HRLI AC1,DPLED
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	POPJ P,

;;FREEL FREES A LIST OF BLOCKS POINTED TO BY AC1, AND UPDATES
;; THE USER'S BLKTOT.  

FOOFRL:
	HRRZ AC1,UUO
	PUSHJ P,FSGIVE
	HRRZ AC1,TAC1
	JUMPE AC1,CPOPJ
FREEL:
	HRRZ AC3,LINK(AC1)	;GET CDR OF LIST.
	PUSHJ P,CGIVFS		;FREE CAR OF LIST.
	MOVEM AC3,AC1
	JUMPN AC1,FREEL		;FREE CDR.
	POPJ P,

DPYFOO:
	JSP AC3,FNDJOB		;GET JOB NO. (GETJOB IS IN MAIL).
	EXCH DAT,ITEM		;PRETEND IT'S OURS...
	PUSHJ P,PRGFND		;FIND ASSOCIATED DPY PRGM.
	POPJ P,			;SHOULDN'T LOSE ANY MORE THAN ANYONE ELSE
	MOVEM DDB,DPYMAP(DAT)	;ENTER IN OUR TABLE.
	POPJ P,			;WE WILL NOW USE OTHER GUY'S DPY PRGM.

;;UPG IS THE DEMOCRATIC UUO WHICH ALLOWS ALL MEN,
;; HOWEVER HUMBLE THEIR STATION (PROVIDED IT IS TY20
;; OR HIGHER) TO RUN THEIR VERY OWN DISPLAY 
;; PROGRAMS.

↑UPGIOT:
BEGIN UPG

T2←DSER
PBSZ←←CNT	;DPY INSTRS /BLOCK.
SIZE←←=17
PGWC←←0
PGSA←←1
PGNP←←2

	PUSHJ P,PGSET		;GET REQUESTED P OF G .
	POPJ P,			;NO SUCH DPY, LEAVE NOW
	JUMPL DDB,DDUPG
	MOVEM ITEM,CURPG(DDB)
	XCTR	XR,[HRLZ TEM,(UUO)]	;STARTING ADDR. OF PRGM.
	XCTR	XR,[MOVM AC3,1(UUO)]	;LENGTH OF PRGM.
	CAIL AC3,NBS*PBSZ	;IS PIECE OF GLASS GOING TO BE TOO BIG ?
	JRST UPGTB
	HRLZM AC3,UCHN		;SAVE WC IN LEFT OF UCHN, MAKE RIGHT HALF 0 FOR NOW.
	MOVEI TAC,PBSZ-1+PGNP(AC3)
	IDIVI TAC,PBSZ		; FIND OUT HOW MANY BLOCKS THIS PROGRAM WILL CONSUME
	MOVEI T2,(TAC)
	SUB TAC,SIZE(ITEM)	;HOW BIG IS THIS PG NOW ?
	ADD TAC,BLKTOT(DDB)	;THIS IS HOW MUCH IT GROWS.
	JUMPG TAC,UPGER1	;IS USER OVER HIS ALLOTMENT ?
	HRREI TAC,-1(T2)	;SAVE IT.
	SETZM SIZE(ITEM)	;...SEE FOLLOWING INSTR.
	MOVEI TAC1,DISNOP	;SEE FOLLOWING INSTR...
	JUMPE AC3,UPREL1	;IF WC IS 0, RELEAS PAGE.
	MOVEI AC3,NBS+2		; NICE BIG PIECE
	PUSHJ P,UGETF1		;GET BLOCK FOR THE RELOCATION TABLE.
	JUMPL AC1,CPOPJ		;IF WE ARE AT SPACEWAR LEVEL AND NO FREE STG., JUST RETURN.
	MOVEM AC1,UUO
	MOVEI TAC1,0
	TLOA UUO,TAC		;MAKE UUO AN INDEXED POINTER TO REL. TBL.
L1:
	MOVEM AC1,TAC1		;SAVE LOC. OF THIS BLOCK.
	PUSHJ P,CGETFS		;GET A BLOCK OF FREE STG.
	JUMPL AC1,FOOFRL	;GO AWAY IF SPACEWAR AND NO FREE STG.
	MOVSM AC1,@UUO		;ENTER IN RELOCATION TABLE.
	MOVEM TAC1,LINK(AC1)	;LINK TO PREVIOUS BLOCK.
	SOJGE TAC,L1		;GET REST OF BLOCKS NEEDED.
	MOVEM T2,SIZE(ITEM)	;UPDATE SIZE OF THIS PG.

	MOVN TAC1,UCHN		;LENGTH OF USERS CODE.
	HLR TAC1,TEM		;STARTING ADDR.
	HRR UCHN,UUO		;BOTTOM OF RELOCATION TABLE.
	HLRZ T2,(UUO)
	ADD UCHN,[XWD PGNP,0]
	HLRZM UCHN,PGWC(T2)
	HLRZM TEM,PGSA(T2)
	ADD T2,[XWD -PBSZ+PGNP,PGNP]
LOOP:
	XCTR	XR,[MOVE (TAC1)]	;PICK UP WORD FROM PRGM.
	TRNN 3			;DOES IT NEED EXAMINING ?
	PUSHJ P,SPECOP		;YES, IT IS A POTENTIALLY DANGEROUS INSTR.
	MOVEM (T2)		;STORE THE INSTR.
	AOBJP TAC1,DONE		;AT END OF PGM. ?
	AOBJN T2,LOOP		;NO. END OF BLOCK ?
	MOVE 1(UCHN)		;YES. GET START OF NEXT ONE.
	HRRI DISJMP		;FORM JMP INSTR. TO IT.
	MOVEM (T2)		;PLACE AT END OF LAST BLOCK.
	ADD [XWD 1,0]		;MAKE JMP GO TO 2ND WORD OF NEW BLOCK..
	MOVEM 1(T2)		;...IN CASE THERE IS A TSS WHICH SKIPS..
	HLR T2,1(UCHN)		;GET START OF CURRENT BLOCK.
	HRLI T2,-PBSZ		;LENGTH OF BLOCK.
	AOJA UCHN,LOOP		;GO FILL NEXT BLOCK.

UPGTB:
	ERMS {PIECE OF GLASS TOO BIG.}
	POPJ P,
	
SPECOP:
	LDB AC1,[POINT 3,0,33]	;GET OPCODE.
	XCT SPCTBL(AC1)		;DO APPROPRIATE THING.
	POPJ P,			;STORE INSTR.

DONE:
	MOVE TAC1,(UUO)		;START OF BLOCK 0 OF PRGM.
	ADD TAC1,[XWD PGNP,DISJMP]
	MOVEM TAC1,1(T2)	;MAKE END OF PGM JMP BACK TO START.
	MOVEM TAC1,2(T2)
	HRRZ AC1,UUO		;NOW RELEASE THE RELOC. TABLE.
	PUSHJ P,FSGIVE
	HRRI TAC1,DISJSR	;JSR TO START OF PGM.
↑UPREL1:HLRZ AC1,PGCALL(DDB)
	SUBI AC1,(ITEM)		;GET NEG POG #
	MOVSI AC2,400000
	LSH AC2,(AC1)		;MAKE PGACT BIT
	TRNE TAC1,20
	IORM AC2,PRGACT(DDB)	;IS JSR - MARK ACTIVE
	TRNN TAC1,20
	ANDCAM AC2,PRGACT(DDB)	;IS NOP - MARK INACTIVE
	EXCH TAC1,(ITEM)	;EXCHANGE FOR OLD ONE.
	HLRZS AC1,TAC1		;GET START OF OLD PRGM.
	JUMPE TAC1,CPOPJ	;RETURN IF NO OLD PRGM.
	  ;FREE THE OLD PRGM.,AND FIX PRGM TO RESTART AT TOP.
	SUBI AC1,PGNP
	JRST SETRST		;SETRST IS IN PRINT.

;;MORE OF UPG.

;;SPCTBL IS DISPATCH TABLE FOR HANDLING SPECIAL DPY INSTRS.

SPCTBL:
	JRST HLTOP	;HALT
	JRST ILLJMS	;JMS
	JRST SELCHK
	JRST ADRRST	;RST (NO BITS ON -- NOOP) (DCS-5/29/70)
	JRST ADROP	;JMP
	JRST ADROP	;JSR OR SAVE
	JRST SELCHK
	JRST ADROP 	;RST (AGAIN.)

SELCHK:
	MOVE TAC,JOB
	MOVE TAC,JBTPRV(TAC)
	TLNE TAC,UPGPRV			;RETURN QUICK IF HE HAS THE PRIV
	POPJ P,				;HE HAS THE PRIVILEGE
	MOVE TAC,[<77770010>⊗DPYNUM]	;DESELECT ANYONE.
	MOVEI AC2,DPYNUM-1		;DPY'S ONLY.
	PUSH P,TAC1
LOOPS:
	LSH TAC,-1			;SHIFT MASK.
	SKIPN AC3,TTYTAB+DPYL0(AC2)	;POINTER TO DPY DDB.
	JRST DCHNOK		;SELECT OK!
	MOVE TAC1,DEVMOD(AC3)
	LDB AC3,[POINT 6,1(AC3),5]	;GET # OF JOB THAT HAS THAT DPY.
	TDNE TAC1,[XWD TTYATC,ASSCON!ASSPRG]
	CAMN AC3,JOB(PID)			;THIS ONE?
DCHNOK:
	TLO TAC,400000			;SELECT BIT.
	SOJGE AC2,LOOPS
	POP P,TAC1
	MOVSI AC2,400000		;GET A BIT.
	MOVN AC3,PRGNUM(DDB)		;DPY NUMBER THIS PROG.(0 TO DPYNUM-1)
	LSH AC2,(AC3)
	TDO TAC,AC2			;MAKE SURE HE GETS HIS OWN.
	AND TAC
	POPJ P,

; RST WITH NO PARAM BITS ON IS A NOOP -- ALLOW ANY ARGUMENT
; TO APPEAR UNCHANGED IN THE LEFT HALF

ADRRST:
	TRNN	60		;SIZE OR [X,Y] FIELDS ON?  (DCS-5/29/70)
	 POPJ	 P,		; NO, LEAVE IT ALONE	   (DCS)

;CALL ADROP WITH THE FOLLOWING
;	0	XWD <ADDRESS TO CHECK>,<ANYTHING>
;	TEM	XWD <USER BASE ADDRESS>,<ANYTHING>
;	UCHN	XWD <LENGTH OF USER BUFFER>,<ANYTHING>
;	UUO	XWD TAC,<ADDRESS OF RELOCATION TABLE>
;	TAC1	XWD <ANYTHING>,<ADDRESS TO TYPE OUT ON ERROR>

ADROP:
	SUB TEM			;AN ADDRESSABLE INSTR. UNRELOCATE IT.
	CAML UCHN		;ADDRESS TOO HIGH ?
	JRST ILLAD		;YUP.
	ADD 0,[XWD PGNP,0]	; SKIP OVER HEADER WORDS
	HLRE AC1,0		; PICK UP ADDRESS
	IDIVI AC1,PBSZ		; GET # BLOCKS AND DISPLACEMENT INTO LAST BLOCK
	HRL 0,AC2		; USE DISPLACEMENT INTO BLOCK PLUS ADDRESS OF BLOCK
	MOVE TAC,AC1
	ADD @UUO		;ADD IN RIGHT RELOCATION.
	JUMPGE AC1,CPOPJ	;WAS ADDRESS TOO SMALL ?
ILLAD:
	PUSHJ P,DPYERR		;ILLEGAL ADDRESS IN DPY INSTR.
	ERMS {ILLEGAL INSTR. ADDRESS.}
ILL1:
	MOVEI DISNOP		;REPLACE OFFENDING INSTR. WITH NOP.
	POPJ P,

ILLJMS:
	PUSHJ P,DPYERR
	ERMS {JMS NOT LEGAL; USE JSR.}
	JRST ILL1

HLTOP:
	MOVE (UUO)		;REPLACE HLT WITH RETURN JMP.
	ADD [XWD PGNP,DISJMP]
	POPJ P,

UPGER1:
	ERMS {TOTAL DPY BUFFER SPACE EXCEEDED.}
	POPJ P,

; DATA DISC PROGRAM HANDLER
; SENDS THE PROGRAM DIRECTLY OUT OF LOSER CORE IN EXEC MODE

;EXTENDED FEATURES:
;BIT 0 OF HEADER WD 0 => OVERLAPPED XFER (RETURNS WITHOUT WAITING)
; IN THIS MODE HEADER WD 2 ≠ 0 => XFER GOING.
; DPYOUT ALWAYS WAITS FOR PREV XFER, SO DPYOUT WITH WC=0 WILL
; WAIT FOR BUFFER TO BE AVAIL.
;BIT 1 OF HEADER WD 0 => DOUBLE FIELD MODE, WHICH DOES XFER
; TWICE - ONCE ON EACH FIELD. HEADER WD 3 SHOULD POINT TO WORD
; OF BUFFER CONTAINING (ONLY) LOW-ORDER LINE ADDRESS SELECT
; AS 3RD COMMAND BYTE. THIS BYTE WILL BE ADJUSTED TO APPROP
; FIELD ON EACH XFER.

DDUPG:
	SKIPE DDOFF		; DO WE HAVE A DATA DISC TODAY
	POPJ P,			; NO, SPEAK NO EVIL!
	PUSHJ P,DDWAIT		;WAIT FOR PREV XFER, IF ANY
	XCTR	XR,[SKIPGE AC1,(UUO)]	; PICK UP ADDRESS OF USER BUFFER
	XCTR	XW,[SETZM 2(UUO)]	;INIT XFER IN PROGRESS FLAG IF USED
	XCTR	XR,[SKIPG AC2,1(UUO)]	; PICK UP WORD COUNT OF BUFFER
	POPJ P,			;THAT WAS EASY
	ADDI AC2,-1(AC1)	; MAKE POINTER TO LAST WORD
	XCTR	XR,[SKIPE (AC2)]	;DON'T CLOBBER IF OK (MIGHT BE UPPER)
	XCTR	XW,[SETZM (AC2)]	; PUT A HALT THERE AT THE END OF THE BUFFER
	MOVEI AC3,10		; WE WILL LOOK IN THIS FAR FOR A CHANNEL SELECT
DDCWL:
	XCTR	XR,[MOVE AC2,(AC1)]	; PICK UP WORD OF PROGRAM
	LDB TAC,[POINT 3,AC2,35]
	CAIN TAC,4		; IS IT A COMMAND WORD?
	JRST CHKAD		; YES, SEE IF IT HAS A CHANNEL SELECT IN IT
DDCINC:
	ADDI AC1,1		; BUMP POINTER INTO USER CORE
	SOJG AC3,DDCWL		; BUMP COUNT OF DEPTH AND LOOP BACK
	HLRE TAC,PRGNUM(DDB)	; NO CHANNEL SELECT, SEE IF WE CAN SEND TO HIS OWN SCREEN
	JUMPGE TAC,DDSCHN
	JRST ILLCHN

DDWAIT:
	SKIPN PRGCNT(DDB)
	POPJ P,			;NOTHING GOING ON
	MOVNI AC2,DIOWQ
	MOVEI AC3,400000
	CONO PI,APROFF
	SKIPN PRGCNT(DDB)
	JRST APRONJ		;MUST HAVE JUST FINISHED
	MOVEM AC2,JOBQUE(J)
	IORM AC3,PRGJMP(DDB)	;TELL PI ROUTINES TO WAKE US
	CONO PI,APRON
	SKIPGE JBTLIN(J)
	JRST WSCHED		;AVOID RETESTING IF DETACHED (HEADER WILL GO AWAY)
	PUSHJ P,WSCHED		;WAIT FOR IT
	JRST DDWAIT		;THEN CHECK AGAIN TO BE SURE

APRONJ:
	CONO PI,APRON
	POPJ P,

; HERE WE ARE, READY TO SET THE CHANNEL ADDRESS OF HIS DATA DISC PROGRAM

DDSCHN:
	MOVE AC1,[CW 1,47,3,1,2,0]
	DPB TAC,[POINT 8,AC1,23]
	MOVEM AC1,PRGCW(DDB)	; PUT IN COMMAND WORD WITH CHANNEL SELECT
	XCTR	XR,[MOVE AC2,(UUO)]
	PUSHJ P,CHKADR
	HRLI AC2,DISJMP
	MOVSM AC2,PRGJMP(DDB)	; PUT IN JUMP TO USER'S PROGRAM
	MOVEI TAC,
	XCTR	XR,[SKIPL (UUO)]	;OVERLAPPED MODE?
	JRST UPGQ0		;NO
	XCTR	XRW,[MOVES 2(UUO)]	;BE SURE WE CAN WRITE HERE
	MOVEI AC2,2(UUO)
	PUSHJ P,CHKADR
	MOVEI TAC,(AC2)		;SAVE ABS ADR FOR PI ROUTINES
UPGQ0:
	PUSHJ P,GETQ
	XCTR	XR,[MOVE AC3,(UUO)]
	TLNN AC3,200000		;DOUBLE FIELD MODE?
	JRST UPGQ1		;NO
	XCTR	XR,[HRRZ AC2,3(UUO)]	;ADR OF WORD WITH LINE SELECT
	XCTR	XRW,[MOVES (AC2)]	;CHECK WRT ACCESS HERE
	PUSHJ P,CHKADR
	HRLI TAC,(AC2)		;SAVE THIS ADR
	PUSH P,AC1
	PUSHJ P,GETQ		;WILL NEED 2 Q BLKS
	SETOM QFIELD(AC1)
	PUSHJ P,UPGQ
	POP P,AC1
UPGQ1:
	SETZM QFIELD(AC1)
	PUSHJ P,UPGQ
	XCTR	XR,[SKIPL (UUO)]	;OVERLAPPED?
	JRST DDWAIT		;NO - WAIT
	POPJ P,			;YES - RETURN

UPGQ:
	HRLM	DDB,(AC1)	;LOAD UP TASK BLOCK WITH PROGRAM HEADER
	MOVEI	AC2,POG		;DISPATCH TO USER PROGRAM SERVICE
	HRRM	AC2,(AC1)
	MOVEI	AC2,PRGCNT(DDB)	;PICK UP ADDRESS OF FAKE COUNT FIELD
	MOVEM	AC2,QCOUNT(AC1)
	MOVEM	TAC,QHPOS(AC1)	;STORE SPEC ADRS
	TRNE	TAC,-1
	AOS	(TAC)		;COUNT XFER GOING (FOR LOSER)
	AOS	PRGCNT(DDB)	;AND FOR US
	MOVEM	J,QWAKE(AC1)
	MOVE	AC2,[XWD 1,50]	; MAKE IT LOOK LIKE IT WILL TAKE ENTIRE SCREEN
	MOVEM	AC2,QLINE(AC1)
	AOS	JBTGLU(J)	;KEEP US AROUND
IFN FTSTAT,<PUSHJ P,GLUSTT>
	JRST	QBLOCK

; GET HERE TO LOOK AT A USER'S COMMAND WORD AND SEE IF THERE IS A CHANNEL SELECT

CHKAD:
	LDB TAC,[POINT 3,AC2,26]
	CAIN TAC,2		; IS IT A CHANNEL SELECT?
	JRST CHKAC1		; YES, SEE IF IT IS LEGAL.
	LDB TAC,[POINT 3,AC2,29]
	CAIN TAC,2
	JRST CHKAC2
	LDB TAC,[POINT 3,AC2,32]
	CAIN TAC,2
	JRST CHKAC3
	JRST DDCINC

CHKAC1:
	LDB TAC,[POINT 8,AC2,7]
CHKAC4:
	PUSHJ P,CHAD
	JRST DDSCHN

CHKAC2:
	LDB TAC,[POINT 8,AC2,15]
	JRST CHKAC4

CHKAC3:
	LDB TAC,[POINT 8,AC2,23]
	JRST CHKAC4

;CHECK & RELOC USER ADR
CHKADR:
	HLRZ AC3,JBTADR(J)
	CAIGE AC3,(AC2)
	JRST CHKADU		;PAST LOWER - TRY UPPER
	ADD AC2,JBTADR(J)
	POPJ P,

CHKADU:
	TRZN AC2,400000
	JRST UUOERR		;CAN'T BE UPPER
	TRZE AC3,400000
	SUBI AC2,1(AC3)
	LDB AC3,PSEGN
	JUMPE AC3,UUOERR	;NO UPPER
	HLRZ AC3,JBTADR(AC3)
	CAIGE AC3,(AC2)
	JRST UUOERR		;TOO BIG
	LDB AC3,PSEGN
	ADD AC2,JBTADR(AC3)
	POPJ P,

;CHANNEL ADDRESS CHECKING. HE CAN WRITE ON HIS OWN SCREEN,
;OR ON ANY CHANNEL HE OWNS, OR ON ANY FREE CHANNEL.

CHAD:
	JUMPE TAC,MYCHN		;GIVE HIM HIS OWN FOR 0
	ANDI TAC,37
	MOVEI AC1,(TAC)
	PUSHJ P,DDCHEK
	POPJ P,		;FREE
	JRST .+2
	POPJ P,		;HE OWNS IT
	MOVE AC1,JBTPRV(J)
	MOVE AC2,DDTAB(TAC)
	TLNN AC2,DDANYW		;MAYBE OWNER SAYS IT'S OK
	TLNE AC1,UPGPRV
	POPJ P,		;HE CAN WRITE ANYWHERE WITH THE PRIVILEGE
MYCHN:
	HLRE TAC,PRGNUM(DDB)	;GIVE HIM HIS OWN CHANNEL (IF ANY)
	JUMPGE TAC,CPOPJ	;WIN
	SUB P,[1,,1]
ILLCHN:
	MOVEI AC1,(DDB)
	SKIPE DPRLSF(DDB)
	PUSHJ P,FSGIVE	;MAKE SURE THE PHONY HEADER GETS RETURNED
	PUSHJ P,TTYFUW
	PUSHJ P,INLMES
	ASCIZ /ILLEGAL DD CHANNEL.
/
	JRST TYPGO

;;PGSET  SETS UP REQUESTED PIECE OF GLASS.

↑PGSET:	PUSHJ P,PRGFND		;FIND USER'S DPY PGM.
	POPJ P,			;NO DISPLAY HERE
	JUMPL DDB,CPOPJ1
PGSETA:
	HLRZ ITEM,PGCALL(DDB)	;PTR. TO PG HEADER.
	JUMPE ITEM,PGSET1	;IF NONE, START FROM SCRATCH.
	CAMLE UCHN,LSTPG(DDB)	;DOES THIS PG ALREADY "EXIST" ?
	JRST PGSET2		;NO. GO EXTEND THE HEADER.
	ADDI ITEM,(UCHN)	;YES. MAKE ITEM POINT AT
	JRST CPOPJ1		;THE CALLING INSTR. FOR IT.
PGSET1:
	PUSHJ P,CGETFS		;GET BLOCK TO USE FOR PG HEADER.
	MOVEM AC1,ITEM
	SETOM LSTPG(DDB)	;NO PG'S EXIST YET.
	HRLI TAC1,PGCALL+1(DDB)	;INVENT RETURN JMP TO PGM HEADER.
	HRRI TAC1,DISJMP
	MOVEM TAC1,(ITEM)	;PUT IN FIRST WORD OF PG HEADER.
	HRLI ITEM,DISJMP
	MOVSM ITEM,PGCALL(DDB)	;FIX CALL ON PG HEADER.
PGSET2:
	MOVEI TAC1,DISNOP	;EXTEND ACTIVE PART OF PG HEADER.
	ADD ITEM,LSTPG(DDB)	;GET LAST CURRENT PAGE.
	EXCH UCHN,LSTPG(DDB)
	SUB UCHN,LSTPG(DDB)	;NO. OF PLACES TO EXTEND.
	HRLI ITEM,(UCHN)	;MAKE AOBJN WORD.
	MOVE UCHN,1(ITEM)	;GET RETURN JMP.
PGSL1:
	MOVEM UCHN,2(ITEM)	;PUT RTN JMP FARTHER UP.
	MOVEM TAC1,1(ITEM)	;PUT NOP WHERE IT USED TO BE.
	SETZM SIZE+1(ITEM)	;THIS PG IS NOW 0 SIZE.
	AOBJN ITEM,PGSL1
	JRST CPOPJ1

; THIS IS THE DPY ERROR ROUTINE. IT TYPES OUT THE PC IN TAC1 ON
; THE DISPLAY.

DPYERR:
	PUSH P,TEM
	PUSH P,TAC1
	JSA ITEM,ERRP		;DO THIS SO NO TERMINATING CRLF
	POINT 7,[ASCIZ/$$ USER DPY ERROR AT /]
	HRR AC1,(P)
	MOVEI AC2,6
DPYER1:
	HRRZS AC1
	LSH AC1,3		;GET ONE OCTAL DIGIT.
	TLO AC1,60
	LDB CHR,[POINT 7,AC1,17]
	PUSH P,AC1		; SAVE ALL OUR RELEVANT DATA
	PUSH P,AC2
	MOVE DAT,CURPP(DDB)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	HLL DAT,DDB		; PUT IN DD BIT
	CONO PI,SCNOFF		;TURN OFF RPH
	PUSHJ P,TYO		;PRINT  IT.
	CONO PI,SCNON		;TURN ON RPH
	POP P,AC2
	POP P,AC1
	SOJG AC2,DPYER1
	ERMS {}
	POP P,TAC1
	POP P,TEM
	POPJ P,

↑↑UPGMVM:PUSHJ P,UPGMV		;DO `MOVEM' INTO P OF G: TAKE CARE OF PRELIMINARIES.
	POPJ P,			;IGNORE IF NO CAN DO
	TRNN 3			;IF THING BEING STORED IS A COMPLICATED DPY INSTR.,
	PUSHJ P,SPECOP		; THEN CHECK AND RELOCATE IT.
	MOVSS DAT		;GET RELOCATED ADDRESS OF THE UPGMVM.
	MOVEM (DAT)		;DO THE STORE.
	POPJ P,

↑↑UPGMOV:PUSH P,UCHN		;DO A `MOVE' FROM THE CURRENT P OF G.
	PUSHJ P,UPGMV		;LET SOMEBODY ELSE DO THE REAL WORK !
	TDZA DAT,DAT		;RETURN 0 IF NO CAN DO
	JRA DAT,.+1		;HO, HO, HO.  SEE THE CLEVER PROGRAMMER.
	POP P,UCHN		; P1ULOC DOESN'T HAVE OUR UUO ANY MORE, MUST SAVE CHANNEL NUMBER OURSELVES
	XCTR	XW,[MOVEM DAT,(UCHN)]	;PUT RESULT IN USER'S AC.
	POPJ P,

UPGMV:
	PUSHJ P,PRGFND		;COMMON ROUTINE FOR UPGMOV AND UPGMVM. FIND PRGM.
	POPJ P,			;NO DPY, NO MOVY
	JUMPL DDB,CPOPJ
	SKIPE ITEM,CURPG(DDB)	;GET CURRENTLY SELECTED P OF G.
	SKIPN SIZE(ITEM)	;MAKE SURE IT EXISTS.
	POPJ P,
	XCTR	XR,[MOVE DAT,(UCHN)]	;PICK UP CONTENTS OF USER'S AC.
	MOVS T2,(ITEM)		;GET PTR. TO THE P OF G.
	SUBI T2,PGNP		;MAKE IT POINT TO THE DESCRIPTOR WORDS.
	HRLZ TEM,PGSA(T2)	;STARTING ADDR. (IN USER CORE) OF P OF G.
	HRLZ UCHN,PGWC(T2)	;LENGTH OF P OF G.
	HRLZ UUO		;ADDRESS OF THE `MOVE' OR `MOVEM'.
	MOVE UUO,[XWD TAC,TBL]	;PREPARE TO GENERATE A BLOCK MAP FOR
	HRLZM T2,(UUO)		;THE P OF G. (PUT IN BOTTOM PTR.).
	SKIPE T2,LINK(T2)	;GET NEXT BLOCK, IF ANY.
	AOJA UUO,.-2		;PUT IT IN MAP.
	HRRI UUO,TBL		;MAKE UUO POINT TO MAP.
	HLRZ TAC1,0		;PRINT THIS ADDRESS IN EVENT OF ERROR!
	PUSHJ P,ADROP		;NOW RELOCATE AND CHECK ADDR. OF MOVE.
	EXCH DAT,0		;PUT OPERAND (IF `MOVEM') INTO 0.
	JRST CPOPJ1

↑↑PGIOT:
	CAIL UCHN,PGMAX		;GENERAL P OF G SERVICE IOT.
	JRST UUOERR
	PUSHJ P,DDFND		; FIND A PROGRAM HEADER (UCHN =3 GAURANTEES ONE)
	POPJ P,			;IGNORE IF NO DISPLAY
	JUMPG DDB,@PGDSP(UCHN)	; IF III, DISPATCH NOW
	CAIGE UCHN,3		; ONLY ONES LEGAL FOR DD CURRENTLY
	POPJ P,			; ALL THE OTHERS DON'T MAKE SENSE.
	JRST @PGDSP(UCHN)	;INDEX REG FIELD WAS MISSING, SO
				; ONLY PGSEL WAS AVAILABLE -- DCS (6/2/70)

DEFINE UUOS{FOR X IN(PGSEL,PGACT,PGCLR,DDUPG,PGINFO)}
; UUOMAC PGDSP,PGIOT
PGDSP:

0+PGSEL
0+PGACT
0+PGCLR
0+DDUPG
0+PGINFO

UUOCNT←←.-PGDSP
PGIOT UUOCNT-1,UUOLNK
↑↑UUOLNK←←.

SIXBIT/PGSEL/
SIXBIT/PGACT/
SIXBIT/PGCLR/
SIXBIT/DDUPG/
SIXBIT/PGINFO/

PGMAX←←UUOCNT

ORG PGSEL
PGSEL:
	HRRZ UCHN,UUO		;SELECT THE P OF G INDICATED BY THE ADDR. FIELD.
	CAIL UCHN,20		;IS IT LEGAL ?
	JRST ADRERR
	PUSHJ P,PGSETA		;FIND THE P OF G.
	POPJ P,			;SHOULD NEVER GET HERE, BUT PGSETA SKIP RETURNS
	MOVEM ITEM,CURPG(DDB)	;MAKE IT THE CURRENTLY SELECTED ONE.
	POPJ P,

↑VPGACT:MOVEI DDB,(DAT)		;HERE ON CLK RQ FROM VDSTR
	HLRZ UUO,PRGACT(DDB)	;THIS MAKES THE PROGRAM AGREE WITH THE BITS
PGACT:
	HLRZ ITEM,PGCALL(DDB)
	JUMPE ITEM,CPOPJ
	HRLM UUO,PRGACT(DDB)
	MOVE TAC,LSTPG(DDB)
	MOVEI AC1,DISNOP
	MOVEI AC2,DISJSR
PGACL:
	SKIPN SIZE(ITEM)
	JRST PGAC1
	HRRM AC1,(ITEM)
	TRNE UUO,400000
	HRRM AC2,(ITEM)
PGAC1:
	ROT UUO,1
	SOJL TAC,CPOPJ
	AOJA ITEM,PGACL

;;PGCLR FLUSHES ANY PIECES OF GLASS A LOSER MAY HAVE.  DDB SHOULD BE SET UP POINTING TO PRGM HEADER.

↑PGCLR:	SETZM CURPG(DDB)
	HLRZ ITEM,PGCALL(DDB)	;GET PTR. TO PG HEADER BLK.
	JUMPE ITEM,CPOPJ	;IF NONE, GO AWAY.
PGCLR1:
	MOVEI TAC1,DISNOP	;FREE A PIECE OF GLASS.
	PUSHJ P,UPREL1		;(SEE ABOVE.)
	SOSL LSTPG(DDB)		;HAVE WE GOT ALL THE PG'S ?
	AOJA ITEM,PGCLR1	;NO. GET SOME MORE.
	MOVEI UCHN,DISNOP	;TURN OFF CALL ON THE PG HEADER.
	EXCH UCHN,PGCALL(DDB)
	HLRZ AC1,UCHN		;PTR. TO HEADER.
	JRST CGIVFS		;FREE THE PG HEADER BLOCK.

; THIS UUO GETS INFORMATION FROM THE SYSTEM ABOUT THE USER'S PIECES
; OF GLASS. IT IS GIVEN IN A 17. WORD TABLE. THE FIRST WORD IS
; XWD <POG ACTIVE BITS>,<PP ACTIVE BITS> IN PPACT AND PGACT FORMAT.
; THE NEXT 16. WORDS, ONE WORD FOR EACH POG, IS XWD <WORD COUNT>,<STARTING ADDRESS>

PGINFO:
	MOVE AC1,PRGACT(DDB)	; PICK UP THE ACTIVATION BITS
	XCTR XW,[MOVEM AC1,(UUO)]
	ADDI UUO,1
	HLRZ AC1,PGCALL(DDB)	; PICK UP ADDRESS OF UPG CONTROL BLOCK
	SETZ AC3,
PGCLP:
	HLRZ CHR,(AC1)		; PICK UP ADDRESS OF FIRST BLOCK OF CODE
	JUMPE CHR,PGSZ		; IF NOTHING THERE, CLEAR WORD IN TABLE
	SUBI CHR,PGNP		; POINT US TO THE CONTROL INFORMATION
	HRRZ AC2,PGSA(CHR)	; PICK UP THE STARTING ADDRESS
	XCTR XRW,[HRRM AC2,(UUO)]
	HRRZ AC1,PGWC(CHR)	; AND THE WORD COUNT
	XCTR XRW,[HRLM AC1,(UUO)]
	JRST PGCNT

PGSZ:
	XCTR XW,[SETZM (UUO)]
PGCNT:
	ADDI UUO,1		; BUMP POINTER INTO USER'S TABLE
	ADDI AC1,1		; AND POINTER TO UPG CONTROL BLOCK
	ADDI AC3,1		; AND COUNT OF NUMBER OF POGS SEEN
	CAIG AC3,LSTPG(DDB)	; ARE WE PAST THE LAST?
	JRST PGCLP		; NO, LOOP BACK
PGXLP:
	CAILE AC3,17		; ARE WE DONE?
	POPJ P,			; YES, LEAVE
	XCTR XW,[SETZM (UUO)]
	ADDI AC3,1		; AND COUNT
	AOJA UUO,PGXLP		; BUMP POINTER AND LOOP

BEND UPG

;;DPYTYP IS CALLED AT CLOCK LEVEL TO TYPE SOME CHRS. FROM A 
;; TTY OUTPUT BUFFER ONTO A DISPLAY.  DAT CONTAINS LINE NUMBER.

DPYTY1:
	TRNE DAT,-1⊗PUNITS	; LEGAL LINE NUMBER?
	JRST DPYTER		; NO, GIVE ERROR MESSAGE
	SKIPN DDB,TTYTAB(DAT)	; PICK UP DEVICE DATA BLOCK ADDRESS
	POPJ P,			; IF NONE, LEAVE NOW, NO CHARACTERS TO TYPE
	HRRZ TAC1,DAT		; SAVE LINE NUMBER
↑DPYERT:
	HRRI DAT,TTIBUF(DDB)	; PICK UP INPUT BUFFER ADDRESS
	HRLI DAT,DPYTY1		; MAKE US COME BACK TO THIS ROUTINE IF WE HAVE TO WAIT
	JRST DPYTY4

↑DPYTYP: HGMAC(34)
	TRNE DAT,-1⊗PUNITS
	JRST DPYTER		; ILLEGAL LINE NUMBER
	HRLI DAT,DPYTYP		; COME BACK TO HERE IF WE HAVE TO WAIT
	SKIPN DDB,TTYTAB(DAT)	; IS THERE A DDB THERE?
	POPJ P,			; NO, NOT MUCH TO DO NOW!
	HRRZ TAC1,DAT		; SAVE LINE NUMBER
	HRRI DAT,TTOBUF(DDB)	; PICK UP OUTPUT BUFFER ADDRESS
DPYTY4:
	MOVEI DSER,(DDB)	;PRESERVE A COPY OF DDB ADDR.
	HRRZ DDB,LETAB-DPYL0(TAC1)	;FIND DPY FOR THIS JOB.
	JUMPN DDB,DPYTY2	; IF WE HAVE A BLOCK, OK
DPYTY5:
	PUSHJ P,DPYMAKE		; OTHERWISE, TRY TO MAKE ONE
	JRST DPYTLN		; NOONE HOME, LOSE LOSE
	AOS NDPMAK#		; BUMP NUMBER OF TIMES WE HAD TO DO THIS
	HRRZ DDB,LETAB-DPYL0(TAC1)
DPYTY2:
	MOVNI IOS,12		;TYPE NO MORE THAN 12 CHARS/TICK.
	SKIPE UUO,CURPP(DDB)	;TYPE ON CURRENTLY SELECTED P OF P.
	JRST DPYTL1
DPYTY6:
	PUSH P,DAT		; SAVE THE OUTPUT BUFFER ADDRESS
	HLRE TAC,PRGNUM(DDB)	; PICK UP DPY NUMBER
	PUSHJ P,PPINIT		; SEE IF WE CAN GET A PAGE PRINTER
	JRST DPYTY3		; NO, COME BACK NEXT TICK AND TRY AGAIN
	PUSHJ P,PPSET		; YES, INITIALIZE IT
	HRRZ UUO,CURPP(DDB)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	POP P,DAT		; GET BACK TTY OUTPUT BUFFER ADDRESS
	JRST DPYTL1

DPYTY3:
	POP P,DAT
	JRST DPYTLN

; HERE WE ARE AT CLOCK LEVEL WITH (SUPPOSEDLY) DAT SET TO
; THE TTY BUFFER AND UUO POINTING TO THE PAGE PRINTER CONTROL BLOCK

DPYTL1:
	SKIPE PPDD(UUO)		; IS THIS A DD DISPLAY?
	TLO UUO,400000		; YES, FLAG THIS TO DPYSER
	SKIPE DPHOLD(DDB)	; ARE WE IN HOLD MODE?
	JRST STAR		; YES, PRINT STARS AND GO AWAY
	SKIPE PPENQ(UUO)	; DO WE CURRENTLY HAVE ANYTHING IN THE QUEUE?
	POPJ P,			; YES, GO AWAY UNTIL IT IS DONE.
DPYTL2:
	CONO PI,SCNOFF		; AVOID EMBARASSING CONFUSION OVER BUFFER EMPTY
DPTL2A:
	PUSHJ P,GETCHO		; GET A CHARACTER
	JUMPE CHR,DPYTLX	; BUFFER EMPTY

	SKIPL	LSTCHR(UUO)	;REG 1/25/74 DID TYO INVENT CRLF LAST TIME?
	JRST	DPTL2B		;NO. BEHAVE NORMALLY
	CAIN	CHR,15		;YES. CR'S GET FLUSHED NOW.
	JRST	DPTL2A		;
	MOVEM	CHR,LSTCHR(UUO)	;SAVE CHR
	MOVEI	CHR,12
	EXCH	CHR,LSTCHR(UUO)	;RESTORE CHR. LSTCHR NOW LOOKS LIKE NORMAL LF.
	CAIN	CHR,12		;FIRST LF AFTER LSTCHR WAS SET TO -1 IS FLUSHED.
	JRST	DPTL2A		;ONLY IF NO PREVIOUS CHARACTER (EXCEPT CR) SEEN

DPTL2B:
	PUSH P,CHR		; SAVE THE CHARACTER
	EXCH DAT,UUO		; GET PP CONTROL BLOCK ADDRESS IN DAT
	PUSHJ P,TYO		; SEND THE CHARACTER OUT
	CONO PI,SCNON
	EXCH DAT,UUO
	POP P,CHR

	SKIPGE LSTCHR(UUO)	;DID TYO INVENT CRLF AT LONG LINE?  REG 1/25/74
	MOVEI CHR,12		;YES. PRETEND WE WERE THE ONE WHO ASKED FOR LF.

	CAIN CHR,12		; IS IT END OF LINE TIME?
	SOSE LHCNT(DDB)		; YES, ARE WE SUPPOSED TO HOLD NOW?
	JRST DPYTL3		; NO, GO ON
	LDB AC1,HLINES		; YES, RESET HOLD COUNT
	MOVEM AC1,LHCNT(DDB)
	SETOM DPHOLD(DDB)
	JRST STAR

DPYTL3:
	SKIPE GLTCH(UUO)	; GLITCH TIME?
	SKIPE GLHCNT(DDB)	; YES, IS IT TIME TO HOLD?
	JRST DPYTL4
	LDB AC1,HGLTCH		; YES, RESET COUNT
	MOVEM AC1,GLHCNT(DDB)
	SETOM DPHOLD(DDB)
	JRST STAR

DPYTL4:
	JUMPL UUO,DPTDD		; IF DD, GO TO SPECIAL ROUTINE
;*** RPH PATCH TO SLOW DOWN OUTPUT OF BLANK LINES
	CAIE CHR,12
	CAIN CHR,15
	JRST DPYTLN
;*** END SLOW DOWN PATCH
	AOJN IOS,DPYTL2		; OTHERWISE, COUNT DOWN AND LOOP BACK
	JRST DPYTLN		; AND PUT IN ANOTHER CLOCK REQUEST IF TOO MANY CHARACTERS THIS TICK

; ROUTINE TO TYPE CTY ERROR MESSAGE ON ILLEGAL LINE NUMBER

DPYTER:
	PUSH P,DAT
	PUSHJ P,DISERR
	[ASCIZ /ILLEGAL LINE NUMBER AT DPYTYP - /]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	POP P,DAT
	POPJ P,

; ROUTINE TO TYPE STAR ON LINE THREE WHEN TYPEOUT IS HELD UP

STAR:
	JUMPG UUO,IISTAR	; SEPARATE ROUTINE FOR III
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; PICK UP ONE FOR THE OTHER FIELD
	MOVE AC2,(P)		; GET THE ADDRESS OF THE FIRST ONE BACK
	HRLI UUO,PPSTAR		; SET UP DISPATCH TO ROUTINE THAT DRAWS STAR ON LINE THREE
	MOVSM UUO,(AC1)		; SET IT IN FIRST TASK BLOCK
	MOVSM UUO,(AC2)		; AND IN SECOND ONE
	SETZM QCOUNT(AC1)	; DON'T WAKE ANYBODY UP ABOUT THIS
	SETZM QCOUNT(AC2)
	SETZM QFIELD(AC1)	; FIRST FIELD OF ERASURE
	SETOM QFIELD(AC2)	; SECOND FIELD
	MOVE AC3,[XWD 3,3]	; TELL QBLOCK WHERE TO QUEUE THIS REQUEST
	MOVEM AC3,QLINE(AC1)
	MOVEM AC3,QLINE(AC2)
	PUSHJ P,QBLOCK		; NOW QUEUE UP THE REQUESTS
	POP P,AC1
	JRST QBLOCK

IISTAR:
	MOVE AC1,PSELB(DDB)	; PICK UP GUY'S SELECT WORD
	AND AC1,[77B5]		; MASK OUT ALL BUT HIS SELECT BIT
	ORM AC1,DPYHLD		; SELECT HIM FOR THE MASSAGE
	LSH AC1,-=12		; MOVE OVER TO DESELECT FIELD
	ANDCAM AC1,DPYHLD
	POPJ P,

; ROUTINE, CALLED FROM CLOCK CALL WITH LINE NUMBER IN DAT, TO CONTINUE PAGE PRINTER

↑UNHOLD:
	HRLI DAT,DPYTYP		; SET UP TO COME BACK TO PRINT ROUTINE IF DONE
	TRNE DAT,-1⊗PUNITS	; IS THE LINE NUMBER LEGAL?
	JRST DPYTER		; NO, TYPE MESSAGE
	SKIPN DDB,TTYTAB(DAT)	; IS THERE A TTY DDB?
	POPJ P,			; NO, FORGET IT.
	HRRZ TAC1,DAT		; SAVE LINE NUMBER
	HRRI DAT,TTOBUF(DDB)	; PICK UP OUTPUT BUFFER ADDRESS
	MOVEI DSER,(DDB)	; COPY THE DEVICE DATA BLOCK POINTER
	HRRZ DDB,LETAB-DPYL0(TAC1)
	JUMPE DDB,DPYTY4	; IF NO PROGRAM HEADER, NO STAR TO ERASE
	SKIPN UUO,CURPP(DDB)	; GET ADDRESS OF PAGE PRINTER CONTROL BLOCK
	JRST DPYTY6		; IF NONE, GO MAKE ONE UP
	SKIPE PPDD(UUO)
	TLO DDB,400000
	HLL UUO,DDB
	JUMPG UUO,UNHIII
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ANOTHER ONE FOR THE OTHER FIELD
	MOVE AC2,(P)		; PICK UP ADDRESS OF FIRST ONE
	SETZM QFIELD(AC1)	; SEND IT OUT ON ONE FIELD
	SETOM QFIELD(AC2)	; THE OTHER ON THE OTHER
	HRLI UUO,ERASE		; DISPATCH TO THE ERASURE ROUTINE
	MOVSM UUO,(AC1)		; SET THAT IN DISPATCH ADDRESS
	MOVSM UUO,(AC2)
	SETZM QCOUNT(AC1)	; DON'T WAKE ANYBODY UP
	SETZM QCOUNT(AC2)
	MOVE AC3,[XWD 3,3]	; ERASE LINE 3
	MOVEM AC3,QLINE(AC1)
	MOVEM AC3,QLINE(AC2)
	PUSHJ P,QBLOCK
	POP P,AC1
	PUSHJ P,QBLOCK
	HRLI UUO,400000		; RESTORE DD FLAG
	JRST DPYTL1

UNHIII:
	MOVE AC1,PSELB(DDB)
	AND AC1,[77B5]
	ANDCAM AC1,DPYHLD
	LSH AC1,-=12
	ORM AC1,DPYHLD
	JRST DPYTL1

; COME HERE FOR DATA DISK TO SEE IF IT IS END OF LINE OR GLITCH TIME.

DPTDD:
	SKIPN GLTCH(UUO)	; HAS THE PAGE PRINTER GLITCHED?
	CAIN CHR,12		; OR IS THIS END OF LINE?
	JRST DPTDDK		; YES, QUEUE UP A DD REQUEST AND LEAVE
	JRST DPYTL2		; OTHERWISE, PUT IN ANOTHER CHARACTER

DPTDDK:
	HRRZ AC1,TPJMP(UUO)	; FIRST, IS THE P OF P ACTIVE?
	CAIN AC1,DISNOP
	JRST DPYTL2		; NO, JUST EMPTY THE BUFFER
	JRST QDDR

DPYTLN:
	HRR DAT,TAC1		; PUT IN LINE NUMBER AS DATUM
↑DPYTIM:CONO PI,PIOFF
	IDPB DAT,CLKQ		;PUT IN CLOCK REQUEST.
	CONO PI,PION
	POPJ P,

SUBTTL DATA DISK SERVICE ROUTINE - JAM, DEC. 1970

; THESE ROUTINES ARE CALLED BY THE FOLLOWING IN APRINT
;	SOSGE DDCNT
;	JRST DDCLK
;	SKIPE DDSTART
;	JRST DDSTRT
;APRADD:
; THE DATA DISK ROUTINES KNOW ALL ABOUT THE PAGE PRINTER
; AND THE PIECE OF GLASS MECHANISM. TRANSFERS ARE STARTED
; BY PLACING AN ADDRESS IN THE QUEUE WITH THE LEFT HALF GIVING
; THE TYPE OF TRANSFER.

; HERE ARE THE DD HARDWARE BITS
; CONO BITS

START←←100	; STARTS TRANSFER
RESET←←10	; RESETS INTERRUPT BIT
ENB←←40		; INTERRUPT ENABLE
LOSENB←←400	; ENABLE LATE FLAG INTERRUP
DAMMIT←←20	; MAKES TRANSFER GO OUT ON SPECIFIC FIELD
EXECM←←1000	; EXEC MODE, ALLOWS ONLY ONE CHANNEL SELECT
DDNXM←←2000	; NON-EX MEM FLAG
USUAL←←START!ENB!LOSENB!DAMMIT!APRCHN

; CONI BITS
FIELD←←40	; FIELD BIT
INT←←20		; INTERRUPT BIT
LOSE←←200	; LATE FLAG

; $M+2/     -1775,,770707

; TASKS ARE QUEUED UP IN SMALL BLOCKS IN THE FOLLOWING FORM:

		; FIRST WORD CONTAINS XWD <RELEVANT DATA BLOCK>,<ROUTINE>
QLINE←←1	; XWD <STARTING LINE #>,<ENDING LINE #>
QFIELD←←2	; 0 FOR EVEN FIELD, -1 FOR ODD FIELD
QHPOS←←3	; XWD <HPOS1>,<HPOS2> FOR CURSOR TRANSFERS. ZERO ERASES CURSORS.
QLINK←←4	; LINKAGE WORD. XWD <BACKWARD LINK OR 0>,<FORWARD LINK OR 0>
QWAKE←←5	; CONTAINS JOB NUMBER TO WAKE UP, OR CLOCK REQUEST TO PLANT
QCOUNT←←6	; ADDRESS OF WORD TO DECREMENT WHEN THIS TASK DONE. WHEN ZERO, WAKE UP VIA QWAKE WHOMEVER
QTIME←←7	; COUNT DOWN OF NUMBER OF FAILURES
↑QLENGTH←←10	; LENGTH OF A TASK BLOCK

; CLOCK LEVEL QUEING SCHEME. PLANTS TASKS IN QUEUE AND LEAVES.
; LAST TASK TO FINISH PLANTS CLOCK REQUEST TO TRANSFER MORE DATA.

QDDR:
	MOVE AC3,VPOS(UUO)	; PICK UP VERTICAL POSITION
	SUBI AC3,1		; DON'T GO ALL THE WAY TO THE CURRENT LINE
	MOVEM AC3,VP(UUO)	; STORE IT
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ADDRESS OF FIRST TASK BLOCK
	PUSHJ P,GETQ		; GET ANOTHER TASK BLOCK
	MOVE AC2,(P)		; PICK UP ADDRESS OF FIRST TASK BLOCK TOO
	HRR DAT,TAC1		; PUT IN LINE NUMBER AS DATUM OF CLOCK REQUEST
	MOVEM DAT,QWAKE(AC1)	; PUT THE OUTPUT BUFFER ADDRESS AS WAKEUP WORD
	MOVEM DAT,QWAKE(AC2)
	AOS PPENQ(UUO)		; BUMP TASK COUNT BY TWO
	AOS PPENQ(UUO)
	MOVEI AC3,PPENQ(UUO)	; COUNT US DOWN ON THE PAGE PRINTER COUNTER
DOXFR:
	SETZM PPVIRG(UUO)	; NOTE THAT SOMETHING HAS GONE OUT ON THIS PIECE OF PAPER
	MOVEM AC3,SC(UUO)	; SAVE THE COUNT ADDRESS, IF ANY, FOR FUTURE REFERENCE
	MOVEM AC3,QCOUNT(AC1)
	MOVEM AC3,QCOUNT(AC2)
	SETZM QFIELD(AC1)	; SEND ONE OUT ON ONE FIELD
	SETOM QFIELD(AC2)	; AND THE OTHER OUT ON THE OTHER
	HRLM UUO,(AC1)
	HRLM UUO,(AC2)		; SAVE PAGE PRINTER CONTROL BLOCK ADDRESS AS DATA BLOCK ADDRESS
	MOVEI AC3,PPXFR		; PICK UP ADDRESS OF I-LEVEL SUBROUTINE
	HRRM AC3,(AC1)		; PLACE IT IN ROUTINE ADDRESS POSITION
	HRRM AC3,(AC2)
	SKIPN GLTCH(UUO)	; IS THIS A WHOLE SCREEN TRANSFER?
	JRST DPTDL		; NO, JUST DO ONE LINE
	SETZM GLTCH(UUO)	; WE ARE DONE GLITCHING
	EXCH DAT,UUO		; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	PUSHJ P,POSLIN		; GET LINE NUMBER OF FIRST LINE OF TRANSFER
	EXCH DAT,UUO
	CAML AC3,VPOS(UUO)	; IS THERE REALLY A PAGE HERE?
	JRST NOPAGE		; NO!
	HRLM AC3,QLINE(AC1)
	HRLM AC3,QLINE(AC2)	; THAT WILL BE STARTING LINE NUMBER ON BOTH FIELDS
	MOVE AC3,VP(UUO)	; PICK UP NUMBER OF LAST LINE OF TRANSFER
	HRRM AC3,QLINE(AC1)	; THIS WILL BE ENDING LINE NUMBER
	HRRM AC3,QLINE(AC2)
	PUSHJ P,QBLOCK		; QUEUE UP FIRST TASK
	POP P,AC1		; GET ADDRESS OF SECOND TASK BACK
	PUSHJ P,QBLOCK		; QUEUE IT UP

; WE GET HERE AT CLOCK LEVEL IN THE MIDDLE OF QUEUEING UP A WHOLE SCREEN REQUEST.
; WE HAVE PUT IN THE TEXT REQUESTS AND ARE NOW GOING TO PUT IN THE ERASURE
; REQUEST.

	MOVE AC2,VP(UUO)	; FIRST, IS THERE ANYTHING TO DO?
	MOVEM AC2,LLW(UUO)	; UPDATE LAST LINE WRITTEN
	CAML AC2,GLW(UUO)
	POPJ P,			; NO, WE ARE DONE
	PUSHJ P,GETQ
	PUSH P,AC1		; GET ANOTHER TASK BLOCK AND SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ONE FOR EACH ERASURE FIELD
	MOVE AC3,(P)		; GET BACK ADDRESS OF FIRST ONE
	HRLM UUO,(AC1)		; PUT IN PAGE PRINTER CONTROL BLOCK ADDRESS
	HRLM UUO,(AC3)
	MOVEI AC2,ERASE		; WE WILL CALL THE ERASE CODE
	HRRM AC2,(AC1)
	HRRM AC2,(AC3)
	MOVEM DAT,QWAKE(AC1)	; PUT THE CLOCK REQUEST WORD IN
	MOVEM DAT,QWAKE(AC3)
	MOVE AC2,SC(UUO)	; PICK UP COUNT ADDRESS
	MOVEM AC2,QCOUNT(AC1)	; COUNT DOWN THROUGH IT.
	MOVEM AC2,QCOUNT(AC3)
	SETZM QFIELD(AC1)	; SEND THEM OUT ON OPPOSITE FIELDS
	SETOM QFIELD(AC3)
	MOVE AC2,GLW(UUO)	; ERASE TO THE LAST LINE WRITTEN
	HRRM AC2,QLINE(AC1)
	HRRM AC2,QLINE(AC3)
	MOVE AC2,VP(UUO)	; ERASE FROM THE CURRENT POSITION
	MOVEM AC2,GLW(UUO)	; UPDATE LAST LINE WRITTEN
	HRLM AC2,QLINE(AC1)
	HRLM AC2,QLINE(AC3)
	SKIPN SC(UUO)		; IS THERE A COUNT ADDRESS?
	JRST QDD1		; NO, DON'T INCREMENT IT!
	AOS @SC(UUO)		; YES, BUMP IT TWICE
	AOS @SC(UUO)
QDD1:
	PUSHJ P,QBLOCK		; QUEUE UP THE FIRST ONE
	POP P,AC1
	JRST QBLOCK		; AND THE SECOND ONE

; WE GET HERE IF THERE REALLY ISN'T ANYTHING ON THE PAGE

NOPAGE:
	PUSHJ P,WAKEQ		; WAKE UP ANYONE WHO'S THERE
	PUSHJ P,GIVQB		; JUST RETURN EVERYTHING TO FREE STORAGE.
	POP P,AC1
	PUSHJ P,WAKEQ
	JRST GIVQB

; WE GET HERE TO QUEUE UP A ONE LINE REQUEST.

DPTDL:
	MOVE AC3,LLW(UUO)	; PICK UP LINE NUMBER
	CAMLE AC3,VP(UUO)	; IS THIS PAST WHERE WE ARE SUPPOSED TO BE?
	MOVE AC3,VP(UUO)	; YES, USE OUR ARGUEMENT
	HRLM AC3,QLINE(AC1)	; STORE THIS
	HRLM AC3,QLINE(AC2)
	MOVE AC3,VP(UUO)	; END UP ON LINE THE CALLER REQUESTED
	HRRM AC3,QLINE(AC1)
	HRRM AC3,QLINE(AC2)
	MOVEM AC3,LLW(UUO)	; AND THIS IS NOW THE LAST LINE WRITTEN
	PUSHJ P,QBLOCK		; PUT THIS BLOCK IN THE QUEUE
	POP P,AC1		; GET BACK ADDRESS OF SECOND BLOCK
	JRST QBLOCK		; QUEUE IT UP TOO

; WE GET TO THIS ROUTINE WHEN THE BUFFER IS EMPTY.

DPYTLX:
	JUMPG UUO,DPYDON	; III DISPLAYS CAN GO ON TO TTYSER NOW
	SKIPN DPYCHR(UUO)	; HAS AT LEAST ONE CHARACTER BEEN TYPED?
	JRST DPYDON		; NO, EXIT
	SETZM DPYCHR(UUO)	; CLEAR TYPEOUT FLAG
	MOVN AC1,DPHPOS(UUO)	; PICK UP HORIZONTAL POSITION POINTER
	PUSH P,DAT		; SAVE TTY BUFFER ADDRESS
	HRR DAT,UUO		; PUT PAGE PRINTER CONTROL BLOCK ADDRESS IN DAT FOR REFLINE
	MOVE AC2,LLW(UUO)	; SEE IF PAGE PRINTER IS UP TO DATE
	CAMN AC2,VPOS(UUO)	; COMPARE LAST LINE WRITTEN WITH VERTICAL POSITION
	CAME AC1,LNLNGT(UUO)	; IF NOT AT COLUMN ZERO,
	PUSHJ P,REFLINE		; PUT IN A SINGLE LINE REQUEST
	POP P,DAT
	HRRZ AC1,HEDPTR(UUO)	; PICK UP POINTER TO DPY PROGRAM HEADER
	MOVSI AC2,DPLED		; MAKE A POINTER TO THE LINE EDITOR QUEUE ROUTINE
	HRR AC2,AC1		; AND MAKE IT INTO A CLOCK REQUEST WORD
	SETO AC3,		; SEE IF LINE EDITOR CLOCK FLAG IS SET
	EXCH AC3,LECLK(AC1)	; IF NOT SET, SET IT NOW
	JUMPL AC3,DPYDON	; IF ALREADY IN, LEAVE NOW
	CONO PI,PIOFF		; NOT IN, PLANT CLOCK REQUEST
	IDPB AC2,CLKQ
	CONO PI,PION
	JRST DPYDON

; THIS ROUTINE QUEUES UP AN ERASURE REQUEST FOR THE LINE EDITOR <ESC>C COMMAND

↑LEERSN:TLCA DAT,LEERSN≠PPNSET	;CHANGE CLK RQ TO CALL PPNSET
↑RFPCS:	HRLI DAT,LERFP
	SKIPE III(DAT)
	JRST LEPGC
	MOVEI AC2,LEENQ2(DAT)	;ENTER HERE FOR SOMETHING ELSE TO BE QUEUED AFTER THE ERASE
	AOSA LEENQ2(DAT)
↑LEERS:	MOVEI AC2,
	SKIPE III(DAT)
	JRST LEPGC2		;DIFFERENT "ERASE" ON III
	PUSHJ P,GETQ		; GET A TASK BLOCK
	MOVEM AC2,QCOUNT(AC1)
	MOVEM DAT,QWAKE(AC1)
	SETOM LECC(DAT)
LEERS3:
	MOVE AC2,[XWD 1,=40]
	MOVEM AC2,QLINE(AC1)
	SETZM QFIELD(AC1)	; START ON FIELD ZERO
	HRLM DAT,(AC1)		; GIVE IT DPY PROGRAM HEADER ADDRESS
	MOVEI AC2,WSE		; GO TO THE ERASURE ROUTINE
	HRRM AC2,(AC1)
	SETOM LEVP(DAT)		;TELL DPLED OUR CURSORS BIT THE DUST
	SETOM LECVP(DAT)
	JRST QBLOCK		; PUT IT IN THE QUEUE

LEPGC:
	HLRZ TAC,DAT
	PUSH P,DAT
	PUSHJ P,(TAC)		;DO PP STUFF FIRST
	POP P,DAT
LEPGC2:
	MOVEI DDB,(DAT)
	JRST PGCLR

; THE LINE EDITOR PLANTS A CLOCK REQUEST TO HERE WHEN IT
; IS DONE TRANSFERRING A LINE INTO THE PAGE PRINTER BUFFER.
; WE SEND OUT THE LINE IT HAS JUST TRANSFERRED.

↑REFLINE:
	HRRZ AC1,TPJMP(DAT)	; PICK UP JUMP TO TEXT
	CAIN AC1,DISNOP		; IS IT REALLY A JUMP?
	POPJ P,			; NO, DON'T BOTHER
	PUSHJ P,GETQ		; GET US A TASK BLOCK
	PUSH P,AC1
	PUSHJ P,GETQ
	MOVE AC2,(P)
	MOVE AC3,VPOS(DAT)	; PICK UP VERTICAL POSITION
	MOVEM AC3,VP(DAT)	; SAVE THIS AS ARGUEMENT FOR QDD
	MOVEI AC3,PPNQT(DAT)	; COUNT DOWN THROUGH OTHER COUNT CELL
	HRRZ UUO,DAT		; IT EXPECTS THE PAGE PRINTER ADDRESS IN UUO
	AOS PPNQT(DAT)		; COUNT DOWN SO THE LINE EDITOR WILL KNOW WHEN WE ARE DONE
	AOS PPNQT(DAT)
	SETZM QWAKE(AC1)	; DON'T WAKE UP ANYBODY
	SETZB DAT,QWAKE(AC2)
	JRST DOXFR		; USE QDD TO DO ALL THIS

; HERE LIES A ROUTINE TO QUEUE UP A WHOLE PAGE TRANSFER WHEN NOT GLITCHING

↑LERFP:	MOVEI DDB,(DAT)
	SKIPE III(DAT)
	JRST PPRST		;RESTART PROG IF III
	HRRZ UUO,CURPP(DAT)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVE AC1,HEDPTR(UUO)
	CAIE AC1,(DAT)
	JRST PPCLB		;CURPP IS CLOBBERED OR SOMETHING
	HRRZ AC1,TPJMP(UUO)	; PICK UP JUMP TO TEXT
	CAIN AC1,DISNOP		; IS IT REALLY A JUMP?
	POPJ P,			; NO, FORGET IT
	SKIPE PPENQ(UUO)	; IS THERE ANYTHING IN THE PAGE PRINTER'S QUEUE?
	JRST LERFP1		; YES, IT WILL GET CAUGHT LATER
	SETZM PPVIRG(UUO)	; NO LONGER A VIRGIN PIECE OF PAPER
	JSP AC3,GET2Q
	MOVEI AC3,LEENQ2(DAT)
	MOVEM AC3,QCOUNT(AC1)
	MOVEM AC3,QCOUNT(AC2)
	MOVEI AC3,2
	ADDM AC3,LEENQ2(DAT)
	HRR AC3,DAT
	HRLI AC3,LERELE
	MOVEM AC3,QWAKE(AC1)
	MOVEM AC3,QWAKE(AC2)
	HRLM UUO,(AC1)		; PUT IN ADDRESS OF PAGE PRINTER CONTROL BLOCK
	HRLM UUO,(AC2)
	MOVEI AC3,PPXFR		; THE I-LEVEL SUBROUTINE ADDRESS
	HRRM AC3,(AC1)
	HRRM AC3,(AC2)
	EXCH DAT,UUO		; PICK UP THE NUMBER OF THE LINE AT THE TOP OF THE PAGE
	PUSHJ P,POSLIN
	EXCH DAT,UUO
	HRLM AC3,QLINE(AC1)	; PUT IN THAT AS OUR STARTING LINE NUMBER
	HRLM AC3,QLINE(AC2)
	MOVE AC3,VPOS(UUO)	; PICK UP THE CURRENT POSITION OF THE BOTTOM OF THE PAGE
	HRRM AC3,QLINE(AC1)
	HRRM AC3,QLINE(AC2)
Q2BLCK:
	PUSHJ P,QBLOCK		; QUEUE THEM UP
	POP P,AC1
	JRST QBLOCK		; QUEUE UP THE LAST TASK AND LEAVE

LERFP1:
	SETOM GLTCH(UUO)	; FORCE THE PAGE PRINTER TO REFRESH NEXT TIME AROUND
	POPJ P,

GET2Q:
	
	PUSHJ P,GETQ		; OTHERWISE, GET A TASK BLOCK TO DO IT OURSELVES
	PUSH P,AC1
	PUSHJ P,GETQ
	HRRZ AC2,(P)
	SETZM QFIELD(AC1)	; SEND THESE OUT ON OPPOSITE FIELDS
	SETOM QFIELD(AC2)
	JRST @AC3

LERELE:
		;REFRESH LINE EDITOR
	EXCH DAT,ITEM
	PUSHJ P,QLETXT		;QLETXT IS IN LINED
	EXCH DAT,ITEM
	POPJ P,

PPCLB:
	PUSHACS
	PUSHJ P,DISDAT
	PUSHJ P,DISMES
	ASCIZ /CURPP CLOBBERED AT LERELE
/
	DEBCHE
	POPACS
	POPJ P,

; HERE IS THE MIGHTY LINE EDITOR AND CURSOR GENERATOR.
; THIS ROUTINE SINGLEHANDEDLY SENDS OUT LINE EDITOR TRANSFERS, LINE EDITOR
; ERASURES, ALL CURSORS AND ALL CURSOR ERASURES.

↑DPLED:	HGMAC(33)
	SKIPE LEENQ(DAT)	; DO WE HAVE SOMETHING IN THE QUEUE ALREAD
	POPJ P,			; YES, THIS ISN'T SUPPOSED TO HAPPEN!
	HRRZ UUO,CURPP(DAT)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	SKIPE PPENQ(UUO)	; IS THERE ANYTHING IN THE PAGE PRINTER QUEUE?
	JRST DPYTIM		; YES, COME BACK LATER
	CONO PI,SCNOFF		;FREEZE EVERYTHING
	MOVE AC1,VPOS(UUO)	; ASSUME WE ARE GOING IN THE USUAL POSITION
	MOVEM AC1,LELINE(DAT)
	MOVE AC1,DPHPOS(UUO)
	ADD AC1,LNLNGT(UUO)
	MOVEM AC1,PPHPOS(DAT)	;INITIALLY ASSUME LINE EDITOR X = PP X
	SKIPL AC3,LEPOS(DAT)
	JRST DPLEVS
	LDB AC3,[POINT 11,AC3,21]
	TRNE AC3,1⊗=10		; EXTEND SIGN BIT
	OR AC3,[-1⊗=10]
	PUSHJ P,POSLI2
	MOVEM AC3,LELINE(DAT)
	SETZB AC1,PPHPOS(DAT)	;NOW LINE EDITOR X IS ALWAYS ZERO
DPLEVS:
	MOVEI AC3,LEENQ(DAT)	; GET ADDRESS OF COUNT WORD
	MOVEM AC3,SC(UUO)	; USE IT TO COUNT DOWN OUR TASKS
	MOVE AC3,PRGNUM(DAT)	; PICK UP DPY NUMBER
	SKIPG J,LETAB(AC3)	; IS THE LINE EDITOR CURRENTLY INITIALIZED??
	JRST DPLGCP		; YES, GET ITS POSITION FROM THE CHARACTER COUNT

; HERE WE SET UP THE CURSOR POSITION AND START ON THE DECISION TREE

DPLGC2:
	MOVEM AC1,CHP(DAT)	; SAVE THE HORIZONTAL POSITION
	MOVE AC1,LELINE(DAT)
DPLGC1:
	MOVEM AC1,CVP(DAT)	; AND THE VERTICAL POSITION
	MOVE AC1,LELINE(DAT)	; GET VERTICAL POSITION
	CAMN AC1,LEVP(DAT)	; HAS THE VERTICAL POSITION OF THE LINE EDITOR CHANGED?
	JRST DPTLE1		; NO, SEE IF ANYTHING ELSE HAS CHANGED.
	PUSHJ P,DPEC		; ERASE THE LINE EDITOR CURSOR
	PUSHJ P,DPEOPC		; ERASE THE PAGE PRINTER CURSOR
	PUSHJ P,DPWT		; WRITE OUT THE TEXT AGAIN.
	MOVE AC1,CVP(DAT)	; PICK UP CURSOR POSITION
	CAMN AC1,LELINE(DAT)	; IS IT THE SAME AS THE PAGE PRINTER POSITION?
	JRST DPTL14		; YES, WRITE OUT BOTH CURSORS ON THE SAME LINE
	PUSHJ P,DPWC		; NO, WRITE OUT THE LINE EDITOR CURSOR
	PUSHJ P,DPWPC		; THEN WRITE OUT THE PAGE PRINTER CURSOR
	JRST DPTLE5		; GO UPDATE STATE OF HISTORY TO REFLECT OUR TRANSFERS.

DPTL14:
	PUSHJ P,DPWB		; SAME LINE, WRITE OUT BOTH CURSORS AT ONCE
	JRST DPTLE5

DPLGCP:
	ADD AC1,LEHPOS(DAT)	; ADD IN LINE EDITOR CURSOR HORIZONTAL POSITION
	JUMPE AC1,DPLGC2	; IF NO DISTANCE INTO LINE, SET POSITIONS TO ZERO
	IDIV AC1,LNLNGT(UUO)	; CONVERT TO NUMBER OF LINES AND DISPLACEMENT INTO LAST LINE
	ADD AC1,LELINE(DAT)	; ADD IN STARTING LINE NUMBER
	MOVEM AC2,CHP(DAT)	; THE REMAINDER IS THE HORIZONTAL POSITION
	JRST DPLGC1		; AND WE NOW HAVE IT ALL!

; WE GET HERE IF THE VERTICAL POSITION OF THE LINE EDITOR HAS NOT CHANGED.
; WE CHECK IF ANYTHING ELSE ABOUT THE LINE MIGHT HAVE CHANGED.

DPTLE1:
	JUMPGE J,DPTL1A		;DON'T BOTHER CHECKING EMPTY EDITOR
	MOVE AC1,PPHPOS(DAT)
	EXCH AC1,LSTHP(DAT)
	CAMN AC1,LSTHP(DAT)	;SEE IF LE HAS MOVED HORIZONTALLY
	JRST DPTL1A		;NO
	PUSHJ P,LEFIX		;YES - RECALCULATE TABS & LONG-LINE CRLFS
	SETOM LETXC(DAT)	;TEXT NOW NEEDS WRITING
DPTL1A:
	MOVE AC1,NCRS(DAT)	; WE GET HERE IF THE VERTICAL POSITION IS THE SAME
	CAMGE AC1,LENCRS(DAT)	; NOW HAS THE LINE SHRUNK ANY?
	PUSHJ P,DPEOSL		; YES, ERASE LINES PAST FIRST ONE.
	MOVE AC1,CVP(DAT)	; PICK UP CURSOR VERTICAL POSITION
	CAME AC1,LECVP(DAT)	; HAS THE CURSOR VERTICAL POSITION CHANGED?
	JRST DPTLE2		; YES, SEE HOW MUCH AND WHERE IT IS NOW.
	MOVE AC1,CHP(DAT)	; IF THE VERTICAL POSITION IS THE SAME,
	CAME AC1,LECHP(DAT)	; THEN HOW ABOUT THE HORIZONTAL POSITION?
	JRST DPTLE3		; DIFFERENT, GO SEND OUT A NEW ONE.
	MOVE AC1,PPHPOS(DAT)	;SEE IF PP CURSOR MOVED
	CAME AC1,LEHP(DAT)
	JRST DPTLE6		; YES, GO SEND IT OUT AGAIN
	SKIPN LETXC(DAT)	; HAS THE TEXT CHANGED?
	SKIPE LEMISS(DAT)	; OR DID THE LINE EDITOR MISS A BEAT DUE TO AN INVALID BUFFER?
	JRST DPTL12		; YES, SEND OUT THE TEXT AGAIN
	SETZM LECLK(DAT)	; NO, NOTHING AT ALL TO DO!
	CONO PI,SCNON
	POPJ P,

; LINE EDITOR DECISION TREE. WE GET HERE IF THE LINE EDITOR CURSOR HAS NOT
; MOVED, BUT THE PAGE PRINTER CURSOR HAS(???)

DPTLE6:
	MOVE AC1,CVP(DAT)	; ARE THE TWO CURSORS ON THE SAME LINE?
	CAME AC1,VPOS(UUO)
	JRST DPTLE7		; NO, THEY CAN BE SENT OUT SEPARATELY.
DPTLE9:
	PUSHJ P,DPWB		; YES, SEND OUT BOTH
	JRST DPTLE4

DPTLE7:
	PUSHJ P,DPWPC		; WRITE OUT THE PAGE PRINTER CURSOR ALONE
	JRST DPTLE4		; DO TEXT CHECK AND LEAVE

DPTLE2:
	MOVE AC1,LELINE(DAT)	; WE COME HERE IF THE CURSOR VERTICAL POSITION HAS CHANGED
	CAME AC1,LECVP(DAT)	; IS THE OLD VERTICAL POSITION THE SAME AS THE PAGE PRINTER?
	PUSHJ P,DPEC		; NO, ERASE THE OLD CURSOR
	MOVE AC1,LELINE(DAT)	; PICK UP VERTICAL POSITION AGAIN
	CAMN AC1,CVP(DAT)	; IS IT THE SAME AS THE CURSOR POSITION?
	JRST DPTLE9		; YES, SEND OUT BOTH CURSORS
DPTLE8:
	PUSHJ P,DPWPC		; NO, SEND OUT THE PAGE PRINTER'S
DPTL11:
	PUSHJ P,DPWC		; SEND OUT THE LINE EDITOR CURSOR TOO
	JRST DPTLE4

DPTLE3:
	PUSHJ P,DPEC		; ERASE THE CURSOR
	MOVE AC1,LELINE(DAT)	; PICK UP THE VERTICAL POSITION
	CAMN AC1,CVP(DAT)	; IS IT THE SAME AS THE CURSOR POSITION
	JRST DPTLE9		; YES, SEND THEM BOTH OUT
	PUSHJ P,DPWC		; WRITE OUT OUR CURSOR
	MOVE AC1,PPHPOS(DAT)	;GET PP CURSOR POS
	CAME AC1,LEHP(DAT)	; IS IT THE SAME AS THE CURRENT POSITION?
	PUSHJ P,DPWPC		; NO, WRITE OUT ANOTHER PAGE PRINTER CURSOR
	JRST DPTLE4		; YES, NO NEED TO WRITE A NEW ONE

; EVERYBODY COMES HERE TO EXIT

DPTLE4:
	SKIPN LETXC(DAT)	; HAS THE TEXT CHANGED?
	SKIPE LEMISS(DAT)	; OR DID I-LEVEL MISS DUE TO BUFFER INVALID?
DPTL12:
	PUSHJ P,DPWT		; YES, QUEUE UP A TEXT REQUEST
DPTLE5:
	MOVE AC1,LELINE(DAT)	; SAVE NEW STATE OF LINE EDITOR AND CURSORS
	MOVEM AC1,LEVP(DAT)
	MOVE AC1,PPHPOS(DAT)
	MOVEM AC1,LEHP(DAT)
	MOVE AC1,NCRS(DAT)	; NUMBER OF CRLFS IN LINE TOO
	MOVEM AC1,LENCRS(DAT)
	MOVE AC1,CVP(DAT)	; CURSOR VERTICAL POSITION
	MOVEM AC1,LECVP(DAT)
	SETZM LETXC(DAT)	; CLEAR THE FLAGS
	SETZM LEMISS(DAT)
	MOVE AC1,CHP(DAT)	; CURSOR HORIZONTAL POSITION
	MOVEM AC1,LECHP(DAT)
	CONO PI,SCNON
	POPJ P,			; BYE NOW. Y'ALL HAVE A GOOD TIME!

; THIS ROUTINE QUEUES UP A LINE EDITOR TEXT REQUEST

DPWT:
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1		; SAVE ITS ADDRESS
	PUSHJ P,GETQ		; GET ANOTHER ONE
	MOVE AC2,(P)		; PICK UP ADDRESS OF FIRST ONE AGAIN
	MOVEI AC3,LEXFR		; CALL THE LINE EDITOR I-LEVEL ROUTINE
	HRRM AC3,(AC1)		; PUT IT IN THE DISPATCH ADDRESS OF EACH TASK BLOCK
	HRRM AC3,(AC2)
	MOVE AC3,LELINE(DAT)	; PICK UP VERTICAL POSITION OF LINE EDITOR BUFFER
	HRLM AC3,QLINE(AC1)	; START THE TRANSFER HERE
	HRLM AC3,QLINE(AC2)
	HRLM DAT,(AC1)		; PUT IN ADDRESS OF DPY PROGRAM HEADER
	HRLM DAT,(AC2)
	ADD AC3,NCRS(DAT)	; GET NUMBER OF LAST LINE OF TRANSFER
DPWT1:
	HRRM AC3,QLINE(AC1)	; SET THAT AS LAST LINE
	HRRM AC3,QLINE(AC2)
	SETZM QFIELD(AC1)	; SEND OUT TASKS OUT ON OPPOSITE FIELDS
	SETOM QFIELD(AC2)
	HRLI DAT,DPLED		; MAKE UP A CLOCK REQUEST WORD
	MOVEM DAT,QWAKE(AC1)
	MOVEM DAT,QWAKE(AC2)
	SKIPN AC3,SC(UUO)	; IS THERE A COUNT WORD?
	JRST DPWT2		; NO, DON'T BOTHER
	AOS @SC(UUO)		; YES, BUMP IT TWICE
	AOS @SC(UUO)
DPWT2:
	MOVEM AC3,QCOUNT(AC1)
	MOVEM AC3,QCOUNT(AC2)
	PUSHJ P,QBLOCK		; QUEUE UP THE FIRST ONE
	POP P,AC1		; GET THE ADDRESS OF THE SECOND ONE
	JRST QBLOCK		; QUEUE IT UP TOO.

; THIS ROUTINE ERASES THE OLD SECOND LINE OF THE LINE EDITOR

DPEOSL:
	PUSHJ P,GETQ		; GET A TASK BLOCK
	PUSH P,AC1
	PUSHJ P,GETQ
	MOVE AC2,(P)
	MOVEI AC3,ERASE
	HRRM AC3,(AC1)
	HRRM AC3,(AC2)
	MOVE AC3,LELINE(DAT)	; PICK UP VERTICAL POSITION
	ADD AC3,NCRS(DAT)	; ADD IN LENGTH OF TRANSFER
	ADDI AC3,1		; BUMP LINE NUMBER TO ONE PAST THE CURRENT LAST LINE
	HRLM AC3,QLINE(AC1)	; PUT THAT IN AS STARTING AND ENDING LINE
	HRLM AC3,QLINE(AC2)
	MOVE AC3,LEVP(DAT)	; PICK UP LAST VERTICAL POSITION
	ADD AC3,LENCRS(DAT)	; ADD IN LENGTH OF LAST TRANSFER
DPEOS1:
	HRLM UUO,(AC1)		; PUT IN ADDRESS OF PAGE PRINTER CONTROL BLOCK
	HRLM UUO,(AC2)
	JRST DPWT1

; THIS ROUTINE ERASES THE OLD CURSOR

DPEC:
	SKIPA AC2,LECVP(DAT)	;OLD POSITION
DPEOPC:
	MOVE AC2,LEVP(DAT)	;SAME THING FOR PP CURSOR
	JUMPL AC2,CPOPJ		;WARN'T NONE
	PUSHJ P,GETQ
DPEC1:
	HRLM AC2,QLINE(AC1)	; PUT THAT IN AS STARTING LINE
;	ADDI AC2,1		; BUMP IT BY ONE
	HRRM AC2,QLINE(AC1)	; FOR PESSIMISM
	SETOM QHPOS(AC1)	; CLEAR THE HORIZONTAL POSITION, INDICATING CURSOR ERASURE
DPEC2:
	SETZM QFIELD(AC1)	; GOING OUT ON FIELD 1
	HRLI DAT,DPLED
	MOVEM DAT,QWAKE(AC1)	; WAKE UP THE LINE EDITOR DECISION TREE WHEN DONE
	MOVE AC3,SC(UUO)	; COUNT THROUGH OUR COUNTER TOO
	MOVEM AC3,QCOUNT(AC1)
	SKIPE SC(UUO)		; IS THERE A COUNT WORD?
	AOS @SC(UUO)		; YES, BUMP IT BY ONE
	HRLM UUO,(AC1)		; SAVE THE PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVEI AC3,CURSOR	; USE THE CURSOR SUBROUTINE
	HRRM AC3,(AC1)
	JRST QBLOCK		; QUEUE UP THE REQUEST

; THESE ROUTINES QUEUE UP THE VARIOUS COMBINATIONS OF CURSORS THAT MAY ARISE.

DPWPC:
	PUSHJ P,GETQ		; GET A TASK BLOCK FOR THE PAGE PRINTER'S CURSOR
	MOVE AC2,LELINE(DAT)	; GET IT'S VERTICAL POSITION
	MOVE AC3,PPHPOS(DAT)
DPWPC1:
	SETOM QHPOS(AC1)	; CLEAR OUT ONE OF THE HORIZONTAL POSITION WORDS
DPWPC2:
	HRLM AC2,QLINE(AC1)	; STORE THE STARTING LINE NUMBER OF THE TRANSFER
;	ADDI AC2,1		; FOR SAFETY, MAKE IT LOOK LIKE IT IS TWO LINES LONG
	HRRM AC2,QLINE(AC1)	; AND STORE THAT AS THE DESTINATION LINE NUMBER
	HRLM AC3,QHPOS(AC1)	; STORE THE HORIZONTAL POSITION
	JRST DPEC2		; FINISH QUEUEING UP THE BLOCK

; THIS ROUTINE QUEUES UP A LINE EDITOR CURSOR ONLY.

DPWC:
	PUSHJ P,GETQ		; GET A TASK BLOCK
	MOVE AC2,CVP(DAT)	; PICK UP THE CURSOR VERTICAL POSITION
	MOVE AC3,CHP(DAT)	; GET THE HORIZONTAL POSITION
	JRST DPWPC1		; LET THE ABOVE ROUTINE DO ALL THE WORK

; THIS ROUTINE QUEUES UP A TRANSFER WITH TWO CURSORS ON THE SAME LINE

DPWB:
	PUSHJ P,GETQ
	MOVE AC2,LELINE(DAT)
	MOVE AC3,CHP(DAT)	; PICK UP THE LINE EDITOR CURSOR'S HORIZONTAL POSITION
	HRRM AC3,QHPOS(AC1)	; PUT IT IN AS ONE OF THE HORIZONTAL POSITIONS INVOLVED
	MOVE AC3,PPHPOS(DAT)	;GET PP CURSOR POS
	JRST DPWPC2		; USE IT TOO.

;QBLOCK	  HERE IS THE MAGIC SCHEDULING QUEUE ROUTINE
; IT IS CALLED WITH THE ADDRESS OF A TASK BLOCK IN AC1. SAID BLOCK
; MUST HAVE QLINE AND QFIELD SET, BECAUSE THE BLOCK IS MERGED INTO
; THE QUEUE STRUCTURE IN THE RIGHT PLACE ON THE BASIS OF THOSE DATA.

;   ∃ BLOCKS CALLED "FRAMES".  EACH FRAME HAS A POINTER TO A LIST OF ONE OR
; MORE TASK BLOCKS, ALL OF WHICH HAVE THE SAME FIELD (EITHER EVEN OR ODD).
; THE TASK BLOCKS ARE LISTED IN ASCENDING ORDER OF LINE NUMBER. IN GENERAL,
; THE LIST OF FRAMES ALTERNATES BY FIELD PARITY, THE EXCEPTION BEING 
; "MISSING" FRAMES.  FRAME BLOCK FORMAT IS:
;
; 		XWD 0,<POINTER TO NEXT FRAME, OR 0>
;	QLINE:	BITS 0-19 INDICATE WHICH LINES ARE USED BY TASK BLOCKS
;		  IN THIS FRAME.  BITS 0,1,2 FOR LINES 1&2,3&4,5&6, ETC.
;	QFIELD:	SAME AS IN A TASK BLOCK, 0 OR -1 FOR EVEN OR ODD FIELD.
;	QHPOS:	NOT USED
;	QLINK:	XWD 0,<ADDRESS OF 1ST TASK BLOCK>

QBLOCK:
	HGMAC(32)
	MOVEI AC2,10		; SET FOR 8 TIMES THROUGH
	MOVEM AC2,QTIME(AC1)	; BEFORE WE DECLARE IT A LOSING TRANSFER
REQBLK:
	HRRZ AC2,(AC1)
	CAIL AC2,PPXFR
	CAILE AC2,PPSTAR
	JRST QBLERR
	HLRZ AC2,(AC1)
	CAML AC2,MEMSIZ
	CAMLE AC2,RMEMSIZ
	JUMPN AC2,QBLERR	; IF THERE IS SOMETHING THERE NOT IN FREE STORAGE, ERROR!
	SKIPN INTACT(PID)	; IS SOME WISEASS CALLING US AT USER INTERRUPT LEVEL?
	JRST QBLCLC		; NO, ALL IS WELL.
	HRLI AC1,QBLCLK		; YES, PUT IN A CLOCK REQUEST TO DO THIS TASK AT REAL CLOCK LEVEL
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	POPJ P,			; PRETEND WE DID IT.

; HERE WE SEE IF THE TASK IS AN EASY OUTSIDER.
; IF IT IS NOT, WE MAKE UP A MASK FOR THE NUMBER OF
; LINES IT COVERS.

QBLCLK:
	HRRZ AC1,DAT		; PICK UP THE TASK BLOCK ADDRESS
QBLCLC:
	PUSH P,TAC		; SAVE THE WORLD
	PUSH P,TAC1
	PUSH P,DAT
	PUSH P,UCHN
	PUSH P,CHR
	HLRE DAT,QLINE(AC1)	; PICK UP STARTING POSITION
	HRRE UCHN,QLINE(AC1)	; AND THE ENDING LINE NUMBER
	JUMPLE UCHN,QOOB	; IF ENDING LINE IS OUT OF BOUNDS, THIS IS AN EASY OUTSIDER
	SKIPN DDOFF		; IF DD IS BEING MAINTAINED, PRETEND THE TRANSFER IS OUT OF BOUNDS
	CAILE DAT,=40		; OR IF STARTING LINE IS BELOW SCREEN . . .
	JRST QOOB		; IS AN EASY OUTSIDER
	CAIG DAT,(UCHN)		; IS THE STARTING LESS THAN THE FINISHING?
	AOJA UCHN,QBLGO		;CAN'T MAKE NEXT LINE
	PUSHACS
	PUSHJ P,DISERR
	[ASCIZ /STARTING LINE LESS THAN FINISHING LINE AT QBLOCK
/]
	-1
	POPACS
QBLGO:
	SETZ TAC,		; HERE WE MAKE A 20-BIT MASK, IN BITS
	SETO TAC1,		;	0-19 OF TAC, WHERE EACH BIT
	ADDI DAT,1		;	REPRESENTS 2 LINES, AND IS ON
	ADDI UCHN,1		;	IF EITHER LINE IS TO BE WRITTEN
	LSH DAT,-1
	LSH UCHN,-1
	SUBM DAT,UCHN
IFN FTDDSTAT,<			;ONLY IF COUNTING STATISTICS
	ADDM	UCHN,NDDLCT	;COUNT  -(TOTAL NUMBER OF LINES QUEUED)
	AOS	NDDXCT		;COUNT TOTAL NUMBER OF TRANSFERS QUEUED.
	CAML	UCHN,[-2]
	AOS	NDDL1C		;COUNT 1 AND 2 LINE TRANSFERS.
>
	ROTC TAC,-1(UCHN)
	MOVN UCHN,DAT
	ROT TAC,1(UCHN)		; C(TAC) IS THE PROPER 20-BIT MASK

; HERE WE SCAN THE QUEUE SYSTEM LOOKING FOR A FRAME WITH SOME FREE LINES

QBL1:
	MOVE DAT,QFIELD(AC1)	; WE WILL ENTER THE TASK ON ITS FIELD
	MOVE AC3,QLINE(AC1)	; MERGE BY LINE NUMBER
	MOVE AC2,1		; SET THE FIELD SAVED WORD TO DIFFERENT FROM ANY LEGAL FIELD
	MOVEM AC2,DDLFD
	SETZB AC2,DDLST		; NOTE THAT THERE IS NO LAST FRAME
	EXCH AC2,DDQUE		; PICK UP (SHUDDER!) THE ENTIRE QUEUE STRUCTURE
	JUMPE AC2,QBL3		; IF THERE ISN'T ANY, MAKE UP ONE FROM SCRATCH.
	MOVEM AC2,DDSQ		; IF THERE IS ONE, SAVE IT FIRST.
CNXTFR:
	CAME DAT,QFIELD(AC2)	; IS THIS FRAME ON THE RIGHT FIELD?
	JRST QBL4		; NO, MOVE ON TO NEXT FRAME
	TDNE TAC,QLINE(AC2)	; YES, IS THERE ROOM ON THIS FRAME?
	JRST QBL8		; NO, GO ON TO NEXT FRAME
	ORM TAC,QLINE(AC2)	; YES, MARK OUR LINES AS CLAIMED
QBL6:
	HRRZ CHR,QLINK(AC2)	; PICK UP ADDRESS OF TASK LIST FOR THIS FRAME
	JUMPE CHR,QBL7		; NONE THERE, ANNEX OUR TASK
	MOVE AC2,CHR		; SAVE THIS TASK BLOCK ADDRESS FOR ANNEXATION PURPOSES
	CAMLE AC3,QLINE(AC2)	; NOW, DO WE GO ABOVE THIS BLOCK?
	JRST QBL6		; NO, TRY NEXT BLOCK
	HRRM AC2,QLINK(AC1)	; YES, LINK US IN BETWEEN THESE TWO BLOCKS
	HLRZ AC3,QLINK(AC2)	; PICK UP POINTER TO PREVIOUS TASK
	HRLM AC3,QLINK(AC1)	; MAKE OUR BACKWARD LINK POINT TO THE LAST BLOCK
	HRRM AC1,QLINK(AC3)	; MAKE THE LAST BLOCK POINT TO US
	HRLM AC1,QLINK(AC2)	; MAKE THE NEXT BLOCK'S REVERSE POINTER POINT TO US
	JRST QBLXIT		; PUT THE QUEUE STRUCTURE BACK AND LEAVE

QBL7:
	HRRM AC1,QLINK(AC2)	; ANNEX US BY PUTTING OUR ADDRESS IN THE LAST BLOCK'S FORWARD POINTER
	HRLZM AC2,QLINK(AC1)	; AND POINT OUR REVERSE POINTER TO HIM
	JRST QBLXIT

; WE GET HERE IF THE TASK IS ENTIRELY OUT OF BOUNDS

QOOB:
	PUSHJ P,WAKEQ		; WAKE UP ANYONE WAITING.
	POP P,CHR		; RESTORE THE WORLD.
	POP P,UCHN
	POP P,DAT
	POP P,TAC1
	POP P,TAC
GIVQB:
	JRST GIVQ

; WE GET HERE IF EITHER THE DISPATCH ADDRESS OR THE DATA BLOCK ADDRESS
; IS ILLEGAL.

QBLERR:
	PUSH P,(AC1)
	PUSHJ P,DISERR
	[ASCIZ /ILLEGAL TASK AT QBLOCK - /]
	DISARG OCT,<-1(P)>
	[ASCIZ /
/]
	-1
	SUB P,[XWD 1,1]
	JRST GIVQ

WAKEQ:
	SKIPE QCOUNT(AC1)	; IS THERE A COUNT HERE?
	SOSLE @QCOUNT(AC1)	; PERHAPS WE HAVE TO GO THROUGH THE WAKEUP RITUAL?
	POPJ P,			; NOT YET.
	SKIPN AC2,QWAKE(AC1)	; YES WE DO. PICK UP WAKEUP WORD
	POPJ P,
	TDNE AC2,[-100]		; IS IT A JOB NUMBER?
	JRST WAKEQ1		; NO, MUST BE A CLOCK REQUEST
	SKIPL JBTSTS(AC2)	; MAKE SURE HE IS STILL RUNABLE
	POPJ P,			; NO, LEAVE NOW
	MOVNI AC3,RUNQ		; PUT THAT JOB IN THE RUN QUEUE
	MOVEM AC3,JOBQUE(AC2)
	MOVEI AC3,QJOB(AC2)
	CONO PI,PIOFF
	SKIPE (AC3)
	JRST .+3
	EXCH AC3,QJOB
	HRROM AC3,@QJOB
	CONO PI,PION
	POPJ P,

WAKEQ1:
	CONO PI,PIOFF		; STOP THE WORLD!
	IDPB AC2,CLKQ		; PUT IN THE CLOCK REQUEST
	CONO PI,PION
	POPJ P,

; WE GET HERE WHEN THERE IS NO QUEUE AT ALL.

QBL3:
	PUSHJ P,MAKFRM		; MAKE UP A NEW FRAME HEADER
	MOVEM AC1,DDSQ		; MAKE THIS THE NEW QUEUE
	JRST QBLXIT		; RESTORE ACCUMULATORS AND LEAVE.

; HERE IS A ROUTINE TO MAKE UP A NEW FRAME HEADER AND PUT THE CURRENT
; BLOCK IN IT AS ITS ONLY TASK.

MAKFRM:
	PUSH P,AC1		; SAVE THE TASK BLOCK ADDRESS
	AOS NDDFRM		; COUNT ONE MORE FRAME CREATION
	PUSHJ P,GETQ		; GET A BLOCK FOR THE FRAME HEADER
	SETZM (AC1)		; LINK IT TO NOWHERE FOR NOW.
	MOVEM TAC,QLINE(AC1)	; PUT IN OUR MASK AS THE INITIAL MASK FOR THE FRAME
	MOVEM DAT,QFIELD(AC1)	; STORE THE FIELD WORD AS THIS FRAME'S FIELD
	POP P,AC2		; GET BACK THE TASK BLOCK ADDRESS
	HRRZM AC2,QLINK(AC1)	; POINT THE FRAME HEADER TO US
	HRLZM AC1,QLINK(AC2)	; AND OUR BACKWARD POINTER TO THE FRAME HEADER
	POPJ P,

; WE GET HERE IF THIS FRAME HAS THE WRONG FIELD

QBL4:
	CAME DAT,DDLFD		; DOES THE LAST FRAME ALSO HAVE THE WRONG FIELD?
	SKIPN DDLST		; YES, DO WE EVEN HAVE A LAST FRAME?
	JRST QBL5		; NO TO EITHER, MOVE ON TO NEXT FRAME
	PUSH P,AC2		; SAVE POINTER TO CURRENT FRAME
	PUSHJ P,MAKFRM		; MAKE UP A BRAND NEW AND DIFFERENT FRAME
	MOVEM AC1,@DDLST	; INSERT IT BETWEEN THESE TWO
	POP P,(AC1)		; POINT IT TO THE SUCCESSOR
	JRST QBLXIT

; HERE IS A ROUTINE THAT MOVES ON TO THE NEXT FRAME, IF THERE IS NO NEXT
; FRAME, IT MAKES UP A FRAME AND ANNEXES IT ONTO THE FRAME LIST.

QBL8:
	MOVEM DAT,DDLFD		; SAVE THE FIELD OF THE FRAME
	JRST QBL9

QBL5:
	SETCAM DAT,DDLFD	; SAVE THE FIELD OF THE FRAME (OPPOSITE FROM US)
QBL9:
	HRRZM AC2,DDLST		; SAVE THE ADDRESS OF THE LAST FRAME
	HRRZ AC2,(AC2)		; PICK UP ADDRESS OF NEXT FRAME
	JUMPN AC2,CNXTFR	; IF THERE IS ONE, GO CHECK IT OUT.
	PUSHJ P,MAKFRM		; OTHERWISE, MAKE UP A NEW FRAME HEADER
	HRRZM AC1,@DDLST		; LINK US ON TO THE FRAME LIST
QBLXIT:
	PUSHJ P,DDQCHK
	MOVE AC2,DDSQ		; ALL DONE, PUT THE TASK QUEUE BACK
	MOVEM AC2,DDQUE
	AOS NDDQUE		; MARK ONE MORE IN THE QUEUE
	POP P,CHR		; RESTORE THE ACCUMULATORS
	POP P,UCHN
	POP P,DAT
	POP P,TAC1
	POP P,TAC
	CONO PI,PIOFF		; STOP THE WORLD WHILE WE START UP THE DATA DISC
	SKIPN DDRUN		; IS THE DISK RUNNING?
	SETOM DDSTART		; NO, START IT UP NEXT TICK
	CONO PI,PION
	POPJ P,

;CHECK STATE OF DD QUEUE.  CALL BEFORE SETTING UP DDQUE FROM DDSQ
DDQCHK:
	MOVEI DAT,DDSQ
DDQCH1:
	SKIPN AC1,(DAT)
	POPJ P,
	CAMGE AC1,MEMSIZ
	JRST DDQCE3		;ADDRESS OUT OF BOUNDS
	MOVSI CHR,-1
	TDNN CHR,(AC1)
	TDNE CHR,QLINK(AC1)
	JRST DDQCE1		;EXTRANEOUS BITS ON IN FRAME
;reg	MOVEI CHR,77777
;	TDNE CHR,QLINE(AC1)
;	JRST DDQCE1		;EXTRANEOUS BITS IN QLINE
	SKIPE CHR,QFIELD(AC1)
	AOJN CHR,DDQCE2		;QFIELD NOT 0 OR -1
	HRRZ AC2,QLINK(AC1)	;POINTER TO TASK BLOCK
	JUMPE AC2,DDQCH4
	CAMGE AC2,MEMSIZ
	JRST DDQCE3
	PUSHJ P,DDTSCH		;CHECK LIST OF TASK BLOCKS
DDQCH4:
	MOVE DAT,AC1
	JRST DDQCH1

DDQCE3:
	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /FRAME BLOCK OR TASK BLOCK ADDRESS OUT OF BOUNDS /
	JRST DDCKR1

DDQCE2:
	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /QFIELD NOT ZERO OR ONE /
	JRST DDCKR1

DDQCE1:
	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /EXTRANEOUS BITS ON /
DDCKR1:
	PUSHJ P,DISMES
	ASCIZ /IN FRAME BLOCK AT /
	MOVE TAC,-17+AC1(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /
PREVIOUS FRAME BLOCK AT /
	MOVE TAC,-17+DAT(P)
	PUSHJ P,DISLOC
DDCKR3:
	PUSHJ P,DISMES
	ASCIZ /
FIND A WIZARD OR TYPE POPJ 3,$X
/
	PUSHJ P,DISFLUSH
	POPACS			;SO WE DON'T HAVE TO LOOK HARD TO FIND THE AC'S
	PUSHJ P,DDTCALL	
	JRST DDQCH4		;MAYBE IT'S POSSIBLE TO CONTINUE

DDCHER:
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /DATA DISK QUEUE INCONSISTENT
/
	JRST @-17+CHR(P)

;CHECK TASK LIST POINTED TO BY AC2 , AC1 POINTS TO FRAME IT COMES FROM
DDTSCH:
	PUSH P,AC1
DDTSC2:
	HRRZ CHR,(AC2)		;ADDRESS OF TASK ROUTINE
	CAIL CHR,DWPINI
	CAIL CHR,WHOINI
	JRST DDTSE4
	SKIPE CHR,QFIELD(AC2)
	AOJN CHR,DDTSE1		;QFIELD NOT 0 OR -1
	HLRZ CHR,QLINK(AC2)	;BACKWARDS LINK
	CAIE CHR,(AC1)
	JRST DDTSE2		;BACKWARDS LINK IS WRONG
	HRRZ AC1,AC2
	HRRZ AC2,QLINK(AC2)	;GET FORWARD LINK
	JUMPE AC2,DDTSC1	;END OF LIST
	CAMGE AC2,MEMSIZ
	JRST DDTSE3		;TASK LINK OUT OF BOUNDS
	JRST DDTSC2

DDTSC1:
	POP P,AC1
	POPJ P,

DDTSE4:
	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /TASK ROUTINE ADDRESS OUT OF RANGE /
	JRST DDCKR2

DDTSE3:
	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /FORWARD LINK OUT OF BOUNDS /
	JRST DDCKR2

DDTSE2:
	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /BACKWARS LINK WRONG /
	JRST DDCKR2

DDTSE1:
	JSP CHR,DDCHER
	PUSHJ P,DISMES
	ASCIZ /QFIELD NOT ZERO OR ONE /
DDCKR2:
	PUSHJ P,DISMES
	ASCIZ /IN TASK BLOCK AT /
	MOVE TAC,-17+AC2(P)
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ /
PREVIOUS TASK BLOCK (MAYBE FRAME BLOCK) AT /
	MOVE TAC,-17+AC1(P)
	PUSHJ P,DISLOC
	JRST DDCKR3

; HERE LIES THE INCREDIBLE INTERRUPT-LEVEL ROUTINES!
; LET THE READER BEWARE.

↑DDSTRT:
	SETZM DDSTART
	SKIPN DDQUE		; IS THERE ANYTHING FOR US?
	JRST APRADD		; NO, LEAVE NOW
	SETOM DDRUN		; WE ARE NOW OFFICIALLY RUNNING.
	MOVEM TAC,DDSTAC	; SAVE THE ACCUMULATORS
	MOVEM AC1,DDSAC1
	MOVEM AC2,DDSAC2
	MOVEM AC3,DDSAC3
	MOVEM DAT,DDSDAT
	EXCH P,APRPDL(PID)	; GET US A PDL TOO
	MOVEI AC3,APRADD	; WE WILL RETURN TO APRINT WHEN WE ARE DONE
	MOVEM AC3,DDRET
	MOVE AC1,DDQUE		; REMOVE THE FIRST FRAME FROM THE QUEUE ENTIRELY
NEWFRM:
	MOVE AC2,(AC1)		; PICK UP THE ADDRESS OF THE NEXT FRAME
	MOVEM AC2,DDQUE		; MAKE IT THE NEW QUEUE
	MOVEM AC1,DDCURQ	; SAVE THIS ADDRESS AS OUR CURRENT FRAME
	HRRZ TAC,QLINK(AC1)	; PICK UP THE ADDRESS OF THE FIRST TASK IN THE FRAME
SCNLOP:
	HRRZ AC2,QLINK(TAC)	; PICK UP THE ADDRESS OF THE NEXT TASK
	MOVEM AC2,DDNXT		; SAVE IT FOR FUTURE REFERENCE
	HLRZ DAT,(TAC)		; PICK UP THE DATA BLOCK ADDRESS
	HRRZ AC3,(TAC)		; AND THE ROUTINE ADDRESS
	CAIL AC3,DWPINI
	CAIL AC3,WHOINI
	CAIA			;LET'S NOT JUMP TO CONTUSIONS
	JRST (AC3)		; JUMP OFF TO THE ROUTINE
	PUSH P,CHR		;IN CASE WE WANT TO LOOK AT CHR
	MOVEI DAT,DDCURQ
	PUSHJ P,DDQCH1		;SHOULDN'T EVER RETURN
	PUSHJ P,DDTCALL
	JRST AUTOLOAD

; ALL THE I-LEVEL ROUTINES RETURN TO HERE WHEN THEY ARE DONE

RESCAN:
	SKIPE TAC,DDNXT		; IS THERE ANOTHER TASK IN THIS FRAME?
	JRST SCNLOP		; YES, SERVE IT NOW.
	HRRZ AC1,DDCURQ		; PICK UP THE FRAME HEAD WE WERE WORKING ON.
	HRRZ AC2,QLINK(AC1)	; SEE IF THERE ARE ANY TASKS LEFT ON IT.
	JUMPE AC2,DDEXIT	; NO, THEY MUST HAVE ALL SUCCEEDED
	HRLI AC2,DDREQ		; YES, PUT IN A CLOCK REQUEST TO REQUEUE THEM
	CONO PI,PIOFF		; THIS WAY, THEY WILL GET TRIED AGAIN
	IDPB AC2,CLKQ
	CONO PI,PION
DDEXIT:
	PUSHJ P,GIVQ		; RELEASE THE FRAME HEADER
	SKIPE AC1,DDQUE		; SEE IF THERE IS ANOTHER FRAME
	JRST NEWFRM		; YES, DO IT.
	SETZM DDRUN		; NO, DIE QUIETLY
	CONO DDD,RESET		; CLEAR OUT THE BEAST
	MOVE TAC,DDSTAC		; RESTORE ALL OUR ACCUMULATORS
	MOVE AC1,DDSAC1
	MOVE AC2,DDSAC2
	MOVE AC3,DDSAC3
	MOVE DAT,DDSDAT
	EXCH P,APRPDL(PID)
	JSR DDRTN		; RETURN TO LOSER

; THIS ROUTINE IS CALLED AT CLOCK LEVEL WITH A LIST OF TASKS THAT
; TIMED OUT OR LOST IN SOME OBSCURE WAY. WE JUST REQUEUE THEM AND
; TRY AGAIN.

DDREQ:
	HRRZ AC1,DAT		; PICK UP THE TASK LIST
DDREQ1:
	HRRZ DAT,QLINK(AC1)	; GET ADDRESS OF NEXT BLOCK ON LIST
	SOSG QTIME(AC1)		; HAVE WE TRIED TOO MANY TIMES
	JRST DDREQ2		; YES, DON'T REQUE IT.
	PUSHJ P,REQBLK		; REQUE THE TASK
DDREQ3:
	JUMPE DAT,CPOPJ		; IF NO MORE TASKS, LEAVE
	MOVE AC1,DAT
	JRST DDREQ1

DDREQ2:
	MOVE TAC,AC1
	PUSHJ P,DEQWAK		; WAKE UP CALLER
	JRST DDREQ3

; THIS ROUTINE TAKES A TASK OUT OF THE QUEUE AND WAKES UP ANYONE IF
; IT IS SUPPOSED TO.

DEQ:
	;SOSGE NDDQUE		; NOTE ONE MORE GONE FROM QUEUE
	;SETZM NDDQUE		; DON'T LET IT GET NEGATIVE
	MOVE AC2,QLINK(TAC)	; PICK UP ADDRESS OF SUCCESSOR
	TRNE AC2,-1		; IS THERE ANYONE HOME?
	HLLM AC2,QLINK(AC2)	; YES, MAKE REVERSE LINK OF SUCCESSOR POINT TO OUR PREDECESSOR
	MOVSS AC2		; SAME DEAL FOR OTHER SIDE
	TRNE AC2,-1		; ANYONE HOME?
	HLRM AC2,QLINK(AC2)	; MAKE FORWARD LINK OF PREDECESSOR POINT TO SUCCESSOR
DEQWAK:
	SKIPE QCOUNT(TAC)	; IS THERE A COUNT WORD SOMEWHERE?
	SOSLE @QCOUNT(TAC)	; YES, COUNT IT DOWN.
	JRST DEQ1		; NO COUNT OR COUNT NOT EXPIRED
	SKIPN AC1,QWAKE(TAC)	; PICK UP WAKEUP WORD
	JRST DEQ1		; IF NONE THERE, DON'T BOTHER
	TDNE AC1,[-100]		; IS IT A JOB NUMBER?
	JRST DEQ2		; NO, MUST BE CLOCK REQUEST
	SKIPL JBTSTS(AC1)
	JRST DEQ1		;DON'T REQUE IF ↑C
	HLRZ AC2,(TAC)
	HRRE AC2,PRGJMP(AC2)	;CHECK WAIT FLAG
	JUMPGE AC2,DEQ1		;NOT WAITING - DON'T REQUE
	MOVNI AC2,RUNQ		; IS JOB NUMBER, PUT THIS JOB IN THE RUN QUEUE
	MOVEM AC2,JOBQUE(AC1)
	MOVEI AC1,QJOB(AC1)
	CONO PI,PIOFF
	SKIPE (AC1)
	JRST .+3
	EXCH AC1,QJOB
	HRROM AC1,@QJOB
	CONO PI,PION
	JRST DEQ1

DEQ2:
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
DEQ1:
	MOVE AC1,TAC		; PUT TASK BLOCK ADDRESS IN AC1 FOR THE FOLLOWING ROUTINE
GIVQ:
	PUSHJ P,SFSGIV
	DDFS
	POPJ P,

; PAGE PRINTER TRANSFERS

PPXFR:
	SKIPL AC1,HEDPTR(DAT)	;LET'S SEE IF THIS IS A LEGAL PP
	CAML AC1,RMEMSI
	JRST ILLPP		;GARBAGEY HEADER ADR
	HLRZ AC1,PRGNUM(AC1)
	LDB AC3,[241000,,DDCW(DAT)]
	CAIE AC1,(AC3)
	JRST ILLPP		;DD CHNL DOESN'T MATCH
	SETZM DDSAV(DAT)	; INITIALIZE THE SAVE WORD
	SKIPE PPINV(DAT)	; IS THE TEXT VALID?
	JRST PPXFR2		; NO, FLUSH THE TRANSFER
	PUSHJ P,POSLIN		; GET NUMBER OF FIRST LINE ON PAGE IN AC3
	HLRE AC1,QLINE(TAC)	; PICK UP FIRST LINE OF TRANSFER
	CAMG AC1,VPOS(DAT)	; IS FIRST LINE OF TRANSFER BELOW CURRENT SCREEN?
	CAMGE AC1,AC3		; OR ABOVE FIRST LINE OF SCREEN?
	JRST PPXFR2		; YES, ABORT TRANSFER
	HRRE AC1,QLINE(TAC)	; SAME FOR LAST LINE OF TRANSFER
	CAMG AC1,VPOS(DAT)
	CAMGE AC1,AC3
	JRST PPXFR2
	HLRE AC3,QLINE(TAC)	; PICK UP STARTING LINE NUMBER
	SKIPG AC3		; IF IT IS ABOVE SCREEN . . .
	MOVEI AC3,1		; USE TOP OF SCREEN AS FIRST LINE
	MOVEI AC1,-1(AC3)	; GET NORMALIZED LINE NUMBER
	PUSHJ P,GLNADR		; GET LINE ADDRESS FROM LINE NUMBER
	ADD AC2,[XWD DISJMP,1]	; BUMP PAST CRLF ON LAST LINE
	MOVSM AC2,DDCW+2(DAT)	; PLACE JUMP TO TEXT IN CODE
	IMULI AC1,=12
	SKIPE QFIELD(TAC)	; CHECK THE FIELD
	ORI AC1,1		; PUT IT OUT ON THE ODD FIELD THIS TIME
	DPB AC1,[POINT 4,DDCW+1(DAT),23]
	LSH AC1,-4
	DPB AC1,[POINT 5,DDCW+1(DAT),15]
	HRRE AC3,QLINE(TAC)	; PICK UP FINISHING LINE OF TRANSFER
	CAILE AC3,=40		; IS IT OFF THE SCREEN?
	MOVEI AC3,=40		; YES, USE THE LAST LINE ON THE SCREEN
	CAMN AC3,VPOS(DAT)	; IS THIS THE SAME AS THE VERTICAL POSITION OF THE PAGE PRINTER
	JRST PPXFR4		; YES, NO NEED TO SAVE ANY WORDS.
	ADDI AC3,1		; BUMP LINE POINTER BY ONE TO GET TO THE END OF THIS LINE
	PUSHJ P,GLNADR		; PICK UP THE ADDRESS OF THE END OF THAT LINE
	MOVE AC1,(AC2)		; PICK UP THE WORD AT THE END OF THE LINE
	MOVEM AC2,DDSPT(DAT)	; SAVE THE POINTER TO THE SAVED WORD.
	MOVEM AC1,DDSAV(DAT)	; STORE IT IN THE PAGE PRINTER CONTROL BLOCK
	MOVSI AC1,DDSAV(DAT)	; PICK UP ADDRESS OF SAVED WORD
	HRRI AC1,DISJMP		; PLACE A JUMP TO IT WHERE IT WAS IN THE BUFFER
	MOVEM AC1,(AC2)

PPXFR3:
	MOVEI AC1,DDCW(DAT)	; PICK UP ADDRESS OF START OF TRANSFER
	CONO DDD,USUAL		; SET UP THE DATA DISC
	DATAO DDD,AC1		; SEND OUT THE ADDRESS
	PUSHJ P,ISYNC		; WAIT FOR IT
	JFCL
	JRST PPXFR1		; LOSE BIG, LEAVE THE TRANSFER IN THE QUEUE
PPXFR2:
	PUSHJ P,DEQ		; WIN, TAKE THE TASK OUT OF THE QUEUE
PPXFR1:
	MOVSI AC1,040000	; CLEAR THE 'NO ERASE' BIT IF WE SET IT
	ANDCAM AC1,DDCW(DAT)
	SKIPE AC1,DDSAV(DAT)	; RESTORE THE SAVED WORD, IF THERE IS ANY
	MOVEM AC1,@DDSPT(DAT)
	JRST RESCAN

PPXFR4:
	MOVSI AC1,040000	; IF WE ARE AT THE BOTTOM OF THE SCREEN,
	CAMN AC2,VPOS(DAT)	; THEN DON'T ERASE THE REST OF THE LINE
	ORM AC1,DDCW(DAT)	; BECAUSE WE MIGHT BE ERASING PART OF THE LINE EDITOR
	JRST PPXFR3		; THE LINE EDITOR WILL ERASE THE REST OF THE LINE ITSELF

ILLPP:
	PUSHACS
	PUSHJ P,DISDAT
	PUSHJ P,DISMES
	ASCIZ /ILLEGAL PP AT PPXFR
/
	DEBCHE
	POPACS
	PUSHJ P,DEQ
	JRST RESCAN

; HERE IS THE ERASE CODE.

ERASE:
	HLRE AC2,QLINE(TAC)	; PICK UP STARTING ADDRESS
	SKIPG AC2		; IS IT ABOVE THE SCREEN?
	MOVEI AC1,1		; YES, START FROM LINE 1
	MOVEI AC1,-1(AC2)	; CONVERT IT TO HARDWARE FORM
	IMULI AC1,=12
	SKIPE QFIELD(TAC)	; WHAT FIELD DOES THIS GO OUT ON?
	ORI AC1,1		; ODD FIELD
	DPB AC1,[POINT 4,DDERRS+1,23]
	LSH AC1,-4
	DPB AC1,[POINT 5,DDERRS+1,15]
	MOVE AC1,DDCW(DAT)	; PICK UP FUNCTION SELECT
	MOVEM AC1,DDERRS	; USE IT FOR THE ERASURE
	HRRE AC1,QLINE(TAC)	; GET ENDING LINE NUMBER
	CAILE AC1,=40		; IF OFF THE BOTTOM OF THE SCREEN . . .
	MOVEI AC1,=40		; THEN USE THE NUMBER OF THE LAST LINE ON THE SCREEN
	SUB AC2,AC1		; GET THE NUMBER OF LINES TO BE ERASED
	ADD AC2,[XWD DISJMP,DDCRLF+=39]
	MOVSM AC2,DDERRS+2	; JUMP TO THE POSITION IN THE ERASURES THAT CORRESPONDS TO THAT MANY LINES.
	CONO DDD,USUAL
	DATAO DDD,[DDERRS]
CWAIT:
	PUSHJ P,ISYNC
	JFCL
	JRST RESCAN		; LOSE BIG, JUST DO ANOTHER TASK
	PUSHJ P,DEQ		; WIN, TAKE US OUT OF THE QUEUE
	JRST RESCAN		; AND GO DO SOMETHING ELSE.

; CURSOR TRANSFERS.

CURSOR:
	MOVE AC1,[POINT 36,CURZWD-1,35]
	MOVEM AC1,CZPNT		; INITIALIZE LIST OF WORDS IN CURSOR CODE WE USED
	MOVE AC1,DDCW(DAT)	; PICK UP COMMAND WORD WITH FUNCTION SELECT IN IT
	TLO AC1,002000		; MAKE IT A GRAPHICS WORD
	MOVEM AC1,DDCURS	; AND USE IT AS OUR SELECT WORD
	HLRE AC1,QLINE(TAC)	; PICK UP LINE NUMBER OF TRANSFER
	JUMPLE AC1,CDX		; IF OUT OF BOUNDS, FORGET IT
	CAILE AC1,=40		; IS IT OFF THE BOTTOM OF THE SCREEN?
	JRST CDX		; YES, RESTORE CURSOR CODE AND LEAVE
	IMULI AC1,=12
	SUBI AC1,2		; BACK UP THE LINE TO BEFORE THE NEXT TEXT
	DPB AC1,[POINT 4,DDCURS+1,23]
	LSH AC1,-4
	DPB AC1,[POINT 5,DDCURS+1,15]
	HLRE AC1,QHPOS(TAC)	; PICK UP FIRST HORIZONTAL POSITION
	SKIPL AC1		; IS THERE ANY?
	PUSHJ P,CMAKE		; YES, MAKE UP CODE FOR IT
	HRRE AC1,QHPOS(TAC)	; PICK UP SECOND HORIZONTAL POSITION
	SKIPL AC1		; IS THERE ANY?
	PUSHJ P,CMAKE		; YES, COMPILE IT.
	CONO DDD,USUAL
	DATAO DDD,[DDCURS]
	PUSHJ P,ISYNC
	JFCL
	JRST CURS2		; UNFORGIVABLE LOSSAGE, TRY AGAIN LATER
CDX:
	PUSHJ P,DEQ		; REMOVE US FROM THE QUEUE
CURS2:
	HRRZ AC1,CZPNT		; PICK UP POINTER TO CURSOR CODE ADDRESSES
	MOVEI AC2,2		; PICK UP A BLANK GRAPHICS WORD
CURS1:
	CAIGE AC1,CURZWD	; ARE WE BACK TO THE START YET?
	JRST RESCAN		; YES, GO BACK FOR ANOTHER TASK
	MOVEM AC2,@(AC1)	; NO, CLEAR OUT THIS CURSOR
	SOJA AC1,CURS1		; BACK UP FOR THE NEXT ONE, IF ANY.

; THIS ROUTINE MAKES UP THE CODE FOR A CURSOR.

CMAKE:
	IMULI AC1,6		; CONVERT TO NUMBER OF BITS FROM LEFT MARGIN
	ADDI AC1,1		; THE UNIVERSAL FUDGE FACTOR STRIKES AGAIN!
	LDB AC2,[POINT 5,AC1,35]
	LSH AC1,-5		; IT IS NOW CONVERTED TO NUMBER OF WORDS AND BITS WITHIN LAST WORD
	ADDI AC1,DDCURS+2	; MAKE UP POINTER TO THE GRAPHICS WORD IN QUESTION
	IDPB AC1,CZPNT		; SAVE THIS ADDRESS SO WE CAN ZERO IT WHEN WE LEAVE
	MOVSI AC3,360000	; SHIFT OVER A CURSOR
	MOVNS AC2
	LSH AC3,(AC2)
	ANDCMI AC3,17		; ZERO OUT POSSIBLE OVERFLOW INTO OPCODE
	ORM AC3,(AC1)		; PUT THOSE BITS INTO THE LOCATION WE CALCULATED
	CAMLE AC2,[-=28]	; IS THERE TWO WORDS WORTH?
	POPJ P,			; NO, RETURN NOW
	ADDI AC1,1		; YES, BUMP POINTER
	IDPB AC1,CZPNT		; AND SAVE IT
	MOVSI AC3,360000	; MAKE UP ANOTHER CURSOR
	LSH AC3,=32(AC2)
	ORM AC3,(AC1)		; SET IT IN PLACE
	POPJ P,

; LINE EDITOR TRANSFERS

LEXFR:
	HRRZ AC1,CURPP(DAT)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	SKIPE PPNQT(AC1)	; IS THERE ANYTHING NOT COUNTED IN THE QUEUE
	JRST LEXFR2
	SKIPN PPENQ(AC1)	; IF ANYONE THERE, ABORT THE TRANSFER
	SKIPE LEINV(DAT)	; IS THE BUFFER VALID?
	JRST LEXFR2		; NO, SET 'MISSED IT' FLAG AND QUIT
	HLRE AC1,QLINE(TAC)	; PICK UP LINE NUMBER
	JUMPLE AC1,LEXFR1	; IF STARTING LINE IS ABOVE SCREEN, FORGET IT
	SUBI AC1,1		; OTHERWISE WE WILL SHOW AS MUCH AS WE CAN
	IMULI AC1,=12		; CONVERT TO DD FLAVOR LINE ADDRESS
	SKIPE QFIELD(TAC)	; WHAT FIELD DOES THIS TRANSFER WANT TO GO TO?
	ORI AC1,1		; ODD FIELD, MAKE LINE ADDRESS ODD
	DPB AC1,[POINT 4,LEBFR+1,23]
	LSH AC1,-4
	DPB AC1,[POINT 5,LEBFR+1,15]
	MOVE AC1,FCPOS(DAT)	; PICK UP NUMBER OF CHARACTERS IN BUFFER
	MOVE AC2,PRGNUM(DAT)	; GET DPY NUMBER
	SKIPL LETAB(AC2)	; IS THE LINE EDITOR INITIALIZED?
	SETZ AC1,		; NO, NO CHARACTERS IN IT
	JUMPN AC1,LEXFR3	; IF SOME CHARACTERS THERE, WE ARE SET.
	MOVE AC1,[ASCID /  
/]
	MOVEM AC1,LEBFR+2	; IF NONE, CLEAR OUT THE LINE WITH A SPACE AND A CRLF
LEXFR4:
	MOVE AC1,CURPP(DAT)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	MOVE AC2,DDCW(AC1)	; GET FUNCTION SELECT WORD
	MOVEM AC2,LEBFR		; USE IT FOR US
	MOVEI AC2,2		;COLUMN OFFSET
	SKIPGE LEPOS(DAT)
	JRST .+3		;THAT'S THE POS IF LEYPOS IN EFFECT
	ADD AC2,DPHPOS(AC1)
	ADD AC2,LNLNGT(AC1)	;ELSE FOLLOW PP
	DPB AC2,[POINT 8,LEBFR+1,7]
	CONO DDD,USUAL		; START UP THE BEAST
	DATAO DDD,[LEBFR]	; AND AWAY WE GO . . .
	PUSHJ P,ISYNC
	JRST RESCAN
	JRST RESCAN
	JRST LEXFR1		; WIN, DEQUEUE US AND LEAVE

; WE GET HERE WHEN THE TRANSFER IS DONE OR ABORTED.

LEXFR2:
	SETOM LEMISS(DAT)	; NOTE THAT WE MISSED THIS TRANSFER DUE TO BUFFER INVALID
LEXFR1:
	PUSHJ P,DEQ		; REMOVE US FROM THE QUEUE
	HRRZ AC2,CURPP(DAT)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	HRRZ AC3,LLW(AC2)	; PICK UP LAST LINE TRANSFERRED
	CAME AC3,VPOS(AC2)	; IS THE PAGE PRINTER UP TO DATE?
	SKIPE PPENQ(AC2)	; YES, IS IT BUSY NOW?
	JRST RESCAN		; UP TO DATE OR BUSY
	HRLI AC2,REFLINE	; NOT UP TO DATE AND NOT BUSY, REFRESH ITS LINE
	CONO PI,PIOFF		; PLANT A CLOCK REQUEST
	IDPB AC2,CLKQ
	CONO PI,PION
	JRST RESCAN

LEXFR3:
	MOVEI AC1,LEBUF(DAT)	; GET THE ADDRESS OF THE LINE EDITOR TEXT
	HRLI AC1,DISJMP		; MAKE A JUMP TO IT
	MOVSM AC1,LEBFR+2	; AND PUT IT IN THE STARTUP CODE
	JRST LEXFR4

; WHOLE SCREEN ERASURE AND AVAILABLE MESSAGE

WSE:
	MOVE AC1,CURPP(DAT)	; PICK UP ADDRESS OF PAGE PRINTER CONTROL BLOCK
	MOVE AC2,DDCW(AC1)	; GET FUNCTION SELECT WORD
	MOVEI AC3,13		; MAKE IT INTO AN ERASE REQUEST
	MOVEM AC2,WSERC+1	; PUT DOWN NORMAL COPY FIRST
	TLNE AC2,(1B5)		; WHAT FLAVOR?
	ORI AC3,4
	DPB AC3,[POINT 8,AC2,7]
	MOVEM AC2,WSERC
	CONO DDD,USUAL
	DATAO DDD,[WSERC]
	JRST CWAIT		; GO WAIT FOR TRANSFER AND LEAVE


; HERE IS THE WHO LINE ROUTINE.

WHOWRT:

	MOVE	AC1,QHPOS(TAC)	; PICK UP SAVED DPY NUMBER
	CAIE	AC1,DDAVLU	;AVAILABLE CHANNEL?
	JRST WHOWR2		;NO
	MOVEI DAT,AVLWHO	;GET PTR TO DD PROG
	MOVE	AC1,AVLVP	;GET DD CW TO RANDOM POSITION ON SCREEN
	JRST WHOWR3
WHOWR2:
	SKIPN	FRETAB(AC1)	; IS OUR FREE STORAGE STILL HERE?
	JRST	WHOWR1		; NO, EXIT NOW
	MOVE	AC1,[CW 3,2,4,0,5,0]
WHOWR3:
	SKIPE	QFIELD(TAC)
	ORI	AC1,1B23
	MOVEM	AC1,1(DAT)	; PUT IT IN THE DD PROG
	MOVEI	AC1,3(DAT)	; PUT RETURN ADDRESS INTO SYSTEM WHO LINE DPY CODE
	HRLM	AC1,DDDRET
	CONO	DDD,USUAL
	DATAO	DDD,DAT
	PUSHJ	P,ISYNC
	JFCL
	JFCL
	MOVE	AC1,QHPOS(TAC)	; GET DPY NBR/AVL CODE BACK
	CAIE	AC1,DDAVLU	; ARE WE DOING THE AVL CHN?
	JRST	WHOWR1		; NO
	HRLZI	AC2,20000	; YES, TURN OFF ERASE BIT IN CW
	ANDCAM	AC2,(DAT)
WHOWR1:
	PUSHJ	P,DEQ
	AOS	WHOPTR		;COUNT ANOTHER FIELD DONE.
	JRST	RESCAN

; USER DATA DISC PROGRAM . . .

POG:
	HLRZ AC1,QHPOS(TAC)	;ADR OF CELL TO SET FIELD
	JUMPE AC1,POG2		;NONE
	HRLI AC1,140100		;MAKE BYTE PNTR TO FIELD BIT
	MOVE AC2,QFIELD(TAC)
	DPB AC2,AC1		;STORE FIELD
POG2:
	CONO DDD,USUAL!EXECM
	MOVEI AC1,PRGCW(DAT)	; PICK UP ADDRESS OF START OF PROGRAM
	DATAO DDD,AC1		; SEND IT OUT
;DONT	MOVE AC1,TIME
;SAVE	SKIPN DPGTIM(DAT)
;TIME	MOVEM AC1,DPGTIM(DAT)	; NOTE TIME PROGRAM WENT OUT
	PUSHJ P,ISYNC
	JFCL
	JFCL
	HRRZ AC1,QHPOS(TAC)	;ADR OF LOSER'S COUNT CELL
	JUMPE AC1,.+2		;NONE
	SOS (AC1)
	MOVE AC1,QWAKE(TAC)	; PICK UP JOB NUMBER
	SOS JBTGLU(AC1)		; RELEASE US FROM CORE
IFN FTSTAT,<
	PUSH P,J
	MOVE J,AC1
	PUSHJ P,GLUSTT
	POP P,J
>
	SKIPN DPRLSF(DAT)	; ARE WE A DETACHED JOB?
	JRST POG1		; NO, LEAVE
	HRRZI AC1,(DAT)		; PICK UP ADDRESS OF DPY PROGRAM HEADER TO BE RETURNED
	HRLI AC1,POGCLK		; RETURN IT AT FREE STORAGE
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
POG1:
	PUSHJ P,DEQ		; REMOVE THE TASK
	JRST RESCAN

POGCLK:
	HRRZ AC1,DAT		; RETURN PROGRAM HEADER ITSELF
	JRST FSGIVE

; ROUTINE TO PRINT 'PAGE PRINTER HOLDING' MESSAGE

PPSTAR:
	MOVE AC1,DDCW(DAT)
	MOVEM AC1,DDSTRS
	SETZ AC1,
	SKIPE QFIELD(TAC)
	MOVEI AC1,1		; SET LINE ADDRESS ODD
	DPB AC1,[POINT 1,DDSTRS+1,23]
	CONO DDD,USUAL
	DATAO DDD,[DDSTRS]
	JRST CWAIT

; ALL TRANSFERS COME BACK TO HERE WHEN THEY ARE DONE OR TIMED OUT

ISYNC:
	POP P,DDDSP		; SAVE RETURN ADDRESS
	MOVEI AC3,6		; TIMEOUT IF NO INTERRUPT IN 8 TIX
	MOVEM AC3,DDCNT		; STORE IN THE COUNT WORD
	MOVEM DAT,DDCUR		; SAVE CONTROL BLOCK ADDRESS
	MOVEM TAC,DDCURT	; SAVE TASK BLOCK ADDRESS TOO.
	MOVE DAT,DDSDAT		; RESTORE ACCUMULATORS
	MOVE AC1,DDSAC1
	MOVE AC2,DDSAC2
	MOVE AC3,DDSAC3
	MOVE TAC,DDSTAC
	EXCH P,APRPDL(PID)	; RESTORE THE PDL
	JSR DDRTN		; AND RETURN TO WHEREVER

↑DDINT:	SKIPN DDRUN
	JRST DDILL
	MOVEM AC3,DDSAC3	; SAVE ONE ACCUMULATOR
	MOVEI AC3,DDIXIT	; MAKE US RETURN THROUGH CH3 NEXT TIME OUT
	MOVEM AC3,DDRET		; SO WE CAN RE-ENABLE THE CHANNEL
	MOVE AC3,DDDSP		; PICK UP RETURN ADDRESS
	EXCH PID,APRID+P1PID	; PICK UP PROCESSOR IDENTIFICATION
	CONSZ 510,DDNXM
	JRST DDNX
	CONSO 510,LOSE		; DID DD MISS A WORD FROM MEMORY?
	JRST DDINT1		; NO, GO AHEAD
DDINT2:
	CONO 510,RESET		; YES, STOP IT AMID-TRANSFER
	JRST DDCMR

; DATA DISC NON-EX MEM TYPEOUT, ACCUMULATOR SAVER, AND CLOCK TIMEOUT ROUTINES

DDNX:
	EXCH P,APRPDL(PID)
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISERR
	[ASCIZ /DATA DISC NON-EX MEM
/]
	-1
	POPACS
	EXCH P,APRPDL(PID)
	JRST DDINT2


DDINT1:
	ADDI AC3,2		; ALL OK, BUMP RETURN ADDRESS TO SUCCESS RETURN
DDCMR:
	MOVEM DAT,DDSDAT	; SAVE THE REST OF THE ACCUMULATORS
	MOVEM TAC,DDSTAC
	MOVEM AC1,DDSAC1
	MOVEM AC2,DDSAC2
	EXCH P,APRPDL(PID)
	MOVE DAT,DDCUR		; PICK UP ADDRESS OF CONTROL BLOCK
	MOVE TAC,DDCURT		; PICK UP ADDRESS OF TASK BLOCK
	HRLOI AC2,377777	; SET COUNT TO MAXIMUM WHEN NO TRANSFER IN PROGRESS
	MOVEM AC2,DDCNT
	JRST (AC3)		; RETURN TO LOSER

↑DDCLK:	MOVEM AC3,DDSAC3	; STORE THIS ACCUMULATOR
	MOVEI AC3,APRADD	; MAKE US RETURN TO APRSER
	MOVEM AC3,DDRET		; NEXT TIME OUT
	MOVE AC3,DDDSP		; PICK UP RETURN ADDRESS
	ADDI AC3,1		; BUMP BY ONE TO NOTE THAT CLOCK TIMEOUT HAS HAPPENED
	CONO 510,RESET		; TIMED OUT, MUST BE HUNG. CLEAR IT OUT.
	JRST DDCMR

DDIXIT:
	EXCH PID,APRID+P1PID	; RESTORE PID
	JEN @CH3		; DISMISS CHANNES

; WE GET HERE IF WE GET AN INTERRUPT FROM THE DATA DISK AND
; OUR MAGIC FLAG INDICATES THAT NO TRANSFER WAS IN PROGRESS.

DDILL:
	EXCH P,APRPDL+P1PID	; GET A PUSHDOWN LIST
	PUSHACS			; SAVE OUR ACCUMULATORS
	PUSHJ P,DISMES		; GIVE HARDWARE PEOPLE NASTY MESSAGE!
	ASCIZ/
UNEXPECTED DATA DISC INTERRUPT!!!
/
	CONO 510,RESET		; CLEAR ITS MIND
	POPACS			; RESTORE OUR ACCUMULATORS
	EXCH P,APRPDL+P1PID	; RESTORE P
	JEN @CH3

;DEFINITIONS FOR DATA DISC ALLOCATION

DDLNK←←<600,,DDTAB>	;LINK OUT
DDALST←←<60600,,DDTAB>	;ALLOC LIST (PERMANENT)
↑DDUSR←←<221000,,DDTAB>	;USER FLD
DDELNK←←40		;LIST TERMINATOR (ZERO IS LEGAL VAL)
DDCLST←←<600,,JB2SWP>	;LIST OF CHANNELS OWNED BY JOB

DDGBIT←←100		;"GET" BIT IN UUO
DDSBIT←←200		;"STATUS" BIT IN UUO
DDGMOD←←50300		;WHOLE MODE FLD
↑DDANYW←←200000		;LET ANYONE WRITE
DDSMSK←←600000		;MASK FOR USER SETTABLE BITS
DDUSR2←←222000		;TO SET USER & CLEAR EXTRA BITS

;SPECIAL USER CODES

↑DDAVLU←←200		;AVAILABLE CHANNEL
↑DDDETU←←201		;DETACHED FROM SYS

;DEFINITIONS FOR VIDEO SWITCH ROUTINES

VDOP←←330300		;OPCODE FLD FOR UUO
VDPERM←←400000		;"PERMANENT" BIT - MUST BE SIGN
VDXBIT←←400		;"EXTRA CHANNEL" BIT

;INITIALIZATION FOR DATA DISC ALLOCATION AND VIDEO SWITCH
DDINI:
	SETOM DDTAB
	MOVE TAC,[DDTAB,,DDTAB+1]
	BLT TAC,DDTAB+DDELNK		;CLEAR TABLE FOR DUPLICATION TEST
	MOVE TAC,[440600,,DDLIST]
	MOVEI AC2,DDELNK
DDINI1:
	ILDB AC1,TAC
	SKIPL DDTAB(AC1)
	JRST 4,.		;OOPS - WE'VE BEEN HERE BEFORE
	MOVEM AC2,DDTAB(AC1)	;INITIALIZE DDTAB WITH ALLOC LIST & FREE LIST
	DPB AC1,[DDALST(AC2)]
	MOVEI AC2,(AC1)
	CAIE AC1,DDELNK
	JRST DDINI1
	MOVEI J,JOBN-1
	MOVEI TAC,
	DPB TAC,[DDCLST(J)]	;INIT JOB CHNL LISTS
	SOJG J,.-1
	MOVEI TAC,40
	MOVEM TAC,DDFCNT	;INIT FREE CHNL COUNT
	MOVSI TAC,200
	HRR TAC,AVLCHN
	PUSHJ P,DDCGET		;GET CHN FOR AVAIL MSG
	JRST 4,.
	MOVEI AC1,(TAC)
	PUSHJ P,VDBIT
	MOVEM AC3,AVLBIT
	MOVSI AC1,-DDNUM
DDINI2:
	MOVEM AC3,VDMAP(AC1)	;MAP EVERYONE TO MSG
	CONO VDS,DPYNUM(AC1)
	DATAO VDS,AC3
	AOBJN AC1,DDINI2
	DPB TAC,[POINT 8,AVLWHO,15]
	PUSHJ P,WHOSYS		;INITIALIZE SYSTEM WHOLINE
	SETOM WHOKLU		;THIS MAKES WHOSER PUT THE MSG OUT
	POPJ P,
↑DDAVST:
	MOVEI AC2,1
	SKIPN DDFCNT		;ARE THERE ANY CHANNELS FREE?
	MOVE AC2,[DDUNMS,,DISJMP]	;NO MAKE UNAVAIL MESSAGE HAPPEN
	SKIPN MAINTMODE
	SKIPE TTYLOK
	MOVE AC2,[XWD DDDMES,DISJMP]
	MOVEM AC2,DDWMES

	DATAI DSK,AC1		;CHOOSE A (RANDOM) NUMBER, ANY NUMBER
	ADD AC1,TIME
	IDIVI AC1,300
	ADDI AC2,10
	MOVEI AC1,(AC2)
	DPB AC2,[150300,,AVLVP]	;STORE LOW ORDER PART
	LSH AC2,-3		;REMOVE LOW ORDER PART
	DPB AC2,[240500,,AVLVP]	;STORE HI PART
	IDIVI AC1,=12		;CONVERT RASTER LINE TO TEXT LINE
	HRLI AC1,3(AC1)		;AVL MSG USES 4 DIFFERENT TEXT LINES
	MOVSM AC1,AVLLN
	HRLZI AC2,20000
	IORM AC2,AVLWHO	;TURN ON ERASE BIT TO FORCE ERASE BEFORE FIRST FIELD
	POPJ P,

DDLIST:
	BYTE (6)37,36,35,34,33,32,31,30,27,25,24,23,7,22,11,12,26,5
	BYTE (6)13,17,2,14,10,1,20,21,16,15,6,4,3,0,DDELNK

↑VDSYNC:0
11
12
13
14
15
6
7

;ALL-PURPOSE DD CHANNEL DIDDLING UUO:
;AC31-35 = CHAN, AC30 => NO SPECIFIC CHAN (CONSOLE CHAN FOR STATUS)
;AC28-29: 0-RELEASE, 1-GET, 2-GET STATUS, 3-SET STATUS
;AC29=1 => FAILURE POSSIBLE, SKIP ON SUCCESS
;AC0 PRIVATE CHAN, SET ON GET OR SET STATUS
;REST OF LH READ-ONLY STATUS BITS, RETURNED ON SINGLE-CHAN OPS OR GETTING CHAN:
;AC10-17 USE: 0=FREE, 1-77=JOB N, 100-177=TTY N-100+DDL0, 200-377 SPECIAL

↑DDCHAN:DPB J,[DDUSR2,,TAC]
	LDB AC1,[DDGMOD,,TAC]
	ANDCMI TAC,-40
	PUSHJ P,@DDCDSP(AC1)
	JRST STOTAC
	AOS (P)
	JRST STOTAC

DDCDSP:
	DDCREL
	DDAREL
	DDCGET
	DDAGET
	DDSGET
	DDCSGT
	DDSSET
	DDCSST

;RELEASE ALL CHANS OWNED BY JOB (ALSO CALLED ON RESET)

↑DDAREL:PUSH P,TAC
	LDB TAC,[DDCLST(J)]
	SOJL TAC,TPOPJ
	HLL TAC,(P)
	MOVEI AC1,
	DPB AC1,[DDCLST(J)]	;CLEAR THE LIST HERE IN ONE SWELL FOOP
DDARL1:
	LDB AC3,[DDLNK(TAC)]
	PUSHJ P,DDREL		;SO WE DON'T HAVE TO DO IT HERE
	HRRI TAC,(AC3)
	CAIE AC3,DDELNK
	JRST DDARL1
	JRST TPOPJ

;RELEASE CHANNEL C(TAC)

DDCREL:
	LDB AC2,[DDLNK(TAC)]	;HERE CHAN BELONGS TO JOB
	LDB AC1,[DDCLST(J)]	;& MUST BE DELINKED FROM JOB'S LIST
	CAIN AC1,1(TAC)
	AOJA AC2,[CAIL AC2,41
		MOVEI AC2,
		DPB AC2,[DDCLST(J)]
		JRST DDREL]
	SOJL AC1,DDREL
DDCRL1:
	LDB AC3,[DDLNK(AC1)]
	CAIN AC3,(TAC)
	JRST [DPB AC2,[DDLNK(AC1)]
JRST DDREL]
	MOVEI AC1,(AC3)
	CAIE AC1,DDELNK
	JRST DDCRL1
↑DDREL:	LDB AC1,[DDUSR(TAC)]	;ENTER TO JUST RELEASE CHANNEL
	TSC AC1,TAC
	TRNE AC1,377
	JRST DDREL2		;DOESN'T BELONG TO HIM
	MOVEI AC1,(TAC)
	AOS AC2,DDFCNT
	CAIN AC2,1
	SETOM WHOKLU		;CHANGE TO AVAILABLE MESSAGE
	MOVSI AC2,377
	CONO PI,SCNOFF
	LDB AC1,[DDALST(AC1)]
	TDNE AC2,DDTAB(AC1)	;SCAN UP ALLOC LIST (ORDERED)
	JRST .-2
	LDB AC2,[DDLNK(AC1)]	;SO WE CAN PUT IN RIGHT PLACE IN FREE LIST
	DPB TAC,[DDLNK(AC1)]
	DPB AC2,[DDLNK(TAC)]
	HRRZS DDTAB(TAC)
↑SCNONJ:CONO PI,SCNON
	POPJ P,

DDREL2:
	TLNN TAC,300
	POPJ P,			;JUST SOME LOSER
	PUSHACS
	PUSHJ P,DISERR
	[ASCIZ /ILLEGAL DD RELEASE - TAC=/]
	DISARG OCT,<TAC-20(P)>
	[ASCIZ /
/]
	-1
	POPACS
	POPJ P,

;GET CHAN SPECIFIED BY TAC(31-35) IF FREE

↑DDCGET:HLLZ AC3,TAC
	MOVEI AC1,(TAC)
	MOVSI AC2,377
	CONO PI,SCNOFF
	TDNN AC2,DDTAB(AC1)
	JRST DDCG1
	CONO PI,SCNON
	HLL TAC,DDTAB(AC1)	;TELL HIM HOW HE LOST
	POPJ P,

DDCG1:
	LDB AC1,[DDALST(AC1)]	;IT'S FREE - SCAN FOR GUY POINTING TO IT
	TDNE AC2,DDTAB(AC1)
	JRST DDCG1
	IORM AC3,DDTAB(TAC)
	LDB AC3,[DDLNK(TAC)]	;SO WE CAN LINK IT OUT
	DPB AC3,[DDLNK(AC1)]
	CONO PI,SCNON
	MOVEI AC1,(TAC)
	JRST DDGET2

;GET ANY FREE CHAN

DDAGET:
	HLLZ AC3,TAC
	CONO PI,SCNOFF
	MOVE AC1,DDFLST
	CAIN AC1,DDELNK
	JRST SCNONJ
	LDB AC2,[DDLNK(AC1)]
	MOVEM AC2,DDFLST
	IORM AC3,DDTAB(AC1)
	CONO PI,SCNON
	HRRI TAC,(AC1)
;COMMON CODE FOR BOTH FLAVORS OF GET. PUTS IN LIST IF GETTING FOR JOB.
;SETS AND ENFORCES PRIVACY BIT.
DDGET2:
	SOSG DDFCNT
	SETOM WHOKLU			;SET NO CHANNELS LEFT MESSAGE
	TLNN TAC,300
	AOJA AC1,[LDB AC2,[DDCLST(J)]	;JOB - ADD TO ITS LIST
		DPB AC1,[DDCLST(J)]
		SOJGE AC2,[SOJA AC1,DDGET3]
		SOJA AC1,.+1]
	MOVEI AC2,DDELNK
DDGET3:
	DPB AC2,[DDLNK(AC1)]
	AOS (P)
	JUMPGE TAC,CPOPJ	;THAT'S ALL IF HE'S NOT PARANOID
	MOVEI AC1,(TAC)		;ELSE FALL THRU

;ROUTINE TO THROW ALL SPIES OFF PRIVATE CHANNEL.

↑DDFLSH:PUSHJ P,VDBIT
	PUSH P,TAC
	PUSH P,TAC1
	LDB TAC1,[DDUSR(AC1)]
	MOVSI TAC,-DDNUM+DPYNUM	;INCLUDE "SHADOW" CHANNELS HERE
DDFLS0:
	TDNN AC3,VDMAP(TAC)	;HERE WE SCAN THE PERM MAPS
DDFLS3:
	AOBJN TAC,DDFLS0
	JUMPGE TAC,DDFLS1
	CAIN TAC1,100(TAC)
	JRST DDFLS3
	PUSHJ P,VDSTR1
	ANDCAM AC3,VDTMP(AC2)
	PUSHJ P,VDOUT1
	AOBJN TAC,DDFLS0
DDFLS1:
	MOVSI TAC,-DDNUM
DDFLS2:
	SKIPE AC2,LETAB+DPYNUM(TAC)	;HERE WE SCAN THE TEMP MAPS
	TDNN AC3,VDTMP(AC2)
DDFLS4:
	AOBJN TAC,DDFLS2
	JUMPGE TAC,DDFLSX
	CAIN TAC1,100(TAC)
	JRST DDFLS4
	ANDCAM AC3,VDTMP(AC2)
	PUSHJ P,VDOUT1
	AOBJN TAC,DDFLS2
DDFLSX:
	POP P,TAC1
	JRST TPOPJ

;SEE IF THIS GUY CAN HACK THIS DD CHAN (AC1)
;0 SKIPS FREE. 1 SKIP LOSE. 2 SKIPS HE'S GOT IT.
DDCHEK:
	LDB AC2,[DDUSR(AC1)]
	JUMPE AC2,CPOPJ
	AOS (P)
	HRRE AC3,JBTLIN(J)
	JRST VDCCK0

;GET STATUS & # OF CONSOLE CHAN, AC UNCHANGED IF NONE (NOT DD)
DDCSGT:
	PUSHJ P,DDCFND
	POPJ P,
			;FALL THRU

;GET STATUS OF CHAN TAC(31-35)
DDSGET:
	HLL TAC,DDTAB(TAC)
	POPJ P,

;FIND CONSOLE CHAN FOR JOB

DDCFND:
	MOVE AC1,JBTLIN(J)
	TLNN AC1,DDDLIN
	POPJ P,
	JUMPL AC1,CPOPJ	;DETACHED
	HRRZ AC1,LETAB-DPYL0(AC1)
	HLR TAC,PRGNUM(AC1)	;PRETEND HE USED HIS CHAN AS ARG (PRESERVE LH)
	JRST CPOPJ1

;SET STATUS OF CONSOLE CHANNEL

DDCSST:
	PUSHJ P,DDCFND
	POPJ P,
			;FALL THRU

;HERE HE CAN SET THE STATUS OF A CHANNEL IF IT'S HIS

DDSSET:
	MOVEI AC1,(TAC)
	PUSHJ P,DDCHEK
	POPJ P,
	POPJ P,
	MOVE AC2,DDTAB(AC1)
	MOVSI AC3,DDSMSK
	CONO PI,SCNOFF
	ANDCAM AC3,DDTAB(AC1)
	AND AC3,TAC
	IORB AC3,DDTAB(AC1)
	HLL TAC,AC3
	CONO PI,SCNON
	JUMPGE TAC,CPOPJ1
	JUMPL AC2,CPOPJ1
	AOS (P)
	JRST DDFLSH		;TURNING PRIVATE - FLUSH LOSERS

;MAKES UP BIT (AC3) FROM DD CHAN (AC1)
↑VDBIT:	MOVNI AC2,(AC1)
	MOVSI AC3,400000
	LSH AC3,(AC2)
	POPJ P,

;THIS ROUTINE UPDATES BOTH PERMANENT & TEMPORARY (IF EXISTENT) MAPS
;WITH INTS OFF TO AVOID INCONSISTENT STATES
;TAC=CONSOLE #, @(P) IS DIDDLE INSTRUCTION
↑VDSTRB:PUSHJ P,VDBIT
↑VDSTR:	JUMPL TAC,VDSTRI
VDSTR1:
	MOVEI AC2,VDMAP-VDTMP(TAC)
	CONO PI,SCNOFF
	XCT @(P)
	SKIPE AC2,LETAB+DPYNUM(TAC)
	XCT @(P)
	CONO PI,SCNON
	JRST CPOPJ1

VDSTRI:
	TLNE AC1,-1
	HLLZ AC3,AC1	;PICK UP BITS PASSED, IF ANY
	SKIPN AC2,LETAB+DPYNUM(TAC)
	JRST CPOPJ1
	HRLI AC2,VPGACT
	CONO PI,PIOFF
	IDPB AC2,CLKQ		;SET TO DO PGACT AT CLK LEVEL
	CONO PI,PION
	SETOM LEACT(AC2)	;SO HEADER STAYS AROUND
	MOVEI AC2,PRGACT-VDTMP(AC2)	;MAKE PNTR TO PGACT BITS
	SKIPL @(P)	;SEE IF DIDDLING INSTR IS BOOLEAN
	HRR AC3,VDTMP(AC2)	;NOT BOOLEAN, COPY RH SO IT WON'T GET CLOBBERED
	XCT @(P)
	JRST CPOPJ1

;SET EITHER TEMPORARY OR PERMANENT MAPPING, DETERMINED BY
;SIGN BIT OF DSER (CALLED FROM VDSMAP ROUTINES)
VDSTRU:
	JUMPL DSER,VDSTR
	SKIPE AC2,LETAB+DPYNUM(TAC)
	XCT @(P)
	JRST CPOPJ1

;OUTPUTS CURRENT MAPPING (TEMPORARY, IF EXISTENT, ELSE PERMANENT)
;FOR CONSOLE C(TAC)
↑VDOUT:	JUMPL TAC,CPOPJ		;NO III'S HERE
VDOUT1:
	SKIPN AC2,LETAB+DPYNUM(TAC)
	MOVEI AC2,VDMAP-VDTMP(TAC)
	CONO PI,SCNOFF
	CONO VDS,DPYNUM(TAC)	;THIS WRAPS AROUND TO "SHADOW" WITH TAC>DDNUM
	DATAO VDS,VDTMP(AC2)
	CONO PI,SCNON
	POPJ P,

;ALL-PURPOSE VDS DIDDLING UUO:
;RH(AC)=ADR
;AC11-17 = TTY#, 0 => OWN CONSOLE; AC9=1 => USE "SHADOW" CHAN INDICATED BY AC11-17
;AC0=1 => PERMANENT CHANGE, 0 => TEMP CHANGE (GOES AWAY ON RESET)
;FINAL STATUS (TEMP/PERM PER AC0) STORED IN AC, -1 IF TTY NOT DD.
;AC6-8 = OPCODE:
;	0 - NOP, NEVER SKIPS, USEFUL FOR GETTING STATUS ALONE
;	1 - SET MAP FROM C(ADR), SKIPS IF ENTIRELY SUCCESSFUL (NO PRIVACY PROBLEM)
;	2 - IOR MAP FROM C(ADR), SET ANALOG IF ≠0. SKIPS ON COMPLETE SUCCESS.
;	3 - ANDCAM MAP FROM C(ADR), CLEAR ANALOG IF ≠0. FAILS ONLY ON BAD TTY #.
;	4 - RESET MAP. IN TEMP MODE THIS RESETS TEMP←PERM. IN PERM MODE PERM MAP
;			IS SET TO MAIN CHANNEL ALONE. FAILS ONLY ON BAD TTY #.
;	5-7 ILLEGAL. CURRENTLY NO-OPS.

↑VDSMAP:XCTR	XR,[MOVE DAT,(TAC)]
	LDB AC1,[VDOP,,TAC]
	CAIL AC1,NVDOPS
	POPJ P,
	MOVE DSER,TAC
	LDB TAC,[220700,,TAC]
	TLNE DSER,VDXBIT
	JRST VDMAP5
	JUMPN TAC,.+2
	HRRE TAC,JBTLIN(J)
	SUBI TAC,DDL0
	CAIGE TAC,DDNUM
	JUMPGE TAC,.+2
	JRST VDMAP4
	SKIPL VDDSP(AC1)
	JRST VDMAP2
	SKIPA AC2,JBTLIN(J)
VDMAP1:
	MOVE AC2,JBTLIN(AC2)
	CAMN AC2,[-1]		;DETACHED?
	JRST VDMP1A
	CAIN TAC,-DDL0(AC2)
	JRST VDMAP2		;LET HIM BY IF IT'S HIS CHAN
	TLNE AC2,PTYLIN
	SKIPN AC2,PTYJOB-PTYL0(AC2)	;OR IF IT'S HIS VIA SOME PTY CHAIN
VDMP1A:
	SKIPA AC2,JBTPRV(J)
	JRST VDMAP1
	TLNE AC2,UPGPRV		;OR IF HE HAS THE MAGIC PRIVILEGE
	JRST VDMAP2
	MOVE AC2,[TTYATC,,ASSCON+ASSPRG]
	SKIPE DDB,TTYTAB+DDL0(TAC)
	TDNN AC2,DEVMOD(DDB)
	JRST VDMAP2		;OR IF IT'S FREE
	LDB AC2,PJOBN
	CAIE AC2,(J)
	JRST VDMAP3
				;FALL THRU TO VDMAP2 IF HE OWNS THE CONSOLE

VDMAP2:
	HLL TAC,VDDSP(AC1)
	TLZ TAC,400000		;DON'T CONFUSE VDOUT, after all we're not a III
	PUSHJ P,@VDDSP(AC1)
	PUSHJ P,VDOUT
	TLNE TAC,200000		;DON'T SKIP IF NOT REQUESTED
	AOS (P)			;NOTE THIS BIT WAS CLEARED BY ANY FAILURE
VDMAP3:
	TLNN DSER,VDPERM	;GIVE HIM APPROPRIATE FLAVOR OF STATUS
	SKIPN DAT,LETAB+DPYNUM(TAC)
	SKIPA TAC,VDMAP(TAC)
	MOVE TAC,VDTMP(DAT)
	JRST STOTAC

VDMAP5:
	ADDI TAC,DDNUM		;HERE TO MAP "SHADOW" CHANNELS
	CAIGE TAC,DPYNUM+DDNUM
	JRST VDMAP2
VDMAP4:
	XCTR	XW,[SETOM (UUO)]	;NOT DD - USE POSSIBLE BUT UNLIKELY VALUE TO FLAG THIS.
	POPJ P,

VDDSP:
	CPOPJ1		;DON'T EVEN BOTHER WITH VDOUT
	600000,,VDSET
	600000,,VDIOR
	600000,,VDACM
	600000,,VDRST
NVDOPS←←.-VDDSP

VDSET:
	PUSHJ P,VDWCHK
	PUSHJ P,VDSTRU
	MOVEM DAT,VDTMP(AC2)
	POPJ P,

VDIOR:
	TRNN DAT,17
	JRST VDIOR1
	MOVEI AC3,17
	PUSHJ P,VDSTRU	;CLEAR ANALOG HERE SO THESE DON'T GET OR'ED
	ANDCAM AC3,VDTMP(AC2)
VDIOR1:
	PUSHJ P,VDWCHK
	PUSHJ P,VDSTRU
	IORM DAT,VDTMP(AC2)
	POPJ P,

VDACM:
	TRNE DAT,17
	TRO DAT,17	;ANYTHING IN ANALOG FIELD CLEARS IT ALL
	PUSHJ P,VDSTRU
	ANDCAM DAT,VDTMP(AC2)
	POPJ P,

VDRST:
	JUMPL DSER,VDNORM
VDRST1:
	SKIPN AC2,LETAB+DPYNUM(TAC)
	POPJ P,
	CONO PI,SCNOFF
	MOVE AC3,VDMAP(TAC)
	MOVEM AC3,VDTMP(AC2)	;SET TEMP MAP FROM PERM
	CONO PI,SCNON
	POPJ P,

↑VDNORM:SKIPN AC2,LETAB+DPYNUM(TAC)
	SKIPA AC1,AVLCHN
	HLRZ AC1,PRGNUM(AC2)
	PUSHJ P,VDSTRB		;SET BOTH MAPS TO HIS CHAN OR AVAILABLE
	MOVEM AC3,VDTMP(AC2)
	POPJ P,

;ROUTINE TO BLESS BITS ABOUT TO BE TURNED ON FOR PRIVACY VIOLATION
;LOSING BITS ARE FLUSHED, AND SKIP FLAG IS CLEARED
VDWCHK:
	MOVSI AC1,-40
VDWCHL:
	JUMPGE DAT,VDWOK
	SKIPL DDTAB(AC1)
	JRST VDWOK
	HRRE AC3,JBTLIN(J)
	PUSHJ P,VDCCHK		;TRYING TO LOOK AT PRIVATE CHAN, SEE IF IT'S OK
	JRST VDWLUZ
VDWOK:
	ROT DAT,1
	AOBJN AC1,VDWCHL
	ROT DAT,4
	TRNN DAT,17
	POPJ P,
	LDB AC1,[300,,DAT]
	IOR DAT,VDSYNC(AC1)
	POPJ P,

VDWLUZ:
	TLZ DAT,400000
	TLZ TAC,200000
	JRST VDWOK

;ROUTINE TO SEE IF LOOKING AT PRIVATE CHAN IS LEGAL
;AC1=CHAN, TAC=MAPPED CONSOLE, AC3=MAPPING CONSOLE, J=MAPPING JOB.
↑VDCCHK:LDB AC2,[DDUSR(AC1)]
	CAIN AC2,100(TAC)
	JRST CPOPJ1		;CAN ALWAYS MAP CONSOLE TO ITSELF
VDCCK0:
	TRNE AC2,300
	JRST VDCCK2		;CONSOLE CHAN
VDCCK1:
	CAIN J,(AC2)
	JRST CPOPJ1		;JOB OWNS IT
	MOVE AC2,JBTLIN(AC2)
	AOJE AC2,CPOPJ		;DETACHED
	TLNN AC2,PTYLIN
	JRST VDCCK3
	MOVE AC2,PTYJOB-PTYL0-1(AC2)	;SEE IF IT CAN GET TO IT VIA PTY
	JRST VDCCK1

VDCCK2:
	ADD AC2,[DDDLIN-1,,DDL0-100+1]
VDCCK3:
	TLNE AC2,DDDLIN
	CAIE AC3,-1(AC2)		;JOB'S OWN CONSOLE WINS
	POPJ P,
	JRST CPOPJ1

BEND DPYSER

SUBTTL WHO LINE GENERATOR--R. HELLIWELL--6/APR/70
COMMENT ⊗
	THIS ROUTINE ALLOWS EACH LUCKY OWNER OF A DISPLAY
TO HAVE ONE LINE OF "WHO" INFORMATION ON HIS SCREEN AT ANY TIME
IT USES THE LINE EDITOR FOR ACTIVATION IN THE FOLLOWING MANNER.

	<ESC>W
	TO DISPLAY THE WHO LINE FOR THE JOB ATTACHED TO THIS DPY.

	<ESC><N>W
	TO DISPLAY THE WHO LINE FOR JOB N ON THIS DPY.

	<BREAK>W
	STOP THE WHO LINE.

LOOK FOR CODE IN THE LINE EDITOR AROUND THE LABEL "ESCW".
ALSO IN DPYSER.
WHOSER IS CALLED FROM CLKINT.
⊗


BEGIN WHOSER

GLOBAL DDUSR

DISJSR←←24		;STORES RETURN
DISJMP←←20		;JUMP
DISNOP←←12		;GOOD NO-OP WITH NO BITS.
DEFINE CW (C1,B1,C2,B2,C3,B3) {<BYTE (8)<B1>,<B2>,<B3>(3)<C1>,<C2>,<C3>>!4}

;AC'S USED
;WHO IS FOR DPY # AND JOB STATUS WORD.
;TAC AND TAC1 AND AC2 ARE SORT OF TEMPORARY
;AC1 LOCATION OF FREE STORAGE BUFFER.
;AC3 BYTE POINTER TO FREE STORAGE, INDEXED BY AC1
;J CONTAINS JOB NUMBER OF WHO LINE.

;WHOPTR 0 = LINE IS FREE.
;      >0 = LINE IS WAITING TO BE QUEUED
;      -2 OR -1 = LINE HAS BEEN QUEUED.

WHO←TEM			;DPY INDEX AT TOP LEVEL.

↑WHOINI:
REPEAT 0,<	; THESE CELLS ARE ALL BETWEEN SYSBEG AND SYSEND AND THUS GET ZEROED AT SYSINI
	SETZM	WHONXT			;NUMBER OF III DONE LAST
	SETZM	WHDDNXT			;NUMBER OF THE DD DONE LAST
	SETZM	JBSRUN			;BITS FOR JOBS THAT
	SETZM	JBSRUN+1		;  HAVE RUN LATELY
	SETZM	FREWAT
	SETZM	FRETAB			;FREE STORAGE POINTER FOR EACH WHO LINE
	SETZM	WHOPTR			;POINTER TO THE DD THAT WAS DONE LAST.
					;SEE WHOQUE IN DPYSER
	MOVE	TAC,[XWD FRETAB,FRETAB+1]
	BLT	TAC,FRETAB+DDNUM+DPYNUM-1
>;END REPEAT 0
	POPJ	P,

↑WHOSER:MOVE	DAT,TIME
	TRNE	DAT,1				;EVEN TIC?
	POPJ	P,				;NO, SKIP IT.
	MOVE	AC1,FREWAT
	JUMPE	AC1,.+2				;WAITING TO GIVE BACK FREE STORAGE?
	PUSHJ	P,FSGIVE			;YES. DO IT.
	SETZM	FREWAT
;WE DO WHO LINES FOR 5 III DISPLAYS IN 10. TICKS, THEN
;ON THE 12.TH  TICK WE DO ONE DD LINE AND THE OTHER III.
WHOIII:
	SOSL	WHO,WHONXT			;NEXT GUY TO DO.
	JRST	WHODO1				;JUMP IF THERE'S ANOTHER III TO DO
WHODO:
	MOVE	TAC,DDOFF			;DATA DISK IS OFF?
	JUMPN	TAC,WHODO9			;JUMP IF DD IS OFF.
	MOVE	TAC,WHOPTR			;DD WHO LINE STILL BUSY?
	JUMPN	TAC,WHODO2			;IF SO, LEAVE EARLY.
WHODO9:
	SOSLE	AC1,WHOKLU			;COUNT DOWN TO AVL MSG SHIFT
	JRST	WHODO4
	PUSHJ	P,DDAVST			;THIS MOVES IT
	MOVEI	AC1,=300
	MOVEM	AC1,WHOKLU	;300 WHODO'S IS A MINUTE (BEFORE NEXT SHIFT OF MSG)
	MOVEI	WHO,DDAVLU			;WHOKLU SET, SERVICE AVLCHN NOW
	JRST	WHODO3
WHODO4:
	SOSGE	WHO,WHDDNXT			;WHO'S NEXT FOR WHO
	PUSHJ	P,WHOSYS			;END OF DD.  RECALCULATE SYSTEM LINE
	LDB	WHO,[DDUSR(WHO)]		;MAP FROM DD CHANNEL TO TTY NUMBER
	CAIN	WHO,DDAVLU			;AVAILABLE CHANNEL?
	JRST	WHODO3				;YES, SKIP WHODO1
	CAIL	WHO,100
	CAILE	WHO,177
	JRST	WHODO2				;NOT USER'S CONSOLE
	SUBI	WHO,100-DPYNUM			;MAKE DPY (TTY) NUMBER
	PUSHJ	P,WHODO1			;GO REFRESH ONE MORE DD WHO LINE
WHODO3:
	MOVEM	WHO,WHOPTR			;SET TO FLAG WHOQUE.
WHODO2:
	MOVEI	WHO,DPYNUM-1			;START ON III DISPLAYS AGAIN
	MOVEM	WHO,WHONXT			;SAVE INDEX OF WHO WAS DONE LAST

WHODO1:
	MOVE	AC1,FRETAB(WHO)			;GET THE FREE STORAGE BLOCK
	MOVE	DDB,LETAB(WHO)			;GET PTR TO DPY HEADER
	JUMPE	DDB,WHOCLR			;JUMP IF NO DPY HEADER
	HRRZ	J,WHOTAB(DDB)			;GET JOB NUMBER FOR THIS LINE.
	MOVE	DAT,JBTSTS(J)			;GET JOB'S STATUS WORD
	TLNN	DAT,JNA				;IS IT STILL THERE?
	SETZB	J,WHOTAB(DDB)			;NO, FLUSH!
	JUMPE	J,WHOCLR			;JUMP IF NO WHO REQUEST
						;CHECK FOR RELEASE OF FREE STORAGE
	JUMPE	AC1,WHOSET			;JUMP IF WE NEED TO MAKE FS BLOCK.
	MOVE	DAT,WHDDNXT
	CAIGE	WHO,DPYNUM			;ALWAYS UPDATE SLOW PART FOR DD
	TRNN	DAT,3				;UPDATE WHOLE III AFTER 4 DATA DISKS
	JRST	WHOLIN				;COMPUTE ENTIRE LINE.
	JRST	ALWAYS				;JUST DO THE FAST PART THIS TIME

WHOCLR:
	JUMPE	AC1,CPOPJ			;DO WE HAVE FREE STORAGE BLOCK
	SETZM	FRETAB(WHO)			;YES. CLEAR FRETAB
	HRRZM	AC1,FREWAT			;YES, QUEUE IT FOR NEXT TIC.
	CAIL	WHO,DPYNUM			;IS THIS A DATA DISC DISPLAY?
	POPJ	P,				;YES, LEAVE EARLY
	HRRZ	DDB,LETAB(WHO)
	JUMPE	DDB,CPOPJ			;IF SLIPPED OUT FROM UNDER US, FORGET IT
	MOVEI	TAC,DISNOP			;RESET WHOCALL.
	MOVEM	TAC,WHOCALL(DDB)
	MOVSI	TAC,400000			;DONT SELECT III FOR SYS WHO LINE
	MOVNI	AC2,(WHO)
	LSH	TAC,(AC2)
	ANDCAM	TAC,WHOSEL			;TURN OFF SET BIT
	LSH	TAC,-=12			;DESELECT THIS III FOR SYS WHO LINE
	ORM	TAC,WHOSEL			;TURN ON RESET BIT
	JRST	WHORST				;RESTART POOLE AND RETURN TO CLKSER

WHOSIX:
	MOVEI	AC2,6			;CHARACTER COUNT
WHOSXX:
	MOVEI	TAC,0			;DATA IN TAC1
	LSHC	TAC,6
	ADDI	TAC," "
	IDPB	TAC,AC3
	SOJG	AC2,WHOSXX
	POPJ	P,

;WSDPAD - CALL WITH
;	AC3 = BYTE POINTER
;	AC2 = CHARACTER COUNT
;	TAC = DATA
;	TAC1, UCHN, DAT ARE CLOBBERED.
;	PRINTS NUMBER WITH LEADING SPACES.
;CALL WSDPD2 WITH UCHN = RADIX; DAT = PADDING CHARACTER. AC3,AC2,TAC AS ABOVE.
;CALL WSDPD3 WITH UCHN = RADIX.  USES BLANK PADDING.
WSDPAD:
	MOVEI	UCHN,=10
WSDPD3:
	MOVEI	DAT," "			;PADDING CHARACTER
WSDPD2:
	IDIVI	TAC,(UCHN)
	HRLM	TAC1,(P)
	SUBI	AC2,1			;COUNT A CHARACTER GENERATED.
	JUMPE	TAC,WSDPD1
	PUSHJ	P,WSDPD2
WSDPD0:
	HLRZ	TAC,(P)
	ADDI	TAC,"0"
	IDPB	TAC,AC3
	POPJ	P,

WSDPD1:
	SOJL	AC2,WSDPD0
	IDPB	DAT,AC3
	JRST	WSDPD1

WPER2D:
	IMULI	TAC,=100	;PRINT TAC/TAC1 AS A PERCENTAGE IN 2 DIGITS
	IDIV	TAC,TAC1
	CAIL	TAC,=100
	MOVEI	TAC,=99		;PRINT 99 FOR 100
				;FALL INTO W0PD2

;PRINT A 2 DIGIT DECIMAL NUMBER PADDED WITH A LEADING ZERO IF NECESSARY
;CALL WITH NUMBER IN TAC, BYTE POINTER IN AC3.  CLOBBERS TAC1
W0PD2:
	IDIVI	TAC,=10
	ADDI	TAC,"0"
	IDPB	TAC,AC3
	ADDI	TAC1,"0"
	IDPB	TAC1,AC3
	POPJ	P,

;PRINT A DECIMAL NUMBER PADDING WITH FOLLOWING BLANKS
;	TAC = DATA
;	AC2 = CHARACTER COUNT
;	AC3 = BYTE POINTER
;TAC, AC2, TAC1 AND DAT ARE CLOBBERED
DECPDF:
	MOVEI	DAT," "			;THIS IS THE CHARACTER TO PAD WITH
	PUSHJ	P,WHPRNT		;CONVERT TAC TO ASCII AND SAVE CHARACTERS
	SOJL	AC2,CPOPJ		;ANY PADDING NEEDED?
	IDPB	DAT,AC3			;YES.  PAD WITH A BLANK
	SOJGE	AC2,.-1			;MORE PADDING NEEDED?
	POPJ	P,			;NOPE

WHPRNT:
	IDIVI	TAC,=10			;ROUTINE TO DO THE WORK FOR DECPDF
	HRLM	TAC1,(P)
	JUMPE	TAC,.+2
	PUSHJ	P,WHPRNT
	HLRZ	TAC,(P)
	ADDI	TAC,"0"
	IDPB	TAC,AC3			;DEPOSIT ONE DECIMAL DIGIT
	SUBI	AC2,1			;NOTE THAT WE HAVE PUT OUT A CHARACTER
	POPJ	P,

;THIS IS THE PART WE ALWAYS UPDATE.
ALWAYS:
	ANDI	J,-1
	MOVE	DAT,JBTSTS(J)
;	TLNN	DAT,JNA
;	JRST	[SETZM WHOTAB(DDB)	;JOB HAS GONE AWAY.
;		POPJ P,]
	MOVE	AC3,[POINT 7,WTEND+4(AC1),34]
	MOVM	TAC,JOBQUE(J)		;GET QUEUE NUMBER.
	MOVE	TAC,QNAMS(TAC)		;GET PRINT NAME.
	TRO	TAC,1
	MOVEM	TAC,@AC3
	MOVEI	TAC," "
	CAMN	J,JOB			;CURRENTLY RUNNING JOB?
	MOVEI	TAC,"-"			;YES
	TLNE	DAT,SWP			;SWAPPED OUT?
	MOVEI	TAC,"*"			;YES
	TRNE	DAT,JLOCK		;LOCKED IN CORE?
	MOVEI	TAC,026;"⊗"			;YES
	DPB	TAC,AC3

	MOVEI	TAC," "
	MOVE	TAC1,SPWGO(J)		;SPACEWAR ON THE 10?
	JUMPE	TAC1,ALWAY1		;NO
	MOVEI	TAC,"\"			;YES
	MOVE	TAC1,SP2GO(J)		;SPACEWAR ON 6 ALSO?
	JUMPE	TAC1,ALWAY2		;NO
	MOVEI	TAC,"X"			;YES
	JRST	ALWAY2

ALWAY1:
	MOVE	TAC1,SP2GO(J)		;SPACEWAR ON THE 6?
	JUMPE	TAC1,ALWAY2		;NO
	MOVEI	TAC,"/"			;YES
ALWAY2:
	LDB	TAC1,PSEGN		;IS THERE A SEGMENT?
	JUMPE	TAC1,ALWAY3		;NO
	MOVE	TAC1,JBTSTS(TAC1)	;YES
	TLNE	TAC1,SWP		;IS IT SWAPPED OUT?
	MOVEI	TAC,"*"			;YES
ALWAY3:
	IDPB	TAC,AC3

;PRINT XTIME INCREMENT
	MOVE	TAC,XTIME(J)		;GET RUN TIME AT LAST INTERACTION
	MOVEI	TAC1,"'"		;PUNCTUATE TICKS WITH RIGHT QUOTE
	TLZE	TAC,400000		; UNLESS NO-UPDATE FLAG SET
	MOVEI	TAC1,42			;IN WHICH CASE USE double QUOTE
	DPB	TAC1,[POINT 7,WTEND+13(AC1),27] ;DEPOSIT PUNCTUATOR
	MOVN	TAC,TAC
	ADD	TAC,TTIME(J)		;CALCULATE INCREMENT IN RUN TIME
	JUMPE	DDB,XTALL		;ALWAYS IF TTY (DDB=0)
	HLRZ	TAC1,WHOTAB(DDB)	;GET INCREMENT FROM LAST TIME
	CAIN	TAC1,(TAC)		;SAME?
	JRST	NOXTIM			;YES.  DON'T UPDATE INCREMENT
	HRLM	TAC,WHOTAB(DDB)		;NO.  SAVE INCREMENT THIS TIME FOR NEXT TIME
XTALL:
	IDIVI	TAC,=60			;CONVERT TO SECONDS
	PUSH	P,TAC1			;SAVE TICKS
	MOVE	AC3,[POINT 7,WTEND+12(AC1),13]
	PUSHJ	P,WHOTIM		;PRINT X INCREMENT
	IBP	AC3			;SKIP OVER PUNCTUATOR (ALREADY DEPOSITED)
	POP	P,TAC			;RETRIEVE TICKS
	PUSHJ	P,W0PD2			;PRINT TICKS

NOXTIM:
	MOVE	TAC,TTIME(J)		;GET RUN TIME
	JUMPE	DDB,DOTIME		;ALWAYS DO FOR TTY WHO (DDB=0)
	CAML	TAC,WHORUN(DDB)		;TIME TO UPDATE RUN TIME YET?
	JRST	DOTIME			;YES
	ADDI	TAC,=60			;MAYBE NOT.  IS WHORUN REASONABLE?
	CAML	TAC,WHORUN(DDB)
	POPJ	P,			;YES
	SUBI	TAC,=60			;NO, READJUST RUN TIME AND THEN UPDATE
DOTIME:
	MOVE	DAT,TAC			;COPY RUN TIME
	IDIVI	TAC,=60			;LEAVE SECONDS IN TAC.
	SUBI	DAT,(TAC1)		;ADJUST DAT TO LAST WHOLE SECOND OF RUN TIME
	ADDI	DAT,=60			; AND THEN ADD ONE SECOND
	SKIPE	DDB			;NOT FOR TTY WHO
	MOVEM	DAT,WHORUN(DDB)		; AND SAVE THAT AS TIME FOR NEXT UPDATE
	MOVE	AC3,[POINT 7,WTEND+10(AC1),6]	;FALL INTO WHOTIM

WHOTIM:
	IDIVI	TAC,=60*=60		;HOURS IN TAC, MINUTES, SECONDS IN TAC1
	JUMPE	TAC,[MOVEI DAT," "	;FILL HOURS FIELD WITH ONE SPACE
		DPB DAT,AC3
		MOVEI DAT,0		; AND ONE NULL.  THEN FILL MINUTES WITH NULLS
		IDPB DAT,AC3
		JRST WMIN]
	MOVEI	DAT,"0"			;FLAG TO FILL MINUTES FIELD WITH 0'S
	ADDI	TAC,"0"
	DPB	TAC,AC3
	MOVEI	TAC,":"
	IDPB	TAC,AC3
WMIN:
	MOVE	TAC,TAC1
	IDIVI	TAC,=60
	PUSH	P,TAC1			;SAVE SECONDS
	MOVEI	UCHN,=10		;SET RADIX. DAT SET WITH FILL CHARACTER
	MOVEI	AC2,2			;NUMBER OF CHARACTERS TO FILL.
	PUSHJ	P,WSDPD2		;WRITE DECIMAL WITH FILL.
	MOVEI	TAC,":"
	IDPB	TAC,AC3
	POP	P,TAC
	JRST	W0PD2			;WRITE SECONDS AS TWO CHARACTERS.  RETURN.

; THIS ROUTINE SETS UP A NEW WHO TABLE FROM A PIECE OF FREE STORAGE

WHOSET:
	MOVEI	AC3,WLINK+1		;GET SIZE.
	PUSHJ	P,FSGET			;GET FREE STORAGE.
	POPJ	P,			;NONE, RETURN.
	MOVEM	AC1,FRETAB(WHO)		;SAVE FREE STORAGE POINTER.
	MOVE	TAC,AC1
	HRLI	TAC,TITLE
	BLT	TAC,WLINK(AC1)		;PUT LINE MODEL INTO FREE STORAGE.
	SETZM	WHORUN(DDB)		;ZERO THE TIME TO UPDATE RUN TIME NEXT
	CAIL	WHO,DPYNUM		;IS THIS A DD DISPLAY?
	JRST	WHOLIN			;YES, NOTHING SPECIAL TO DO
	MOVEI	TAC,DISNOP		;IIIs DONT DO THEIR OWN SYSTEM WHO LINE
	MOVEM	TAC,2(AC1)		; SO A NO-OP REPLACES THE JMP TO SYS LINE
	HRLI	AC1,DISJMP
	MOVSM	AC1,WLINK(AC1)		;STORE JUMP BACK TO FRONT OF BLOCK.
	HRLI	AC1,DISJSR
	MOVE	AC3,LETAB(WHO)
	JUMPE	AC3,WHOCLR		;JUMP IF DPY HEADER DISAPPEARED
	MOVSM	AC1,WHOCALL(AC3)	;STORE JSR TO FS BLOCK WHERE III WILL HIT IT
	ANDI	AC1,-1			;CLEAR LEFT SIDE.
	MOVSI	TAC,400000		;SELECT THIS III FOR SYS WHO LINE
	MOVNI	AC2,(WHO)
	LSH	TAC,(AC2)
	ORM	TAC,WHOSEL		;TURN ON SET BIT
	LSH	TAC,-=12		;DONT DESELECT THIS III FOR SYS WHO LINE
	ANDCAM	TAC,WHOSEL		;TURN OFF RESET BIT
↑WHOLIN:PUSHJ	P,ALWAYS
;	HRRZ	TAC,WHOTAB(DDB)		;HAS JOB GONE AWAY?
;	JUMPE	TAC,CPOPJ		;YES. DON'T WORK AT IT.
	HRRZ	TAC,J
	MOVE	AC3,[POINT 7,WTEND(AC1)]
	MOVEI	AC2,2			;2 CHARACTERS
	PUSHJ	P,WSDPAD		;WRITE DECIMAL JOB NUMBER
	MOVE	AC3,[POINT 7,WTEND(AC1),27]
	MOVE	TAC1,PRJPRG(J)		;PROJECT-PROGRAMMER INITIALS.
	PUSHJ	P,WHOSIX		;DO SIXBIT OUTPUT
	HRRE	TAC,JBTLIN(J)		;GET LINE NUMBER AND SEE IF DETACHED
	JUMPL	TAC,[MOVE TAC1,[ASCID /  DET/]
		MOVEM TAC1,WTEND+2(AC1)
		JRST WLRET]
	MOVEI	AC2,5			;NOT DETACHED.  PRINT LINE NO IN 5 SPACES
	MOVEI	UCHN,10			;OCTAL RADIX
	PUSHJ	P,WSDPD3		;WRITE IT WITH BLANK PADDING

WLRET:
	MOVE 	AC3,[POINT 7,WTEND+5(AC1),20]
	MOVE	TAC1,JOBNAM(J)			;JOB NAME
	PUSHJ	P,WHOSIX
	MOVE	TAC,JBTADR(J)			;CORE SIZE.
	JUMPE	TAC,[LDB TAC,IMGIN		;IF SWAPPED OUT, GET SWAPPED SIZE
		JRST WSIZE]
	HLRZ	TAC,TAC
	AOJ	TAC,
	LSH	TAC,-12
WSIZE:
	MOVEI	AC2,4			;4 CHARACTERS OUT, PAD WITH BLANKS
	PUSHJ	P,WSDPAD		;WHOSER DECIMAL PAD OUTPUT

	MOVE	AC3,[POINT 7,WTEND+11(AC1),20]	;OVERALL RUN/WAIT PERCENTAGE
	MOVE	TAC,TTIME(J)			;RUN TIME
	MOVE	TAC1,JBTWAT(J)			;WAIT TIME
	JUMPGE	TAC1,.+2			;IS WAIT TIME HONEST?
	ADD	TAC1,UPTIME			;NO.  ADJUST IT
	PUSH	P,TAC1				;SAVE TOTAL WAIT TIME
	PUSHJ	P,WPER2D			;PRINT PERCENTAGE IN 2 COLS WITH LEADING ZERO

	MOVE	AC3,[POINT 7,WTEND+14(AC1),13]	;INCREMENTAL RUN/WAIT PERCENTAGE
	MOVE	TAC,TTIME(J)			;RUN TIME
	MOVE	TAC1,XTIME(J)			;RUN TIME LAST SAVED
	TLZ	TAC1,400000			;CLEAR NO-UPDATE BIT
	SUB	TAC,TAC1			;CALCULATE INCREMENTAL RUN TIME
	POP	P,TAC1				;RETRIEVE CURRENT WAIT TIME
	SUB	TAC1,JB2WAT(J)			;CALCULATE INCREMENTAL WAIT TIME
	PUSHJ	P,WPER2D			;PRINT PERCENTAGE IN 2 COLS WITH LEADING ZERO

	MOVS	TAC1,DSKOPS(J)			;GET NUMBER OF DSK OPS
	HLRZ	TAC,TAC1			;TOTAL NO OF DSK OPS
	SUBI	TAC,(TAC1)			;LESS PREVIOUS TOTAL
	MOVEI	AC2,6				;6 COLS
	PUSHJ	P,WSDPAD			;LEADING BLANKS, DECIMAL NUMBER

	LDB	TAC,PSEGN			;DOES HE HAVE A SECOND SEGMENT?
	JUMPE	TAC,[MOVEI TAC,DISNOP		;NO
		MOVEM TAC,WTEND+16(AC1)
		MOVEM TAC,WTEND+17(AC1)
		JRST WALIAS]
	MOVE	AC3,[POINT 7,WTEND+16(AC1),6]	;YES
	MOVEI	TAC1,1
	MOVEM	TAC1,WTEND+16(AC1)
	MOVEM	TAC1,WTEND+17(AC1)
	MOVEI	TAC1," "
	DPB	TAC1,AC3			;PRECEDE SEGMENT NAME WITH 1 SPACE
	MOVE	TAC1,JOBNAM(TAC)
	MOVEI	AC2,7				;WRITE SIXBIT + 1 SPACE
	PUSHJ	P,WHOSXX

WALIAS:
	MOVE	TAC1,DSKPPN(J)			;DOES HE HAVE AN ALIAS?
	JUMPE	TAC1,[MOVEI TAC,DISNOP		;NOPE
		MOVEM TAC,WTEND+20(AC1)
		MOVEM TAC,WTEND+21(AC1)
		POPJ P,]
	MOVEI	TAC,1				;YES
	MOVEM	TAC,WTEND+20(AC1)
	MOVEM	TAC,WTEND+21(AC1)
	MOVE	AC3,[POINT 7,WTEND+20(AC1),6]
	MOVEI	TAC," "
	DPB	TAC,AC3
	MOVEI	TAC,050;;"("
	IDPB	TAC,AC3
	PUSHJ	P,WHOSIX			;PUT IN 6 SIXBIT CHARS FROM DSKPPN
	MOVEI	TAC,051;;")"				; SURROUNDED BY PARENTHESES
	IDPB	TAC,AC3
	POPJ	P,

↑WHOSYS:
	MOVN	TAC,TTIME		;GET CURRENT NULL TIME
	EXCH	TAC,LASTNL		;SAVE IT AND GET PREVIOUS NULL TIME
	ADD	TAC,TTIME		;FIND INCREMENT IN NULL TIME
	MOVN	TAC1,UPTIME		;GET CURRENT UPTIME
	EXCH	TAC1,LASTUP		;SAVE IT AND GET PREVIOUS UP TIME
	ADD	TAC1,UPTIME		;FIND INCREMENT IN UP TIME
	JUMPE	TAC1,NONULL
	IMULI	TAC,=100		;CALCULATE NULL TIME IN PERCENT
	IDIV	TAC,TAC1
	MOVE	AC3,[POINT 7,COMWHO+7,13]
	MOVEI	AC2,3			;PRINT NULL PERCENTAGE IN 3 SPACES,
	PUSHJ	P,WSDPAD		; PADDING WITH SPACES
NONULL:
	MOVE	AC3,[POINT 7,COMWHO+15,13]
	HRRZ	TAC,TIMDAT		;GET TIME OF DAY IN SECS
	IDIVI	TAC,=60			;MINS INTO TAC, SECS INTO TAC1
	IDIVI	TAC,=60			;HOURS INTO TAC, MINS INTO TAC1
	PUSH	P,TAC1			;SAVE MINS
	PUSHJ	P,W0PD2		;WRITE HOURS AS 2 DECIMAL DIGITS, PADDING WITH 0'S
	IBP	AC3			;SKIP OVER COLON AFTER HOURS
	POP	P,TAC			;RETRIEVE MINS
	PUSHJ	P,W0PD2			; AND WRITE 2 DIGIT NUMBER

	MOVE	AC1,THSDAT		;GET TODAY'S DATE
	CAMN	AC1,WHODAT		;NEW DAY ARRIVED YET?
	JRST	WHOSY1			;NO. DONT RECOMPUTE DAY AND DATE
	MOVEM	AC1,WHODAT		;YES

	MOVE	AC3,[ASCID /     /]
	MOVEM	AC3,COMWHO+11		;PUT SPACES INTO WHOLINE
	MOVEM	AC3,COMWHO+12
	
	IDIVI	AC1,=31			;DAY INTO AC2
	PUSH	P,AC2			;SAVE DAY
	IDIVI	AC1,=12			;MONTH INTO AC2
	MOVE	AC1,MONTAB(AC2)		;GET TEXT OF MONTH
	DPB	AC1,[POINT 21,COMWHO+11,34]
	POP	P,TAC			;GET DAY BACK
	ADDI	TAC,1			; AND CORRECT IT
	MOVE	AC3,[POINT 7,COMWHO+12,6]
	MOVEI	AC2,2			;WRITE IT IN 2 COLS
	MOVEI	UCHN,=10		; IN DECIMAL
	MOVEI	DAT,0			; WITH LEADING NULLS
	PUSHJ	P,WSDPD2
	MOVE	TAC,WHODAT		;GET DATE AGAIN
	PUSHJ	P,DAYCNT		;CONVERT TO NUMBER OF DAYS SINCE 1-1-64
	IDIVI	TAC,7			;GET DAY OF WEEK (REMAINDER)
	LSH	TAC1,1			;(TABLE ENTRIES ARE 2 WORDS EACH)
	MOVE	TAC,DAYTAB(TAC1)
	ORI	TAC,1
	MOVEM	TAC,COMWHO+13		;STORE FIRST PART OF DAY
	MOVE	TAC,DAYTAB+1(TAC1)
	ORI	TAC,1
	MOVEM	TAC,COMWHO+14		;STORE SECOND HALF OF DAY

WHOSY1:
	MOVE	TAC,DQCNT		;GET NBR OF JOBS IN DISK QUEUE
	MOVE	AC3,[POINT 7,COMWHO+10,13]
	MOVEI	AC2,2			; AND WRITE IT IN 2 COLS
	PUSHJ	P,WSDPAD		; PADDING WITH BLANKS

	MOVE	AC3,[POINT 7,COMWHO+2,20]
	MOVN	TAC,DDFCNT		;GET NUMBER OF FREE DD CHANS
	ADDI	TAC,=31			; AND SUBTRACT FROM TOTAL NUMBER
	MOVEI	AC2,2			;PRINT NUMBER OF DD CHANS IN USE
	PUSHJ	P,WSDPAD		; IN 2 SPACES PADDING WITH BLANKS

	MOVE	AC1,JBSRUN		;GET BITS FOR JOBS RUN LATELY
	MOVE	AC2,JBSRUN+1
	LSHC	AC1,2*=36-JOBN		;ADJUST HIGHEST JOB'S BIT TO SIGN BIT OF AC1
	SETZB	TAC,JBSRUN		;TAC = # OF JOBS LOGGED IN.  CLEAR RUN BITS.
	SETZB	TAC1,JBSRUN+1		;TAC1= # OF JOBS RUN LATELY.
	SETZB	DDB,DAT			;DDB = CORE OF JOBS RUN LATELY.
					;DAT = CORE OF ALL JOBS
	MOVSI	WHO,JNA
	MOVEI	J,JOBN-1
WRUN1:
	TDNN	WHO,JBTSTS(J)		;IS THIS JOB LOGGED IN?
	JRST	WRUN2			;NOPE
	ADDI	TAC,1			;YES.  COUNT HIM
	HLRZ	UCHN,JBTADR(J)		;GET HIS CORE SIZE
	JUMPN	UCHN,.+3		;IS HE SWAPPED OUT?
	LDB	UCHN,IMGIN		;YES.  GET SIZE
	LSH	UCHN,12			; AND ADJUST TO ACTUAL SIZE (NOT 1K BLOCKS)
	ADD	DAT,UCHN		;ADD CORE SIZE TO TOTAL FOR ALL JOBS
	TLNN	AC1,400000		;HAS THIS JOB RUN LATELY?
	JRST	WRUN2			;NOPE.  FORGET HIM
	ADDI	TAC1,1			;YES.  COUNT HIM
	ADD	DDB,UCHN		; AND ADD IN HIS CORE
WRUN2:
	LSHC	AC1,1			;PUT NEXT JOB'S BIT IN SIGN OF AC1
	SOJG	J,WRUN1			;MOVE ON TO NEXT JOB, IF ANY

	PUSH	P,TAC1			;SAVE # OF JOBS RUN LATELY
	PUSH	P,DAT			;SAVE TOTAL CORE SIZE
	MOVEI	AC2,4			;WRITE # OF JOBS IN 4 SPACES,
	PUSHJ	P,WSDPAD		; PADDING WITH BLANKS,
	IBP	AC3			; AND SKIP OVER THE COMMA (EG: 12,888)
	POP	P,TAC			;GET BACK TOTAL CORE SIZE,
	ADDI	TAC,1777		; ROUND IT UP,
	LSH	TAC,-12			; CONVERT TO 1K BLOCKS,
	MOVEI	AC2,4			; AND PRINT IN 4 SPACES
	PUSHJ	P,DECPDF		; WITH FOLLOWING BLANKS
	POP	P,TAC			;GET BACK # OF JOBS RUN LATELY
	MOVEI	AC2,3			; AND WRITE IT IN 3 SPACES,
	PUSHJ	P,WSDPAD		; PADDING WITH BLANKS,
	IBP	AC3			; AND SKIP OVER THE COMMA AGAIN
	MOVE	TAC,DDB			;GET CORE OF JOBS RUN LATELY,
	ADDI	TAC,1777		; ROUND IT UP,
	LSH	TAC,-12			; AND CONVERT TO 1K BLOCKS.
	MOVEI	AC2,3			;WRITE IT IN 4 SPACES,
	PUSHJ	P,DECPDF		; PADDING WITH FOLLOWING BLANKS

	MOVE	TAC,CORMAX		;GET AMOUNT OF AVAILABLE CORE,
	LSH	TAC,-12			; CONVERT IT TO 1K BLOCKS,
	MOVEI	AC2,4			; AND PRINT IT IN 4 SPACES,
	PUSHJ	P,WSDPAD		; PADDING WITH BLANKS

	MOVEI	WHO,37			;START OVER WITH FIRST DD CHAN
	MOVEM	WHO,WHDDNXT
	POPJ	P,

BEND WHOSER
;: DPYSER[J17,SYS] EOF.
;: TTYSER[J17,SYS]
COMMENT ⊗   VALID 00087 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00006 00002	BEGIN TTYSER - SCANNER, KEYBOARD AND CONSOLE TELETYPE SERVICE ROUTINE
C00008 00003	DATA STRUCTURES AND PARAMETERS
C00011 00004	IOS BITS
C00014 00005	LINE BITS, LINE # DEFS
C00017 00006	AC'S, BYTE POINERS, CTLV
C00019 00007	LINBIT, TTYINI
C00024 00008	MORE TTYINI, SCNINI
C00027 00009	TTYCOM, TTYCM, CNTCOM, COMBCK
C00034 00010	TTYATI, TTYSUB
C00037 00011	TTYSUB TABLES
C00038 00012	FILL, ECHO, FULL, TABS, TIME, WHO
C00044 00013	TTYATT
C00047 00014	TTYDET, TRESCN, TRESCU
C00050 00015	TBYTEP
C00051 00016	TTYGET, TTYFNU, TTYFND, TTYFUW, TTYERP, TTYERR
C00054 00017	TTYSET, TTYSTC
C00055 00018	TTYSTR, TTYUSR
C00057 00019	TTYTLK
C00061 00020	TTYSRC, STLNAC
C00063 00021	GETDDB, LOG2LN
C00065 00022	DDBSRC, STDTBL
C00069 00023	SCNIN
C00071 00024	TTYSKL, TTYREL, TTYKIL
C00076 00025	MORE TTYKIL
C00080 00026	OUTCH6, OUTCHS, OUTCHR
C00084 00027	MORE OUTCHR  ADJHP
C00087 00028	PUTCHI, PUTCHO
C00091 00029	GETCHR, GETCHY
C00093 00030	GETCHA, GETCHO
C00095 00031	TSETBF, SETBFI, SETBF3, SETBFO
C00097 00032	SPCHEK, SPCACT
C00100 00033	SPCTAB
C00103 00034	TTYUUO, CLRBUF, INSKIP
C00106 00035	INCHSL, INCHRS, INCHWL, IWAIT, OUTSTR, INCHGT, INCHGB
C00110 00036	INCHRW, ONEOUT, GETLIN, SETLIN, SYNCHK, SYNCHA, SETACT
C00117 00037	OUTFIV, FIVOUT
C00120 00038	TTYMES
C00124 00039	TTREAD, TTYJNO, TTYJOB
C00127 00040	SNEAKS, SNEAKW, ACTCHR
C00130 00041	DDTIN
C00133 00042	DDTOUT, DDTWAT
C00135 00043	SCNDSP, TTYIN, TWSYNC, TTYSKP
C00138 00044	MONUSR
C00142 00045	TTYOUT
C00144 00046	USRMON
C00147 00047	SCNIN1, SCNTYP, KBDINT
C00150 00048	SHFTBL, CONVTB
C00152 00049	DKBINT
C00155 00050	DKBTBL
C00157 00051	SCNINT
C00158 00052	CTYINT
C00159 00053	RECINT, RECINA, RECINB, RECINC, RECIM3, NOESC, ESCRET
C00165 00054	RECIN3, RECIN4, UTYPET, TYPTST, TYPGO, TTINT
C00170 00055	ESCAPE BITS
C00171 00056	SETESC
C00174 00057	DOESC
C00176 00058	SPESC
C00177 00059	ESCAPES
C00179 00060	MORE ESCAPES	VDESET	VDECHK	VDVCHK
C00182 00061	ASSCN, ASESC, ESCB  AUDIO SWITCH SERVICE
C00190 00062	PKINT	PAGING INTERRUPT SERVICE ROUTINE
C00194 00063	ADSMAP, BEEP UUOS
C00206 00064	RECIML
C00207 00065	TYPX, COMSET
C00209 00066	TTEDIT
C00213 00067	TTIPUT, DUPLEX, DUPLX1, INBFUL
C00216 00068	CONTC, CONTOB, CONTO, CONTB, ALTMOD, TTYUNH
C00220 00069	RUBOUT, AOJDPX, CONTK, CONTL
C00222 00070	CONTI, CONTP
C00225 00071	CRLFEC, CRLF
C00227 00072	CNCTST, CNCMOD
C00229 00073	BSECHO, DCPUTR, DELETL
C00231 00074	DOTALK, NOTALK
C00237 00075	XMTINT, XMTIN1, DPYSTR, DPYDON
C00240 00076	XMTIN4, XMTIN2, LINDON, TTYPE
C00243 00077	TYP, TYPL, CTYP
C00245 00078	PTYGET, PTOCK, PTICHK, PTYCLR
C00249 00079	PTYUUO, LINMAP, PTOCNT, PTIFRE
C00252 00080	PTYREL, PTRD1S, PTRD1W, PTWAIT
C00255 00081	PTWR1S, PTLL3, PTWR1W, PTRDS, PTWRS7, PTWRS9
C00259 00082	PTJOBX
C00261 00083	PTJHLT, PTJCON, PTIWTS, PTCLRB
C00264 00084	PTDON, PTDOFF,PTLOGN,IMLOAD
C00267 00085	PHONE DIALER LIVES HERE
C00269 00086	DIAL UUO
C00275 00087	DIALER INTERRUPTS COME HERE
C00278 ENDMK
C⊗;

BEGIN TTYSER - SCANNER, KEYBOARD AND CONSOLE TELETYPE SERVICE ROUTINE
SUBTTL TTYSER - -DEC MOD D. POOLE MOD R. HELLIWELL




;SCNSER IS ORGANIZED(?) INTO THE FOLLOWING SECTIONS

;	I.	COMMENTARY ON OPERATION AND DATA STRUCTURES
;      II.	SYSTEM INITIALIZATION ROUTINE - SCNINI
;      III.	COMMAND LEVEL ROUTINES
;			A. TTYATT
;			B. TTYCOM
;			C. TTYDCM
;			D. TTYDET
;			E. TTYFND,TTYFNU
;			F. TTYKIL
;			G. TTYSET
;			H. TTYSRC
;			I. TTYSTR
;			J. TTYTLK
;			K. TTYUSR
;     IV.	UUO LEVEL ROUTINES
;			A. DDTIN
;			B. DDTOUT
;			C. TTYUUO
;			D. TTYIN
;			E. TTYOUT
;	V.	INTERRUPT SERVICE ROUTINES
;			A. CTYINT
;			B. SCNINT
;			C. RECINT - ALL LINES RECEIVER INTERRUPT
;				1. TTEDIT - EDITS AND ECHOS
;			D. XMTINT -  TRANSMIT INTERRUPT
;				1. GETCHR
;				2. TYP
;	VI.	PSUEDO-TELETYPE SERVICE ROUTINES
;			A. PTYGET
;			B. PTYCLR
;			C. PTYUUO

;DATA STRUCTURES AND PARAMETERS

;	DEFINED ON CONFIGURATION TAPE
;		SCNLIN=OCTAL NO. OF SCANNER LINES (0 THRU SCNLIN-1)

;	DEFINED BELOW
;		TRANSLATOR TABLE PARAMETERS
;		TTYLEN=SCNLIN+DPYNUM+1	LENGTH OF TTY TRANSLATOR TABLE (INCLUDING CTY)
;		TTYTAB:	BLOCK TTYLEN	TTY TRANSLATOR TABLE
;			SIGN BIT=1 IF COMMAND JUST TYPED
;			BIT 1 = 1  IF DELAYED COMMAND
;			BITS 3-10 = UNUSED
;			BITS 11-17=TALK RING LINE # (PTALK)
;			BITS 18-35=ADDR. OF DEVICE DATA BLOCK 
;				FOR THIS LINE.
;		DEVOPR:	0	SIXBIT PHYSICAL NAME OF OPERATORS
;				CONSOLE SET BY SCNIN0 TO FIRST
;				ACTIVE TTY.

;	DEFINED BELOW
;		LINE NUMBER PARAMETERS
;		TCONLN=SCNLIN	CTY LINE NUMBER
;		MTTYLN=-TTYLEN	-LENGTH OF TRANSLATOR TABLE
;		FSNCHN=SCNCHN*101	CHANNEL ASSIGNMENT FOR
;				FULL DUPLEX SCANNER
;		TTYLST=TTY0DB	FIRST TTY DEVICE DATA BLOCK

;TTY DEVICE DATA BLOCK FORMAT

;THE FOLLOWING ARE DEFINITIONS OF THE RELATIVE LOCATIONS OF THE
;BUFFER PARAMETER WORDS OF THE DEVICE DATA BLOCK FOR EACH BUFFER, WITH
;TTX'BUF AS THE BASE (DETAILED DESCRIPTIN IN SCNDDB COMMENTS):

	XP	BUF,0		;BUF(DAT) CONTAINS POINTER TO BEG. OF CURRENT BUFFER
	XP	↑PUTR,1		;PUTR(DAT)-PUTS CHARCTERS INTO BUFFER
	XP	PCTR,2		;NUMBER OF TIMES TO INCR. PUTR BEFORE REINITING
	XP	↑TAKR,3		;TAKER POINTER TO PICK UP CHARACTERS
	XP	TCTR,4		;COUNT OF NUMBER OF TIMES TAKR CAN BE INCREMENTED
	XP	↑FCTR,5		;COUNT OF FREE SPACES LEFT IN BUFFER
	XP	TSYNC,6		;LOCATION OF TISYNC RELATIVE TO DAT


;		DEVNAM:	PHYSICAL DEVICE NAME SET UP DYNAMICALLY
;			VIA SCNIN0.
;		DEVCHR:	LEFT HALF IS STANDARD
;			BITS 18-24=LINE NUMBER(BYTE POINTER=PUNIT)
;			BITS 25-35=MONITOR BUFFER SIZE + 1(BYTE POINTER=PDVBLN)

;IOS BITS
;		DEVIOS:	LEFT HALF
;			1,2,4,20,40 ARE STANDARD
			↑USRB←←100	;SET TTY TO USER MODE
					;WHEN OUTPUT FINISHES
					;TILL NEXT INPUT OR INIT (↑O).
			↑TPMON←←400	;TTY IS IN MONITOR
					;COMMAND MODE.
			DDTM←←1000	;DDT MODE
			↑↑TTYDTC←←2000	;TTY DDB IS DETACHED FROM LINE
			↑TOIP←←10000	;TYPE-OUT IN PROGRESS
					;TAKER IS BEHIND PUTR
			SYNC←←20000	;BREAK CHARACTER SEEN
					;SIGNAL TO INCREMENT SYNC COUNT
					;FOR BUFFER INVOLVED
			IMLTTY←←40000	;IMLAC IS IN TTY MODE FOR NEXT CHARACTER
			TTYHLD←←100000	;TYPEOUT HOLD (BO)
			SNKWAT←←200000	;SNEAK PREVIEW WAIT FLAG!
			TTYIOW←←400000	;TTY INPUT WAIT BIT

;		RIGHT HALF BITS (USER MODE)
			IOSUPR←←1000	;SUPPRESS ALL OUTPUT
			BKSP←←100	;FULL CHARACTER SET. PASS
					;ON ALL CHARACTERS EXCEPT ↑C
					;NO SPECIAL CHARACTER PROCESSING
			NOECHO←←200	;ECHO SUPPRESSION REQ BY PROG
			NOECHB←←400	;SUPPRESS ECHO OF CTRL BITS
			MERTP1←←2000	;DURING ERROR TYPEOUT THIS MEANS
					;THE INPUT BUFFER IS IN USE.
			MERTPO←←IOIMPM	;MONITOR ERROR TYPE-OUT
;		DEVSER:	STANDARD
;		DEVBUF:	STANDARD
;		DEVIAD:	BITS 6-12=HORIZONTAL POSITION (BYTE
;				POINTER = PHPOS).
;			BITS 13-35 ARE STANDARD.
;		DEVOAD:	BITS 0-8=NUMBER OF CHARACTERS TO FIT
;				;INTO OUTPUT BUFFER
;				(POINTER= PFITCH)
;			BITS 13-35 ARE STANDARD
IFNDEF FTDDTM,<FTDDTM←←-1>	;NON-ZERO TO INCLUDE CALLI DDTIN,OUT

;LINE BITS, LINE # DEFS
;DEFINITION OF LINE CHARACTERISTICS TABLE BITS
;LINTAB MADE BY SYSTEM BUILDER
;FOLLOWING IS FORMAT AS SET UP BY SCNINI
;	XWD BITS,LOGICAL LINE#

↑DISLIN←←400000			;THIS LINE IS TO A DISPLAY KEYBOARD
↑CTYLIN←←200000			;THIS "LINE" IS CONSOLE DEVICE "TTY"
TTYFIL←←100000			;THIS LINE IS IN "FILL" MODE
↑DDDLIN←←20000			;DATA DISK DISPLAY LINE
M37←←10000			;MODEL 37 TTY
↑PTYLIN←←4000	;PSEUDO-TTY.
IMLIN←←2000			;THIS IS AN IMLAC

APLINE←←12			;LINE # OF AP LINE
IMSSS←←7			;SUPPES

	;ABOVE ARE "PERMANENT" CHARACTERISTICS

↑TLKRNG←←1			;THIS LINE CURRENTLY IN A TALK RING
XON←←2				;↑Q TYPED, PAPER TAPE INPUT
FULTWX←←4			;SELF ECHOING FUL DUPLEX
TBXPND←←10			;EXPAND TABS (SOMETIMES PERMANENT SOMTIMES CHANGEABLE)
FCS←←20				;FULL CHAR SET MODE
ROBTPD←←40			;RUBOUT TYPED LAST (ECHO \ BEFORE NEXT CHAR.)
SPCBRK←←100	;SPECIAL ACTIVATION MODE... EVERYTHING EXCEPT LETTERS AND NUMBERS IS A  BREAK CHAR.
PTYUSE←←200	;;PTY LINE IN USE... DO NOT KILL DDB AT TTYKIL.
PTYWAK←←400		;SAYS PTY INPUT WAIT MAY BE TERMINATED BY TTY INPUT.
↑IMPBIT←←1000			; THE GUY ON THE OTHER END OF THIS PTY IS AN IMP
LERSEE←←40000	;USER WANTS TO SEE EVERYTHING TYPED TO
		; DPY LINE EDITOR DURING RE-EDITS. SEE LINED.


;ABOVE ARE TEMPORARY BITS, TURNED ON AND OFF BY VARIOUS MEANS
;(BY MONITOR, TYPE-IN COMMANDS, OR PROGRAM)

		;BITS BELOW CAN BE SET OR ZEROED BY PROGRAM
LGLSET←←TBXPND!TTYFIL!FCS!XON!SPCBRK!PTYWAK!IMPBIT!FULTWX!LERSEE
KILMSK←←ROBTPD!TLKRNG!XON!SPCBRK!PTYLIN!PTYWAK!IMPBIT!LERSEE	;CLEARED AT TTYKIL

; THESE ARE INSERTED HERE BECAUSE THEY AREN'T DEFINED ANYWHERE ELSE
; IN THIS SYSTEM

GLOBAL TTPLEN	;STUPID FAIL
MTTYLN←←-TTPLEN		; MINUS NUMBER OF TELETYPES, TOTAL
↑TCONLN←←SCNNUM+DPYNUM+DDNUM
↑PTYL0←←TCONLN+1		;FIRST PTY LINE NO.
↑DPYL0←←SCNNUM
↑DDL0←←DPYL0+DPYNUM
FSNCHN←←SCNCHN*101		; SCANNER PI CHANNEL ASSIGNMENTS


;AC'S, BYTE POINERS, CTLV
;ACCUMULATOR ASSIGNMENTS

	CHR←TEM		;AC FOR CHARACTER
	LINE←TAC1		;SCANNER LINE NUMBER
	HPOS←ITEM		;HORIZONTAL POSITION OF TTY.(0-71)


	;SPECIAL SYMBOLS

	SCNON←←1B25!1⊗(7-SCNCHN)
	SCNOFF←←1B26!1⊗(7-SCNCHN)

	IDLECH←←1		;DELAY CHAR FOR TABS, ETC.
				; SHOULD BE ↑V, BUT FOR 37'S


;BYTE POINTERS

PFITCH:
	POINT 9,DEVOAD(DDB),8		;NR OF CHARACTERS TO FIT
PHPOS:
	POINT 7,DEVIAD(DDB),12	;HORIZONTAL POSITION

IFN FTTALK,<
↑PTALK:	POINT PUNITS,TTYTAB(LINE),17	;POINTER TO ANOTHER TTY IN TALK RING
					;(SAME SIZE BYTE AS SYS UNIT #)
>


↑PLASTC:
	POINT 7,TTYPTR(DDB),35	; FOR ECHO CHECKING ON HDX LINES
↑PCOMIC:
	POINT 9,TTYPTR(DDB),19	; FOR RESCANNING COMMAND INPUT LINE
				;"COMMAND INPUT COUNTER" SAVES TITCTR
PLSTLC:
	POINT 9,TTYPTR(DDB),28	;FOR ↑U DELETION

;TTYPTR CONTAINS THE FOLLOWING BYTES:
;
;	0-3	SPARE
;	4-10	PTYJOB, FOR NO. OF JOB OWNING THE PTY (IF ANY) USING THE DDB.
;	11-19	PCOMIC, FOR COMMAND RESCAN
;	20-28	PLSTLC, FOR ↑U
;	29-35	PLASTC, FOR ECHO CHECKING HALF DUPLEX LINES

↑CTLV1:	PUSHJ P,TTYFNU
	MOVEI IOS,NOECHO
	XORM IOS,DEVIOS(DDB)
	POPJ P,

;LINBIT, TTYINI
;SCNINI IS CALLED AT SYSTEM INITIALIZATION TIME FROM
;IOGO IN SYSINI VIA DISPATCH TABLE
;IT	1)CLEARS ALL RECEIVER FLAGS,
;	2)CLEARS THE PHYSICAL NAME (DEVNAM) OF ALL UNUSED
;	  (TTYUSE=0) TTY DEVICE DATA BLOCKS,
;	3)SETS DEVIOS TO XWD TPMON+IOFST,0  IN ALL TTY DEVICE
;	  DATA BLOCKS,
;	4)SETS TTYUSE=1 IN ALL TTY DDBS IN THE TRANSLATOR TABLE.

DEFINE BITS(X),<XWD X,.-LINBIT>

LINBIT:
	
REPEAT 10,<BITS	TBXPND!FCS
>				;0-7 ARE MODEL 33
REPEAT 2,<BITS TBXPND!FCS
>				;10,11 DATAPHONES
REPEAT 3,<BITS	TBXPND!M37!FCS
>				;12-14 ARE MODEL 37
REPEAT 3,<BITS	IMLIN!FCS
>				;15-17 ARE IMLACS
REPEAT DPYNUM,<BITS	DISLIN!FCS
>
REPEAT DDNUM,<BITS DDDLIN!FCS>
	BITS	CTYLIN
REPEAT PTYNUM,<BITS 0>		;JUST IN CASE SOMEONE LOOKS HERE
;END OF BIT TABLE

↑TTYINI:
	PUSHJ	P,DWPINI		;LET JAM THROW AWAY THE DPY FREE STORAGE
					;BEFORE WE DO OUR BUGEY!
IFN DILNUM,<PUSHJ P,DILINI>		;INITIALIZE DIALER STUFF
	MOVSI	LINE,-TCONLN-1		;REAL TTY'S ONLY
SCN0:
	MOVE	TAC,LINBIT(LINE)	;GET PERMANENT LINE CHARACTERISTICS
	HRRM	TAC,LINTAB(LINE)	;SET LOG. LINE NUMBERS
	IORB	TAC,LINTAB(LINE)	;SET SIGNIFICANT BITS
	TLZ	TAC,KILMSK		;ZAP INSIGNIFICANT BITS
	HLLM	TAC,LINTAB(LINE)	;LEAVING REST OF BITS AS THEY WERE
	AOBJN	LINE,SCN0

	CONO	CTY,3600!CTYCHN		; CLEAR	CTY, ASSIGN CHANNEL
	CONO	DKB,10!SCNCHN		; CLEAR DDD TTY SCANNER AND ASSIGN CHANNEL
	PUSHJ	P,SCNINI		;DEVICE DEPENDENT SCANNER INIT
	SETZM	TTYTAB
	SETZM	COMCNT			;NO COMMANDS TO PROCESS
	MOVE	TAC,[XWD TTYTAB,TTYTAB+1]
	BLT	TAC,TTYTAB+TTPLEN-1	;CLEAR ALL DDB ADDRESSES
	MOVE	TAC,[TCONLN,,TTYLST]	;INIT CTY TO USE DDB IN ALLDAT
	MOVEM	TAC,TTYTAB+TCONLN	;  BH 5/6/74
	SETZM	PAGNOW
	SETZM	ASBTAB			;CLEAR ALL BEEP DURATIONS
	MOVE	TAC,[ASBTAB,,ASBTAB+1]
	BLT	TAC,ASBTAB+DPYNUM+DDNUM-1
	SKIPL	TTYLOK
	SKIPE	MAINTM
	JRST	NOASIN			;DON'T INIT AUDIO SW IF SYS NOT FOR REAL
	SETZM	ASTAB
	MOVE	TAC,[ASTAB,,ASTAB+1]
 	BLT	TAC,ASTAB+DPYNUM+DDNUM-1
NOASIN:
	HRRZS 	TTYLST+DEVSER		;CLEAR DDB CHAIN
	SETZB	IOS,TTYLST+DEVIOS	;SO DDB WILL GET FLUSHED
;	MOVEI	DDB,TTYLST		;2 LINES COMMENTED OUT BH 5/6/74
;	PUSHJ	P,TTYKIL		;HERE.
	MOVEI	ITEM,JOBN-1		;REGENERATE DDB'S FOR ALL LIVE JOBS
SCNC1:
	MOVE	TAC,JBTSTS(ITEM)
	TLNN	TAC,JNA			;IS THIS A JOB
	JRST	SCNC3			;NO, IGNORE HIM.
	HRRE	LINE,JBTLIN(ITEM)	;GET LINE HE IS USING
	JUMPL	LINE,SCNC2		;DETACHED LINE
	PUSHJ	P,DDBSRC		;GET HIM A DDB
	JRST	SCNC3			;IF NO DDB AVAILABLE OR NO LINE OR DETACHED
	PUSHJ	P,TTYATI		;ATTACH JOB
	TLNE	LINE,PTYLIN
	SKIPE	PTYJOB-PTYL0(LINE)	;IS THIS PTY REALLY ATTACHED TO SOMEONE?
	JRST	SCNC3			;YES
	PUSHJ	P,TTYDET		;NO, DETACH HIM.
	JRST	SCNC3			;NEXT PLEASE
SCNC2:
	TLNE	TAC,JSEG		;IS IT AN UPPER SEGMENT?
	JRST	SCNC3			;YES, NO DDB FOR HIM
	MOVNI	LINE,1			;YES, GET A DETACHED LINE
	PUSHJ	P,DDBSRC		;GET DDB
	JRST	SCNC3
	DPB	ITEM,PJOBN
SCNC3:
	SOJG	ITEM,SCNC1

;MORE TTYINI, SCNINI
; HERE WE GET THE DDB'S FOR THE REST OF THE TTY'S (I.E., NOT
; THE ONES ATTATCHED TO JOBS ALREADY).

	MOVSI	LINE,-TTPLEN+PTYNUM		;SET DDB USE BITS FROM TRANSLATOR TABLE
SCN2:
	MOVSI	IOS,600000
	ANDCAM	IOS,TTYTAB(LINE)		;NO COMMAND WAITING !
	HRRZ	TAC,LINE
	CAIGE	TAC,PTYL0			;PTY LINE?
	JRST	NOTPTY
	SKIPN	TTYTAB(LINE)			;DOES HE HAVE A DDB
	JRST	SCN6
	HRLI	TAC,PTYLIN!PTYUSE!XON		; MAGIC PTY BITS
	MOVEM	TAC,LINTAB(LINE)		; INITIALIZE THIS PTY
	JRST	SCN3				; STUFF IN 0'S
SCN6:
	SETZM	PTYJOB-PTYL0(LINE)
	SETZM	LINTAB(LINE)		;CLEAR PTY BITS
	JRST	SCN3
NOTPTY:
	SKIPE	TTYTAB(LINE)		; IS THERE A DDB ADDRESS THERE?
	JRST	SCN3
	SKIPE	TTYLOK
	CAIN	TAC,TCONLN
	CAIA
	JRST	SCN3
	PUSH	P,LINE
	HRRZ	LINE,LINE
	CAIL	LINE,DPYL0
	CAIL	LINE,DDL0+DDNUM
	CAIA
	JRST	SCN5			;FOR DPYS ONLY
	CAIE LINE,IMSSS
	CAIN LINE,APLINE
	JRST .+3		;DON'T MAKE DDB (I.E. DON'T TYPE OUT) ON THESE LINES
	PUSHJ	P,DDBSRC		;MAKE TTY DDB AND SET UP TTYTAB
	JFCL
	POP	P,LINE
SCN3:
	AOBJN	LINE,SCN2
	SETZM LINSAV	;SO INIT. MESSAGE WILL GET TO EVERYONE.
	POPJ P,		;ALL DONE

SCN5:
	POP	P,LINE
	JRST	SCN3

;DEVICE DEPENDENT PORTION OF INITIALIZATION CODE
;CALL:	MOVEI	TAC,CHANNEL NUMBER
;	PUSHJ	P,SCNINI

SCNINI:
	MOVEI	TAC,100000
	CONO	DCSA,4010	;RELEASE XMITTER, RECEIVER
	CONSZ	DCSA, 1000
	CONO	DCSA, 4000
	CONSZ	DCSA, 10
	DATAI	DCSB, LINE
	SOJG	TAC,.-4
	CONO	DCSA,FSNCHN	;ASSIGN INTERRUPT CHANNELS
	POPJ	P,

;TTYCOM, TTYCM, CNTCOM, COMBCK
;ROUTINE TO SETUP AC DDB TO ADDRESS OF TTY WHICH HAS TYPED A COMMAND
;AC DAT TO BYTE POINTER TO OUTPUT BUFFER FOR COMMAND MESSAGES
;AC ITEM TO JOB NUMBER TTY IS ATTACHED TO
;CALL:	PUSHJ P,TTYCOM
;	NONE FOUND
;	AC'S SETUP
;CALLED FROM COMMAND

↑TTYCOM:
	SKIPGE	LINE,LINSAV
	JRST	TTYCM1			;GIVE SOMEONE ELSE A CHANCE
	MOVSI	LINE,MTTYLN
	SKIPL	TAC,TTYTAB(LINE)
TTYCM1:
	AOBJN	LINE,.-1
	MOVEM	LINE,LINSAV
	JUMPG	LINE,CPOPJ
	HRRZ	DDB,TTYTAB(LINE)
	JUMPE	DDB,TTYCM2		;IT HAPPENS!!!!
	MOVE	DAT,DEVMOD(DDB)
	TLNN	DAT,TTYATC		;IS HE ATTACHED TO IT BY JOB?
	TRNN	DAT,ASSCON!ASSPRG	;NO, ASSIGNED OR INITED TTY'S CAN'T TYPE COMMANDS
	JRST	.+2
	JRST	TTYCM2			;(THIS CAN'T HAPPEN (IT SAYS SO IN COMSET))
	MOVEI	DAT,TTIBUF(DDB)		;SO GETCHR CAN BE CALLED FROM COMCON
	MOVE	LINE,TITCTR(DDB)
	DPB	LINE,PCOMIC		;SAVE COMMAND INPUT COUNTER
	LDB	LINE,PUNIT		;LINE NO.
	LDB	J,PJOBN			;JOB NO. TTY ATTACHED TO
	MOVSI	CHR,TTYATC
	TDNN	CHR,DEVMOD(DDB)
	MOVEI	J,0			;NO JOB ATTACHED TO THIS TTY
	TLNN	TAC,DLYBIT		;IS THIS A DELAYED COMMAND?
	JRST	CPOPJ1			;NO, RETURN TO SCAN IT
	MOVSI	TAC,DLYBIT		;INDICATE NO LONGER DELAYED COMMAND
	ANDCAM	TAC,TTYTAB(LINE)
	JRST	CPOPJ1			;RETURN TO COMMAND SCAN

↑TTYCM:	MOVE	LINE,LINSAV		;HERE WHEN COMMAND MUST BE DELAYED
	MOVSI	DDB,DLYBIT		;INDICATE DELAYED COMMAND
	IORB	DDB,TTYTAB(LINE)
	PUSHJ	P,TRESCN		;BACK UP TO START OF COMMAND
	MOVE	LINE,LINSAV		;TRESCN HAS CALLED STLNAC
	JRST	TTYCM1			;LOOK FOR OTHER COMMAND TO PROCESS

TTYCM2:
	PUSHACS
	PUSH	P,DDB
	PUSH	P,LINE
	PUSHJ	P,DISMES
	ASCIZ	/COMMAND BIT SET AND NO DDB, OR TTY ASSIGNED: TTY /
	POP	P,TAC
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/, DDB= /
	POP	P,TAC	
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	POPACS
	MOVSI	DDB,COMBIT!DLYBIT	;CLEAR THESE BITS!
	SOS	COMCNT			;FIX COMCNT
	ANDCAM	DDB,TTYTAB(LINE)
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM	;MAKE SURE ALL IS OK
>
	JRST TTYCM1		;LET COMMAND FIGURE OUT THAT COMCNT IS MAYBE NOW ZERO

IFN FTTTYBUG,<
;WELL, WE FIXED THIS PROBLEM, I THINK. 12/1/73 

;THIS AWFUL KLUDGE IS TO HELP SOLVE THE COMCNT MYSTERY
;IF IT STAYS FOR MORE THAN TWO WEEKS, I SHOULD BE SHOT.  REG 10/5/73
↑CNTCOM:
	PUSH	P,TAC
	PUSH	P,TAC1
	CONI	PI,TAC1
	ANDI	TAC1,SCNOFF-1000	;SCANNER CHANNEL ACTIVE BIT
	PUSH	P,TAC1
	CONO	PI,SCNOFF		;TURN OFF THE SCANNER
	MOVEI	TAC1,0
	MOVSI	TAC,MTTYLN
	SKIPGE	TTYTAB(TAC)
	ADDI	TAC1,1
	AOBJN	TAC,.-2
	CAMN	TAC1,COMCNT
	JRST	CNTCM1
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/COMCNT & TTYTAB DISAGREE.  CALLER = /
	MOVE	TAC,-23(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISMES
	ASCIZ	/ COMCNT= /
	MOVE	TAC,COMCNT
	PUSHJ	P,DISLOC
	PUSHJ	P,DISTAB
	MOVE	TAC,TAC1-17(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	MOVE	TAC,TTCBCK
	PUSHJ	P,DISOCT
	PUSHJ	P,DISTAB
	MOVE	TAC,TTCBCK+1
	PUSHJ	P,DISOCT
	PUSHJ	P,DISTAB
	MOVE	TAC,TTCBCK+2
	PUSHJ	P,DISOCT
	PUSHJ	P,DISCRLF
↑COMBUG:	JRST	.+3			;PATCH HERE TO STOP THE WORLD
	PUSHJ	P,DISFLUSH
	PUSHJ	P,DDTCALL
	POPACS
	MOVEM	TAC1,COMCNT		;FIX IT!
CNTCM1:
	POP	P,TAC1
	CONO	PI,2000(TAC1)
	POP	P,TAC1
	POP	P,TAC
	POPJ	P,

;THE 23% OVERKILL, CALL IMMED AFTER IORM OR ANDCAM OF TTYTAB
↑COMBCK:	PUSH P,IOS
	PUSH P,TAC
	MOVE TAC,-2(P)
	MOVE IOS,-2(TAC)	;FETCH IORM OR ANDCAM
	POP P,TAC
	HRRI IOS,@IOS
	TLZ IOS,37
	PUSH P,IOS
	LDB IOS,[270400,,IOS]	;AC FIELD
	SKIPN IOS
	SKIPA IOS,-1(P)
	MOVE IOS,@IOS
	JUMPGE IOS,[	POP P,IOS	;NOT COM BIT
			POP P,IOS
			POPJ P,]
	POP P,IOS		;GET INSTRUCTION BACK
	PUSH P,TAC
	PUSH P,TAC1
	PUSH P,AC1
	TLNN IOS,020000		;IORM=436, ANDCAM=412 (SKIP IF IORM)
	TLZ IOS,400000		;INDICATE ANDCAM
	HRRZ TAC,IOS
	SUBI TAC,TTYTAB		;LINE NUMBER
	JUMPL	TAC,COMBCX
	CAIL	TAC,TTPLEN
	JRST	COMBCX
	IDIVI TAC,=36		;TAC←INDEX INTO TTCBCK, TAC1←SHIFT CNT
	MOVEI AC1,1
	LSH AC1,(TAC1)
	SKIPL IOS
	ANDCAM AC1,TTCBCK(TAC)
	SKIPGE IOS
	IORM AC1,TTCBCK(TAC)
COMBCY:
	POP P,AC1
	POP P,TAC1
	POP P,TAC
	POP P,IOS
	POPJ P,
COMBCX:
	PUSHACS
	PUSHJ	P,DISMES
	ASCIZ	/AT COMBCK WITH INVALID INDEX = /
	MOVE	TAC,TAC-17(P)
	PUSHJ	P,DISLOC
	PUSHJ	P,DISCRLF
	JRST	COMBCY
>;END FTTTYBUG

;TTYATI, TTYSUB
;ROUTINE TO ATTACH TTY TO A JOB
;CALL:	MOVE DDB,ADDRESS OF TTY DEVICE DATA BLOCK
;	MOVE ITEM,JOB NUMBER
;	PUSHJ P,TTYATT
;	OK RETURN	;DDB, DAT AND TRANSLATOR TABLE SET

;CALLED FROM COMCON (ATTACH) AND COMCSS (JOBINI).
;ON OK RETURN	1)SETS TTYATC
;		3)PUTS ADDRESS OF ATTACHED DDB INTO DDB.
;		4)SETS PHYSICAL NAME TO SIXBIT /TTY LINE #/
;		  OR SIXBIT /CTY/,
;		5)SETS DEVOPR IF IT IS NON-ZERO.


IFE FTATTACH,<
↑TTYATT:
	>
;COME HERE TO ATTACH TTY IN DDB TO JOB IN ITEM.
↑TTYATI:
	PUSHJ	P,STLNAC		;SETUP LINE
	MOVEM	LINE,JBTLIN(ITEM)	;SET LINE # FOR JOB
	DPB	ITEM,PJOBN		;SET JOB NUMBER OF OWNER
	MOVSI	TAC,TTYATC		;MAKE IT ATTACHED TO JOB
	IORM	TAC,DEVMOD(DDB)
	MOVSI	IOS,TTYDTC		;MAKE DDB ATTACHED TO TTY
	ANDCAB	IOS,DEVIOS(DDB)
	POPJ	P,

;CLOCK LEVEL (CONSOLE) "TTY" COMMAND
↑TTYSUB:HRRZS (P)			;USE STACK AS FLAG
TTYSB1:
	PUSHJ P,CTEXT1			;READ TTY COMMAND
	JUMPE TAC1,[CAIE TEM,"-"	;ALLOW - ALSO
		JRST NOTENF		;NOPE
		PUSHJ P,GETLCCHR	;YES, GOBBLE TO NEXT CHAR SO WE DON'T LOOP
		HRROS (P)		;FLAG -
		JRST TTYSB1]
	CAMN TAC1,['NO    ']
	JRST [	HRROS (P)		;FLAG 'NO' SEEN
		JRST TTYSB1]		;NOTE THAT REPEATED 'NO' IS OK, BUT DOESN'T COMPLEMENT
	MOVSI TAC,-TCOMLN
TCOMLP:
	CAMLE TAC1,TCOMND(TAC)
	AOBJN TAC,.-1
	JUMPGE TAC,COMERA		;ERROR, COMMAND NOT FOUND
	CAMN TAC1,TCOMND(TAC)
	JRST TCMGOT
	MOVE AC2,TAC1
	SKIPA AC1,[770000,,0]
TCMMSK:
	ASH AC1,-6
	ANDCM AC2,AC1
	JUMPN AC2,TCMMSK
	MOVE AC2,TCOMND(TAC)
	AND AC2,AC1
	CAME AC2,TAC1			;PARTIAL MATCH ON CURRENT WORD?
	JRST COMERA			;NO
	HLRE AC2,TAC
	AOJE AC2,TCMGOT			;ONLY COMMAND LEFT?
	AND AC1,TCOMND+1(TAC)
	CAMN AC1,TAC1
	JRST COMERA			;TOO MANY MATCHES
TCMGOT:
	PUSHJ P,STLNAC
	JRST @TCOMDS(TAC)

;TTYSUB TABLES
;"TTY" COMMANDS, MUST BE IN ALPHABETICAL ORDER
DEFINE TNAMES
<
	.TMAC	ECHO,TTECHO
	.TMAC	FILL,FILTTY
	.TMAC	FULL,TTFULL
	.TMAC	TABS,TTTAB
	.TMAC	TIME,TTYTIM
	.TMAC	UPDATE,TTYUPD
	.TMAC	WHO,TTYWHO
>

DEFINE .TMAC(A,B)
<	SIXBIT/A/
>

XLIST
TCOMND:
	TNAMES
TCOMLN←←.-TCOMND
LIST

DEFINE .TMAC(A,B)
<	B
>

XLIST
TCOMDS:
	TNAMES
LIST

;FILL, ECHO, FULL, TABS, TIME, WHO
FILTTY:
	TLNE LINE,DISLIN!DDDLIN		;THESE GUYS MAY SCREW UP
	POPJ P,
	SKIPGE (P)			;'NO' TYPED?
	TLZA LINE,TTYFIL		;YES, DO NOFILL
	TLO LINE,TTYFIL			;FILL CR'S
STOLIN:
	HLLM LINE,LINTAB(LINE)
	POPJ P,

TTECHO:
	SKIPGE (P)			;'NO' TYPED?
	TLOA LINE,FULTWX		;YES, SET AS FULL DUPLEX
	TLZ LINE,FULTWX			;CLEAR FULL DUPLEX
	JRST STOLIN

TTFULL:
	SKIPGE (P)
	TLZA LINE,FCS
	TLO LINE,FCS
	JRST STOLIN

TTTAB:
	SKIPGE (P)
	TLOA LINE,TBXPND		;EXPAND
	TLZ LINE,TBXPND			;DON'T EXPAND
	JRST STOLIN

TTYUPD:
	JUMPE	J,CPOPJ			;IF NO JOB, NO XTIME
	MOVSI	TAC,400000		;THIS IS THE NO-UPDATE BIT IN XTIME
	SKIPGE	TAC1,(P)		;'NO' TYPED?
	ORM	TAC,XTIME(J)		;YES.  SET NO-UPDATE BIT.
	JUMPL	TAC1,.+2		;'NO' TYPED?
	ANDCAM	TAC,XTIME(J)		;NO.  CLEAR NO-UPDATE BIT.
	POPJ	P,

TTYTIM:
	JUMPE	J,CPOPJ			;NO JOB, NO XTIME
	MOVSI	TAC,400000		;THE NO-UPDATE BIT IN XTIME
	SKIPL	TAC1,(P)		;'NO' TYPED?
	ADD	TAC,TTIME(J)		;NO.  UPDATE XTIME AND SET NO-UPDATE BIT
	MOVEM	TAC,XTIME(J)		;IF 'NO' TYPED, CLEAR XTIME AND SET NO-UPDATE.
	HRRZS	DSKOPS(J)		;MAKE ALL DISK OPERATIONS "RECENT"
	SETZ	TAC,			;ASSUME NO WAIT TIME
	JUMPL	TAC1,TTYTI1		;'NO' TYPED?
	HRLS	DSKOPS(J)		;NO.  MAKE NO DISK OPS RECENT
	SKIPGE	TAC,JBTWAT(J)		;GET WAIT TIME
	ADD	TAC,UPTIME		;MAKE IT HONEST
TTYTI1:
	MOVEM	TAC,JB2WAT(J)		;SAVE CURRENT WAIT TIME
	POPJ	P,

TTYWHO:
	SKIPL	(P)			;'NO' TYPED?
	JRST	UWHO			;NO NO.
TTWHSY:
	MOVEI	AC3,COMWHO+2		;TYPE OUT SYSTEM WHO LINE
	JRST	UWHO1

UWHO:
	PUSHJ	P,DECIN
	SKIPA	TAC1,J			;NO ARG, USE OUR JOB #
	JRST	COMERA			;LOSE
	JUMPE	TAC1,TTWHSY		;0 ARG, OR NO ARG & NOT LOGGED IN
	CAIL	TAC1,JOBN		;TOO BIG?
	JRST	NOTLOG			;YES
	MOVE	TAC,JBTSTS(TAC1)
	TLNN	TAC,JNA			;IS IT A JOB?
	JRST	NOTLOG			;NO
	PUSH	P,J			;SAVE J
	PUSH	P,DDB			;AND DDB ON STACK
	MOVE	J,TAC1
	MOVEI	AC1,TITLE		;USE WHO LINE MODEL
	SETZ	DDB,			;FLAG THAT IT IS TTY CALLING
	PUSHJ	P,WHOLIN
	POP	P,DDB			;RESTORE DDB
	POP	P,J			;AND J
	MOVEI	AC3,WTTYS		;START HERE
UWHO1:
	SKIPN	AC2,(AC3)		;PICKUP WORD AND CHECK FOR END
	POPJ	P,			;DONE
	TRZN	AC2,1			;TEXT WORD?
	AOJA	AC3,UWHO1		;NO
	MOVE	AC1,[POINT 7,AC2]	;YES, MAKE BYTE POINTER
UWHO2:
	TLNN	AC1,760000
	AOJA	AC3,UWHO1
	ILDB	TEM,AC1			;UNPACK THE CHARACTERS
	JUMPE	TEM,UWHO2
	PUSH	P,AC1
	PUSH	P,AC2
	PUSH	P,AC3
	XCT	TYO			;OUTPUT THE CHAR.
	POP	P,AC3
	POP	P,AC2
	POP	P,AC1
	JRST	UWHO2

↑WHOUUO:XCTR XR,[HRRZ UUO,(UCHN)]	;POINTER TO WHERE USER WANTS STRING
	HRLI UUO,(<POINT 7,0>)		;MAKE IT BYTE POINTER
	MOVEI AC3,COMWHO+2		;SKIP SOME SPACES
	XCTR XR,[HLRE TAC,(UCHN)]	;GET JOB NUMBER FIELD
	JUMPL TAC,WHOUU1		;IF -, JUST REPORT SYSTEM WHO LINE
	JUMPE TAC,.+2
	CAIL TAC,JOBN
	MOVE TAC,J			;ZERO OR >JOBN IS US
	MOVE TAC1,JBTSTS(J)
	TLNN TAC1,JNA			;JOB THERE?
	JRST WHOUU2			;NO, ZERO STRING
	PUSH P,J
	MOVE J,TAC
	MOVEI AC1,TITLE			;USE PROTOTYPE
	SETZ DDB,			;FLAG WHOSER NO TTY HERE
	PUSHJ P,WHOLIN
	POP P,J
	MOVEI AC3,WTTYS			;WHERE TO PICKUP STRING FROM
WHOUU1:
	SKIPN AC2,(AC3)
	JRST WHOUU2			;FINISH OUT WORD WITH NULLS
	TRZN AC2,1			;TEXT WORD?
	AOJA AC3,WHOUU1			;NO, CHECK NEXT WORD
	MOVE AC1,[POINT 7,AC2]
WHOUU0:
	TLNN AC1,760000
	AOJA AC3,WHOUU1
	ILDB TEM,AC1
	JUMPE TEM,WHOUU0
	XCTR XLB,[IDPB TEM,UUO]
	JRST WHOUU0

WHOUU2:
	SETZ TEM,			;MAKE IT ASCIZ STRING
WHOUU3:
	XCTR XLB,[IDPB TEM,UUO]
	TLNE UUO,760000
	JRST WHOUU3
	POPJ P,

;TTYATT
;COME HERE TO ATTACH TTY TO DDB THAT JOB IS ALREADY ATTACHED TO
;AND FLUSH OLD DDB IF NECESSARY.
IFN FTATTACH,<
↑TTYATT:
	PUSHJ	P,STLNAC		; GET LINE CHARACTERISTICS
	MOVEI	DDB,TTYLST		;SEARCH FOR DDB THAT IS ATTACHED
	JRST	.+2
TTYAT2:
	HLRZ	DDB,DEVSER(DDB)
	JUMPE	DDB,CPOPJ		;HAVE ALL TTY DDB'S BEEN LOOKED AT?
	LDB	TAC,PJOBN		;NO, GET JOB NUMBER.
	HLL	TAC,DEVMOD(DDB)		;ATTACH AND USE BITS
	TLNN	TAC,DVTTY		;IS THIS STILL A TTY DDB?
	JRST	TTYAT2			;NO, THIS MUST BE IJOB.
	MOVE	IOS,DEVIOS(DDB)
	CAIN	ITEM,(TAC)		;JOB NUMBER THE ONE TO ATTACH?
	TLNN	TAC,TTYATC		;YES, IS DDB ATTACHED TO JOB?
	JRST	TTYAT2			;NO, KEEP LOOKING.
	TLNN	IOS,TTYDTC		;IS DDB DETACHED FROM LINE?
	POPJ	P,			;NO, ERROR RETURN WITH DDB SET
	PUSH	P,DDB			;SAVE NEW DDB ADDRESS.
	MOVE	DDB,TTYTAB(LINE)	;ZAP, CHANGE LINES
	LDB	TAC,PJOBN		;GET JOB # OF OLD DDB
	JUMPN	TAC,TTYAT3		;IF IT'S ZERO
	MOVSI	TAC,IO!TOIP		;THEN CLEAR THESE BITS
	ANDCAM	TAC,DEVIOS(DDB)		;SO DDB GETS KILLED BY TTYDET
TTYAT3:
	PUSHJ	P,TTYDET		;DO YO STUFF
	POP	P,DDB			;GET BACK NEW GUY
	MOVEM	DDB,TTYTAB(LINE)	;TTYDET CLOBBERS THIS.
IFN FTTTYBUG,<	PUSHJ	P,CNTCOM	>;MAKE SURE THAT ALL IS WELL?
	DPB	LINE,PUNIT		;SET THIS LINE IN DDB
	PUSHJ	P,TTYATI		;SET UP NEW DDB
				;NOW, GO TO INTERUPT LEVEL TO SET DAT
				;AND CHECK IF TYPING NEEDS TO BE STARTED.
	PUSH	P,ITEM			;SAVE THIS
	PUSHJ	P,XMTIN1		;START TYPING
	POP	P,ITEM
	SETZ	TAC,
	JRST	SCNIN
>;FTATTACH

;TTYDET, TRESCN, TRESCU
IFN FTATTACH,<
;ROUTINE TO DETACH TTY FROM JOB
;CALL:	MOVE DDB,ADDRESS OF TTY DDB TO BE DETACHED
;	PUSHJ P,TTYDET

;CALLED FROM TTYATT AND COMCON (DETACH).
;CLEARS TTYATC AND TRANSLATOR TABLE ENTRY.
;SETS TTYDTC IN DEVIOS(DDB)


↑TTYDET:LDB	TAC,PJOBN	;GET JOB NO.
	SETOM	JBTLIN(TAC)	;FLAG LINE AS DETACHED.
	MOVSI	IOS,TTYDTC
	MOVE	TAC,DEVMOD(DDB)		;SET TTY DETACHED BIT
	TLNE	TAC,TTYATC		;WAS TTY ALREADY DETACHED?
	TDNE	IOS,DEVIOS(DDB)
	JRST	TTYKIL			;YES, MAKE TTY AVAIL. EXTRA DETACH COMMAND
	IORB	IOS,DEVIOS(DDB)
	CONO	PI,SCNOFF
	PUSHJ	P,TTYSKL
	CONO	PI,SCNON
	JRST	TTYKL1			;GO CLEAR TRANSLATOR TABLE
>

; ROUTINE TO RESET COUNTS AND BYTE POINTERS TO RESCAN THE LAST COMMAND LINE

↑TRESCN:
	LDB	TAC,PCOMIC		; GET OLD TITCTR
TRESC2:
					;HERE TO SCAN BACK TO CURRENT INPUT.
	MOVEM	TAC,TITCTR(DDB)		;RESTORE IT
	PUSHJ	P,TBYTEP
	MOVEM	TAC,TITAKR(DDB)
TRESC1:
	MOVE	TAC,TIPCTR(DDB)		;CALLED HERE FROM ↑U CODE
	CONO	PI,SCNOFF
	SUB	TAC,TITCTR(DDB)		; THIS IS NOW THE NEW CHR. COUNT TO END OF BUFFER
	SKIPG	TAC
	ADDI	TAC,TTICHR
	MOVEM	TAC,TIFCTR(DDB)
	CONO	PI,SCNON
	JRST	STLNAC

; ROUTINE TO RESCAN ALL COMMAND LINES IN BUFFER. CALLS TRESCN, THEN
; COUNTS NUMBER OF COMMAND LINES IN BUFFER, THEN CALLS TRESCN AGAIN

↑TRESCU:TLNE IOS,TPMON			;MONITOR MODE?
	POPJ P,				;OH WELL, LOSERS LOSE
	TRNN UUO,-1
	JRST TRESCA
	LDB TAC,PCOMIC
	SUB TAC,TITCTR(DDB)
	SKIPG TAC
	ADDI TAC,TTICHR
	XCTR	XW,[MOVEM TAC,(UUO)]
TRESCA:
	PUSHJ	P,TRESCN		;RESCAN LINE
	JRST	SYNCHK			;RE-CALCULATE ACTIVATED CHAR. COUNT.

;TBYTEP
; ROUTINE TO MAKE A POINTER TO THE BUFFER OUT OF A COUNT OF CHARACTERS
; FROM THE START OF THE BUFFER.

	XWD 	441100,0
TLHBYT:
	XWD	331100,0
	XWD	221100,0
	XWD	111100,0
	XWD	001100,0

TBYTEP:
	PUSH	P,LINE		;SAVE LINE
	MOVNS	TAC
	ADDI	TAC,TTICHR
	IDIVI	TAC,4
	ADD	TAC,TTIBUF(DDB)
	HLL	TAC,TLHBYT(LINE)
	POP	P,LINE		;RESTORE LINE
	AOJA TAC,CPOPJ

;TTYGET, TTYFNU, TTYFND, TTYFUW, TTYERP, TTYERR
;ROUTINE TO FIND TTY FOR A JOB
;CALL:	MOVE ITEM,JOB NUMBER
;	PUSHJ P, TTYFND
;	RETURN WITH DDB SET TO ADR OF DDB
;	AND DAT SET TO BYTE POINTER TO MONITOR OUTPUT BUFFER

TTYGET:
		

↑TTYFNU:
	MOVE	ITEM,JOB(PID)
↑TTYFND:
	PUSHJ	P,TTYSRC
TTYDAT:
	MOVEI	DAT,TTOBUF(DDB)
	POPJ	P,


;PUT JOB IN IO WAIT IF TTY BUFFER NOT EMPTY
;CALLED BY NON ERROR MESSAGE ROUTINES AT UUO LEVEL

↑TTYFUW:
	JUMPE PID,TTYFU1
	PUSHACS
	CONSO APR,MAOFF
	JRST TTYFU2
	PUSHJ P,DISMES
	ASCIZ /ππPID CLOBBERED AT TTYFUW
/
	POPACS
	SETZ PID,
	JRST TTYFU1
TTYFU2:
	PUSHJ P,DISMES
	ASCIZ /ππPDP-6 AT TTYFUW
/
	POPACS
	POPJ P,

TTYFU1:
	PUSHJ	P,TTYFNU
	LDB	TAC,PJOBN	; GET JOB # OF DDB
	CAME	TAC,JOB		; IS THIS OURS?
	POPJ	P,		; NO, FORGET IT.
	MOVE	TAC,TOPUTR(DDB)
	CAMN	TAC,TOTAKR(DDB)
	POPJ	P,
	MOVEI	IOS,IOACT			;YES
	IORB	IOS,DEVIOS(DDB)
	JRST	WSYNC

;ROUTINE TO INDICATE MONITOR ERROR MESSAGE TO BE FORCED OUT
;WHEN NO MORE ROOM IN TTO BUFFER, TTI BUFFER WILL BE USED

↑TTYERP:		;ENTER HERE TO START ERROR TYPEOUT AND CLEAR INPUT
	PUSHJ	P,TTYERR
	JRST	SETBFI
↑TTYERR:				;COME HERE IF YOU NEED SPACE BUT
					;DON'T NECESSARILY NEED TO FLUSH INPUT
	PUSHJ	P,TTYSRC		; FIND TTY DDB
	MOVEI	IOS,MERTPO		;SET MONITOR ERROR PRINT OUT BIT
	IORB	IOS,DEVIOS(DDB)
	TLNE	IOS,TTYDTC		; LEAVE IF DETACHED LINE
	POPJ	P,
	PUSHJ	P,STLNAC
	TLNN	LINE,DISLIN!DDDLIN
	POPJ	P,
	PUSHACS
	HRRZ	DDB,LETAB-DPYL0(LINE)	;GET THE RIGHT SIDE ONLY
	JUMPE	DDB,TTYDX1		;NO LINE.
	HLRZ	DAT,PPCALL(DDB)
	TLNE	LINE,DDDLIN		;SKIP IF THIS IS III
	TLO	DDB,400000		;SET BIT IF DD
	HLL	DAT,DDB
	PUSHJ	P,PPCLR
TTYDX1:
	POPACS
	POPJ P,

;TTYSET, TTYSTC
;ROUTINE TO SET TTY INTO USER MODE NOW.
;CALL:	MOVE DDB,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,TTYSET

;CALLED FROM RUNCSS (START1)
;CLEARS DDTM,IOSUPR,USRB,TTYIOW AND IOW


↑TTYSET:
	MOVE	IOS,[XWD DDTM+USRB+TTYIOW+IOW,IOSUPR]
	ANDCAB	IOS,DEVIOS(DDB)
	POPJ	P,0

;ROUTINE TO START TTY OUTPUT AFTER CLEARING USRB

↑TTYSTC:
	MOVSI	TAC,USRB		; CLEAR BIT IN MEMORY
	ANDCAM	TAC,DEVIOS(DDB)
	JRST	TTYSTR

;TTYSTR, TTYUSR
;ROUTINE TO START TTY OUTPUT
;CALL:	MOVE DAT,BYTE POINTER TO LAST OUTPUT ITEM
;	MOVE DDB,ADDRESS OF TTY DDB
;	MOVE ITEM,JOB NUMBER		;(MUST BE PRESERVED)
;	PUSHJ P,TTYSTR

;CALLED FROM COMINI
;INITIALIZED TTY FOR MONITOR OUTPUT AND STARTS OUTPUT

↑TTYSTR:
	MOVE	IOS,[XWD DDTM!IOBEG!IO!TPMON,IOSUPR!IOBKTL!IOACT]
	ANDCAB	IOS,DEVIOS(DDB)
	TLNE	IOS,TTYDTC		;DON'T START DETACHED LINES
	POPJ	P,
	PUSHJ	P,STLNAC		;GET LINE CHARACTERISTICS
	MOVSI	TAC,IO!TPMON
	TLNE	IOS,USRB		;GOING OUT OF MONITOR MODE?
	TLZ	TAC,TPMON		;YES, DON'T DIDLE THESE
	IORM	TAC,DEVIOS(DDB)
	MOVSI	TAC,USRB+TPMON
	TLNE	IOS,USRB
	ANDCAM	TAC,DEVIOS(DDB)
	MOVE	IOS,DEVIOS(DDB)		;GET CORRECT IOS
	SKIPLE	TISYNC(DDB)		;ANY TYPE AHEAD?
	PUSHJ	P,COMSET		;YES.
	JRST	UTYPET			;GO TYPE FIRST CHAR.

;ROUTINES TO SET SCANNER TO START UP JOB WHEN OUTPUT FINISHES
;CALL:	MOVE DDB,TTY DDB ADR.
;	PUSHJ P,TTYUSR
;	TTY WILL GO TO USER MODE WHEN TYPING OUT STOPS

↑TTYUSR:
	MOVSI	IOS,USRB		; SET BIT TO SWITCH TTY TO USER MODE
	IORM	IOS,DEVIOS(DDB)		; WHEN MONITOR OUTPUT FINISHES
	JRST	SETRUN			;GO FLAG JOB AS RUNABLE IMMEDIATELY

;TTYTLK
;ROUTINE TO ADD TTY TO TALK RING
;CALL:	ADR. OF DDB TO BE ADDED TO RING AT -3(P)
;	MOVE TAC,SIXBIT /TTYN/
;	PUSHJ P,TTYTLK
;	TTY IS BUSY RETURN OR NOT A TTY OR TOO BIG A LINE NO.
;	OK RETURN, TTY ADDED TO TALK RING

IFN FTTALK,<

↑TTYTLK:
	PUSHJ	P,GETDDB		; IN CASE NOT SET UP
	POPJ	P,			;NONE AVAIL. GIVE UP
IFN FTTKBG,<
	LDB	CHR,PUNIT		;BH 3/15/74 FOR BUG TRAP BELOW
>;FTTKBG
	MOVE	TAC,DEVMOD(DDB)
	TLNN	TAC,DVTTY
	POPJ	P,
	MOVE	IOS,DEVIOS(DDB)	;IS TTY IN MONITOR MODE AND LEFT HAND MARGIN?
	TLNE	IOS,TTYHLD	;EVIL THINGS MIGHT HAPPEN IF WE TRY TALKING
	POPJ	P,		;TO A LINE THAT'S HOLDING.
	MOVE	LINE,-3(P)		;TTY GIVING TALK COMMAND
	MOVE	LINE,DEVNAM(LINE)	;ITS NAME
	MOVE	TAC,DEVNAM(DDB)	;OPR IS NEVER TOO BUSY...
	CAMN	LINE,TAC		;IF THE SAME,
	POPJ	P,			;  NO SOAP
	CAME	LINE,DEVOPR		;EITHER ONE OPR?
	CAMN	TAC,DEVOPR
	JRST	TTYTK1
	MOVSI	TAC,TLKPRV
	TDNE	TAC,JBTPRV(J)	;CHECK PRIVILEGE
	JUMPN	J,TTYTK1	;JUMP IF PRIV SET
	TLNE	IOS,TPMON
	TLNN	IOS,IOFST
	POPJ	P,			;NO, HE IS BUSY.
TTYTK1:
	CONO	PI,SCNOFF
IFN FTTKBG,<
	HRRZ	TAC,TTYTAB(CHR)		;BH 3/15/74
	JUMPE	TAC,TTYTK2		;  BUG TRAP: MAYBE NO OBJECT DDB HERE?
>;FTTKBG
	LDB	LINE,PUNIT		;LINE NUMBER IN RING.
	MOVSI	TAC,TLKRNG
	LDB	CHR,PTALK
	TDNN	TAC,LINTAB(LINE)
	HRRZ	CHR,LINE
	IORM	TAC,LINTAB(LINE)
	EXCH	DDB,-3(P)		;GET DDB OF TALKER
	LDB	LINE,PUNIT		;LINE NO. OF TALKER
	DPB	CHR,PTALK		;SET TO POINT INTO RING
	MOVSI	TAC,TLKRNG
	IORM	TAC,LINTAB(LINE)
	MOVEM	LINE,TAC		;SAVE LINE NO. OF TALKER
	EXCH	DDB,-3(P)		;RESTORE
	LDB	LINE,PUNIT		;LINE NO. IN RING AGAIN
	DPB	TAC,PTALK		;MAOE IT POINT TO TALKER
	CONO	PI,SCNON
	JRST	CPOPJ1			;OK RETURN

IFN FTTKBG,<
TTYTK2:
	MOVE	TAC,-3(P)		;BH 3/15/74 BUG TRAP HERE TO PAGE END
	PUSHACS
	PUSH	P,DDB			;FORMER DDB OF TALKEE
	PUSH	P,CHR			;DEAD TALKEE
	PUSH	P,TAC			;TALKER'S DDB
	MOVE	DDB,TAC
	LDB	TAC,PUNIT		;TALKER
	PUSH	P,TAC
	PUSHJ	P,DISMES
	ASCIZ /ππππNO DDB FOR TALKEE AT TTYTK1!!
TALKER=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /  DDB=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /
TALKEE=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /  DDB WAS AT /
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /
FIND A WIZARD!  IF NONE, TYPE: POPJ 3,$X
/
	PUSHJ	P,DISFLU
	POPACS
	PUSHJ	P,DDTCAL
	CONO	PI,SCNON
	POPJ	P,
>;FTTKBG
>

;TTYSRC, STLNAC
;ROUTINE TO SEARCH TRANSLATOR TABLE FOR TTY
;CALL:	MOVE J,JOB NUMBER
;	PUSHJ P,TTYSRC
;	RETURN WITH ADDRESS OF DEVICE DATA BLOCK IN DDB.


↑↑TTYSRC:
	JUMPE	J,TTYF1			;SEARCH FOR OPER. TTY IF JOB NO. 0
	MOVSI	LINE,TTYATC
	MOVEI	DDB,TTYLST		;TTYDDBS START HERE
TTYSRA:
	LDB	TAC,PJOBN		;JOB ATTACHED TO THIS DDB
	CAIE	TAC,(J)			;IS THIS THE ONE
	JRST	TTYF0
	TDNE	LINE,DEVMOD(DDB)	;IS HE ATTACHED TO IT?
	JRST	TTYF9			;YES.
TTYF0:
	HLRZ	DDB,DEVSER(DDB)		;FOLLOW CHAIN
	JUMPN DDB,TTYSRA		;TO ITS END
TTYF1:
	SKIPE TAC,DEVOPR
	JRST TTYF3
	MOVEI	LINE,TCONLN		;NO USE CTY.
	SKIPE	DDB,TTYTAB(LINE)	;DOES IT HAVE A DDB?
	JRST	TTYF9
	MOVSI	TAC,'CTY'		;NO
TTYF3:
	PUSHJ	P,GETDDB		;GET A DDB FOR DEVOPR
	JRST	SCREW			;OH BOY HERE WE GO
TTYF9:
	MOVE	IOS,DEVIOS(DDB)		;SET UP IOS

	SETZ	LINE,
	TLNE	IOS,TTYDTC
	POPJ	P,
↑STLNAC:
	LDB	LINE,PUNIT		; GET UNIT # FROM DDB
	HLL	LINE,LINTAB(LINE)		;AND LINE BITS
	POPJ	P,0			;RETURN

SCREW:
	PUSHACS
	PUSHJ P,DISDATE
	PUSHJ P,DISMES
	ASCIZ/LOSE BIG! SOMEONE IS TRY TO TYPE ON A VIRGIN TTY,
AND NO CORE AVAILABLE.
/
	POPACS
	CONSZ PI,77400	;WHERE ARE WE
	POPJ P,		;CROSS FINGERS AND PRAY
	JSP DAT,UERROR	;UUO LEVEL, A WAY OUT.

;GETDDB, LOG2LN
;ROUTINE TO SETUP DDB FOR OUTPUT
;CALL	MOVE TAC,[SIXBIT /TTY#/
;	PUSHJ P,GETDDB
;	NONE AVAILABLE RETURN
;	RETURN WITH LINE AND DDB SETUP

↑GETDDB:
	PUSHJ P,LOG2LN		;CONVERT TO LINE NUMBER
	POPJ P,			;ILLEGAL
GETDBA:
	CAIL LINE,TTPLEN	;LEGAL LINE NUMBER?
	POPJ P,			;NO
GETDB1:
	SKIPE DDB,TTYTAB(LINE)		;DOES THIS LINE ALREADY HAVE A DDB?
	JRST CPOPJ1			;YES
	CAIL LINE,PTYL0
	POPJ P,			;ONLY DDBSRC WILL CREATE PTY DDB! (BH 3/18/74)
	PUSHJ P,DDBSRC		;NO. SEARCH FOR FREE DDB
	POPJ P,			;NONE AVAILABLE
	HLLZM IOS,DEVIOS(DDB)		;INITIALIZE STATE
	PUSH P,DEVNAM(DDB)
	MOVEI TAC,ASSCON+ASSPRG
	ANDCAM TAC,DEVMOD(DDB)
	JRST TPOPJ1

↑LOG2LN:MOVS TAC,TAC
	MOVEI LINE,TCONLN
	CAIN TAC,'CTY'
	JRST CPOPJ1
	TRC TAC,'TTY'
	TRNE TAC,-1
	POPJ P,			;NOT TTY#
↑SIX2LN:JUMPE TAC,CPOPJ		;JUST TTY
	MOVEI LINE,
LOG2LL:
	ROT TAC,3
	TRZE TAC,2
	TRNE TAC,5
	POPJ P,			;NOT DIGIT
	ROTC TAC,3		;DIGIT → LINE
	JUMPN TAC,LOG2LL	;MORE?
	CAIGE LINE,TTPLEN	;NO, CHECK LEGALITY
	AOS (P)
	POPJ P,

;DDBSRC, STDTBL
;ROUTINE TO SEARCH FOR FREE TTY DEV DATA BLOCK
;CALL:	MOVE LINE,TTY LINE NO.
;	PUSHJ P,DDBSRC
;	NONE FOUND OR LINE NO. TOO BIG
;	RETURN DDB,LINE AND DEVNAM SET AND BITS TPMON,IOFST,IOACT,
;		TTYUSE,ASSCON SET.
;	IF CALLED WITH LINE SET TO -1 A DETTACHED
;	DDB IS CREATED AND GIVEN TO JOB IN ITEM.

↑DDBSRC:
	HRRE	TAC,LINE			; NUMBER OF LINE ONLY
	CAILE	TAC,TTPLEN		;IS LINE NO. TOO BIG
	POPJ	P,			;YES.
	HLL LINE,LINTAB(LINE)
	TLNN LINE,DDDLIN
	JRST DDBSR1
	MOVE AC3,AVLBIT
	CONSO PI,770000
	TDNE AC3,VDMAP-DDL0(LINE)	;NOT AT PI LEVEL - SEE IF COMPLETELY FREE
	SKIPE DDOFF			;ALSO SEE IF DD UP
	POPJ P,
DDBSR1:
	MOVEI AC3,TTYFS
	PUSHJ P,SFSGET
	POPJ P,
	MOVEI	DDB,DDBSKW(AC1)
	HRLI	AC1,TTYLST-DDBSKW
	BLT	AC1,TTYPTR(DDB)	;COPY PART OF A REAL DDB INTO OUR NEW BLOCK
	SETZM	DEVIOS(DDB)
	SETZM	DEVLOG(DDB)
	SETZM	DEVNAM(DDB)
	SETZM	DEVBUF(DDB)
	SETZM	PTYPTR(DDB)
	SETZM	SAVDDB(DDB)
	MOVSI	AC1,TTICHR
	DPB	AC1,PJOBN	;CLEAR JOB NUMBER IN DEVCHR
	DPB	AC1,PUNIT	;UNIT NUMBER TOO  BH 5/6/74
	HRRI	AC1,TIBF-1(DDB)
	MOVEM	AC1,TTIBUF(DDB)
	MOVSI	AC1,TTOCHR
	HRRI	AC1,TOBF-1(DDB)
	MOVEM	AC1,TTOBUF(DDB)
	PUSHJ	P,TSETBF
	MOVSI TAC,STDTBL
	HRRI TAC,ACTBTS(DDB)
	BLT TAC,ACTMOD(DDB)
	MOVE	TAC,[XWD TTYUSE!TTYATC,ASSCON!ASSPRG]
	ANDCAM	TAC,DEVMOD(DDB)
	HRLZI	AC1,(DDB)
	HRR	AC1,DEVSER(DDB)
	CONO	PI,SCNOFF
	EXCH	AC1,TTYLST+DEVSER
	MOVEM	AC1,DEVSER(DDB)
	CONO	PI,SCNON
	MOVSI	TAC,PROG
	MOVEM	TAC,DEVIAD(DDB)		;CLEARS PHPOS
	MOVEM	TAC,DEVOAD(DDB)		;CLEARS PFITCH
	MOVE	IOS,[XWD TPMON+IOFST,IOACT]
	MOVEM	IOS,DEVIOS(DDB)		;MAKE SURE HE LOOKS LIKE A VIRGIN.
	PUSHJ	P,TSETBF		;INITIALIZE BUFFERS
	MOVE	TAC,[XWD TTYUSE,0]	;INITIALIZE DATA BLOCK.
	CAIE	LINE,-1		;IS SOME ONE GETTING A DETTACHED DDB?
	JRST [	TLNN LINE,DDDLIN!DISLIN
		JRST SCNIN		; NO, FINISH UP AND LEAVE
		PUSHJ P,DPYMAKE		; MAKE UP A DPY HEADER
		JRST TTYKL5		;LOSE - RELEASE THE DDB & LEAVE
		JRST SCNIN]
	TLO	TAC,TTYATC	;ATTACH JOB TO DDB
	IORM	TAC,DEVMOD(DDB)
	SETOM	JBTLIN(ITEM)	;YES, FLAG AS DETTACHED
	DPB	ITEM,PJOBN	;MAKE IT HIS;
	MOVSI	IOS,TTYDTC	;FLAG AS DETTACHED FROM LINE
	IORB	IOS,DEVIOS(DDB)
	JRST	CPOPJ1		;SKIP RETURN

;STANDARD SPECIAL ACTIVATION MODE BREAK TABLE
;BREAK ON ANYTHING BUT LETTER OR NUMBER
STDTBL:
	777777777777
	777700037600
	000000374000
	000007600000

;SCNIN
;INITIALIZE TTY DEVICE DATA BLOCK(CALLED FROM TTYATT TOO)
;CALL:	MOVE TAC,BITS IN DEVMOD TO BE TURNED ON
;	MOVE DDB,ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ P,SCNIN
;	SKIP RETURN ALWAYS

;	CALLED BY JRST FROM TTYATT
;	AND FALLS IN FROM DDBSRC ABOVE

;SETS PHYSICAL NAME TO SIXBIT /TTY#/ OR SIXBIT /CTY/
;	WHERE # IS THE LINE NUMBER.
;STORES LINE NUMBER IN DEVICE DATA BLOCK

SCNIN:
	IORM TAC,DEVMOD(DDB)
	DPB LINE,PUNIT			;SET LINE NO. IN DDB.

IFN FTTALK,<
	DPB LINE,PTALK			;SETUP TALK RING TO CONTAIN
					;ONLY THIS TTY.
>
	MOVEI TAC,
	ANDI LINE,-1
SCNIN0:
	ROTC TAC,-3
	HRRI TAC,2
	ROT TAC,-3
	JUMPN LINE,SCNIN0
	HRRI TAC,'TTY'
	MOVSM TAC,DEVNAM(DDB)
	PUSHJ	P,STLNAC
	HRRM DDB,TTYTAB(LINE)	;SET DDB ADR. IN TRANSLATOR TABLE.
	MOVSI TAC,'CTY'
	TLNE	LINE,CTYLIN		;IS THIS CONSOLE TTY?
	MOVEM TAC,DEVNAM(DDB)	;YES, SET NAME TO CTY.
	JRST CPOPJ1			;SUCCESSFUL RETURN.

;TTYSKL, TTYREL, TTYKIL
;CALL TO MAKE REQUEST TO DPYKIL.
;CONO PI,SCNOFF MUST HAVE BEEN DONE BEFORE THIS ROUTINE IS CALLED.
TTYSKL:
	PUSHJ	P,STLNAC		;GET LINE CHARACTERISTICS..
	TLNE	LINE,DDDLIN!DISLIN
	SKIPN	AC2,LETAB-DPYL0(LINE)
	POPJ	P,
	MOVEI	AC1,-DPYL0(LINE)
	SETO	AC3,
	EXCH	AC3,LECLIN(AC2)
	JUMPL	AC3,CPOPJ
	SETZM	LEACT(AC2)		; SEE IF THE LINE EDITOR SAYS ANYTHING IN THIS TIME
	LSH	AC1,=12
	ADD	AC1,DPYKRQ		; MAKE IT APPROPRIATE LENGTH
	CONO	PI,PIOFF
	IDPB	AC1,CLOCK(PID)
	CONO	PI,PION
	POPJ	P,

↑TTYREL:
IFN DILNUM,<
	LDB LINE,PUNIT		;SETUP LINE
	PUSHJ P,DILTRL		;CHECK FOR DIALER RELEASE
>;DILNUM
	HLLZS TAC1,DEVIOS(DDB)	;CLEAR INITTED BITS IN IOS.
	MOVE TAC,DEVMOD(DDB)
	TLNE TAC,TTYATC		;THAT'S ALL IF IT'S HIS CONSOLE
	POPJ P,
	MOVSI IOS,TPMON		;NO, PUT HIM BACK IN MONITOR MODE
	IORB IOS,DEVIOS(DDB)
	TRNE TAC,ASSCON		;DON'T KILL IF ASSIGNED BY CONSOLE
	POPJ P,

;ROUTINE TO SET SCNSER TO RETURN TTY TO VIRGIN STATE
;CALL:	MOVE	DDB, ADDRESS OF DEVICE DATA BLOCK
;	PUSHJ	P,TTYKIL

;CALLED FROM COMCSS (JOBKIL).
;IF NOT OPERATOR CONSOLE, THEN
; 1)CLEAR PHYSICAL AND LOGICAL	NAMES,
; 2)CLEAR JOB NUMBER ASSIGNMENT
;	3)CLEAR	TTYUSE,TTYATC,ASSCON,ASSPRG,
;	4)CLEAR ENTRY IN TRANSLATOR TABLE.

↑TTYKIL:
	CONO	PI,SCNOFF			;LET'S DO IT RIGHT!
	TLNE	IOS,TTYDTC
	JRST	TTYKL5			;TAKE 3 GIANT STEPS IF YOU'RE DETACHED.
	PUSHJ	P,TTYSKL		;IF A DPY, MAKE IT AVAIL. (SETS LINE)
TTYKL7:
	SKIPN	DDB,TTYTAB(LINE)	;DID SOMEONE ELSE GET IT?
	JRST	TYPT1			;YES.
	TRNN	DDB,-1			;IS THERE REALLY ONE HERE?
	JRST	[PUSHJ P,TTYKL9		;NO DDB, NO NOTHING!
IFN FTTTYBUG,<	PUSHJ P,CNTCOM		>
		JRST TYPT1]		;AND THEY'RE OFF
	MOVSI	IOS,TTYIOW!IOW!TTYDTC!DDTM	; CLEAR TTY INPUT AND OUTPUT
	ANDCAM	IOS,DEVIOS(DDB)		;WAIT BITS SO TTY WILL BE KILLED
					;PROPERLY AT INTER. LEVEL IF STILL OUTPUTING
	MOVE	TAC,[TTYATC,,ASSCON!ASSPRG]
	ANDCAM	TAC,DEVMOD(DDB)		;TTY IS NO LONGER A JOB'S CONSOLE.
	MOVSI	IOS,TPMON		;CLEAR JOB NUMBER
	DPB	IOS,PJOBN
	IORB	IOS,DEVIOS(DDB)		;TURN TPMON ON IN CASE TTY IS
					;STILL OUTPUTTING
	SKIPG	TTYTAB(LINE)		;REQUEST IN ALREADY?
	JRST	TYPT1			;LEAVE NOW!
	MOVE	TAC,TITCTR(DDB)		;TAKR COUNT
	CAMN	TAC,TIPCTR(DDB)		;COMPARE WITH PUTR
	JRST	NOTYPA			;NO TYPE AHEAD
	SKIPLE	TISYNC(DDB)		;ANY LINES TO TELL MONITOR ABOUT?
	PUSHJ	P,COMSET		;WAKE COMMAND DECODER
	JRST	TYPT1

NOTYPA:

	TLNN	LINE,PTYUSE		;DON'T KILL DDB FOR USED PTY'S.
	TLOE	IOS,IO+TOIP		;IS IT OUTPUTTING OR TALKING?
	JRST	TTYKL6
TTYKL5:
	MOVEI	TAC,TTYLST		;DON'T KILL THIS GUY
	CAIE	TAC,(DDB)		;IS THIS THE FIRST DDB
	JRST	TTYKL2			;BLAST THE MOTHER
	HLLZS	DEVIOS(DDB)		;CLEAR INITTED STUFF IN IOS
	PUSHJ	P,LINCLR		;CLEAR LINE TABLE.
	SETZM	DEVLOG(DDB)		;CLEAR LOGICAL NAME
	JRST TYPT1			;ON CLYDE.

TTYKL6:
	IORB	IOS,DEVIOS(DDB)		;MAKE SURE IT GETS KILLED AT INTERUPT LEVEL.
	JRST	TYPT1

;MORE TTYKIL
;THIS RETURNS A DDB TO FREE STORAGE.

TTYKL2:
	MOVEI	AC1,TTYLST		;SEARCH CHAIN FOR POINTER TO DDB.
TTYKL3:
	MOVE	TAC,AC1
	HLRZ	AC1,DEVSER(AC1)		;LINK
	CAIE	AC1,(DDB)		;IS THIS THE GUY THAT POINTS TO OURS
	JUMPN	AC1,TTYKL3
	JUMPE	AC1,TTYKL4
	MOVE	AC1,DEVSER(DDB)
	MOVEM	AC1,DEVSER(TAC)		;LINK HIM OUT
TTYKL8:
	PUSHJ	P,LINCLR		;CLEAR LINTAB BITS
	TLNN	IOS,TTYDTC
	PUSHJ	P,TTYKL9
IFN FTTTYBUG,<	PUSHJ	P,CNTCOM	>
	CONO	PI,SCNON		;AND AWAY THEY GO!!
	MOVEI	AC1,-DDBSKW(DDB)
	PUSHJ	P,FSGIVE
	MOVEI	DDB,0
	POPJ	P,

LINCLR:
	TLNE	IOS,TTYDTC		;NO LINE IF DETACHED
	POPJ	P,
	TLNN	LINE,PTYLIN		;PTY'S AREN'T IN THIS TABLE
	IOR	LINE,LINBIT(LINE)	;OR IN INITIALIZE BITS
	TLZ	LINE,KILMSK		;CLEAR BITS IN LINE TABLE
	HLLM	LINE,LINTAB(LINE)
	POPJ	P,

TTYKL1:
	LDB	LINE,PUNIT		;LINE NO.
	SKIPGE	TTYTAB(LINE)
	SOS	COMCNT
	PUSHJ	P,TTYKL9		;CLEAR TRANSLATOR TABLE
IFN FTTTYBUG,<	PUSHJ	P,CNTCOM>
	SETZM	DEVNAM(DDB)
	JRST	TSETBF			;BLAST TYPE AHEAD AND OUTPUT.

TTYKL4:

	PUSHACS
	PUSH P,TAC
	PUSH P,DDB
	PUSHJ P,DISMES
	ASCIZ /πππDDB NOT FOUND IN LIST AT TTYKIL
DDB=/
	POP P,TAC
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ /
LAST LINK=/
	POP P,TAC
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ /
/
	POPACS
	JRST TTYKL8		;GIVE IT BACK ANYWAY

;ALL THE "PUSHJ P,TTYKL9"S ABOVE USED TO BE "SETZM TTYTAB(LINE)"
;IF LH OF TTYTAB ENTRY ≠ LINE THEN WE WERE IN A TALK RING AND
;THIS ROUTINE PATCHES THE RING UP TO LEAVE US OUT

TTYKL9:
	LDB AC2,PTALK		;MY TALKRING POINTER
	MOVEI AC3,0
	EXCH AC3,TTYTAB(LINE)	;DON'T NEED TTYTAB ANYMORE
	JUMPE AC3,CPOPJ		;GRUMBLE, SOMEBODY CLOBBERED IT ALREADY
	CAIN AC2,(LINE)		;POINTS TO ME?
	POPJ P,			;YES, NO PROBLEM
	PUSH P,AC2		;SAVE NEXT GUY
	MOVE AC3,LINE		;MY LINE NUMBER
TTYK91:
	MOVE LINE,AC2		;LOOP THROUGH TILL YOU FIND ME
	LDB AC2,PTALK
	CAIE AC2,(AC3)
	JRST TTYK91		;NOT ME YET
	POP P,AC2		;RETRIEVE MY POINTEE
	DPB AC2,PTALK		;MAKE PREV POINT TO NEXT
	CAIE AC2,(LINE)
	JRST TTYK92
	MOVSI AC2,TLKRNG
	ANDCAM AC2,LINTAB(LINE)	;TURN OFF THE FLAG IF ONLY ONE LEFT
TTYK92:
	MOVE LINE,AC3		;FIX LINE
	POPJ P,

;OUTCH6, OUTCHS, OUTCHR
;MORE CHARACTER AND BUFFER HANDLING ROUTINES

;OUTCHR CALLED AT UUO LEVEL TO OUTPUT A CHARACTER
;DAT AND DDB MUST BE SET UP
;CHECK IS MADE FOR WHETHER SPECIAL ECHO IS REQUIRED
;RIGHT THINGS ARE DONE WITH PHPOS & HPOS(NEEDNT BE SET)
;CALL	MOVE	CHR,CHAR TO BE OUTPUT
;	PUSHJ	P,OUTCHR
;	ONLY RETURN, WITH CHAR. OR ITS SPECIAL ECHO PLACED IN OUT BUFFER

↑OUTCH6: ADDI CHR,40		;TYPE OUT SIXBIT.

↑OUTCHS:
	JUMPE PID,OUTC1S
	CONSO APR,MAOFF		;ARE WE REALLY THE TEN?
	JRST CTYTYO		;NO, JUST TYPE ON THE SIX'S CTY
	PUSHACS
	PUSHJ P,DISMES
	ASCIZ /ππPID CLOBBERED AT OUTCHS
PID=/
	MOVE TAC,PID
	PUSHJ P,DISOCT
	PUSHJ P,DISMES
	ASCIZ /
/
	POPACS
	SETZ	PID,		;MAKE IT RIGHT!!
OUTC1S:
	PUSH	P,TAC
	PUSH	P,HPOS	;CALL OUTCHR ROUTINE
				; BUT SAVE ITEM AND TAC
	PUSHJ	P,OUTCH5
	POP	P,HPOS
	JRST	TPOPJ

OUTCHR:
	MOVE	TAC,DEVIOS(DDB)	;GET IOS
	TLNE	TAC,TTYDTC
	POPJ P,
	ANDI TAC,16
	CAIN TAC,10		;MODE 10 OR 11?
	JRST	OUTCH2		;YES, NO CONVERSION
	MOVEI	AC3,20		;CHECK FREE SPACE
	CAML	AC3,TOFCTR(DDB)	; FOR EXPANDING CHARS
	JRST	GETCH1		;NOT ENOUGH ROOM
OUTCH5:
	MOVE	TAC,DEVIOS(DDB)
	TLNE TAC,TTYDTC
	POPJ	P,
	ANDI TAC,16
	CAIN TAC,10		;MODE 10 OR 11?
	JRST OUTCH2		;YES, NO CONVERSION
	ANDI	CHR,177	;MASK ANY JUNK
	PUSH	P,LINE
	PUSHJ	P,STLNAC	;SET UP LINE
	LDB	HPOS,PHPOS	;GET HORIZONTAL POSITION
	MOVE	AC3,HPOS	;SAVE FOR TAB
	PUSHJ	P,ADJHP	;NEW HPOS AFTER CHAR OUTPUT
	JFCL
	TLNE	LINE,DISLIN!IMLIN!DDDLIN!PTYLIN
	JRST	OUTCHA		;PAGE PRINTER WILL HANDLE CRLF
	CAIL	HPOS,=72	;DID IT GO OVER LINE?
	PUSHJ	P,CRLFEC	;YES, OUTPUT CRLF
OUTCHA:
	DPB	HPOS,PHPOS	;UPDATE IN CORE
	TLNN	TAC,SPOUT	;VT,FF,HT?
	JRST	OUTC1X		;NO.
	TLNE	LINE,PTYLIN	;IS THIS A PTY?
	TLNE	LINE,IMPBIT	;YES. IS IT AN IMP?
	JRST	OUTCH1		;NOT A PTY, OR AN ARPA-PTY. - EXPAND TABS, ETC.
OUTC1X:
	POP	P,LINE
OUTCH2:
	CONO	PI,SCNOFF	;PREVENT REENTRANT CALLS ON PUTCHO...
	PUSHJ	P,PUTCHO	;PUT OUT THE CHAR.
	CONO	PI,SCNON
	POPJ	P,

;MORE OUTCHR  ADJHP
;HERE ON UUO OUTPUT OF HT,FF,VT

OUTCH1:
	MOVE	HPOS,AC3	;POS BEFORE THE TAB
	MOVE	TAC,CHR		;COPY THE CHARACTER
	CAIN	CHR,11		;IS IT A TAB
	TLNE	LINE,TBXPND	;ARE WE ALWAYS EXPANDING THEM?
	JRST	OUTC1Y		;EXPAND!
	TLNE	LINE,IMLIN!PTYLIN!DISLIN!DDDLIN	;NEED IDLE CHARS.?
	JRST	OUTC1X		;NO
OUTC1A:
	POP	P,LINE		;HERE ON OUTPUT OF TAB TO SMART TTY
	ANDI	HPOS,7		;JUST LOW PART FOR INDEX
	XCT	[	MOVEI HPOS,6	;8 SPACES-2 IDLES
			MOVEI HPOS,7	;7 SPACES-1 IDLE
			MOVEI HPOS,7	;6 SPACES-1 IDLE
			MOVEI HPOS,7	;5 SPACES-1 IDLE
			MOVEI HPOS,7	;4 SPACES-1 IDLE
			JRST OUTCH2	;3 SPACES-0 IDLES
			JRST OUTCH2	;2 SPACES-0 IDLES
			JRST OUTC1Z](HPOS)	;1 SPACE -CONVERT TO SPACE (OR CTY WILL MISS TAB STOP)
	PUSHJ	P,OUTCH2	;SEND THE REAL CHAR
	MOVEI	CHR,IDLECH	;A DELAY CHARACTER
	JRST	OUTC1C		;OUTPUT SLUFFS. COUNT WILL BE MODIFIED ON VT,FF

OUTC1Y:
	POP	P,LINE		;HERE TO EXPAND CHARACTER.
OUTC1Z:
	MOVEI	CHR,40		;STUPID TTY.
	CAIE	TAC,11		;H TAB?
	MOVEI	CHR,12		;NO. OUTPUT LF'S.
OUTC1C:
	CAIN	TAC,14		;FF?
	MOVEI	HPOS,0		;YES. 8 LF'S.
	CAIN	TAC,13		;VT?
	MOVEI	HPOS,4		;YES. 4 LF'S.
OUTC1B:

	PUSHJ	P,OUTCH2	;OUTPUT THE PHONY CHAR
	ADDI	HPOS,1		;COUNT THE OUTPUTS
	TRNE	HPOS,7		;ENOUGH?
	JRST	OUTC1B		;NO. MORE.
	POPJ	P,		;NO MORE


			;CALLED AT UUO AND INT LEVEL
			;TO ADJUST HPOS FOR OUTPUT OF CHR
			;SKIPS IF SPCHECK SAYS SPECIAL CHAR

ADJHP:
	PUSHJ	P,SPCHEK	;GET BITS FROM SPCTAB
	AOJA	HPOS,CPOPJ	;ORDINARY CHAR.
	CAIL	CHR,40	;WHICH SPECIALS?
	JRST	CPOPJ1		;HIGH ONES
	CAIN	CHR,15	;CARRIAGE RETURN?
	MOVEI	HPOS,0		;YES.
	CAIE	CHR,11	;TAB?
	JRST	CPOPJ1		;NO. NO HP MOD
	TRO	HPOS,7		;TAB. TO NEXT 8
	AOJA	HPOS,CPOPJ1

;PUTCHI, PUTCHO
;ROUTINE TO PUT A CHARACTER INTO A BUFFER (FOR INPUT,MERTPO, AND ONCE)
;CALL	MOVEI DAT,TTXBUF(DDB)		;TO SPECIFY BUFFER
;	PUSHJ	P,PUTCHI
;	ERROR RETURN, BUFFER "FULL"
;	SUCCESSFUL RETURN

PUTCHI:

	SOSG	FCTR(DAT)		; ANY FREE SPACES LEFT?
	JRST	PUTCI0			;NO
PUTCHA:
	SOSLE	PCTR(DAT)		;LAST BYTE IN BUFFER FILLED?
	JRST	PUTCI1			;NO. GO AHEAD
	PUSH	P,TAC
	MOVE	TAC,BUF(DAT)		;GET ADR AND SIZE OF BUFFER
	HLRZM	TAC,PCTR(DAT)		;INITIAL COUNTER
	HRRM	TAC,PUTR(DAT)		;BYTE POINTER.
	POP	P,TAC			;RESTORE TAC
PUTCI1:
	IDPB	CHR,PUTR(DAT)
	JRST	CPOPJ1

;ROUTINE TO STUFF MONITOR ERROR MESSAGE IN TTI BUFFER
;CALLED IN LINE FROM PUTCHO

TTIOUT:
	MOVE	IOS,DEVIOS(DDB)
	AOS	TOFCTR(DDB)		;RE-ADJUST FREE CHAR COUNT
	TRNN	IOS,MERTPO		;MONITOR ERROR MESSAGE?
	JRST	GETCH1			;NO, ZERO CHR TO INDICATE
	TRON	IOS,MERTP1		;TEST FLAG AND SET IF NOT ON
	PUSHJ	P,SETBFI		;CLEAR INPUT
	MOVEM	IOS,DEVIOS(DDB)		;AND MAKE SURE FLAG GETS ON
	MOVEI	DAT,TTIBUF(DDB)		;YES, PUT REST IN TTI BUFFER
	PUSHJ	P,PUTCHI
	POPJ	P,			;ERROR RETURN
	POPJ	P,

;ROUTINE TO PLACE A CHARACTER INTO THE OUTPUT BUFFER
;CALLED AT INTERRUPT LEVEL 
;CALL	MOVE	CHR,CHARACTER TO PLACE INTO BUFFER
;	PUSHJ	P,PUTCHO
;	ONLY RETURN, WHETHER OR NOT CHARACTER WAS PLACED

PUTCHO:
	PUSH	P,TAC
	LDB	TAC,PUNIT
	HLL	TAC,LINTAB(TAC)
	TLNE	TAC,TTYFIL		;FILLING THIS TTY?
	JRST	FILLCR
FILNCR:
	TLNN	TAC,FCS
	JRST	PUTCNV			;NOT FULL CHAR SET - CONVERT LOWER TO UPPER
PUTNLC:
	POP	P,TAC
PUTCRS:
	SOSG	TOFCTR(DDB)		;RETURN IMMEDIATELY IF NO ROOM
	JRST	TTIOUT			;UNLESS MONITOR ERROR MESSAGE
	SOSLE	TOPCTR(DDB)		;LAST BYTE IN BUFFER?
	JRST	PUTCO1			;NO. GO ON.
	PUSH	P,TAC			;SAVE AN AC
	MOVE	TAC,TTOBUF(DDB)		;GET COUNT AND ADDRESS
	HLRZM	TAC,TOPCTR(DDB)		;INITIAL COUNTER
	HRRM	TAC,TOPUTR(DDB)		;INITIAL POINTER
	POP	P,TAC			;RESTORE AC
PUTCO1:
	IDPB	CHR,TOPUTR(DDB)		;PUT CHARACTER INTO BUFFER
	POPJ	P,

FILLCR:
	CAIE	CHR,15
	JRST	FILNCR
	LDB TAC,PIOMOD			;GET IO MODE
	CAIE TAC,10
	CAIN TAC,11
	JRST FILNCR			;DON'T FILL IN IMAGE MODE
	MOVEI	TAC,10
	EXCH	TAC,(P)
PUTCRX:
	PUSHJ	P,PUTCRS
	JUMPE	CHR,CRFULL
	SOSLE	(P)			;DONE YET?
	JRST	PUTCRX			;NO
CRFULL:
	POP	P,(P)
	POPJ	P,

PUTCNV:
	CAIL	CHR,"a"
	CAILE	CHR,"z"
	JRST	PUTNLC
	ANDCMI	CHR,40			;CONVERT TO UPPER CASE
	JRST	PUTNLC

;GETCHR, GETCHY
;CHARACTER AND BUFFER HANDLING ROUTINES

;ROUTINE TO PICK UP A CHARACTER FROM ANY BUFFER
;CALL	MOVEI	DAT,TTXBUF(DDB)		;TO SPECIFY BUFFER
;	PUSHJ	P,GETCHR
;	ONLY RETURN			;CHARACTER OR ZERO IN CHR
;					;ZERO INDICATES BUFFER "EMPTY"(TAKR=PUTR)

↑GETCHR:PUSHJ P,GETCHY
	ANDI CHR,177		;THROW OUT CONTROL BITS.
	POPJ P,

GETCHY:
	
	HLRZ CHR,BUF(DAT)		;CHARS IN BUFFER (THIS IS A BUG TRAP!!)
	CAIN CHR,TTICHR			;TTICHR FOR INPUT.
	JRST GETCHA
	PUSHACS
	PUSH P,LINE
	PUSHJ P,DISMES
	ASCIZ /TTY/
	POP P,TAC
	PUSHJ P,DISLOC
	PUSHJ P,DISMES
	ASCIZ / AT GETCHY FOR OUTPUT
/
	POPACS
	DEBCHECK
	JRST GETCHO

;GETCHA, GETCHO
; ROUTINE TO GET CHARACTER

GETCHA:
	SOSGE	TSYNC(DAT)		;ALWAYS COME HERE FOR INPUT.
	SETZM TSYNC(DAT)		;DON'T LET IT GET NEGATIVE
	LDB	CHR,[POINT PUNITS,-TTIBUF+DEVCHR(DAT),35-PUNITP]
	CAIL	CHR,DPYL0
	CAILE	CHR,DPYL0+DPYNUM+DDNUM-1
	JRST	GETCHO
	HLRZ	CHR,LETAB-DPYL0(CHR)
	TRNN	CHR,WTFLAG
	JRST	GETCHO		; IF LINED NOT WAITING, JUST LEAVE WITH THE GOODS
	PUSHJ	P,GETCHO		; GET CHARACTER
	PUSHACS
	LDB	DAT,[POINT PUNITS,-TTIBUF+DEVCHR(DAT),35-PUNITP]
	PUSHJ	P,ACTIV3
	POPACS
	POPJ	P,

↑GETCHO:		;7 BIT BYTES ALREADY (OUTPUT)
GETCHX:
	MOVE	CHR,TCTR(DAT)		; GET TAKR BUFFER
	CAMN	CHR,PCTR(DAT)		;IS IT SAME AS PUTR(BUFFER EMPTY)?
	JRST	GETCH1			;YES, LOAD CHR WITH ZERO AND EXIT
	SOSLE	TCTR(DAT)		;NO, ARE WE AT END OF BUFFER?
	JRST	GETCH2			;NO. GO ON.
	MOVE	CHR,BUF(DAT)		;YES. START AT TOP AGAIN
	HLRZM	CHR,TCTR(DAT)		;INITIAL COUNTER
	HRRM	CHR,TAKR(DAT)		;INITIAL POINTER
GETCH2:
	ILDB	CHR,TAKR(DAT)		;GET CHARACTER
	AOS	FCTR(DAT)		;INCREMENT FREE CHAR. COUNT
	JUMPE	CHR,GETCHX		;SKIP NULLS
	POPJ	P,
GETCH1:
	TDZA	CHR,CHR		;RETURN 0 INDICATING END OF BUFFER
PUTCI0:
	AOS	FCTR(DAT)		;FIX FREE COUNTER
	POPJ	P,

;TSETBF, SETBFI, SETBF3, SETBFO
;ROUTINES TO SET UP BUFFERS

↑TSETBF:
	PUSHJ	P,SETBF2		; INIT TTO BUFFER

↑SETBFI:MOVE	DAT,J			; SAVE J
	LDB J,PJOBN			; GET JOB #
	JUMPE J,SETBF4
	MOVSI TAC,COMSNB
	PUSHJ P,CLRSIN			; CLEAR FROM SWAPIN LIST FOR COMMAND
SETBF4:
	MOVE J,DAT			; RESTORE J
	MOVEI	DAT,1
	DPB	DAT,PCOMIC
	DPB	DAT,PLSTLC
	MOVEI	DAT,TTIBUF(DDB)		;SPECIFY USER MODE INPUT BUFFER
	SETZM	TISYNC(DDB)		;NO LINES IN BUFFER
	HRLI TAC,1100		;9 BIT BYTES IN INPUT BUFFER !!
	JRST	SETBF0			;INIT BUFFER
↑SETBF3:PUSHJ P,XMTIN4		;MAKE SURE GUY ISN'T HUNG ON OUTPUT.
SETBF2:
	MOVEI	DAT,TTOBUF(DDB)		;SPECIFY OUTPUT BUFFER
↑SETBFO:HRLI TAC,700		;7 BIT BYTES IN OUTPUT BUFFER.
SETBF0:
	HRR	TAC,BUF(DAT)
	MOVEM	TAC,TAKR(DAT)
	MOVEM	TAC,PUTR(DAT)
	MOVEI TAC,1
	MOVEM	TAC,TCTR(DAT)		;SO FIRST SOSG DOESNT SKIP
	MOVEM	TAC,PCTR(DAT)
	HLRZ	TAC,BUF(DAT)		;CHARACTER COUNT
	MOVEM	TAC,FCTR(DAT)		;UPDATE FREE CHARACTER COUNT
	POPJ	P,

;SPCHEK, SPCACT
;ROUTINE TO CHECK IF A CHARACTER IS SPECIAL(ASCII 0-37, 175-177)
;CALL	MOVE	CHR,CHAR. TO BE CHECKED
;	PUSHJ	P,SPCHEK
;	RETURN1 IF REGULAR ASCII CHAR (40-174), C(TAC)=0
;	RETURN2 IF SPECIAL CHAR., TAC LOADED WITH WORD FROM SPCTAB

↑SPCHEK:LDB TAC,[POINT 7,CHR,35]	;GET CODE WITHOUT CTRL BITS.
	SKIPE	TAC,SPCTAB(TAC)
	TLNN TAC,SPCBTS		;MAYBE A SPECIAL...
	POPJ P,	;NOT SPECIAL, AFTER ALL.
	JRST	CPOPJ1

;SPECIAL CHARACTER TABLE
;FORMAT	XWD BITS+CHAR,ADRESS OF ROUTINE
;HIGH ORDER BITS IN LH:

SPACTN←←400000		;SPECIAL ACTION TO BE TAKEN
ALLSPA←←200000		;ALWAYS CONTROL FUNCTIONS, NEVER BREAK CHARACTERS.
SPOUT←←100000		;SPECIAL HANDLING ON UUO OUTPUT
IMLCHR←←40000		;NOT SPECIAL ON IMLACS EVEN IF ALLSPA IS ON.
↑BREAKB←←20000		;BREAK CHARACTER
SPHPOS←←10000		;CHARACTER AFFECTS HORIZONTAL POSITION
FCSBRK←←4000		;BREAK CHARACTER IN FCS(100) MODE
ECHSUP←←2000		;SUPRESS ECHO OF CHAR ITSELF
SPBKDS←←1000		;PERFORM SPECIAL ACTION EVEN WITH CTRL. BITS.
LETTER←←400
NUMBER←←200
LNUMBT←←LETTER!NUMBER	;A LETTER OR DIGIT.

SPCBTS←←SPACTN!SPOUT!BREAKB!SPHPOS!FCSBRK

DEFINE SPC(U,L,X){FOR Z←U,L {X
			      }
		  }

SUPBTS←←1		;SUPRESS ACTIVATION ON CONTROL BITS.
SUPCCR←←2		;SUPRESS EFFECT OF CONTROL CR TO LINE EDITOR
SUPSCM←←4		;SUPRESS SUPBTS (ACTIVATE ANYWAY) IF CTRL-META

SPCACT:

	LDB TAC,[POINT 7,CHR,35]
	JUMPE TAC,CPOPJ		;ALWAYS ACTIVATE ON ↑C
	PUSH P,LINE
	IDIVI TAC,=36
	ADDI TAC,(DDB)
	MOVE TAC,ACTBTS(TAC)
	LSH TAC,(LINE)
	MOVE LINE,ACTMOD(DDB)
	TLNE TAC,400000
	JRST TTPOP
	TRNE LINE,SUPSCM
	CAIE UCHN,3
	TRNN LINE,SUPBTS
	JUMPG UCHN,TTPOP
	AOS -1(P)
TTPOP:
	POP P,LINE
	POPJ P,

;SPCTAB
SPCTAB:
	XWD	ALLSPA+SPACTN+ECHSUP+BREAKB+SPBKDS,CONTC	;↑C
	0					;↑A
	XWD	ALLSPA+SPACTN+ECHSUP+IMLCHR,CONTB	;↑B FULTWX&HOLD SW
	0					; β
	0					;↑D EOT
	0					;↑E WRU
0;	XWD	SPACTN+ECHSUP,CONTF		;↑F FCS SW
	0					;↑G (BELL)
	0					;↑H OR BACKSPACE KEY
	XWD	ALLSPA+SPACTN+SPHPOS+SPOUT+SPBKDS,CONTI	;↑I OR TAB
	XWD	BREAKB+SPBKDS,0			;↑J OR LINE FEED
	XWD	ALLSPA+SPACTN+SPOUT,CONTK	;↑K OR VERT TAB
	XWD	ALLSPA+SPACTN+SPOUT,CONTL	;↑L OR FORM FEED
	XWD	ALLSPA+SPACTN+SPHPOS+SPBKDS,CRLF;↑M OR CARRIAGE RETURN
	0					;↑N
	XWD	SPACTN,CONTO			;↑O SUPP OUTPUT
0;	XWD	SPACTN+ECHSUP,CONTP		;↑P T35 SW
	0					;↑Q XON (PAPERTAPE)
	0					;↑R TAPE PUNCH ON
	0					;↑S XOFF
	0					;↑T TAPE PUNCH OFF
	XWD	SPACTN,CONTU			;↑U DELETE LINE
	0					;↑V OR IDLE
	0					;↑W
	0					;↑X
	0					;↑Y
	XWD	ALLSPA+SPACTN+ECHSUP+IMLCHR,CONTZ	;↑Z TTY EOF
	0 					;ASCII 33 (OLD ALT-MODE)
	0					;ASCII 34
	0					;ASCII 35
	0					;ASCII 36
	0					;ASCII 37

SPC (" ","0"-1,0)
SPC ("0","9",<XWD NUMBER,0>)
SPC ("9"+1,"A"-1,0)
SPC ("A","Z",<XWD LETTER,0>)
SPC ("Z"+1,"a"-1,0)
SPC ("a","z",<XWD LETTER,0>)
SPC ("z"+1,174,0)

	XWD	ALLSPA+SPACTN+BREAKB+ECHSUP,ALTMOD	;OLD DEC ALTMODE 175
	0						;CLOSE CURLY BRACKET
	XWD	SPACTN+ECHSUP+FCSBRK+SPBKDS,RUBOUT	;177 RUBOUT


;TTYUUO, CLRBUF, INSKIP
;TTYUUO - QUANTITY IN AC FIELD DETERMINES ACTION OF UUO (051)

↑TTYUUO:
	CAIL	UCHN,TTUUOL		;TOO HIGH AC FIELD?
	POPJ	P,			;YES, NO-OP
	PUSHJ	P,TTYFNU
	HLRZ TAC,TTUUOT(UCHN)		;GET BITS
	TLNE	IOS,TTYDTC
	TRNE TAC,200000			;DO WE CALL ROUTINE IF DETACHED?
	CAIA				;YES
	POPJ	P,			;QUIT NOW
	SKIPG	TTUUOT(UCHN)		;IS IT AN INPUT TYPE ?
	PUSHJ	P,UNSUPR			;YES. TURN OFF CTRL. O.
	JRST	@TTUUOT(UCHN)		;DISPATCH TO UUO ROUTINES

DEFINE UUOS{FOR X IN(<INCHRW,600000>,<OUTCHR,,ONEOUT>,<INCHRS,600000>,<OUTSTR>
,<INCHWL,600000>,<INCHSL,600000>,GETLIN,<SETLIN>
,<RESCAN,,TRESCU>,<CLRBFI,,CLRBUF>,<CLRBFO,,SETBF3>,<INSKIP,600000>
,<INWAIT,600000,IWAIT>,SETACT,<TTREAD,200000>,OUTFIV)}

; UUOMAC TTUUOT,TTYUUO

TTUUOT:

600000,,0+INCHRW
0+ONEOUT
600000,,0+INCHRS
0+OUTSTR
600000,,0+INCHWL
600000,,0+INCHSL
0+GETLIN
0+SETLIN
0+TRESCU
0+CLRBUF
0+SETBF3
600000,,0+INSKIP
600000,,0+IWAIT
0+SETACT
200000,,0+TTREAD
0+OUTFIV

UUOCNT←←.-TTUUOT
TTYUUO UUOCNT-1,UUOLNK
↑↑UUOLNK←←.

SIXBIT/INCHRW/
SIXBIT/OUTCHR/
SIXBIT/INCHRS/
SIXBIT/OUTSTR/
SIXBIT/INCHWL/
SIXBIT/INCHSL/
SIXBIT/GETLIN/
SIXBIT/SETLIN/
SIXBIT/RESCAN/
SIXBIT/CLRBFI/
SIXBIT/CLRBFO/
SIXBIT/INSKIP/
SIXBIT/INWAIT/
SIXBIT/SETACT/
SIXBIT/TTREAD/
SIXBIT/OUTFIV/

TTUUOL←←UUOCNT
ORG CLRBUF
CLRBUF:
	TLNE	IOS,TPMON		;NOT ALLOWED IN MONITOR MODE!
	POPJ	P,			;JUST RETURN
	TLNE	LINE,IMLIN
	JRST	IMLCLR
	PUSHJ	P,SETBFI			;CLEAR INPUT BUFFER
	TLNE	LINE,DDDLIN!DISLIN	;THAT'S ALL FOR TTY'S
	SKIPL	TAC,LETAB-DPYL0(LINE)		;DOES HE HAVE A LINE EDITOR
	POPJ	P,				;NO, DONE
	MOVEI	CHR,10044			;GET A CLEAR
	SETZ	UCHN,				;WITH NO BITS
	JRST	PTLL3				;AND SEND IT DOWN THE TUBES

IMLCLR:
	MOVE	CHR,[ASCID/π/]		;TELL IMLAC TO CLEAR ITS BUFFER.
	PUSHJ	P,FIVOUT
	PUSHJ	P,SETBFI		;CLEAR OURS
	MOVSI	IOS,IMLTTY
	ANDCAB	IOS,DEVIOS(DDB)		;AND THE BUCKY-BIT KLUDGE.
	POPJ	P,

INSKIP:
	TRNE UUO,1
	SKIPLE TISYNC(DDB)		;INSKIP 1 WAITS FOR A WHOLE LINE
	TLNE	IOS,TTYDTC!TPMON
	POPJ	P,
	MOVE	TAC,TIPUTR(DDB)
	CAME	TAC,TITAKR(DDB)	;ANY CHARS. IN INPUT BUFFER ?
	JRST	CPOPJ1		;YES. SKIP RETURN.
	TLNN	LINE,DDDLIN!DISLIN	;THAT'S ALL UNLESS HE'S A DPY
	POPJ	P,
	SKIPGE	TAC,LETAB-DPYL0(LINE)	;ANYTHING IN LINE EDITOR
	SKIPG	CCPOS(TAC)		;I.E. CURSOR NOT AT LEFT
	POPJ	P,			;NO
	JRST	CPOPJ1			;YES, SKIP RETURN

;INCHSL, INCHRS, INCHWL, IWAIT, OUTSTR, INCHGT, INCHGB
;INPUT A CHARACTER AND SKIP---IF NONE TYPED, DON'T SKIP

INCHSL:
	SKIPG	TISYNC(DDB)		;ANY LINES IN BUFFER?
	POPJ	P,			;NO, RETURN
INCHRS:

	TLNE	IOS,TPMON
	POPJ	P,
	PUSHJ	P,INCHGT		;GET ANY CHRS. FROM LINE EDITOR.
	MOVEI	DAT,TTIBUF(DDB)		;GET A CHARACTER
	PUSHJ	P,GETCHY		;FROM TTI BUFFER
	PUSHJ	P,PTICHK		;WAKE UP PTY WAITERS, IF ANY.
	JUMPE	CHR,CPOPJ		;RETURN IF NULL(EMPTY BUFFER)
	CAIN	CHR,600
	JRST	INCHSZ			;STORED ↑C
INCHSY:
	XCTR	XW,[MOVEM CHR,(UUO)]	;MOVE INTO LOC. SPECIFIED BY UUO
	JRST	CPOPJ1			;AND SKIP RETURN

INCHSZ:
	MOVE	CHR,DEVMOD(DDB)
	TLNN	CHR,TTYATC		;IF ATTACHED TO JOB
	TRNN	CHR,ASSCON!ASSPRG	;OR NOT ASSIGNED OR INITED
	JRST	MONUS6			;THEN PROCESS CONTROL-C
	JRST	INCHSY			;GIVE THE LOSER THE CONTROL-C

;INPUT CHARACTER AND WAIT, LINE MODE

INCHWL:
	PUSHJ	P,INCHSL		;SEE IF ANY CHARS.
	JRST	.+2			;NO
	POPJ	P,0			;YES. GIVE IT TO USER
	TLNE	LINE,IMLIN		;BY BO - IMLACS HAVE A COMMAND
	JRST	IMCHWL			;FOR SPECIAL ACTIVATION.
IMCHW0:
	MOVE	IOS,[XWD TTYIOW,IOACT]	;NONE. WAIT FOR IT
	IORM	IOS,DEVIOS(DDB)		;TTY TO IOW STATE
	MOVSI	IOS,DDTM		;JUST IN CASE
	ANDCAB	IOS,DEVIOS(DDB)		;CLEAR DDTMODE BREAK FLAG
	PUSHJ	P,TWSYNC		;WAIT FOR CHAR(INTPTI IF APPROPRIATE).
	PUSHJ	P,INCHSL		;REPEATED TESTING HERE SO
	JRST	IMCHW0			;IMLACS ONLY GET THE WORD-MODE
	POPJ	P,			;COMMAND ONCE.

IMCHWL:
	TLNN	LINE,SPCBRK		;IMLAC: SPECIAL ACTIVATION MODE?
	JRST	IMCHW0
	MOVE	CHR,[ASCID/α/]		;YES.  TELL IT WE'RE WAITING.
	PUSHJ	P,FIVOUT
	JRST	IMCHW0

IWAIT:
	LDB CHR,PLASTC		;GET LENGTH OF LAST RE-EDITED LINE.
	TRNE UUO,-1		;IS ADDRESS OF IWAIT 0 ?
	XCTR	XW,[MOVMM CHR,(UUO)]	;NO. USER WANTS GOOD NUMBER.
	SKIPLE	TISYNC(DDB)	;IS THERE A LINE PRESENT ?
	TLNE	IOS,TPMON	;NOTHING IN MONITOR MODE
	CAIA
	POPJ	P,
	MOVE	IOS,[XWD TTYIOW,IOACT]
	IORM	IOS,DEVIOS(DDB)
	MOVSI	IOS,DDTM
	ANDCAB	IOS,DEVIOS(DDB)
	PUSHJ	P,TWSYNC
	JRST	IWAIT

;OUTPUT A STRING--AT PRESENT LIKE DDTOUT

OUTSTR:
	JRST	DDT5			;TO BE NEW ROUTINE

INCHGT:
	TLNN	LINE,DISLIN!DDDLIN	; ONLY DPY'S
	POPJ	P,
	MOVE	TAC,TITAKR(DDB)
	CAME	TAC,TIPUTR(DDB)		;WILL HE GET A CHAR. WITHOUT ACTIVATING THE LINE EDITOR?
	POPJ	P,		;YES
INCHGB:
	SKIPGE	TAC,LETAB-DPYL0(LINE)	;ANYTHING IN LINE EDITOR?
	SKIPG	CCPOS(TAC)		;IS POINTER INTO LINE?
	POPJ	P,			;NO
	JRST	LACTIV			;WILL TRANSFER SOME RIGHT NOW!
					;IF THERE ARE ANY!

;INCHRW, ONEOUT, GETLIN, SETLIN, SYNCHK, SYNCHA, SETACT
;MORE ROUTINES CALLED BY TTY UUO DISPATCHER

;INCHRW GOES INTO I/O WAIT IF NO CHARACTER HAS BEEN TYPED--NO SKIPS

INCHRW:
	PUSHJ	P,INCHRS		;GET ACHAR IF ONE IS THERE
	JRST	.+2			;NONE THERE
	POPJ	P,			;CHAR. PICKED UP AND STORED
	TLNE	LINE,IMLIN		;BY BO - IMLACS HAVE FANCY
	JRST	IMCHRW			;COMMAND FOR THIS.
IMCHR0:
	MOVE	IOS,[XWD TTYIOW+DDTM,IOACT]	;SETUP FOR IOWAITM
	IORB	IOS,DEVIOS(DDB)		;SPECIFICALLY FOR INPUT WAIT
	PUSHJ	P,TWSYNC		;WAIT FOR CHAR. TO BE TYPED
	JRST	INCHRW			;GO GET IT

IMCHRW:
	MOVE	CHR,[ASCID/↓/]		;IMLAC COMMAND: SEND ONE CHAR.
	PUSHJ	P,FIVOUT
	JRST	IMCHR0

;ONEOUT OUTPUTS ONE CHARACTER

ONEOUT:
	XCTR	XR,[MOVE CHR,(UUO)]	;PICK UP CHAR. FROM USER
	TRNE	IOS,IOSUPR		;IF ↑O MODE
	POPJ	P,0			;RETURN
	ANDI	CHR,177			;MASK ANY JUNK
	JUMPE	CHR,CPOPJ		;DONT STORE NULLS
	PUSHJ	P,OUTCHR		;PLACE IT IN TTO BUFFER
	JUMPN	CHR,TYPGO		;IF IT STORED, RETURN
	PUSHJ	P,TTOUWS		;BUFFER WAS FULL. TRY AGAIN LATER
	JRST	ONEOUT

;GETLIN PUTS LINE CHARACTERISTICS WORD INTO ADR. IN UUO ADR. FIELD

GETLIN:
	XCTR	XR,[SKIPGE TAC,(UUO)]	;DOES USER WANT OWN LINE CHAR. WD.?
	JRST	GETLN1			;YES
	MOVEI	LINE,0			;NO, CHECK SIZE OF NUMBER
	CAIL	TAC,TTPLEN		;TOO HIGH?
	SOJL	LINE,GETLN3
	MOVE	LINE,LINTAB(TAC)	;NO, GET IT
	HRRI	LINE,(TAC)
GETLN1:
	MOVE	TAC,LINE	;START WITH THIS LINE
	JRST	GETLN5		;JUMP IN
GETLN2:
	TLNN	TAC,PTYLIN		;IS THIS A PTY?
	JRST	GETLN4
	MOVE	TAC,PTYJOB-PTYL0(TAC)	;OWNER OF THIS PTY
	MOVE	TAC,JBTLIN(TAC)		;HIS LINE CHARACTERISTICS
GETLN5:
	CAME	TAC,[-1]		;THAT'S ALL IF WE FIND A DETACHED LINE
	JRST	GETLN2		;DOWN THE CHAIN
	JRST	GETLN3
GETLN4:
	AND	TAC,[XWD DISLIN!DDDLIN,0]	;COPY THESE BITS
	TDO	LINE,TAC			;INTO LINE BITS, IN CASE WE ARE A PTY
GETLN3:
	XCTR	XW,[MOVEM LINE,(UUO)]		;GIVE IT TO USER
	POPJ	P,

;ROUTINE TO SET LINE CHARACTERISTICS THAT ARE SETABLE

SETLIN:
	MOVSI	TAC,LGLSET&¬IMPBIT	;MAKE MASK OF ALL OF THEM
	TLNE	LINE,DISLIN!DDDLIN!PTYLIN!IMLIN
	TLZ	TAC,TBXPND
	ANDCAM	TAC,LINTAB(LINE)	;SHUT OFF ALL SETABLE BITS
	TLO	TAC,IMPBIT		;THIS CAN BE TURNED ON BUT NOT OFF
	XCTR	XR,[AND TAC,(UUO)]	;SET ONLY THOSE BITS USER WANTS SET
	IORB	TAC,LINTAB(LINE)	;SET RESULTANT
	HLL	LINE,TAC		;NEW BITS TO LINE
SYNCHK:
	MOVE	AC1,TITCTR(DDB)		;PREPARE TO SIMULATE GETCHY
	MOVE	AC2,TITAKR(DDB)	
	MOVEI	AC3,1			;ONE FOR FIRST CHAR.
	SETZM	TISYNC(DDB)		;IN CASE BUFFER EMPTY
SYNCH2:
	CAMN	AC1,TIPCTR(DDB)		;IS THIS THE END?
	POPJ	P,			;YES, LEAVE
	SOJG	AC1,SYNCH3		;TEST FOR WRAP AROUND
	HRR	AC2,TTIBUF(DDB)		;RESET BYTE POINTER
	HLRZ	AC1,TTIBUF(DDB)		;AND TAKR COUNTER
SYNCH3:
	ILDB	CHR,AC2			;PICK UP CHAR!
	TLNE IOS,TPMON			;MONITOR DOESN'T GET ANY OF THIS
	JRST SYNCH5
	TLNN LINE,SPCBRK		;ARE WE SPECIALLY ACTIVATING
	JRST SYNCH1			;NO
	LDB UCHN,[POINT 2,CHR,28]
	PUSHJ P,SPCACT
	JRST SYNCH4
	AOJA AC3,SYNCH2
SYNCH1:
	TRNE CHR,600			;CONTROL BITS?
	JRST SYNCH4			;YES, ACTIVATE THESE SO FAR
SYNCH5:
	PUSHJ P,SPCHEK
	AOJA	AC3,SYNCH2
	TLNE TAC,BREAKB!FCSBRK		;BREAK CHARACTER?
SYNCH4:
	MOVEM	AC3,TISYNC(DDB)		;UPDATE TISYNC WITH # OF CHARS SCANNED SO FAR
	AOJA	AC3,SYNCH2

SYNCHA:
	MOVN	AC1,FCTR(DAT)		;UNUSED SPACE IN BUFFER.
	ADDI	AC1,TTICHR		;SIZE OF BUFFER
	MOVEM	AC1,TSYNC(DAT)		;SET TISYNC
	POPJ	P,


;SETACT		SET A BREAK TABLE
;CALL
;TTYUUO 15,ADDR
;RIGHT HALF CONTAINS ADDRESS OF TABLE TO BE BLT'ED IN (NO NEW TABLE IF 0)
;LEFT HALF CONTAINS ADDRESS OF WHERE TO STORE COPY OF OLD TABLE(NO STORE IF 0)

SETACT:
	XCTR	XR,[MOVS TAC,(UUO)]	;GET POINTER WORD
	TRNN	TAC,-1
	JRST	STACT1			;HE DOESN'T WANT TO KNOW WHAT HE HAD
	MOVE	TAC1,ACTBTS(DDB)	;GIVE HIM A COPY OF THE TABLE
	XCTR	XW,[MOVEM TAC1,(TAC)]
	MOVE	TAC1,ACTBTS+1(DDB)
	XCTR	XW,[MOVEM TAC1,1(TAC)]
	MOVE	TAC1,ACTBTS+2(DDB)
	XCTR	XW,[MOVEM TAC1,2(TAC)]
	MOVE	TAC1,ACTMOD(DDB)
	XCTR	XW,[MOVEM TAC1,3(TAC)]
STACT1:
	HLRZ	TAC1,TAC
	JUMPE	TAC1,CPOPJ
	XCTR	XR,[MOVE TAC,(TAC1)]	;GET HIS NEW TABLE
	MOVEM	TAC,ACTBTS(DDB)
	XCTR	XR,[MOVE TAC,1(TAC1)]
	MOVEM	TAC,ACTBTS+1(DDB)
	XCTR	XR,[MOVE TAC,2(TAC1)]
	MOVEM	TAC,ACTBTS+2(DDB)
	XCTR	XR,[MOVE TAC,3(TAC1)]
	MOVEM	TAC,ACTMOD(DDB)
	POPJ	P,

;OUTFIV, FIVOUT
;FIVOUT		ADDED BY BO FOR GIVING COMMANDS TO IMLACS
;	TTYUUO 17,ADR
;ADR: 5 LEFT-JUSTIFIED ASCII CHARACTERS.
;PUTS THESE CHARACTERS, UP TO THE FIRST NULL, INTO THE OUTPUT BUFFER.
;IF BIT 35 IS A ONE, PREFIXES THESE CHARS WITH A RUBOUT.
;GUARANTEES THAT THESE CHARS WILL BE SENT AS AN INDIVISIBLE BLOCK.

OUTFIV:
	XCTR	XR,[MOVE CHR,(UUO)]	;TTYUUO 17 comes here,
	PUSHJ	P,FIVOUT		;other places in TTYSER go there.
	POPJ P,

FIVOU2:
	CONO PI,SCNON
FIVOU1:
	PUSHJ P,TTOUWS		;Not enough room in buffer, so wait.
	CAIA

FIVOUT:
	PUSH P,CHR		;Make a temp cell for the data.
	MOVEI AC3,6		;Check for enough buffer space.
	CAML AC3,TOFCTR(DDB)
	JRST FIVOU1

	CONO PI,SCNOFF		;Got room.  Turn off channel 5.
	TLNE IOS,TTYDTC		;Detached output gets flushed...
	JRST TYPT1		;...Ch. 5 back on.

	CAML AC3,TOFCTR(DDB)	;Check again for room, this time with
	JRST FIVOU2		;the interrupt disabled.

	PUSHJ P,UNSUPR		;You can't ↑O a command by God!
	MOVSI TAC,(<POINT 7,(P),-1>)	;Byte pointer into data.

	TRNN CHR,1		;If bit 35 is on,
	JRST FIVOU3
	MOVEI CHR,177		;give out with a rubout.
	PUSHJ P,PUTCHO

FIVOU3:
	ILDB CHR,TAC		;Fetch next char,
	JUMPE CHR,FIVOU4	;terminate on a null.
	PUSHJ P,PUTCHO		;Stuff into buff.
	TLNE TAC,760000		;5th chr in wrd?
	JRST FIVOU3		;No.  Do it again.

FIVOU4:
	CONO PI,SCNON		;It's done like you wanted, Massa.
	POP P,(P)		;Chan. 5 is back, so is the stack.
	JRST TYPGO

;TTYMES
;A UUO TO SEND A MESSAGE TO ANOTHER TTY
;FROM 1,2 TO ANYONE OR FROM ANYONE TO THE CTY OR FROM ANYONE
;TO AN UNUSED TTY.
↑TTYMES:
	MOVE	UUO,TAC			;SAVE POINTER
	XCTR	XR,[MOVE TAC,(UUO)]	;PICK UP TTYNN OR LINE NUMBER
	TLNN	TAC,770000		;IS IT SIXBIT
	JRST	TTYMS1			;NO
	CAMN	TAC,['TTY   ']		;GETTING HIS OWN?
	JRST	[PUSHJ P,TTYFND		;GET HIS TTY
		JRST TTYMS0]		;AND SKIP THE REST
	PUSHJ	P,GETDDB		;FIND DDB FOR IT BY SIXBIT TTY NAME
	POPJ	P,
	JRST	TTYMS0

TTYMS1:
	MOVE	LINE,TAC		;FOR GETDBA
	PUSHJ	P,GETDBA		;FIND DDB BY TTY LINE NUMBER
	POPJ	P,			;NO DDB OR ERROR
TTYMS0:
	XCTR	XR,[MOVE UUO,1(UUO)]	;PICK UP POINTER
	TLNN	UUO,770000		;ALREADY GOT P FIELD?
	TLO	UUO,440000		;NO, MAKE IT PICK UP FIRST BYTE OF WORD
	HLRZ	TAC,UUO
	ANDI	TAC,7777		;GET COUNT FIELD
	TLZ	UUO,7777
	TLO	UUO,700			;SET TO 7 BIT BYTES
	JUMPN	TAC,.+2			;IS THERE A COUNT?
	MOVEI	TAC,777777		;NO, USE LARGE COUNT
	XCTR	XW,[MOVEM TAC,JOBTM2]	;SAVE COUNT IN USER CORE
	MOVEI	DAT,TTOBUF(DDB)		;SET-UP DAT
	MOVE	IOS,DEVIOS(DDB)		;MAKE SURE IOS IS SET UP.
	AOS	(P)			;SKIP RETURN FROM HERE
	PUSHJ	P,STLNAC		;GET LINE CHARACTERISTICS. REG 7/20/73
	TLNE	LINE,CTYLIN		;IS THIS THE CTY THAT WE'RE TYPING ON?
	JRST	TTYMS9			;YES.  USE DISASTER SERVICE FOR CTY.
TTYMS3:
	XCTR	XRW,[SOSL CHR,JOBTM2]	;COUNT OUT YET?
	XCTR	XLB,[ILDB CHR,UUO]	;NO. GET A CHAR.
	JUMPLE	CHR,TYPGO		;QUIT ON NULL, OR COUNT EXHAUSTED.
	MOVNI	TAC,10			;TRY THIS MANY TIMES ON EACH CHAR.
	XCTR	XW,[MOVEM TAC,JOBTM1]
TTYMS4:
	MOVE	IOS,DEVIOS(DDB)		;GET IOS
	TDNE	IOS,[XWD TTYDTC,IOSUPR]	;DID SOMETHING HAPPEN?
	POPJ	P,			;YES, FLUSH THE REST!
	PUSHJ	P,OUTCHR
	JUMPN	CHR,TTYMS3		;LOOP IF CHAR PLACED
	XCTR	XRW,[AOSLE JOBTM1]	;COUNT DOWN LOSSAGE
	JRST	TTYMS8			;COUNT OUT, LOSE ON THIS CHAR
	PUSHJ	P,TYPTST		;NO, TRY TO GET HIM GOING
	LDB	TAC,PJOBN		;PICK UP JOB NUMBER
	MOVE	J,JOB(PID)		;NEED THIS FOR SLEEP
	CAMN	TAC,J			;DIFFERENT?
	JRST	TTYMSW			;WAITING FOR OURSELVES IS SIMPLE
	MOVEI	TAC,20
	PUSHJ	P,SLEEPT		;SLEEP 20 TIC'S
TTYMSD:
	PUSHJ	P,STLNAC		;SLEEP CLOBBERS THIS
	XCTR	XLB,[LDB CHR,UUO]	;GET CHAR. BACK
	JRST	TTYMS4			;TRY AGAIN

TTYMSW:
	PUSHJ	P,DDTWAT
	JRST	TTYMSD

TTYMS8:
	SOS	(P)			;HUNG TTY, GIVE LOSSAGE RETURN
	POPJ	P,

;HERE FOR SPECIAL CASE OF TYPING ON CTY.  REG 7/20/73
TTYMS9:
	XCTR	XRW,[SOSL CHR,JOBTM2]	;COUNT OUT YET?
	XCTR	XLB,[ILDB CHR,UUO]	;NO. GET A CHAR.
	JUMPLE	CHR,CPOPJ		;QUIT ON NULL, OR NEGATIVE COUNT.
	PUSHJ	P,DISTYO		;SEND CHARACTERS VIA DISASTER SERVICE
	JRST	TTYMS9

;TTREAD, TTYJNO, TTYJOB
;READ MICROSWITCH KEYBOARD USING SPCWAR MODE FEATURE
;CALL
;	TTYUUO 16,ADDR
;WHERE ADDR CONTAINS LINE NUMBER YOU WISH TO READ
;IF LINE IS ILLEGAL YOURS IS USED
;IF IT IS NOT ON THE KEYBOARD SCANNER THIS IS A NO-OP
TTREAD:
	XCTR	XR,[SKIPL TAC,(UUO)]	;PICK UP LINE HE WANTS
	CAIL TAC,TTPLEN		;HIGHER THAN HIGHEST?
	HRRZ TAC,LINE		;YES
	SUBI TAC,DPYL0		;NORMALIZE IT
	JUMPL TAC,CPOPJ		;NO-OP IF NOT ON KBD SCANNER
	CAIL TAC,DPYNUM+DDNUM
	POPJ P,
	TRO TAC,100		;SET SPW BIT
	MOVEI AC3,20		;TRY THIS MANY TIMES
TTRED1:
	DATAO DKB,TAC
	DATAI DKB,AC1		;READ KBD
	TRNN AC1,1B22		;SHOULD HAVE SPW BIT ON
	SOJG AC3,TTRED1		;NO, TRY AGAIN
	HLRZ AC2,AC1
	CAIE AC2,-100(TAC)	;DID WE GET THE RIGHT LINE?
	SOJG AC3,TTRED1		;NO
TTRED3:
	XCTR	XW,[MOVEM AC1,(UUO)]	;STORE RESULT
	POPJ P,

;TTYJOB
;CALL:
;	MOVEI AC,<LINE #>
;	TTYJOB AC,
;	<# OF JOB OWNING TTY IN AC>
;IF LINE # IS NOT TTY LINE, RETURN JOB CONTROLLING IF PTY
↑TTYJNO:XCTR XR,[MOVE LINE,(UCHN)];GET ARG
	JUMPL LINE,PTYJNO
	CAIGE LINE,TTPLEN	;LEGAL TTY LINE #?
	SKIPN DDB,TTYTAB(LINE)	;GET DDB POINTER
	JRST TTYJN1		;NONE
	LDB TAC,PJOBN		;GET JOB NUMBER
	MOVE AC1,DEVMOD(DDB)	;CHECK IF CONTROLLING JOB
	TLNN AC1,TTYATC		;JOBS CONSOLE?
	TLO TAC,400000		;NO, SET BIT TO INDICATE JUST OWNED
	CAIA
TTYJN1:
	SETZ TAC,		;FLAG NO JOB
TTYJN0:
	XCTR XW,[MOVEM TAC,(UCHN)];STORE ANSWER
	POPJ P,

PTYJNO:
	MOVM LINE,LINE
	CAIL LINE,TTPLEN
	JRST PTYJN1
	HRRE LINE,JBTLIN(J)	;JOBS TTY
	JUMPL LINE,TTYJN1	;RETURN 0 IF NONE
PTYJN1:
	HLL LINE,LINTAB(LINE)	;GET LINE CHARACTERISTICS
	TLNN LINE,PTYLIN	;IS IT A PTY?
	JRST TTYJN1		;NO, NO CONTROLLING JOB
	MOVE TAC,PTYJOB-PTYL0(LINE);CONTROLLING JOB
	JRST TTYJN0

;SNEAKS, SNEAKW, ACTCHR
;TWO UUO'S TO SEE THE NEXT CHAR. YOU WILL INPUT.
;ONE (SNEAKS) WHICH SKIPS IF A CHAR IS WAITING
;THE OTHER (SNEAKW) WAITS FOR A CHAR.
;BOTH RETURN THE CHAR. IN THE AC.

↑SNEAKS:
	PUSHJ P,TTYFNU		;FIND USERS TTY
	TLNE IOS,TPMON!TTYDTC	;DETACHED?
	POPJ P,			;CAN'T GET ANYTHING IF DETACHED
	MOVE AC2,TITAKR(DDB)
	CAME AC2,TIPUTR(DDB)	;ANYTHING IN TTY BUFFER
	JRST SNLOAD		;YES, RETURN IT
	TLNE LINE,DISLIN!DDDLIN
	SKIPL AC1,LETAB-DPYL0(LINE)
	POPJ P,			;NOT DISPLAY, OR NOT ACTIVE
	TLNE AC1,WTFLAG		;IF TRANSFER IN PROGRESS, LOSE
	JRST SNEAKX
	SKIPG CCPOS(AC1)	;CAN WE GET ANYTHING
	POPJ P,			;NO
	MOVE AC2,[POINT 7,LEBUF]
	ADDI AC2,(AC1)		;POINT TO BEGINNING OF LOSER EDITOR BUFFER
	ILDB TAC,AC2
	JUMPE TAC,.-1		;LOOP FOR CHAR.
	JRST SNLD1
SNLOAD:
	MOVE TAC,TITCTR(DDB)
	CAIG TAC,1
	HRR AC2,TTIBUF+BUF(DDB)	;WRAP AROUND BUFFER
	ILDB TAC,AC2
SNLD1:
	XCTR	XW,[MOVEM TAC,(UCHN)]	;STORE RESULT
	JRST CPOPJ1		;RETURN

SNEAKX:
	PUSHJ P,WSCHED		;WAIT ONE TIC
	JRST SNEAKS		;THEN LOOK AGAIN

↑SNEAKW:
	PUSHJ P,SNEAKS
	CAIA
	POPJ P,			;SUCCESS
	MOVE IOS,[XWD TTYIOW!SNKWAT,IOACT]
	IORB IOS,DEVIOS(DDB)
	MOVSI IOS,DDTM
	ANDCAB IOS,DEVIOS(DDB)
	PUSHJ P,TWSYNC		;WAIT FOR CHAR.
	JRST SNEAKW		;TRY AGAIN

;WAITS FOR ACTIVATION AND RETURNS THE CHAR WHICH ACTIVATED IT BUT
;ONLY ON RE-EDITED LINES

↑ACTCHR:PUSHJ P,TTYFNU		;FIND USER'S TTY
	CAME LINE,[-1]		;DETACHED?
	TLNN LINE,DDDLIN!DISLIN	;ONLY DPY'S HAVE ACT. CHAR.
	JRST RTZERO		;RETURN 0 (UUO NOT CLOBBERED YET)
	MOVEI UUO,0		;RPH & FW'S FAULT (NO STORE IN IWAIT)
	PUSHJ P,IWAIT		;WAIT FOR A LINE
	MOVE CHR,LETAB-DPYL0(LINE)
	LDB CHR,[POINT 9,GWORD(CHR),35]
	XCTR	XW,[MOVEM CHR,(UCHN)]
	POPJ P,

;DDTIN
IFN FTDDTM,<

;INPUT TO DDT
;CALL AC,[SIXBIT /DDTIN/]	AC CONTAINS POINTER TO BUFFER AREA
;BUFFER AREA MUST BE 21 WORDS LONG


↑DDTIN:	PUSHJ	P,TTYFNU		; SET UP DDB,LINE
DDTINA:
	MOVE	IOS,[XWD TTYIOW+DDTM,IOACT]
	IORB	IOS,DEVIOS(DDB)		;PUT INTO I/O WAIT
	TLNN	IOS,TPMON		; NOTHING THERE I IN MONITOR MODE.
	JRST	DDTINB
	PUSHJ	P,TWSYNC
	JRST	DDTINA
DDTINB:
	TLNE	LINE,DDDLIN!DISLIN
	PUSHJ	P,INCHGB		;ACTIVATE LINE EDITOR, THEN WAIT ONE TIC IF NESCESARY.
	PUSHJ P,PTICHK		;CHECK FOR PTY LINKAGE.
	MOVE	TAC,TIPUTR(DDB)
	CAMN	TAC,TITAKR(DDB)		;ANYTHING IN BUFFER?
	PUSHJ	P,TWSYNC		;NO, WAIT FOR SOME
DDTIW:
	MOVE	IOS,[XWD TTYIOW+DDTM,IOACT]
	ANDCAB	IOS,DEVIOS(DDB)
	MOVSI	TAC,IOFST
	IORM	TAC,DEVIOS(DDB)	;STOP ALL IO
	MOVSI	AC2,440700
	HRR	AC2,@UUO	;GET CONTENTS OF USER AC.
	MOVE	LINE,TIPUTR(DDB)
	MOVEI	DAT,TTIBUF(DDB)
	MOVEI	AC1,<21*5>-1		;NUMBER OF CHARACTERS ALLOWED
XFRIN:
	PUSHJ	P,GETCHY		;TRANSFER INTO USER'S AREA
XFRIN1:
	CAIN	CHR,600			;PRESTORED CONTROL C?
	JRST	XFRIN0			;YES, GO INTO MONITOR MODE
	XCTR	XDB,[IDPB CHR,AC2]
	CAME	LINE,TITAKR(DDB)	;PICKED UP ALL CHARACTERS YET?
	SOJG	AC1,XFRIN		;LOOP TILL DONE
XFRIN2:
	MOVEI	CHR,0			;TERMINATE STRING
	XCTR	XDB,[IDPB CHR,AC2]
UNSUPR:
	MOVEI	IOS,IOSUPR		;MAKE SURE IO NO LONGER SUPR.
	ANDCAB	IOS,DEVIOS(DDB)
	POPJ	P,

XFRIN0:
	MOVE	CHR,DEVMOD(DDB)		;GET SOME GOOD BITS
	TLNN	CHR,TTYATC
	TRNN	CHR,ASSCON!ASSPRG	;THESE GUYS CAN'T TYPE COMMANDS
	JRST	DDTCNC
	JRST	XFRIN

DDTCNC:
	PUSHJ	P,STLNAC		;GET LINE CHARACTERISTICS
	PUSHJ P,XFRIN2
	JRST	MONUS6			;GO PROCESS ↑C
>

;DDTOUT, DDTWAT
IFN FTDDTM,<
;OUTPUT FROM DDT
;CALL AC,[SIXBIT /DDTOUT/]	AC HAS POINTER TO DDT OUTPUT BUFFER

↑DDTOUT:
	PUSHJ	P,TTYFNU
	MOVE	UUO,@UUO
>

DDT5:
	HRLI UUO,440700
DDT3:
	MOVE IOS,DEVIOS(DDB)		;GET IOS
	TDNE IOS,[XWD TTYDTC,IOSUPR]	;DID SOMETHING HAPPEN?
	POPJ P,				;YES, FLUSH THE REST!
	XCTR XLB,[ILDB CHR,UUO]
	JUMPE CHR,TYPGO			;DONE, START OUTPUT
	PUSHJ P,OUTCHR			;PLACE CHAR IN OUTPUT BUFFER
	JUMPN CHR,DDT3			;LOOP IF CHARACTER WAS PLACED
	ADD UUO,[XWD 070000,0]		;BACK UP POINTER
	PUSHJ P,TYPGO
	PUSHJ P,DDTWAT
	JRST DDT3

↑DDTWAT:MOVEI TAC,TTOCHR		;SPECIFY TO WAIT TILL BUFFER IS EMPTY
	DPB TAC,PFITCH			;IF DDT TYPE-OUT IS TOO LONG
	MOVSI TAC,TTYIOW
	ANDCAM TAC,DEVIOS(DDB)		;MAKE SURE WE LOOK LIKE WE'RE IN OUTPUT WAIT!
	MOVEI IOS,IOACT			;WAIT UNTIL MONITOR BUFFER EMPTY
	IORB IOS,DEVIOS(DDB)
	JRST WSYNC

;SCNDSP, TTYIN, TWSYNC, TTYSKP
;DEVICE DEPENDENT PART OF IO UUOS.

;DISPATCH TABLE

	JRST	TTYINI		;INITIALIZATION
	JRST	CPOPJ1		;NO DO NOTHING
↑SCNDSP:
	JRST	TTYREL		; RELEASE
	JRST	OUT		;CLOSE
	JRST	TTYOUT		;OUTPUT

TTYIN:
	MOVE	IOS,[XWD TTYIOW,IOACT]	;INDICATE INPUT WAIT
	IORB	IOS,DEVIOS(DDB)
	TLNE	IOS,TTYDTC
	JRST	TTYIN2
	MOVSI	TAC,TTYATC
	TDNE	TAC,DEVMOD(DDB)
	TLNN	IOS,TPMON
	JRST	TTYIN3
TTYIN2:
	PUSHJ	P,TWSYNC
	JRST	TTYIN

TTYIN3:
	PUSHJ	P,PTICHK		;CHECK PTY WAITERS.
	MOVSI	IOS,DDTM+TPMON
	ANDCAB	IOS,DEVIOS(DDB)
	PUSHJ	P,STLNAC	;GET LINE CHARACTERISTICS
TTYIN1:
	SKIPG	TISYNC(DDB)
	PUSHJ	P,TWSYNC
	PUSHJ	P,MONUSR
	MOVE	IOS,[XWD TTYIOW!DDTM,IOSUPR!MERTPO!MERTP1!IOACT]
T0POPJ:
	ANDCAB	IOS,DEVIOS(DDB)
	POPJ	P,

;TTYSKP, SKIPS IF NEXT INPUT ON CHN WON'T HANG (MUST BE TTY)
↑TTYSKP:CAMG UCHN,USRHCU
	SKIPN DDB,USRJDA(UCHN)
	JRST IOIERR
	MOVE TAC,DEVMOD(DDB)
	TLNN TAC,DVTTY		;IS IT A TTY?
	POPJ P,			;NO, GIVE HANG RETURN
	MOVE IOS,DEVIOS(DDB)
	TLNN IOS,TTYDTC		;IF DETACHED,
	SKIPG TISYNC(DDB)	;OR NOTHING TO COME IN YET
	POPJ P,			;WILL HANG
	TLNE TAC,TTYATC		;IF NOT USER CONSOLE,
	TLNN IOS,TPMON		;OR NOT IN MONITOR MODE
	AOS (P)			;WON'T HANG
	POPJ P,

;TWSYNC IS CALLED FOR INPUT IO WAIT

TWSYNC:
	TLNN LINE,PTYLIN	; NO, IS IT A PTY?
	JRST TWSYN1		; NO, JUST GO INTO WAIT
	PUSH P,J
	MOVE J,PTYJOB-PTYL0(LINE)
	MOVSI AC1,INTPTI
	TDNE AC1,JBTIEN(J)
	PUSHJ P,TTINT
	POP P,J
	MOVE CHR,DEVIOS(DDB)
	TLNN CHR,TTYIOW		;DID THE LOSER TYPE SOMETHING TO US AT INTERUPT LEVEL?
	JRST TWS2
TWSYN1:
	PUSHJ P,WSYNC			;WAIT FOR INPUT
TWS2:
	MOVE IOS,[XWD TTYIOW+DDTM,IOACT]
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,


;MONUSR
;ROUTINE TO MOVE A LINE OR STRING FROM TTY INPUT BUFFER TO USER'S INPUT BUFFER
;CALLED ONLY FROM UUO LEVEL,FROM INPUT UUO ONLY

MONUSR:
	HRRZ	TAC,DEVIAD(DDB)		;ADDRESS OF BUFFER IN USER AREA
	PUSHJ	P,BUFCLR		;CLEAR WHOLE BUFFER
	JRST	ADRERR			;ADDRESS CHECK RETURN
	PUSHJ	P,STLNAC		;SETUP LINE
	MOVEI	AC2,TTICHR		;MAX NR OF CHARACTERS
	HRRZ	AC1,DEVIAD(DDB)		;ADRESS OF USR BUFFER-1
	ADD	AC1,[XWD 10700,1]	;MAKE BYTE POINTER POINT RIGHT
	MOVEI	DAT,TTIBUF(DDB)		;SPECIFY USER MODE INPUT BUFFER

MONUS1:
	PUSHJ	P,GETCHY		;GET A CHAR. FROM IT
	LDB	TAC,[POINT 7,CHR,35]	;NO CTRL BITS
	MOVE	TAC,SPCTAB(TAC)		;GET GOOD BITS
	JUMPE	CHR,MONUS3		;ZERO IMPLIES EMPTY BFR
	CAIE	CHR,3B28!12		;↑Z? (END OF FILE FOR TTY).
	JRST	MONUS9
	MOVSI	IOS,IOEND	;YES, SIGNIFY SO
	IORB	IOS,DEVIOS(DDB)
	JRST	MONUS3

MONUS9:
	XCTR	XDB,[IDPB CHR,AC1]	;PLACE CHAR. IN USER BUFFER
	TLNN	TAC,FCSBRK!BREAKB	;IS IT A SYNC CHAR. ?
MONUS2:
	SOJG	AC2,MONUS1		;NO, USER BUFFER FULL?
	CAIN	CHR,600			;STORED CONTROL C?
	JRST	MONUS7			;YES, HANDLE IT

MONUS3:
	HRRZ	AC2,DEVIAD(DDB)		;BREAK CHAR OR COUNTED OUT, INPUT UUO DONE
	SUBI	AC1,1(AC2)		;CALCULATE NUMBER OF WORDS
	XCTR	XRW,[HRRM AC1,1(AC2)]	;STORE IN 3RD BUFFER WORD

MONUS4:
	PUSHJ	P,ADVBFF		;INPUT UUO DONE,NEXT BUFFER FULL?
	JRST	MONUS5			;YES, INPUT REALLY IS DONE
	JUMPG	AC2,MONUS5		;IF WE GAVE HIM A WHOLE LINE THEN WE ARE DONE.
	SKIPLE	TISYNC(DDB)		;NO, DO WE HAVE MORE LINES FOR IT?
	JRST	MONUS8			;YES, GIVE USER NEXT LINE, TOO

MONUS5:
	MOVSI	IOS,IOFST
	IORB	IOS,DEVIOS(DDB)
	TLZE	IOS,TTYIOW		;TTY IN INPUT WAIT?
	PUSHJ	P,SETIOD		;YES, TAKE IT OUT OF IT
	POPJ	P,0

MONUS6:
	PUSHJ	P,CNCMOD		;CONTROL C MODE
	MOVSI	TAC,110000		;DECREMENT TAKR POINTER
	ADDM	TAC,TITAKR(DDB)		;SO NEXT ILDB WILL GET ↑C
	AOS	TITCTR(DDB)		;ADJUST COUNTER
	SOS	TIFCTR(DDB)		;ADJUST FREE CHAR. COUNT
	PUSHJ	P,SYNCHK		;FIX UP ACTIVATED COUNT
	PUSHJ	P,COMSET		;WAKE UP COMMAND DECODER
	JRST	WSYNC			;AND WAIT FOR INTERPRETATION

MONUS7:
	MOVE	CHR,DEVMOD(DDB)
	TLNN	CHR,TTYATC
	TRNN	CHR,ASSCON!ASSPRG	;THESE LOSERS CAN'T TYPE COMMANDS
	CAIA
	JRST	MONUS3			;SEND IT IN TO HIM
	MOVE	IOS,[XWD TTYIOW,IOACT]
	IORB	IOS,DEVIOS(DDB)		;PUT JOB BACK IN IOWAIT
	PUSHJ	P,MONUS6
	JRST	TTYIN			;RESTART INPUT UUO

MONUS8:
	TLNN	IOS,IOEND		;ROOM FOR ANOTHER BUFFER. ↑Z SEEN?
	JRST	MONUSR			;NO. GO PASS ANOTHER LINE
	POPJ	P,			;YES. LET UUOCON HANDLE EOF

;TTYOUT
;OUTPUT UUO

TTYOUT:
	MOVSI	IOS,IOBEG
	TDNE	IOS,DEVIOS(DDB)
	TRO	IOS,IOSUPR		;KILL ↑O ON FIRST OUTPUT
	IOR	IOS,[XWD DDTM,MERTPO!MERTP1!IOACT]
	ANDCAM	IOS,DEVIOS(DDB)
	MOVSI	IOS,IO+IOFST
	IORB	IOS,DEVIOS(DDB)


	TLNN	IOS,TTYDTC
	PUSHJ	P,STLNAC		;GET LINE CHARACTERISTICS
	PUSH	P,LINE		;SAVE INFO
	TDNN	IOS,[XWD TTYDTC,IOSUPR]	;CONTROL O?
	PUSHJ	P,USRMON		;NO, MOVE USER'S BUFFER TO TTO BUFFER
	PUSHJ	P,ADVBFE		;ADVANCE USER'S HEADERS
	SKIPA
	TDZA IOS,IOS		;MORE BUFFERS. DON'T CLEAR IOACT.
	MOVEI	IOS,IOACT		;NO MORE BUFFERS
	ANDCAB	IOS,DEVIOS(DDB)		;CLEAR ACTIVE IN IOS
	POP	P,LINE		;RESTORE LINE INFO
	PUSHJ P,TYPGO		;GO START OUTPUT, IF NECESSARY.
	TRNE IOS,IOACT		;ARE WE DONE ?
	JRST TTYOUT		;NO. DO SOME MORE. 
	POPJ P,


;USRMON
;ROUTINE TO MOVE USER OUTPUT BUFFER TO MON. OUTPUT BUFFER
;CALLED ONLY AT UUO LEVEL,BY OUTPUT UUO

USRMON:
	HRRZ	AC2,DEVOAD(DDB)		;ADDRESS OF 2ND BUFFER WORD
	XCTR	XR,[HRRZ AC2,1(AC2)]	;NUMBER OF WORDS TO OUTPUT
	IMULI	AC2,5			;NR OF CHARACTERS

USRMN1:
	HRRZ	AC1,DEVOAD(DDB)		;ADDRESS OF BUFFER
	ADD	AC1,[XWD 10700,1]	;MAKE POINTER.

USRMN2:
	XCTR	XLB,[ILDB CHR,AC1]	;PICK UP CHARACTER
USRMN4:
	JUMPE	CHR,USRMN5		;IF NULL, IGNORE
	PUSHJ	P,OUTCHR		;PLACE IN OUTPUT BUFFER
	JUMPE	CHR,USRMN3		;IF NO MORE ROOM IN MON. BUFFER

USRMN5:
	SOJG	AC2,USRMN2		;LOOP AS LONG AS THERE ARE CHAR'S.
	DPB	AC2,PFITCH		;NO CHARACTERS TO FIT
	POPJ	P,			;DONE

USRMN3:
	PUSH	P,AC2
	CAILE	AC2,777			;GREATER THAN MAX? (9 BIT FIELD)
	MOVEI	AC2,777			;YES, USE MAX
	DPB	AC2,PFITCH		;NUMBER OF CHARACTERS TO GO
	PUSH	P,AC1			;SAVE RELOCATABLE POINTER
	MOVE	LINE,-3(P)		;GET SAVED LINE CHAR WORD
	PUSHJ	P,TTOUWS		;WAIT FOR IO
	POP	P,AC1			;RESTORE POINTER
	POP	P,AC2			;GET BACK CHR COUNT
	MOVE	IOS,DEVIOS(DDB)		;RESTORE IOS
	XCTR	XLB,[LDB CHR,AC1]	;GET LAST CHARACTER
	TRNN	IOS,IOSUPR		;USER TYPED ↑O?
	JRST	USRMN4			;RETURN TO OUT LOOP
	POPJ	P,			;YES, CONSIDER BUFFER MOVED

TTOUWS:
	MOVEI	IOS,IOACT	;SET DEVICE ACTIVE (TTY)
	IORB	IOS,DEVIOS(DDB)
	PUSHJ	P,TYPGO		;START TYPING IF NEEDED
	JRST	WSYNC			;WAIT TILL ROOM IN BUFFER

;SCNIN1, SCNTYP, KBDINT
;COMMON PARTS OF CTY AND SCANNER INTERRUPT SERVICE ROUTINES.


SCNIN1:

	DATAI	DCSA,LINE	;GET LINE NO. FROM FULL DUPLEX.
	CONO	DCSA,4000+FSNCHN
				; RELEASE XMITTER SCANNER
	JRST	XMTINT		;IN SCNSER OR TTYSER
;ROUTINE TO OUTPUT A CHARACTER ON A LINE
;CALLED FROM TYP OR TYPL IN SCNSER

SCNTYP:
	CONO PI,SCNOFF		;TURN SCANNER PI OFF IN CASE AT USER LEVEL
				;SO NO INTERRUPTS BETWEEN CONO, AND DATAO
	CONO DCSB,(LINE)	;NO
	DATAO DCSA,CHR
	CONO PI,SCNON		;TURN SCANNER PI BACK ON
	SKIPE	DDB
	DPB CHR,PLASTC	;SAVE CHAR FOR FULL DUPLEX
	POPJ P,


IFN FTOIKB,	{
↑KBDINT:
	JSR SCNSAV		; SAVE AC'S, SET UP P
	DATAI KBD,CHR
	LDB LINE,[POINT 4,CHR,17]
	LDB UCHN,[POINT 2,CHR,9]	;GET CONTROL BITS.
	TLZ CHR,777577
	CAIN CHR,2	;CHECK FOR LOST CHR
	POPJ P,
	ADDI LINE,DPYL0
	CAIN CHR,1	;USE BLANK KEY FOR ALTMODE
	MOVEI CHR,174
	CAIN CHR,177	;IS IT A BACKSPACE ?
	MOVEI CHR,136	;YES. PRETEND HARDWARE CODE IS 136.
	HRRZ DSER,CHR		;PRESERVE UNSHIFTED CHAR.
	TLZE CHR,200
	HRRZ CHR,SHFTBL(CHR)
	HRRZ CHR,CONVTB(CHR)
	CAIE CHR,600
	DPB UCHN,[POINT 2,CHR,28]	;PUT IN THE CTRL. BITS.
KBDIN1:
	CAIN CHR,213			;<CTRL1>VT?
	MOVEI CHR,10042
	CAIN CHR,212			;<CTRL1>LF?
	MOVEI CHR,10044
	CAIN CHR,412			;<CTRL2>LF?
	MOVEI CHR,10000			;PATCH FOR ↑O
	JRST RECINA


;SHFTBL, CONVTB
SHFTBL:
	0
 174 
0
0
22
177
0
0
	0
11
12
13
14
15
0
0
	0
20
0
0
0
0
24
0
	32
0
0
0
0
0
0
23
	40
1
0
0
0
0
0
0
	173
175
0
176
77
25
46
17
	2
3
6
7
10
44
52
100
	42
47
33
134
34
36
35
0
	REPEAT 30,<0>	;100-127
	0
0
0
31
16
27
136
43
	45			;140
XXZ←←101
	REPEAT 32,<XXZ
XXZ←←XXZ+1>
	0
174
0
0
136

↑CONVTB:	XWD 0,600
	XXZ←←1
	REPEAT 27,<XWD XXZ,XXZ
	XXZ←←XXZ+1>
	XWD 137,137
	XWD 31,31
	XWD 134,136
	XXZ←←33
	REPEAT 45,<XWD XXZ,XXZ
	XXZ←←XXZ+1>
	XWD 140,140
	XXZ←←101
	REPEAT 33,<XWD XXZ,XXZ
	XXZ←←XXZ+1>
	XWD 177,32	;134
	XWD 135,135
	XWD 32,177	;136 IS HARDWARE FORM OF DELETE THESE DAYS.
	XWD 30,30
	XWD 100,100
	XXZ←←141
	REPEAT 33,<XWD XXZ,XXZ
	XXZ←←XXZ+1>
	XWD 176,175	;174 IS HARDWARE ALTMODE.
	XWD 174,176	; 
	XWD 175,174
	XWD 136,134		}

;DKBINT

↑DKBINT:MOVEM	CHR,DKBCHR	;SAVE ONE AC WHILE WE THINK ABOUT THIS CHAR
	DATAI	DKB,CHR
	TRNE	CHR,1B23	;INVALID?
	TRNE	CHR,1B22	;SPW?
	JRST	DKBLUZ		;IGNORE
	EXCH	CHR,DKBCHR	;STORE CHARACTER WHERE WE'LL SEE IT LATER
	JSR	SCNSAV
IFN FTHG,	<	PUSHJ P,HG	>
	DATAI	CHR
	JUMPGE	CHR,.+2
	DATAO	PI,DKBCHR	;DISPLAY IN LIGHTS IF DATA SWITCH 0 SET
	MOVE	CHR,DKBCHR	;GET BACK CHAR
	HLRZ	LINE,CHR
	ANDI	CHR,1777	;MASK UNWANTED BITS
	CAIL LINE,DPYNUM+DDNUM
	POPJ P,
	ADDI LINE,DPYL0
	TRC	CHR,1700		;MAKE SENSE OF THESE BITS RIGHT
	MOVEI AC2,(CHR)
	LDB	TAC,[POINT 2,CHR,29]	;SHIFT-TOP
	LDB	UCHN,[POINT 2,CHR,27]	;CTRL-META
	ANDI	CHR,77			;JUST THESE FOR INDEX
	CAIE	CHR,41			;BREAK?
	CAIN	CHR,42			;ESCAPE?
	JRST	DKBSPC			;SPECIAL CHARACTER
	CAIN	CHR,44			;CLEAR?
	JRST	DKBSPC
	LDB	DAT,DKBBYT(TAC)
	ANDCMI	TAC,1			;TOP ONLY
	LDB	DSER,DKBBYT(TAC)	;UNSHIFTED CHAR.
	MOVEI	CHR,(DAT)		;GET BACK SAVED CHAR.
	CAIE	CHR,600			;EXCEPT FOR ↑C
	DPB	UCHN,[POINT 2,CHR,28]	;GET BACK CONTROL BITS
	TRZA	DSER,600		;NO CONTROL BITS HERE
DKBSPC:
	TRO	CHR,10000		;MAKE IT SPECIAL
	JRST	RECINA

DKBLUZ:
	EXCH	CHR,DKBCHR	;RESTORE CHR, LEAVE CHARACTER WHERE WE CAN SEE IT
	DATAO	PI,DKBCHR	;DISPLAY LOSING LINE NUMBER (AND CHAR) IN LITES
	JRST	12,@CH5		;DISMISS INTERRUPT


DKBBYT:
	POINT 9,DKBTBL(CHR),8
	POINT 9,DKBTBL(CHR),17
	POINT 9,DKBTBL(CHR),26
	POINT 9,DKBTBL(CHR),35

;DKBTBL
DEFINE DKBCHR(A,B)<
BYTE(9)<"A">+40,<"A">,<"B">,<"B">
>


;FORMAT IS   BYTE(9)CHAR	SHIFT CHAR	TOP CHAR	TOP SHIFT CHAR

DKBTBL:
	0
	DKBCHR	A,≤
	DKBCHR	B,π
	DKBCHR	C,ε
	BYTE(9)	"d","D",74,74
	BYTE(9)	"e","E",100,100
	BYTE(9)	"f","F",76,76
	DKBCHR	G,≠
	DKBCHR	H,=
	DKBCHR	I,'
	BYTE(9)	"j","J",137,137
	BYTE(9)	"k","K",31,31 ;; DKBCHR	K,<→>
	BYTE(9)	"l","L",27,27 ;; DKBCHR	L,<double-arrow>
	DKBCHR	M,∃
	DKBCHR	N,∀
	BYTE(9)	"o","O",173,173
	BYTE(9)	"p","P",176,176
	DKBCHR	Q,∧
	DKBCHR	R,#
	DKBCHR	S,≥
	DKBCHR	T,&
	BYTE(9)	"u","U",140,140
	DKBCHR	V,λ
	DKBCHR	W,∨
	DKBCHR	X,β
	BYTE(9)	"y","Y",42,42
	DKBCHR	Z,α

DEFINE DKBCHR(A,B)<
BYTE(9)<"A">,<"A">,<"B">,<"B">
>

	BYTE(9)	15,15,15,15
	DKBCHR	<\>,∞
	BYTE(9)	12,12,12,12
	0					;36
	0					;37 FUCK
	BYTE(9)	40,40,40,40			;40
	0					;41 BREAK
	0					;42 ESC
	BYTE(9)	600,600,600,600			;43 ↑C
	0					;44 CLEAR
	BYTE(9)	11,11,11,11
	BYTE(9)	14,14,14,14
	BYTE(9)	13,13,13,13
	BYTE(9)	50,50,133,133;;	DKBCHR	<(>,[
	BYTE(9)	51,51,135,135;;	DKBCHR	<)>,<]>
	BYTE(9)	52,52,026,026;;DKBCHR	*,⊗
	BYTE(9)	53,53,174,174;;DKBCHR	+,|
	BYTE(9)	54,54,041,041;;DKBCHR	<,>,!
	BYTE(9)	55,55,005,005;;DKBCHR	-,¬
	DKBCHR	.,?
	DKBCHR	/,∂
	DKBCHR	0,0
	DKBCHR	1,≡
	DKBCHR	2,∩
	DKBCHR	3,∪
	DKBCHR	4,⊂
	DKBCHR	5,⊃
	DKBCHR	6,$
	DKBCHR	7,%
	BYTE(9)	<"8">,<"8">,32,32
	BYTE(9)	<"9">,<"9">,30,30
	DKBCHR	:,↓
	DKBCHR	<;>,↑
	BYTE(9)	177,177,177,177
	BYTE(9)	175,175,175,175
	0
	0

;SCNINT
;SCANNER INTERRUPT SERVICE ROUTINE.

↑SCNINT:
	JSR	SCNSAV
	CONSO	DCSA,10		;RECEIVER FLAG?
	JRST	SCNIN1		;NO,XMITTER FLAG
	CONI	DCSB,LINE	;SCANNER INPUT.
	DATAI	DCSB, CHR
	CAIL	LINE,SCNNUM	;ARE WE ENABLED FOR THIS LINE NUMBER?
	POPJ	P,		;NO, DISMISS INTERRUPT
	CAIN LINE,APLINE
	LSH CHR,-2		;PUT AP STUFF IN RIGHT PLACE
	JRST	RECINT		;RECEIVER INT. HANDLER

;CTYINT
;CTY INTERRUPT SERVICE ROUTINE

↑CTYINT:
	JSR	SCNSAV			;YES, SAVE AC'S
	MOVEI	LINE,TCONLN		;LOAD LINE WITH PROPER
	CONSO	TTY,40			;YES. TTI FLAG?
	JRST	CTYOU1			;NO.
	DATAI	TTY,CHR
IFE 0,<
	JRST	RECINT			;RECEIVER INTERRUPT HANDLER
>
IFN 0,<
	MOVEI	LINE,26
	ANDI	CHR,177
	CAIN	CHR,1
	JRST	CTYFOO
	MOVE	UCHN,CTYFO1#
	SETZM	CTYFO1
	MOVE	DSER,CHR
	DPB	UCHN,[POINT 2,CHR,28]
	JRST	KBDIN1

CTYFOO:
	AOS	CTYFO1
	POPJ	P,
>

CTYOU1:
	CONO	TTY,200+SCNCHN		; CLEAR TTO FLAG
	JRST	XMTINT			;COMMON TRANSMIT INTERRUPT HANDLER

;SCANNER INTERRUPT SERVICE ROUTINE IS IN SEPARATE DEVICE DEPENDENT SECTION


;RECINT, RECINA, RECINB, RECINC, RECIM3, NOESC, ESCRET

;COMMON RECEIVER INTERRUPT FOR ALL KEYBOARD DEVICES

↑RECINT:
	MOVEI UCHN,0	;NO CONTROL BITS FROM MOST KEYBOARDS.
RECINA:
	HLL LINE,LINTAB(LINE)
	MOVE TAC,LINTAB(LINE)		;TTYLOK TEST WAS HERE (SEE BELOW) (ME+BH)
PTYREC:
	JUMPE CHR,CPOPJ		;PTY output routines enter here (at uuo level).
	TRNE CHR,10000
	JRST SETESC
NOESC:
	TRNE TAC,REGESC+SPCESC
	JRST DOESC

ESCRET:
	HLL	LINE,LINTAB(LINE)	;TTYLOK TEST MOVED DOWN TO ALLOW SOME ESCS
	TLNN	LINE,CTYLIN		;ALWAYS LET CTY BY
	SKIPN	TTYLOK			;ARE WE IN LOCKOUT MODE
	JRST	NOLOCK			;NO
	MOVSI	DDB,400000		;MAKE A TEST BIT
	MOVNI	LINE,(LINE)
	LSH	DDB,(LINE)
	DATAI	APR,LINE		;READ CONSOLE SWITCHES
	TDNN	DDB,LINE		;DOES THIS GUY GET BY?
	POPJ	P,			;NO
NOLOCK:
	LDB	LINE,[PUNITS⊗6,,TAC]
	SKIPE	DDB,TTYTAB(LINE)	;IS THERE A DDB FOR THIS LINE?
	JRST	RECIN1			;YES, GO ON
	CAIE	LINE,IMSSS
	CAIN	LINE,APLINE		;FLUSH AP LINE OR IMSSS IF NO DDB
	POPJ	P,
	PUSH	P,AC1
	PUSHJ	P,DDBSRC		;NO, FIND ONE
	JRST	TYPX
	POP	P,AC1
RECIN1:
	HLL	LINE,LINTAB(LINE)
RECIN8:

IFN FTTALK,<	CAIN	CHR,10044	;DID HE TYPE CLEAR?
		JRST	RECINZ		;YES, LET POOR FELLOW FLUSH HIS LINED
		TLNE	LINE,TLKRNG	;IN A TALK RING?
		JRST	DOTALK		;YES, GO TALK
RECINZ:

>
	MOVE	IOS,DEVIOS(DDB)		;SET UP IOS
	TLNE	LINE,DDDLIN!DISLIN
	JRST	KBDED		; IF A DPY, GO TO SMART EDITOR
RECIN2:
	TLNE	LINE,IMLIN	;IMLAC LINE?
	JRST	RECIML		;YES, SPECIAL INTERRUPT RECEIVER FOR IMLACS
RECIM2:
	ANDI	CHR,177		;7-BIT ASCII ONLY
;*** BEGIN RPH HACK TO RUN DATAPHONES AS DATA DEVICES
	TLNE	IOS,TPMON	;MONITOR HEAL THY SELF
	JRST	NOSPMD		;NO SPECIAL MODE (IN CASE THIS IS HIS CONSOLE)
	LDB	TAC,PIOMOD	;PICK UP IO MODE
	CAIE	TAC,10		;SPECIAL "IMAGE" MODE?
	CAIN	TAC,11		;ANOTHER SPECIAL MODE FOR AP WIRE
	JRST [	TLZ	IOS,IMLTTY	;**BO MOD TO TURN OFF IMLAC CONTROL FLAG**
		TLNE	IOS,TTYHLD
		PUSHJ	P,TTYUNH	;ALSO DON'T ALLOW HOLDING.
		MOVEI	DAT,TTIBUF(DDB)
		PUSHJ	P,PUTCHI	;PUT CHARACTER DIRECTLY INTO INPUT BUFFER
		JFCL			;IGNORE FAILURE
		MOVE	DAT,FCTR(DAT)
		CAIE	TAC,10		;INTERRUPT EVERY CHAR?
		CAIG	DAT,TTICHR/2	;NO, HALF FULL YET?
		TLOA	IOS,DDTM	;YES, ACTIVATE IT NOW
		JRST	SNKTST		;DON'T ACTIVATE YET
		JRST	RECIN4]		;ACTIVATE, BUT NOT COMMAND DECODER
NOSPMD:

;*** END RPH HACK
	CAIE CHR,0
RECINC:
	CAIN	CHR,3			;CONTROL C?
RECINB:
	PUSHJ	P,CNCTST		;YES, SEE IF 2ND CONTROL C
	TLNE LINE,IMLIN
	JRST RECIM3		;IMLAC'S SEND ALL THE RIGHT CODES.
	TLNN LINE,PTYLIN	;PTY'S WILL BE SENDING RIGHT CURLY BRACKET
	CAIE CHR,176
	CAIN CHR,33		;CONVERT OLD LOSING ALTMODES INTO NEW.
	MOVEI CHR,175
RECIM3:
	LDB	HPOS,PHPOS		;PICK UP HORIZONTAL POSITION OF OUTPUT CHAR.
	MOVEI	DAT,TTIBUF(DDB)		;USER MODE INPUT BUFFER
	PUSHJ	P,TTEDIT		;GO EDIT (AND ECHO) CHARACTER
	TLNN	IOS,TPMON		;NOT IN MONITOR MODE
	TLNN	LINE,PTYLIN
	JRST	RECIN5			;ONLY SPECIAL CHECK FOR PTYS
	JUMPE	UCHN,RECIN5
	MOVE	TAC,ACTMOD(DDB)
	TRNE	TAC,SUPSCM
	CAIE	UCHN,3
	TRNN	TAC,SUPBTS
	TLO	IOS,SYNC		;ACTIVATE PTY ON CTRL META
RECIN5:
	TRNN	IOS,NOECHO		;IF WE ECHOED IT,
	DPB	HPOS,PHPOS		;STORE HORIZONTAL POSITION
	TLNE	IOS,TTYHLD		;IF TYPEOUT IS HOLDING
	CAMN	TAC,SPCTAB+2		;AND THE CHAR WASN'T ↑B...
	CAIA
	PUSHJ	P,TTYUNH		;THEN UNHOLD.
	HLLM	LINE,LINTAB(LINE)	;UPDATE LINE TABLE
	MOVE	TAC,TIFCTR(DDB)		;FREE SPACES LEFT
	CAIG	TAC,12			;ONLY 10 LEFT?
	JRST	RWARN			;YES. GO OUTPUT XOFF
	TLNN	IOS,SYNC!DDTM		;WAS A BREAK CHARACTER TYPED?
	JRST	SNKTST			;NO, GO SEE IF ECHO NEED BE TYPED
	TLNN	IOS,SYNC		;DON'T CRANK UP CH7 UNLESS SYNC CHAR.
	JRST	RECIN4

;RECIN3, RECIN4, UTYPET, TYPTST, TYPGO, TTINT

RECIN3:
	MOVSI	TAC,COMBIT		;IS IT IN COMMAND WAIT NOW?
	TDNN	TAC,TTYTAB(LINE)	;..
	PUSHJ	P,COMSET		;NO, WAKE UP COMMAND DECODER NOW
RECIN4:
	MOVEI	DAT,TTIBUF(DDB)		;SET FOR SYNCHA
	TLZE	IOS,SYNC!DDTM		;ACTIVATION CHAR.?
	PUSHJ	P,SYNCHA		;UPDATE ACTIVATED CHAR. COUNT
					;CLEAR SYNC IN CORE
	MOVEM	IOS,DEVIOS(DDB)		; ..
	MOVE	TAC,TIPCTR(DDB)		;UPDATE COUNTER FOR ↑U
	DPB	TAC,PLSTLC
	TLNE	IOS,TPMON		;NO INTERRUPTS IN MONITOR MODE.
	JRST	TYPTST
	LDB	J,PJOBN			; PICK UP JOB NUMBER
	MOVSI	AC1,INTTTY		; GIVE HIM A TTY INTERRUPT IF DESIRED
	TDNE	AC1,JBTIEN(J)		; IS HE ENABLED FOR IT?
	PUSHJ	P,TTINT			; YES, DO IT.
	TLZN	IOS,TTYIOW		;IN TELETYPE INPUT WAIT?
	JRST	TYPTST			;NO, GO ECHO
SNKWAK:
	PUSHJ	P,STTIOD		;YES, SET IO DONE(OUT OF TTY IOW)
	PUSHJ	P,STXTIM		;UPDATE INTERACTION RUN TIME (XTIME)
	MOVSI	IOS,IOW!TTYIOW!SNKWAT
	ANDCAB	IOS,DEVIOS(DDB)		;CLEAR WAIT BITS
↑UTYPET:
TYPTST:
	TLNE	IOS,TTYDTC
	JRST	TYPT1
	PUSHJ	P,STLNAC		;CLOBBERED BY STTIOD
	TLNE LINE,PTYLIN		;IS THIS A PTY
	JRST PTOCK			;YES, JUST GO CHECK PTY STUFF
	MOVSI	IOS,TOIP
	CONO	PI,SCNOFF
	TDNE	IOS,DEVIOS(DDB)		;TYPE OUT HAPPENNING?
	JRST	TYPT1
	IORB	IOS,DEVIOS(DDB)		;NO, BUT THERE IS NOW
	CONO	PI,SCNON
	TLNN IOS,TTYDTC		;DON'T TYPE IF HE'S DETACHED...
	JRST	XMTIN1			;START OUTPUT
TYPT1:
	CONO	PI,SCNON
	POPJ	P,

SNKTST:
	TLNN IOS,SNKWAT			;IS LOSER IN SNEAK WAIT?
	JRST TYPTST			;NO, PROCEED NORMALLY
	JRST SNKWAK

↑TYPGO:	MOVE	IOS,DEVIOS(DDB)
	TDNE	IOS,[XWD TTYDTC,IOSUPR]
	JRST	TYPT1			;FLUSH OUTPUT
	PUSHJ P,STLNAC
	MOVSI	IOS,IO
	TLNN LINE,PTYLIN
	CONO	PI,SCNOFF		;MAKE SURE OF NO RACE!
	IORB	IOS,DEVIOS(DDB)
	JRST	TYPTST

RWARN:
	TLO	IOS,DDTM		;ACTIVATE EVERYTHING SO FAR
	TLNE	LINE,FULTWX!PTYLIN!DISLIN!IMLIN	;CAN LINE BE STOPPED?
	JRST	RECIN3			;NO. WAKE JOB AND CROSS FINGERS.
	MOVEI	CHR,23			;YES. SEND AN XOFF.
	PUSHJ	P,PUTCHO		; ..
	MOVEI	CHR,IDLECH		;AND AN IDLE FOR TTY TO THINK ON.
	PUSHJ	P,PUTCHO		;OUTPUT IT.
	JRST	RECIN3			;GO WAKE JOB.

TTINT:
	IORM AC1,JBTIRQ(J)
	SETOM INTREQ(PID)
	HLLOS CLKFLG(PID)
	CONO PI,1B24!1⊗(7-CLKCHN)
	POPJ P,

STXTIM:
	LDB	J,PJOBN			;GET JOB NUMBER
↑STXTM2:				;ENTRY POINT FROM RUN-JOB CODE
	JUMPE	J,CPOPJ			;IF NO JOB, NO XTIME
	SKIPGE	XTIME(J)		;IS NO-UPDATE BIT ON?
	POPJ	P,			;YES.  DONT DO ANYTHING!
	MOVE	TAC,TTIME(J)		;PICK UP CURRENT RUN TIME
	MOVEM	TAC,XTIME(J)		;UPDATE INTERACTION RUN TIME
	SKIPGE	TAC,JBTWAT(J)		;PICK UP WAIT TIME
	ADD	TAC,UPTIME		;MAKE IT HONEST
	MOVEM	TAC,JB2WAT(J)		;AND SAVE IT
	HRLS	DSKOPS(J)		;SAVE CURRENT NUMBER OF DISK OPERATIONS
	POPJ	P,

;ESCAPE BITS
;DEFINITIONS FOR ESCAPE PROCESSOR
;ALL THIS STUFF GOES IN RH(LINTAB)

REGESC←←400000	;NORMAL ESCAPE TYPED
SPCESC←←200000	;SPECIAL
ESCNEG←←100000	;NEGATION FLAG (BREAK, ETC.)

ESCTYP←←200200			;BYTE PNTR FOR TYPE BITS
ESCARG←←PUNITS⊗14+<17-PUNITS>⊗6	;EVERYTHING ELSE IS ARG
ESCFLD←←PUNITS⊗14+<22-PUNITS>⊗6	;WHOLE ESCAPE FLD
ESCNUL←←ESCNEG⊗-PUNITS-1		;MAX VAL USED FOR NULL (ZERO SOMETIMES LEGAL)
ESCMAX←←ESCNUL-1		;MAX LEGAL VALUE

;SETESC
;HERE ON <ESC>,<BREAK>, OR <CLEAR> (ALSO FUNNY CHARS FROM PTYS)
;ESCAPE CODE BITS ARE SET UP FOR NEXT TIME

SETESC:
	CAIN CHR,10044
	JRST NOESC		;<CLEAR> ISN'T REALLY AN ESC CHR
	MOVEI AC3,
	CAIN CHR,10042
	MOVEI AC3,REGESC⊗-PUNITS+ESCNUL
	CAIN CHR,10041
	JRST [	CAIE UCHN,1	;WATCH OUT FOR CTRL-BRK
		MOVEI AC3,<REGESC+ESCNEG>⊗-PUNITS+ESCNUL
		JRST .+1]
	CAIN AC2,1641
	MOVEI AC3,SPCESC⊗-PUNITS+ESCNUL
	DPB AC3,[ESCFLD,,LINTAB(LINE)]
	JUMPN AC3,CPOPJ		;EXIT IF ESC CHR
	HLRE AC1,CHR
	JUMPLE AC1,.+2
	ANDI AC1,ESCNUL
	JUMPN AC1,.+2
	MOVEI AC1,ESCNUL	;ELSE MAP 10XXX→<ESC>XXX, 14XXX→<BRK>XXX
	TRNE CHR,4000		;(EASIER FORM FOR PTYUUO'S)
	MOVN AC1,AC1
STDESC:
	CAIN DSER,"a"
	JRST VDESCA
	CAIN DSER,"d"
	JRST VDESCD
	CAIN DSER,"s"
	JRST VDESCS
	CAIN DSER,"t"
	JRST VDESCT
	CAIN DSER,"u"
	JRST ASESC	;AUDIO SWITCH CHANNEL SELECT
	CAIN DSER,"b"
	JRST ESCB	;AUDIO SWITCH UNBEEPER
STDES2:
	TRO CHR,10000	;PASS IT ON TO LINED
	CAIN AC1,ESCNUL	;WITH ARG IN SIGN-MAGNITUDE FORM
	MOVEI AC1,
	JUMPGE AC1,ESCRET
	MOVN AC1,AC1
	CAIN AC1,ESCNUL
	MOVEI AC1,
	HRLI AC1,400000
	JRST ESCRET

;REMEMBER THAT ARG WE READ IN IN DECIMAL? WELL, WE REALLY WANTED
;TO READ IT IN OCTAL, SEE, SO . . .

ESCOCS:
	AOS (P)
ESCOCT:
	IDIVI AC1,=100
	IDIVI AC2,=10
	LSH AC2,3
	ADD AC2,AC3
	LSH AC1,6
	ADD AC1,AC2
	POPJ P,

;DOESC
;HERE ON NEXT CHAR AFTER ESCAPE. ANY ARG IS ACCUMULATED LEAVING ESC BITS SET.
;OTHER CHARS CLEAR BITS (LEAVING ESCAPE MODE) AND DISPATCH TO APPROP HANDLER

DOESC:
	LDB AC1,[ESCARG,,TAC]
	LDB AC2,[ESCTYP,,TAC]
	CAIE AC2,1
	JRST .+3
	CAIE UCHN,3
	SOJA AC2,ESCXIT
	CAIL DSER,"0"
	CAILE DSER,"9"
	JRST DOESC1
	CAIN AC1,ESCNUL
	TDZA AC1,AC1
	IMULI AC1,12
	ADDI AC1,-"0"(DSER)
	CAILE AC1,ESCMAX
	MOVEI AC1,ESCMAX
	DPB AC1,[ESCARG,,LINTAB(LINE)]
	POPJ P,

DOESC1:
	CAIN DSER,"-"
	JRST DOESCN
	TRNE TAC,ESCNEG
	MOVN AC1,AC1
ESCXIT:
	ANDI TAC,1⊗PUNITS-1
	HRRM TAC,LINTAB(LINE)
	JRST @ESCDSP(AC2)	;NOTE AC2>0 OR WE WOULDN'T BE HERE

ESCDSP:
	ESCRET
	SPESC
	STDESC

DOESCN:
	MOVEI TAC,ESCNEG
	XORM TAC,LINTAB(LINE)
	POPJ P,

;SPESC
SPESC:
	TLO TAC,200000
IFN FTDDT,<
	CAIN CHR,600
	CAIE UCHN,3
	CAIA
	JRST DDTCAL
>;FTDDT
	CAIE CHR,600-40(DSER)
	JRST ESCRET
	CAIN CHR,600+"L"
	JRST SPESCL
	CAIE CHR,600+"M"
	JRST STDESC
	PUSHJ P,ESCOCT
	CAIL AC1,TTPLEN
	MOVEI AC1,(LINE)
	HRRM AC1,LINTAB(LINE)
	POPJ P,

SPESCL:
	MOVE TAC,LINE
	MOVE AC2,LINTAB(TAC)
	TLNN AC2,DDDLIN
	POPJ P,
	SUBI TAC,DDL0
	PUSHJ P,ESCOCT
	CAIL AC1,DDL0
	CAIL AC1,DDL0+DDNUM
	POPJ P,
	SKIPN AC2,LETAB-DPYL0(AC1)
	SKIPA AC3,VDMAP-DDL0(AC1)
	MOVE AC3,VDTMP(AC2)
	PUSHJ P,VDSTR
	MOVEM AC3,VDTMP(AC2)
	JRST VDOUT

;ESCAPES

;ADD CHANNEL TO MAPPING
VDESCA:
	PUSHJ P,VDESTV
	PUSHJ P,VDECHK
	PUSHJ P,VDVCHK
	DPB AC1,[400,,VDTMP(AC2)]
	PUSHJ P,VDSTRB
	IORM AC3,VDTMP(AC2)
	JRST VDOUT

;NORMALIZE SWITCH FOR THIS CHANNEL
VDESCN:
	PUSHJ P,VDNORM
	JRST VDOUT

;DELETE CHANNEL FROM MAPPING
VDESCD:
	PUSHJ P,VDESET
	POPJ P,
	PUSHJ P,VDBIT
	CAIL AC1,40
	MOVEI AC3,17	;ANY HIGH # CLEARS ANALOG SELECT
	PUSHJ P,VDSTR
	ANDCAM AC3,VDTMP(AC2)
	JRST VDOUT

;SELECT SINGLE CHANNEL INTO MAPPING
VDESCS:
	PUSHJ P,VDESTV		;<ESC>S
	PUSHJ P,VDECHK
	PUSHJ P,VDVCHK
	MOVEM AC1,VDTMP(AC2)
	PUSHJ P,VDSTRB
	MOVEM AC3,VDTMP(AC2)
	JRST VDOUT

;SELECT SINGLE CHANNEL TEMPORARILY
VDESCT:
	PUSHJ P,VDESTV
	PUSHJ P,VDECHK
	TRZN AC1,-40
	JRST VDESC2
	ANDI AC1,7
	SKIPA AC3,VDSYNC(AC1)
VDESC2:
	PUSHJ P,VDBIT
	SKIPE AC2,LETAB+DPYNUM(TAC)
	MOVEM AC3,VDTMP(AC2)
	JRST VDOUT

VDESTV:
	JUMPGE AC1,CPOPJ	;<ESC>S OR <ESC>T OR <ESC>A
	CAME AC1,[-ESCNUL]	;SKIP IF <BRK>
	POPJ P,
	PUSH P,AC1
	PUSH P,TAC
	HRRZI AC1,ASTVC		;TV AUDIO CHANNEL
	PUSHJ P,ASESC		;SIMULATE ESC # U WHERE # = ASTVC
	POP P,TAC
	POP P,AC1
	POPJ P,

;MORE ESCAPES	VDESET	VDECHK	VDVCHK
;SET UP ARGS FOR VD CMDS, SKIP IF LEGAL.
;NO ARG => MY CHAN. + ARG => DD CHAN #. - ARG => CHAN FOR TTY #.
VDESET:
	HRRI TAC,-DDL0(LINE)
	MOVE AC2,LINTAB+DDL0(TAC)
	TLNN AC2,DDDLIN
	JRST VDEST4
	JUMPL AC1,VDEST3
	CAIE AC1,ESCNUL
	JRST ESCOCS
	MOVEI AC1,-DDL0(AC2)
	TLO TAC,200000
VDEST2:
	SKIPN AC2,LETAB+DPYNUM(AC1)
	SKIPA AC1,AVLCHN
	HLRZ AC1,PRGNUM(AC2)
	JRST CPOPJ1

VDEST3:
	MOVN AC1,AC1
	CAIN AC1,ESCNUL
	JRST VDEST1
	PUSHJ P,ESCOCT
	SUBI AC1,DDL0
	CAIGE AC1,DDNUM
	JUMPGE AC1,VDEST2
	POPJ P,

VDEST1:
	MOVEI AC1,45		;<BRK> WITH NO ARG IS ALWAYS TV CHANNEL
	JRST CPOPJ1		;RPH OCT-27-72

VDEST4:
	TLNE AC2,DISLIN		;NOT DD, SEE IF III
	SKIPN LETAB+DPYNUM(TAC)
	POPJ P,			;NOT III OR NO DPY HEADER MEANS ILLEGAL
	JUMPL AC1,CPOPJ
	HRROI TAC,(TAC)		;(THANK YOU MR. FROST - REG) SET SIGN FOR VDSTRI
	CAIN AC1,ESCNUL
	SKIPA AC1,[-4,,]	;NULL ARG MEANS ALL P OF G'S
	PUSHJ P,ESCOCT
	TRNN AC1,-20
	AOS (P)			;SKIP IF LEGAL P OF G #
	POPJ P,

;SET UP ARGS & CHECK PRIVACY. RETURNS UPLEVEL ON LOSSAGE
VDECHK:
	PUSHJ P,VDESET
	JRST TPOPJ
	TLNE TAC,200000
	POPJ P,
	CAIGE AC1,40
	SKIPL DDTAB(AC1)
	POPJ P,
	MOVEI AC3,(TAC)
	MOVEI J,
	PUSHJ P,VDCCHK
	SUB P,[1,,1]
	POPJ P,

;CHECK IF CHANNEL IS REALLY ANALOG, AND HANDLE SPECIALLY
VDVCHK:
	TRZN AC1,-40
	JRST CPOPJ1
	ANDI AC1,7
	IOR AC1,VDSYNC(AC1)
	PUSHJ P,VDSTR
	XCT @-1(P)
	SUB P,[1,,1]
	JRST VDOUT

;ASSCN, ASESC, ESCB  AUDIO SWITCH SERVICE

;ASBTAB HAS DURATION OF BEEP IN 1/4 SEC UNITS
;IF NON-ZERO, INDICATES BEEP IS HAPPENING

;ASTAB BITS
;RH HAS TIME REMAINING IN TEMP SELECTION IN 1/4 SEC UNITS
;	ZERO MEANS INFINITE
;BITS	  FUNCTION
;0     => UUO IS HANGING UNTIL TEMPORARY SELECTION TIMES OUT
	ASHANG←←400000
	ASHGBP←←430100
;1     => CURRENT SELECTION IS TEMPORARY
	ASTEMP←←200000
;2     => PAGING NOW
	ASPAGN←←100000
;3     => BEEP WHEN TEMPORARY SELECTION TIMES OUT
	ASDBEP←←40000
;4     => PERMANENT CHANNEL NOT PAGE INTERRUPTIBLE
	ASPPUN←←20000
	ASPPUP←←370100
;5     => PERMANENT CHANNEL NOT BEEP INTERRUPTIBLE
	ASPBUN←←10000
	ASPBUP←←360100
;6-7   => TEMPORARY CHANNEL BEEPING DISPOSITION
	ASBPDP←←340200
;8-9   => TEMPORARY CHANNEL PAGING DISPOSTION
	ASPGDP←←320200
;10-13 => TEMPORARY CHANNEL NUMBER
	ASTMPP←←260400
	ASTMPM←←360
;14-17 => PERMANENT CHANNEL NUMBER
	ASPRMP←←220400
	ASPRMM←←17	;MASK

;DISPOSITION CODES
	;0: INTERRUPTIBLE
	;1: NON-INTERRUPTIBLE
	;2: INTERRUPTIBLE, BUT EXTEND DURATION OF TEMP CH
	;3: POSTPONE BEEP UNTIL TEMP SELECTION TIMES OUT

;NOTE: 3 IS APPLICABLE ONLY TO BEEP DISPOSITION

ASPAGC←←0			;AUDIO SWITCH PAGING CHANNEL
ASTVC←←1			;AUDIO SWITCH TV CHANNEL
ASBEPC←←5			;AUDIO SWITCH BEEP CHANNEL
ASBPTM←←3			;3/4 SEC FOR BEEP

;AUDIO SWITCH CHANNEL PERMANENT SELECTION
ASESC:
	HRREI TAC,-DPYL0(LINE)
	JUMPL TAC,CPOPJ		;NOT A DPY
	CAIL TAC,DPYNUM+DDNUM
	POPJ P,
	MOVEI DSER,0
	JUMPGE AC1,ASESC1	;JUMP IF PAGE INTERRUPTIBLE PERM SELECTION ESC U
	MOVN AC1,AC1		;BRK#U MAKE PAGE UNINT.PERMANENT SELECTION
	MOVEI DSER,ASPPUN	;PERM PAGE UNINTERRUPTIBLE
ASESC1:
	CAIN AC1,ESCNUL
	MOVEI AC1,ASPAGC⊗-3*=10+ASPAGC&7	;FAKE OUT ESCOCT
	PUSHJ P,ESCOCT		;ASSUME TYPEIN WAS OCTAL
ASSEL:
	LDB AC3,[ASHGBP,,ASTAB(TAC)]	;UUO HANG BIT
	IORI AC1,(DSER)		;PERM SELECTION AND MAYBE PPUN BIT
	HRLZM AC1,ASTAB(TAC)	;CLEAR ALL OTHER BITS
	SETZM ASBTAB(TAC)	;CLEAR BEEP DURATION
	HRLI AC1,(TAC)
	DATAO AS,AC1		;DO SELECTION NOW
	JUMPN AC3,ASUNHG	;UNHANG POOR UUO
	POPJ P,


↑ASSCN:	CONO PK,0		;MAKE SURE WE DON'T RUN PAGING INT CODE
	MOVSI TAC,-<DPYNUM+DDNUM>
	MOVEI TAC1,-1
ASSCNL:
	TDNE TAC1,ASBTAB(TAC)	;CHECK FOR BEEPING GOING ON
	JRST ASSCB
	TDNN TAC1,ASTAB(TAC)	;SKIP IF NON-INFINITE TEMP SELECTION
	JRST ASSCLN
	MOVE AC1,ASTAB(TAC)
	LDB AC2,[ASPGDP,,AC1]		;TEMP PAGE DISPOSITION
	TLNN AC1,ASPAGN
	JRST ASSCN1		;NOT PAGING NOW
	CAIN AC2,2
	JRST ASSCLN		;PAGING AND EXTEND, SO DON'T COUNT TEMP DURATION
ASSCN1:
	SOS AC1,ASTAB(TAC)	;DECREASE ITS COUNT
	TRNN AC1,-1		;SKIP IF NOT TIME YET
	JRST ASSCTO		;TIMED OUT, SET BACK TO PERMANENT
ASSCLN:
	AOBJN TAC,ASSCNL
	CONO PK,PKCHN
	POPJ P,

;IN MIDDLE OF BEEP (CAN'T BE IN A PAGE -- SEE PKINT)
ASSCB:
	SOS AC1,ASBTAB(TAC)	;DECREMENT BEEP DURATION
	MOVE AC2,ASTAB(TAC)
	TLNN AC2,ASTEMP		;SKIP IF BEEP INTERRUPTED TEMP SEL
	JRST ASSCB1		;BEEP IS DURING PERM SEL
	LDB AC2,[ASBPDP,,AC2]	;TEMP BEEP DISPOSITION
	TDNE TAC1,ASTAB(TAC)	;IF TEMP SEL IS INFINITE OR ...
	CAIN AC2,2
	JRST ASSCB1		;IF EXTEND, THEN DON'T COUNT TEMP DURATION
	SOS AC2,ASTAB(TAC)
	TRNN AC2,-1		;IF TEMP RUNS OUT DURING BEEP, ...
	TLZ AC2,ASTEMP		;MAKE IT LOOK LIKE INTERRUPTED PERM
	MOVEM AC2,ASTAB(TAC)
ASSCB1:
	TRNE AC1,-1
	JRST ASSCLN		;BEEP NOT DONE, CONTINUE SCAN
ASRVRT:
	MOVE AC1,ASTAB(TAC)
	TLZE AC1,ASDBEP
	JRST ASRVR1		;GO AND BEEP
	TLNE AC1,ASTEMP		;SKIP IF GOING BACK TO PERM
	JRST ASRVR3		;GOING BACK TO TEMP
	TLNE AC1,ASHANG		;SKIP IF UUO NOT HUNG
	PUSHJ P,ASUNHG		;UNHANG UUO
	LDB AC2,[ASPRMP,,AC1]	;PERM SEL
ASRVR2:
	HRLI AC2,(TAC)
	DATAO AS,AC2
	JRST ASSCLN		;CONTINUE SCAN

ASRVR3:
	LDB AC2,[ASTMPP,,AC1]	;TEMP SEL
	JRST ASRVR2

ASRVR1:
	MOVEM AC1,ASTAB(TAC)	;STORE BACK WITH BEEP BIT OFF
	MOVEI AC2,ASBPTM
	MOVEM AC2,ASBTAB(TAC)	;SET UP BEEP DURATION
	MOVEI AC2,ASBEPC
	JRST ASRVR2		;SELECT BEEP CHANNEL AND CONTINUE SCAN

ASSCTO:
	TLZ AC1,ASTEMP		;TEMP SEL TIMED OUT, CLEAR TEMP BIT
	TLNE AC1,ASPAGN
	JRST ASSCT2		;PAGING NOW
	TLZE AC1,ASDBEP
	JRST ASRVR1		;DO DELAYED BEEP
	MOVEM AC1,ASTAB(TAC)
	TLNE AC1,ASHANG
	PUSHJ P,ASUNHG		;UNHANG UUO
ASSCT1:
	LDB AC2,[ASPRMP,,AC1]
	JRST ASRVR2		;SELECT PERM AND CONTINUE SCAN

ASSCT2:
	MOVEM AC1,ASTAB(TAC)	;JUST CLEAR TEMP BIT AND
	JRST ASSCLN		;CONTINUE SCAN

;UNHANG UUO THAT WAS WAITING FOR TEMP SEL TO FINISH
ASUNHG:
	PUSH P,DDB
	PUSH P,J
	MOVSI J,ASHANG
	ANDCAM J,ASTAB(TAC)	;CLEAR UUO HANG BIT
	HRRZ DDB,TTYTAB+DPYL0(TAC)
	JUMPE DDB,ASUNHR	;NO DDB, DONE
	MOVSI J,TTYATC
	TDNN J,DEVMOD(DDB)
	JRST ASUNHR		;NOT CONSOLE, DONE
	LDB J,PJOBN		;JOB NUMBER
	MOVM DDB,JOBQUE(J)
	CAIE DDB,IOWQ
	JRST ASUNHR		;NOT IN IOWQ NOW
	MOVEI DDB,RUNQ		;GRONK INTO RUNQ
	MOVNM DDB,JOBQUE(J)
	PUSHJ P,REQUE
ASUNHR:
	POP P,J
	POP P,DDB
	POPJ P,

ESCB:
	HRREI AC2,-DPYL0(LINE)
	JUMPL AC2,CPOPJ
	CAIL AC2,DDNUM+DPYNUM
	POPJ P,			;NOT A DPY
	MOVSI TAC,ASPBUN
	JUMPL AC1,ESCB1
	ANDCAM TAC,ASTAB(AC2)	;ESC B MAKES YOU BEEP INTERRUPTIBLE
	POPJ P,

ESCB1:
	IORM TAC,ASTAB(AC2)	;BRK B MAKES YOU BEEP UNINTERRUPTIBLE
	POPJ P,

;PKINT	PAGING INTERRUPT SERVICE ROUTINE

↑PKCHN←←5			;PI CHANNEL FOR PAGING KLUDGE
↑PKINTB←←10			;INTERRUPT BIT IN CONI
↑PKPAGE←←20			;PAGING BIT IN CONI
↑PKSET←←10
↑PKCLR←←20

↑PKINT:	JSR PKSAV		;SAVES ACS AND PUSHJS TO .+1
	CONO PK,PKCLR!PKCHN
	MOVSI TAC,-<DPYNUM+DDNUM>
	CONSO PK,PKPAGE		;SKIP IF PAGING JUST BEGINNING
	JRST PKINND		;PAGING FINISHED
	SETOM PAGNOW		;INDICATE PAGING NOW IN PROGRESS
	MOVEI TAC1,-1
PKINL:
	MOVEI DSER,0		;-1 => BEEPING
	TDNE TAC1,ASBTAB(TAC)
	MOVNI DSER,1		;BEEPING NOW
	MOVE AC1,ASTAB(TAC)
	TLNN AC1,ASTEMP		;SKIP IF TEMP SELECTION NOW IN FORCE
	JRST PKINP		;PERM
	LDB AC2,[ASPGDP,,AC1]
	CAIN AC2,1
	JRST PKINLA		;NOT PAGE INTERRUPTIBLE
PKINLB:
	JUMPE DSER,PKINL1	;NOT BEEPING, JUST DO IT
	HLLZM ASBTAB(TAC)	;FLUSH BEEP
	TLO AC1,ASDBEP		;SET DELAYED BEEP BIT
PKINL1:
	TLO AC1,ASPAGN		;PAGING NOW
	MOVEM AC1,ASTAB(TAC)
	MOVEI AC2,ASPAGC
	HRLI AC2,(TAC)
	DATAO AS,AC2
PKINLA:
	AOBJN TAC,PKINL
	POPJ P,

;PERMANENT SELECTION IS NOW IN FORCE
PKINP:
	TLNE AC1,ASPPUN		;SKIP IF PAGE INTERRUPTIBLE
	JRST PKINLA		;CONTINUE SCAN
	JRST PKINLB

;HERE IF PAGING INTERRUPT BUT PAGING BIT IS OFF
PKINND:
	SETZM PAGNOW
	MOVE AC1,ASTAB(TAC)
	TLZN AC1,ASPAGN		;SKIP IF HAS BEEN INTERRUPTED FOR PAGING
	JRST PKINNA		;DON'T HAVE TO MUNG HIM
	TLZN AC1,ASDBEP		;SKIP IF HAVE TO DO BEEP NOW
	JRST PKINN1
	MOVEI AC2,ASBPTM
	MOVEM AC2,ASBTAB(TAC)	;SET UP BEEP DURATION
	MOVEI AC2,ASBEPC	;SELECT BEEP CHANNEL AND CONTINUE SCAN
PKINN2:
	MOVEM AC1,ASTAB(TAC)
	HRLI AC2,(TAC)
	DATAO AS,AC2
PKINNA:
	AOBJN TAC,PKINND
	POPJ P,

;DELAYED BEEP BIT WAS OFF
PKINN1:
	TLNN AC1,ASTEMP		;SKIP IF GOING BACK TO TEMP SEL
	JRST PKINNP
	LDB AC2,[ASTMPP,,AC1]	;TEMP CHANNEL SELECTION
	JRST PKINN2

;GOING BACK TO PERMANENT SELECTION
PKINNP:
	TLZE AC1,ASHANG		;SKIP IF UUO NOT HANGING
	PUSHJ P,ASUNHG		;UNHANG THE UUO
	LDB AC2,[ASPRMP,,AC1]	;PERMANENT CHANNEL SELECTION
	JRST PKINN2

;ADSMAP, BEEP UUOS

;ADSMAP AC, (EFFECTIVE ONLY FROM A JOB THAT IS ATTACHED TO ITS CONSOLE)
;AC BITS
;0	1 => TEMPORARY, 0=> PERMANENT
;1	1 => SET SELECTION, 0 => READ
;2	1 => MAKE THE SELECTION IMMEDIATELY (IF TEMP SEL)
;3	1 => DON'T HANG UNTIL PREVIOUS TEMP SEL IS COMPLETE
;4	1 => DON'T HANG UNTIL THIS TEMP SEL IS COMPLETE
;5-6	PAGING DISPOSITION
;7-8	BEEPING DISPOSITION
;14-17	NEW SELECTION (AS CHANNEL NUMBER)
;RH	DURATION FOR TEMP SEL IN 1/4 SEC UNITS

;THE FOLLOWING ADDITIONAL BITS ARE RETURNED ON A READ STATUS:
;9	1 => THERE IS AN ACTIVE TEMP MAP FOR THIS LINE
;10	1 => THERE IS A PAGE IN PROGRESS (WHETHER OR NOT ON THIS LINE)
;11	1 => THERE IS A PAGE IN PROGRESS AND ENABLED ON THIS LINE
;12	1 => THERE IS A BEEP IN PROGRESS ON THIS LINE
;13	1 => THERE IS A DELAYED BEEP PENDING FOR THIS LINE

;IF THE AC CONTAINS -1, THE MAP IS RESET TO ITS PERMANENT STATUS

;IF TRYING TO MAKE A TEMP SEL WITHOUT WAITING FOR THE PREVIOUS TEMP
;SEL TO FINISH, THE UUO WILL BE IGNORED IF THE PREV TEMP SEL HAS NOT
;COMPLETED AND BIT 2 IS ZERO

;IF PERMANENT THEN ONLY LOW BIT OF DISPOSITION FIELD IS LOOKED AT

;DISPOSITIONS
;0	INTERRUPTIBLE
;1	NON-INTERRUPTIBLE
;2	INTERRUPTIBLE, BUT EXTEND DURATION OF TEMP CH
;3	POSTPONE BEEP UNTIL TEMP SELECTION TIMES OUT

;NOTE: 3 IS APPLICABLE ONLY TO BEEP DISPOSITION

↑ADSMAP:	HRRE AC1,JBTLIN(J)
	JUMPL AC1,CPOPJ		;DETACHED
	SUBI AC1,DPYL0
	JUMPL AC1,CPOPJ		;NOT DD OR DPY
	CAIL AC1,DPYNUM+DDNUM
	POPJ P,			;NOT DD OR DPY
	MOVE AC2,TAC
	AOJE AC2,ADSRE2		;TAC=-1 MEANS RESET TO PERM
	TLNN TAC,200000		;SKIP IF SETTING SELECTION
	JRST ADSMRD		;READ SELECTION
	CONO PI,SCNOFF
	TLNN TAC,140000		;SKIP IF DON'T HAVE TO WAIT FOR PREV TEMP SEL
	PUSHJ P,ADSMWT		;WAIT FOR PREV (TURNS SCNOFF)
	JUMPL TAC,ADSMT		;MAKE TEMP SEL
ADSRE1:
	HLRZ TAC,TAC		;GET NEW CH # IN LOW 4 BITS
	MOVEI AC2,0
	DPB TAC,[ASPRMP,,AC2]	;PERM CH #
	MOVSI AC3,ASDBEP
	TDNE AC3,ASTAB(AC1)
	IOR AC2,AC3		;SET DELAYED BEEP BIT IF ALREADY SET
	LDB AC3,[000400,,TAC]	;CHANNEL TO SELECT TO
	TRNN TAC,4000		;SKIP IF PAGE UNINTERRUPTIBLE
	JRST [	PUSHJ P,ADSMP1
		JRST .+2]
	TLO AC2,ASPPUN		;SET PERM PAGE UNINTERRUPTIBLE BIT
	TRNN TAC,1000		;SKIP IF BEEP UNINTERRUPTIBLE
	JRST [	PUSHJ P,ADSMP2
		JRST ADSMP4]
	TLO AC2,ASPBUN		;SET PERM BEEP UNINTERRUPTIBLE BIT
	TLZ AC2,ASDBEP		;CLEAR DELAYED BEEP BIT IF NOT INTERRUPTIBLE
	SETZM ASBTAB(AC1)	;FLUSH BEEPS
ADSMP4:
	MOVEM AC2,ASTAB(AC1)
	HRLI AC3,(AC1)
	DATAO AS,AC3		;MAKE SELECTION NOW
	TRNN TAC,400000
	JRST ADSSCZ		;MAKING PERM SEL, SO DON'T WAIT
	TRNN TAC,20000
	PUSHJ P,ADSMWT		;WAIT FOR TEMP SEL TO FINISH
ADSSCZ:
	CONO PI,SCNON
	POPJ P,

;PAGE INTERRUPTIBLE, SO CHECK FOR PAGING GOING ON
ADSMP1:
	SKIPN PAGNOW
	POPJ P,
	TLO AC2,ASPAGN		;SET PAGING NOW BIT
	MOVEI AC3,ASPAGC	;SELECT PAGING CHANNEL
	HRRZ DSER,ASBTAB(AC1)
	JUMPE DSER,CPOPJ	;NOT BEEP IN PROGRESS
	TLO AC2,ASDBEP		;SET DELAYED BEEP BIT
	SETZM ASBTAB(AC1)	;FLUSH BEEP
	POPJ P,

;BEEP INTERRUPTIBLE, SO CHECK FOR DELAYED BEEP OR BEEP IN PROGRESS
ADSMP2:
	TLNE AC2,ASDBEP		;SKIP IF NO DELAYED BEEP
	JRST ADSMP5
	HRRZ DSER,ASBTAB(AC1)
	JUMPE DSER,CPOPJ	;NO BEEP IN PROGRESS EITHER
	MOVEI AC3,ASBEPC	;CONTINUE WITH BEEP
	POPJ P,
ADSMP5:
	TLNE AC2,ASPAGN
	POPJ P,			;PAGING TAKES PRECEDENCE
	TLZ AC2,ASDBEP		;CLEAR DELAYED BEEP BIT
	MOVEI AC3,ASBPTM
	MOVEM AC3,ASBTAB(AC1)	;START UP BEEP
	MOVEI AC3,ASBEPC
	POPJ P,

;MAKE TEMP SEL (SCNOFF)
ADSMT:
	MOVE AC2,ASTAB(AC1)
	TRNE AC2,-1		;SKIP IF NO TEMP SEL IN PROG OR INF TEMP SEL IS
	TLNE TAC,100000		;SKIP IF GRONK IS OFF
	JRST ADSMT1		;OK TO MAKE NEW TEMP SEL NOW
	JRST ADSSCZ		;TEMP SEL IN PROG, DON'T GRONK, DON'T WAIT (NOOP)
ADSMT1:
	MOVS TAC,TAC		;NEW CH # IN LOW 4 BITS, DURATION IN LH
	LDB AC3,[000400,,TAC]	;NEW CHAN SELECTION
	DPB AC3,[ASTMPP,,AC2]
	LDB TAC1,[130200,,TAC]	;NEW PAGING DISPOSITION
	CAIN TAC1,3
	MOVEI TAC1,1		;CHANGE 3 INTO 1
	DPB TAC1,[ASPGDP,,AC2]	;SET PAGE DISP
	LDB TAC1,[110200,,TAC]	;NEW BEEP DISPOSITION
	DPB TAC1,[ASBPDP,,AC2]	;SET BEEP DISP
	TRNN TAC,400		;SKIP IF NOT PAGE INTERRUPTIBLE
	PUSHJ P,ADSMP1
ADSMT3:
	CAIN TAC1,3
	JRST ADSMT4		;DELAY BEEP
	CAIE TAC1,1		;SKIP IF BEEP UNINTERRUPTIBLE
	JRST [	PUSHJ P,ADSMP2
		JRST ADSMT6]
	TLZ AC2,ASDBEP
	SETZM ASBTAB(AC1)
ADSMT6:
	HLR AC2,TAC		;DURATION
	TLO AC2,ASTEMP		;SET TEMP SEL BIT
	JRST ADSMP4

;DELAY BEEP MODE
ADSMT4:
	HRRZ DSER,ASBTAB(AC1)
	JUMPE DSER,ADSMT6
	TLO AC2,ASDBEP		;SET DELAYED BEEP BIT
	SETZM ASBTAB(AC1)	;FLUSH BEEP NOW
	JRST ADSMT6

;WAIT UNTIL TEMP SELECTION IS DONE (RETURNS WITH SCNOFF)
ADSMWT:
	CONO PI,SCNOFF
	MOVE AC2,ASTAB(AC1)
	TLNE AC2,ASHANG
	JRST ADSMW1
	MOVEI AC3,-1
	TDNN AC3,ASBTAB(AC1)	;SKIP IF BEEPING NOW
	TLNE AC2,ASPAGN		;SKIP IF NOT PAGING NOW
	JRST ADSMW1		;BEEP OR TEMP SEL - WAIT
	TRNN AC2,-1		;NOT BEEPING OR PAGING,TEST FOR TEMP SEL TO WAIT FOR
	POPJ P,			;NOTHING TO WAIT FOR
ADSMW1:
	TLO AC2,ASHANG
	MOVEM AC2,ASTAB(AC1)
	MOVEI AC2,IOWQ
	MOVNM AC2,JOBQUE(J)
	CONO PI,SCNON
	PUSHJ P,WSCHED		;GO INTO IOWQ
	JRST ADSMWT

;READ AS STATUS INTO AC
ADSMRD:
	CONO PI,SCNOFF		;PREVENT CHANGING OUT FROM UNDER US
	MOVE AC2,PAGNOW
	HRRZ AC3,ASBTAB(AC1)
	MOVE TAC1,ASTAB(AC1)
	CONO PI,SCNON
	HRR TAC,TAC1		;READ BACK DURATION
	TLZ TAC,177777
	TLNE TAC1,ASTEMP
	TLO TAC,400		;TEMP MAP IN EFFECT NOW
	JUMPE AC2,.+2
	TLO TAC,200		;THERE'S A PAGE GOING ON
	TLNE TAC1,ASPAGN
	TLO TAC,100		;WE'RE PAGING ON THIS LINE
	JUMPE AC3,.+2
	TLO TAC,40		;WE'RE BEEPING THIS LINE NOW
	TLNE TAC1,ASDBEP
	TLO TAC,20		;WE'RE GOING TO BEEP IT LATER
	JUMPGE TAC,ADSMR1	;JUMP IF READING PERM
	LDB AC2,[ASTMPP,,TAC1]	;TEMP CHAN SEL
	LDB AC3,[ASBPDP,,TAC1]	;TEMP BEEP DISP
	LDB TAC1,[ASPGDP,,TAC1]	;TEMP PAGE DISP
ADSMR2:
	LSH TAC1,2
	IOR TAC1,AC3
	LSH TAC1,9
	IORI TAC1,200000(AC2)
	TSO TAC,TAC1
	JRST STOTAC

ADSMR1:
	LDB AC2,[ASPRMP,,TAC1]	;PERM CHAN SEL
	LDB AC3,[ASPBUP,,TAC1]	;PERM BEEP UNINTERRUPTIBLE BIT
	LDB TAC1,[ASPPUP,,TAC1]	;PERM PAGE UNINTERRUPTIBLE BIT
	JRST ADSMR2

;BEEP AC,
;AC HAS TTY NUMBER TO BEEP OR -1 FOR YOURSELF
↑BEEP:	JUMPGE TAC,BEEP1
	HRRE TAC,JBTLIN(J)
	JUMPL TAC,CPOPJ		;DETACHED
BEEP1:
	ANDI TAC,177
	SUBI TAC,DPYL0
	JUMPL TAC,BEEPND	;NOT A DPY, TRY ↑G
	CAIL TAC,DPYNUM+DDNUM
	JRST BEEPND
	CONO PI,SCNOFF
	MOVE AC1,ASTAB(TAC)
	LDB AC2,[ASBPDP,,AC1]	;GET TEMP BEEP DISP
	TLNN AC1,ASTEMP		;SKIP IF TEMP
	LDB AC2,[ASPBUP,,AC1]	;PERM BEEP DISP
	TRNE AC2,1		;SKIP IF INTERRUPTIBLE
	JRST BEEPU
	TLNN AC1,ASPAGN		;SKIP IF PAGING NOW
	JRST BEEPNP
BEEPDX:
	TLO AC1,ASDBEP		;SET DELAYED BEEP
	MOVEM AC1,ASTAB(TAC)
BEEPX:
	CONO PI,SCNON
	POPJ P,

BEEPNP:
	MOVEI AC2,ASBPTM
	MOVEM AC2,ASBTAB(TAC)
	MOVEI AC3,ASBEPC
	HRLI AC3,(TAC)
	DATAO AS,AC3
	JRST BEEPX

BEEPU:
	TLNE AC1,ASTEMP		;SKIP IF PERM
	CAIN AC2,1
	JRST BEEPX		;NOT INTERRUPTIBLE, SORRY
	JRST BEEPDX		;TEMP SEL (INF OR OTHERWISE), SET DELAYED BEEP

BEEPND:
	MOVEI LINE,DPYL0(TAC)	;BEEP ADDRESSED TO NON-DPY:
	PUSHJ P,GETDBA		;FIND OR CREATE DDB
	POPJ P,			;NO SUCH TTY OR NO DDBS AVAILABLE
	MOVEI CHR,7		;GOBBLE A BELL
	PUSHJ P,OUTCHR		;SOCK IT TO HIM!
	JRST TYPTST

;RESET AUDIO SWITCH MAP TO PERMANENT SETTING
;CALLED BY ADSMAP WITH AC=-1 AND BY RESET
↑ADSRES:	HRRE AC1,JBTLIN(J)	;RESET JOB TO PERMANENT ADS MAP
	JUMPL AC1,CPOPJ		;DETACHED
	SUBI AC1,DPYL0
	JUMPL AC1,CPOPJ		;NOT DD OR DPY
	CAIL AC1,DPYNUM+DDNUM
	POPJ P,			;NOT DD OR DPY
ADSRE2:
	MOVEI TAC,0
	CONO PI,SCNOFF
	LDB AC2,[ASPPUP,,ASTAB(AC1)]
	DPB AC2,[POINT 1,TAC,6]
	LDB AC2,[ASPBUP,,ASTAB(AC1)]
	DPB AC2,[POINT 1,TAC,8]
	LDB AC2,[ASPRMP,,ASTAB(AC1)]
	DPB AC2,[POINT 4,TAC,17]
	TLO TAC,360000
	JRST ADSRE1

;RECIML
;SPECIAL CODE FOR IMLACS (JHS CODE REPLACED BY BO)

RECIML:
	TLZE IOS,IMLTTY		;Flag left from preceding char?
	JRST RECIM1		;Yes.  Add the bucky bits.

	TRNN CHR,200		;No.  Test the 8th bit.
	JRST RECIM2		;Off.  Just plain data.

	TLO IOS,IMLTTY		;On.  Flag it as extra special.
	CAIL CHR,241		;Is it a prefix meaning bucky bits?
	CAILE CHR,243
	JRST RECIM2		;No.

	DPB CHR,[POINT 2,IMLHAC(DDB),34];Save the bucky bits and
	MOVEM IOS,DEVIOS(DDB)	;set the IMLTTY flag for the next char
	POPJ P,			;and get out fast.

RECIM1:
	LDB UCHN,[POINT 2,IMLHAC(DDB),34]
	JRST RECIM2

;TYPX, COMSET
;ROUTINE TO TYPE X IF LINE CANNOT GET INTO SYSTEM

TYPX:
	SUB	P,[1,,1]
	ANDI	CHR,177
	CAIN	CHR,"X"		;CHAR. RECEIVED AN "X"
	POPJ	P,			;YES, MAY BE ECHO, DISMISS INT.
	MOVEI	CHR,"X"
	JRST	TYPL			;TYPE OUT "X"

;ROUTINE TO WAKE UP COMMAND DECODER IF TPMON IS SET

↑COMSET:TLNN	IOS,TTYDTC		;DTACHED GUYS CAN'T SAY ANYTHING!
	TLNN	IOS,TPMON		;MONITOR MODE?
	POPJ	P,			;NO, NOT MONITOR COMMAND
	MOVE	TAC,DEVMOD(DDB)		;GET SOME GOOD BITS
	TLNN	TAC,TTYATC		;IF NOT A CONSOLE
	TRNN	TAC,ASSCON!ASSPRG	;AND ASSIGNED BY PROGRAM OR CONSOLE
	JRST	.+2
	POPJ	P,			;THEN HE CAN'T TYPE COMMANDS
	MOVSI	IOS,IOFST
	IORB	IOS,DEVIOS(DDB)
	MOVSI	TAC,COMBIT		;SET SIGN BIT
	TDNN	TAC,TTYTAB(LINE)	;SKIP IF COMMAND BIT IS ON
	AOS	COMCNT			;COUNT ANOTHER COMMAND WE HAVE
	IORM	TAC,TTYTAB(LINE)	;IN TTY TRANSLATOR TABLE
IFN FTTTYBUG,<
	PUSHJ	P,COMBCK
	PUSHJ	P,CNTCOM		;CALL THE DRD
>
	POPJ	P,

;TTEDIT
;TTY KEYBOARD EDITOR ROUTINE
;UPON RECEIPT OF A CHARACTER, THIS ROUTINE DETERMINES WHAT TO DO
;WITH IT: WHETHER IT'S A SPECIAL CHARACTER NEEDING SPECIAL ECHOING,
;WHETHER SOME OTHER CHARACTER IS TO BE STORED IN ITS PLACE, WHETHER
;IT IS A BREAK CHARACTER (LINE TERMINATOR), OR WHETHER THE CHARACTER
;TYPED IS A SIGNAL TO UNDERTAKE SOME SPECIAL ACTION.
;IN ANY CASE, ALL SPECIAL ACTION, INCLUDING DUPLEXING TAKES PLACE ON
;THE LEVEL OF THIS ROUTINE.
;	THIS ROUTINE CALLS SPCHEK, WHICH MAKES USE OF THE  SPECIAL
;CHARACTER TABLE, SPCTAB. TO MAKE ANY CHANGES IN THE ACTION GENERATED
;BY SPECIFIC CHARACTERS MAKE THE ALTERATIONS REQUIRED BY THE
;COMMENTS DESCRIBING SPCTAB.  NOTE THAT IF A CHARACTER IS TO DISPATCH
;TO A "SPECIAL ACTION ROUTINE" OR A SPECIAL ECHO ROUTINE, THE LEFT
;HALF OF THE CORRESPONDING CHARACTER-WORD MUST HAVE SPACTN
;SET  AND THE ADDRESS OF THE SPECIAL ROUTINE MUST BE
;ASSEMBLED INTO THE RIGHT HALF OF THE WORD.
;CALL	HAVE 7-BIT ASCII CHARACTER IN CHR
;	LDB	HPOS,PHPOS
;	MOVEI	DAT,TTIBUF(DDB)
;	PUSHJ	P,TTEDIT
;	RETURN WITH ACTION DONE, SYNC (LH IOS) SET IF BREAK CHAR. STORED

TTEDIT:
	PUSHJ	P,ADJHP		;ADJUST HP AND CHECK SPECIAL
	JFCL
	TLNE LINE,IMLIN			;IF AN IMLAC,
	JRST [	TLZE IOS,IMLTTY		;TEST CONTROL FLAG.
		JRST TTEDT0		;NO SPECIAL ACTIVATION IF ON.
		CAIN CHR,177		;LEAVE SPACTN FOR RUBOUT.
		JUMPE UCHN,TTEDT2	;EXCEPT WITH BUCKY BITS
		TLNN TAC,IMLCHR		;PREVENT SPACTN ON ~ AND α
		TLNN TAC,ALLSPA		;AND ANYTHING ELSE THAT'S NOT
		TLZ TAC,ALLSPA!SPACTN!ECHSUP!SPHPOS	;ALWAYS SPECIAL.
		JRST TTEDT2]
TTEDT2:
	TLNE	LINE,SPCBRK		;SPECIAL ACTIVATION MODE?
	TLNE IOS,TPMON
	JRST TTEDT0
	PUSH	P,TAC
	PUSHJ	P,SPCACT
	TLO	IOS,SYNC
	POP	P,TAC
	TLNN	TAC,ALLSPA
	TLNN	IOS,SYNC
	CAIA
	TLZ	TAC,SPACTN		;INHIBIT ANY SPECIAL ACTION IF A BREAK
	JRST	TTEDT1
TTEDT0:
	TLNE	TAC,BREAKB!FCSBRK
	TLO	IOS,SYNC	;IT'S A BREAK CHAR.
TTEDT1:
	MOVEM	IOS,DEVIOS(DDB)		;SET SYNC
	JUMPL	TAC,(TAC)		;JUMP IF CHARACTER HAS SPECIAL DISPATCH
TIPACK:
	CAIG	CHR,"z"
	CAIGE	CHR,"a"		;LOWER CASE LETTER?
	JRST	TTIPUT			;NO

;TTIPUT, DUPLEX, DUPLX1, INBFUL
;	TLNN IOS,TPMON			;ALWAYS GIVE MONITOR UPPER CASE.
	TLNN	LINE,FCS		;YES. IS THIS TTY IN 37 MODE?
	TRZ	CHR,40			;NO. MAKE CHAR UPPER CASE
TTIPUT:
	TLZE	LINE,ROBTPD		;HAVE WE BEEN DELETING?
	PUSHJ	P,BSECHO		;YES. OUTPUT A BACKSLASH
TTIPT1:
	DPB UCHN,[POINT 2,CHR,28]	;PUT IN CTRL. BITS.
TTPT2:
	PUSHJ	P,PUTCHI		;PUT CHAR IN INPUT BUFFER
	JRST	INBFUL			;IT DIDNT FIT
	TLNN	TAC,ECHSUP		;SHOULD THIS CHAR BE ECHOED?
DUPLEX:
	TLNE	LINE,FULTWX		;IS THIS LINE ECHOING ITSELF?
	JUMPE	UCHN,CPOPJ		;DON'T ECHO UNLESS CTRL BITS ON.
DUPLX1:
	TLNN	IOS,TPMON		;SHOULD ECHO IF IN MONITOR MODE
	TRNN	IOS,NOECHO		;AND UNLESS USER SAYS NO, IN USER MODE
	JRST	DUPIML			;SO ECHO IT.
	POPJ	P,0			;DONT ECHO IF REQUESTED NOT TO BY USER

INBFUL:
	CAIN	CHR,600			;CHAR WONT FIT. WAS IT ↑C?
	JRST	CNCTS1			;YES. PANIC OUT OF THIS BIND
	MOVEI	CHR,7			;NO. JUST ECHO BELL TO SHOW LOSS
	JRST PUTCHO			;OUTPUT BELL, IF NOT  DPY.

DUPIML:
	JUMPE UCHN,PUTCHO		;IF BUCKY BITS OFF
	TRNN IOS,NOECHB			;OR NOT TO BE ECHOED
	TLNN LINE,IMLIN			;OR NOT AN IMLAC,
	JRST PUTCHO			;JUST ECHO THE CHAR.
	PUSH P,CHR
	TRNN UCHN,1			;<CTL> BIT...
	JRST DUPIM2
	MOVEI CHR,177			;ECHO [BS] [VT].
	PUSHJ P,PUTCHO
	MOVEI CHR,13
	PUSHJ P,PUTCHO
	TRNN UCHN,2			;<META>...
	JRST DUPIM3
DUPIM2:
	MOVEI CHR,177			;ECHO [BS] [FF].
	PUSHJ P,PUTCHO
	MOVEI CHR,14
	PUSHJ P,PUTCHO
DUPIM3:
	POP P,CHR			;NOW ECHO THE CHAR.
	JRST PUTCHO

;CONTC, CONTOB, CONTO, CONTB, ALTMOD, TTYUNH
;CALLED WITH A JUMPL TAC,(TAC), WHERE TAC IS LOADED FROM SPCTAB
;SPECIAL CHARACTER HANDLING ROUTINES


CONTC:
	PUSHJ	P,DELETL		;SINCE PEOPLE WANT FREE ↑U
	TLNN	LINE,DDDLIN!DISLIN	; IF THIS IS A DPY
	JRST	.+3
	JUMPG	UCHN,.+2		;AND IF NO CTRL BITS ARE ON,
	PUSHJ	P,CNCTS1		;PROCESS CONTROL C IMMEDIATELY.
	MOVE	TAC,SPCTAB		;SINCE DELETL CLOBBERS TAC
	PUSHJ	P,TTPT2			;PLACE IN BUFFER.
	MOVEI	CHR,3
	PUSHJ	P,CNTLEC
	JRST	CRLFEC

CONTZ:
	PUSHJ	P,CNTLEC		;OUTPUT ↑C OR ↑Z
	PUSHJ	P,CRLFEC		;OUTPUT A CRLF
	MOVEI	CHR,3B28!12		;CHANGE TO INTERNAL CODE.
	TLO	IOS,SYNC
	JRST	TTPT2			;ACTIVATE BUT DON'T STORE

CONTOB:
	MOVEI CHR,"O"-100		;INVENT A ↑O.
CONTO:
	PUSHJ	P,SETBF2		;CLEAR THE OUTPUT BUFFER
	MOVEI	IOS,IOSUPR		;SET TO JUNK FURTHER OUTPUT
	XORB	IOS,DEVIOS(DDB)
	JRST	CONTU1			;ECHO, ETC.

CONTU:
	TLNE	IOS,DDTM		;IN DDTMODE,
	JRST	TTIPUT			; PASS THIS CHARACTER
	TLZ	LINE,ROBTPD		;NO MORE BACKSLASH
	PUSHJ	P,DELETL		;↑U DELETES INPUT LINE
CONTU1:
	PUSHJ	P,CNTLEC		;ECHO ↑O OR ↑U
	JRST	CRLFEC			;OUTPUT A CRLF AND RETURN WITHOUT
					; STORING THE ↑O OR ↑U

ALTMOD:
	
	HRRI	TAC,(CHR)		;SAVE WHICH KIND OF ALTMOD
	TLNN	LINE,IMLIN
	MOVEI	CHR,44			;ECHO A $ EXCEPT ON IMLACS.
	PUSHJ	P,AOJDPX
	MOVEI	CHR,(TAC)		;RESTORE THE CHARACTER
	JRST	TTIPUT			;STORE THE CHARACTER

;FOLLOWING CHANGE BY BO ON RPH'S ADVICE
;CONTF:	TLCA	LINE,FCS		;COMPLEMENT FCS ON ↑F
;CONTB:	TLC	LINE,FULTWX		;COMPLEMENT FULTWX ON ↑B
;	POPJ	P,0			;AND RETURN WITHOUT STORING THESE

CONTB1:
	TLCA	LINE,FULTWX
CONTF:
	TLC 	LINE,FCS
	POPJ	P,

CONTB:
	TLNE	LINE,DISLIN!DDDLIN!PTYLIN
	JRST	CONTB1
	TLNE	LINE,TLKRNG		;DON'T ALLOW HOLDING IF TALKING.
	POPJ	P,			;TALKING
TTYUNH:
	TLCE	IOS,TTYHLD		;Toggle the hold flag.
	TLZ	IOS,TOIP		;If it was on, turn off TOIP.  The
	MOVEM	IOS,DEVIOS(DDB)		;STO IOS BACK
	POPJ	P,			;next call to TYPTST will restart
					;the output.
;END BO

;RUBOUT, AOJDPX, CONTK, CONTL
RUBOU4:
	MOVSI	IOS,SYNC		;IF PAPER TAPE, NO BREAK
	JRST	T0POPJ			;OR STORE. RETURN.
RUBOUT:


RUBOU3:
	TLNE	IOS,TPMON		;IN MONITOR MODE, NOT A BREAK CHAR
	JRST	RUBOU2
	TDNE	IOS,[XWD DDTM,BKSP]
	JRST	TTIPT1			;STORE RUBOUT IF DDT OR FCS
RUBOU2:
	PUSHJ	P,RUBOU4		;NOT A BREAK AFTER ALL
	LDB	CHR,PUTR(DAT)		;GET LAST CHAR IN
	PUSHJ	P,DCPUTR		;BACK UP TIPUTR
	JRST	RUBOU1			;IT'S EMPTY ALREADY
	TLON	LINE,ROBTPD		;MARK IN RUBOUT SEQUENCE
	PUSHJ	P,BSECHO		;AND OUTPUT BACKSLASH IF FIRST
AOJDPX:
	AOJA	HPOS,DUPLX1		;OUTPUT AND COUNT HPOS

RUBOU1:
	TLZE	LINE,ROBTPD		;END OF INPUT STREAM REACHED
	PUSHJ	P,BSECHO		;OUTPUT A BACKSLASH
	JRST	CRLFEC			;AND A CR LF

CONTK:
	HRRI	TAC,4			;HERE ON V TAB
	SKIPA
CONTL:
	HRRI	TAC,10			;HERE ON FORMFEED
	TLNN	LINE,PTYLIN		;THIS TTY HAVE VERT MECHANICS?
	JRST	SIMFF			;NO. SIMULATE IT
; FOR SOME REASON THE FOLLOWING INSTRUCTION WAS A PUSHJ P,TTIPUT, WHICH
; CAUSED PTYS TO GET  10 26'S (⊗) UPON TYPING ↑L. - JAM (5-21-72)
	JRST	TTIPUT			;PUT CHAR IN BUFFER AND ECHO IT
CONTI1:
	MOVEI	CHR,1			;SYNCHRONOUS IDLE CHARACTERS
SIMFF1:
	PUSHJ	P,DUPLX1		;OUTPUT ECHO OF LF OR IDL
	TRNE	TAC,17			;DONE YET?
	SOJA	TAC,.-2			;NO. OUTPUT MORE
	POPJ	P,0			;DONE


;CONTI, CONTP
SIMFF:
	TLO	TAC,ECHSUP		;DON'T OUTPUT FF OR VT TO A 33
	PUSHJ	P,TTIPUT		;PUT IT IN BUFFER
	MOVEI	CHR,12		;SIMULATE WITH LF'S
	JRST	SIMFF1

CONTI:
	TLNE	LINE,DISLIN!PTYLIN!DDDLIN!IMLIN
	JRST	TTIPUT			;ECHO AND RETURN FOR DISPLAYS
	LDB	HPOS,PHPOS
	ANDI	HPOS,7
	CAIE	HPOS,7			;IF ONLY 1, WE WILL CONVERT TO SPACE
	TLNE	LINE,TBXPND		;FORCING TAB EXPANSION?
	TLO	TAC,ECHSUP		;YES. DON'T OUTPUT TAB TO 33
	PUSHJ	P,TTIPUT		;PUT IN BUFFER AND MAYBE ECHO
	TLNE	LINE,TBXPND		;EXPANDING TABS?
	JRST	CONTI2			;YES
	LDB	CHR,PHPOS		;WHERE WAS TTY BEFORE TAB
	ANDI	CHR,7		;JUST LOW PART FOR INDEX
	MOVEI	TAC,1		;ASSUME 1
	XCT	[	AOJA TAC,CONTI1	;8 SPACES-2 IDLES
			JRST CONTI1	;7 SPACES-1 IDLE
			JRST CONTI1	;6 SPACES-1 IDLE
			JRST CONTI1	;5 SPACES-1 IDLE
			JRST CONTI1	;4 SPACES-1 IDLE
			POPJ P,		;3 SPACES-0 IDLES
			POPJ P,		;2 SPACES-0 IDLES
			JFCL	](CHR)	;1 SPACE -CONVERT TO SPACE (OR CTY WILL MISS TAB STOP)
CONTI2:
	MOVEI	CHR,40		;SPACES FOR THE 33'S
	LDB	HPOS,PHPOS		;WHERE WAS I BEFORE TAB?
	PUSHJ	P,AOJDPX		;OUTPUT A SPACE
	TRNE	HPOS,7			;AT A TAB STOP?
	JRST	.-2			;NO. MORE SPACES.
	POPJ	P,0			;RETURN FROM TTEDIT

CONTP:
	MOVE	TAC,LINBIT(LINE)	;GET HIS INITIAL LINE BITS
	TLNE	TAC,TBXPND		;CAN ONLY TOGGLE IF HE HAS HARDWARE TABS!!!
	JRST	NCONTP			;NO CAN DO
	TLC	LINE,TBXPND		;INVERT STATE OF TABS!
	POPJ	P,

NCONTP:
	SETZ TAC,			;MAKE SURE IT ECHOS!
	JRST	TTIPUT			;AND BACK TO THE MAIN STREAM

;CRLFEC, CRLF
CRLFEC:
	MOVEI	HPOS,0			;ECHO A CR LF, SAVING CHR
	PUSH	P,CHR
	MOVEI	CHR,15			;CARRIAGE RETURN
	PUSHJ	P,DUPLX1		;OUTPUT IT
	MOVEI	CHR,12			;LINE FEED
	PUSHJ	P,DUPLX1		;OUTPUT THAT TOO
CHPOPJ:
	POP	P,CHR			;RESTORE CHR
	POPJ	P,0

CNTLEC:
	
	HRRI	TAC,100(CHR)		;SAVE UN-CNTL CHARACTER
	MOVEI	CHR,"↑"
	PUSHJ	P,AOJDPX
	MOVEI	CHR,(TAC)		;TYPE ↑ CHAR
	PUSHJ	P,AOJDPX
	TRZ	CHR,100			;RESTORE IT TO A CNTL CHAR
	POPJ	P,0

CRLF:
	MOVEI	HPOS,0			;HERE ON INPUT OF A CARRIAGE RETURN
	TLNE	LINE,PTYLIN		; IS THIS A PTY
	JRST	CRLFIP			; YES, TEST XON ALWAYS
	TLNE	IOS,TPMON		; ALWAYS GIVE LF AFTER CR IN MON. MODE
	JRST	CRLFMM
CRLFIP:
	TLNE	LINE,XON		;IF PAPER TAPE, NO FREE LF
	JRST	TTIPUT			;JUST STORE THE CR
CRLFMM:
	PUSHJ	P,TTIPUT		;ORDINARILY, STORE AND GO ON HERE
	MOVEI	CHR,12			;BY ADDING A LF
	MOVSI	IOS,SYNC		;WHICH IS AN ACTIVATOR
	IORB	IOS,DEVIOS(DDB)
	TLNN	LINE,FULTWX		;IF NOT SELF ECHOING,
	JRST	TTIPUT			;THIS WILL GIVE LF ECHO
	PUSHJ	P,TTIPUT		;OTHERWISE, THIS WONT
	JRST 	DUPLX1			;BUT THIS WILL

;CNCTST, CNCMOD
CNCTST:

	TLNE LINE,IMLIN
	TLZE IOS,IMLTTY		;Char code 3 from an IMLAC needs
	CAIA
	POPJ P,			;IMLTTY on to be a ↑C.
	MOVEI CHR,600	;INVENT INTERNAL CODE FOR ↑C.
IFN FTLOGIN,<

	LDB	TAC,PJOBN
	MOVE	TAC,JBTSTS(TAC)

	TLNE	TAC,JACCT		;REG 11/26/73 NO REASON TO LET PTYS THROUGH
	MOVEI	CHR,33			;SEND ALTMODE INSTEAD

;	TLNN	TAC,JACCT
;	JRST	CNCTSA
;	TLNE	LINE,PTYLIN		;DON'T HOLD UP PTY'S
;	CAIA
;	MOVEI	CHR,33
;CNCTSA:
>
	LDB	TAC,TIPUTR(DDB)
	CAIE	TAC,600
	POPJ	P,
CNCTS1:
	PUSHJ	P,SETBFI		;CLEAR INPUT BUFFER.

CNCMOD:
	MOVE	IOS,[XWD DDTM!IO!USRB,IOSUPR!MERTPO!MERTP1]
	ANDCAM	IOS,DEVIOS(DDB)
	MOVSI	IOS,TPMON+IOFST
	IORB	IOS,DEVIOS(DDB)
	POPJ	P,

;BSECHO, DCPUTR, DELETL
;ROUTINE TO ECHO BACK-SLASH

BSECHO:
	PUSH	P,CHR		;*
	MOVEI	CHR,"\"
	PUSHJ	P,AOJDPX
	JRST	CHPOPJ

;ROUTINE TO DECREMENT PUTR

↑DCPUTR:
	LDB	TAC,PLSTLC		; CHECK FOR NONE TO DELETE
	CAMN	TAC,PCTR(DAT)
	POPJ	P,

	MOVSI	TAC,110000
	ADD	TAC,PUTR(DAT)		;*
	TLNE	TAC,400000
	ADD	TAC,[XWD 337777,-1]
	MOVEM	TAC,PUTR(DAT)
	AOS	FCTR(DAT)
	AOS	TAC,PCTR(DAT)
	CAIG	TAC,TTICHR		;*
	JRST	CPOPJ1			;*
	SUBI	TAC,TTICHR		;*
	MOVEM	TAC,PCTR(DAT)
	MOVEI	TAC,STTIBF
	ADDM	TAC,PUTR(DAT)		;*
	JRST	CPOPJ1

;ROUTINE TO DELETE CURRENT LINE (↑U)

DELETL:
	LDB	TAC,PLSTLC		;WHERE WAS LAST BREAK?
	MOVEM	TAC,TIPCTR(DDB)		;STORE COUNT
	PUSHJ	P,TBYTEP		;CONVERT TO A BYTE POINTER
	MOVEM	TAC,TIPUTR(DDB)		;SAVE POINTER
	JRST	TRESC1			;GO COMPUTE TIFCTR

;DOTALK, NOTALK
IFN FTTALK,<
DOTALK:
	ANDI	CHR,177
	SKIPN	DDB,TTYTAB(LINE)
	POPJ	P,0
IFN FTTKBG,<
	HLRZ	TAC,DDB		;BH 3/15/74 BUG TRAP FOR INCOMPLETE LOOP
	ANDI	TAC,177		;BH JUST THE LINE NUMBER
	SKIPN	TTYTAB(TAC)	;BH TAC IS LINE # TALKER LINKED TO
	JRST	DOTALX		;BH HIS DDB GONE ALTOGETHER (CAN'T HAPPEN...)
	HLRZ	HPOS,TTYTAB(TAC);BH ELSE GET HIS LINK
	ANDI	HPOS,177	;BH JUST THE LINE NUMBER
	CAIN	HPOS,(LINE)	;BH OK IF WE'RE ALL THE SAME
	JRST	DOTALY		;BH
	CAIN	HPOS,(TAC)	;BH COMPARE TO HIMSELF
	JRST	DOTALX		;BH OOPS, THEY'RE THE SAME!
>;FTTKBG
DOTALY:
	CAIE	CHR,0
	CAIN	CHR,3
	JRST	NOTALK
	MOVE UUO,LINTAB(LINE)	;SAVE TALKER'S XON BIT
	TLZ	LINE,-1		;NO BITS PLEASE
	PUSH	P,LINE
DOTAL1:
	LDB	LINE,PTALK
	HRRZ	DDB,TTYTAB(LINE)
	CAMN LINE,(P)		;BACK TO OURSELVES YET?
	JRST DOTAL2		;YES, WE ARE SPECIAL
	JUMPE	DDB,DOTAL1	;SKIP GUYS WITHOUT DDBS
	PUSH	P,CHR
	PUSHJ	P,PUTCHO
	MOVE CHR,(P)		;GET CHAR
	TLNN UUO,XON		;IF TALKER HAS XON OR
	CAIE CHR,15		;IF NOT CR,
	JRST DOTAL3		;THEN NO LF
	MOVEI CHR,12
	PUSHJ	P,PUTCHO	;YES, SEND IT
DOTAL3:
	MOVE	IOS,DEVIOS(DDB)
	PUSHJ	P,TYPTST
	POP	P,CHR
	JRST DOTAL1

DOTAL2:
	HLL LINE,LINTAB(LINE)	;GET OUR CHARACTERISTICS
	MOVEM CHR,(P)		;REPLACE SAVED LINE WITH CHR
	TLNN LINE,FULTWX
	PUSHJ P,PUTCHO
	POP P,CHR
	CAIN CHR,15		;NEED LF?
	TLNE LINE,XON		;MAYBE
	JRST TYPTST		;NO
	MOVEI CHR,12
	PUSHJ P,PUTCHO
	JRST TYPTST

;IF I TYPE A ↑C IN TALK RING, THEN
;ASSUME NEXT←ME←PREV
;SET NEXT←PREV
;IF NEXT=PREV, CLEAR ITS TLKRNG BIT
;SET ME←ME
;CLEAR TLKRNG BIT IN LINTAB(ME)

NOTALK:
	MOVEI	HPOS,0(LINE)		;ME
	TLNE	LINE,CTYLIN		;CTY?
	JRST	NOTLKB			;YES, CLEAR EVERYONE IN THIS RING
	LDB	CHR,PTALK		;NEXT
NOTAL1:
	LDB	UUO,PTALK
	CAMN	UUO,HPOS		;ME←?
	JRST	NOTAL2			;YES. LINE=PREV
	MOVE	LINE,UUO		;NO. FIND PREV
	JRST	NOTAL1
NOTAL2:
	DPB	CHR,PTALK		;MAKE NEXT←PREV
	CAIE	CHR,(HPOS)		;NO ↑←N BREAKING SOLITAIRE TALK
	CAIE	CHR,(LINE)		;RING NOW EMPTY?
	JRST	NOTAL3			;NO
NOTLKA:
	MOVSI	CHR,TLKRNG		;YES. CLR HIS BIT
	ANDCAM	CHR,LINTAB(LINE)
	MOVE	DDB,TTYTAB(LINE)	;AND TELL HIM ABOUT IT BY GOLLY!!!
	PUSH	P,HPOS
;;FOR X ε {↑←N}	{
;;	MOVEI	CHR,"X"
;;	PUSHJ	P,PUTCHO
;;}					;USING ANSI STANDARD TEXT 87
MOVEI CHR,"↑" 
 PUSHJ P,PUTCHO
MOVEI CHR,"←" 
 PUSHJ P,PUTCHO
MOVEI CHR,"N" 
 PUSHJ P,PUTCHO
	MOVE	IOS,DEVIOS(DDB)
	PUSHJ	P,TYPTST
	POP	P,HPOS
	MOVE	DDB,TTYTAB(HPOS)	;RESTORE DDB
	MOVE	LINE,UUO
	CAIE	LINE,(HPOS)		;IN WHICH CASE IT HAS NEXT IN RING
	JRST	NOTLKC			;WHICH MAY BE ME ANYWAY
NOTAL3:
	MOVSI	CHR,TLKRNG
	MOVE	LINE,HPOS		;ME
	DPB	HPOS,PTALK		;ME←ME
	ANDCAM	CHR,LINTAB(LINE)	;CLR MY BIT
	MOVEI	CHR,600			;GET A ↑C AGAIN
	DPB	CHR,TIPUTR(DDB)		;LOOK LIKE 2 OF THEM
	HLL	LINE,LINTAB(LINE)	;GET GOOD BITS!
	TLNN	LINE,DDDLIN!DISLIN	;FOR THESE GUYS, LEAVE IT ⊗00
	MOVEI	CHR,3			;EVERYBODY ELSE GETS THIS
	JRST	RECINA			;AND PROCESS IT FROM THE TOP

NOTLKB:
	LDB	LINE,PTALK		;CTY: GET NEXT GUY
	CAIN	LINE,(HPOS)		;IF ONLY ME,
	JRST	NOTAL3			;  JUST CLEAR ME QUIETLY
NOTLKC:
	LDB	UUO,PTALK		;SAVE HIS NEXT
	DPB	LINE,PTALK		;CLEAR HIM OUT
	JRST	NOTLKA			;AND TELL HIM

IFN FTTKBG,<
DOTALX:
	PUSHACS				;BH 3/15/74 BUG TRAP TO END OF PAGE
	PUSH	P,TAC			;OFFENDING TALKEE
	PUSH	P,DDB			;TALKER'S TTYTAB
	ANDI	LINE,177		;TALKER'S NUMBER
	PUSH	P,LINE
	PUSHJ	P,DISMES
	ASCIZ /INCOMPLETE LOOP AT DOTALK!!
TALKER=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /  DDB=/
	POP	P,TAC
	PUSHJ	P,DISOCT
	PUSHJ	P,DISMES
	ASCIZ /
TALKING TO /
	MOVE	TAC,(P)
	PUSHJ	P,DISOCT
	POP	P,TAC
	SKIPE	TTYTAB(TAC)
	JRST	DOTLX1
	PUSHJ	P,DISMES
	ASCIZ /  WHO HAS NO DDB/
	JRST	DOTLX2
DOTLX1:
	PUSHJ	P,DISMES
	ASCIZ /  WHO IS LINKED TO HIMSELF/
DOTLX2:
	PUSHJ	P,DISMES
	ASCIZ /
FIND A WIZARD, OR TYPE POPJ 3,$X
/
	PUSHJ	P,DISFLU
	POPACS
	PUSHJ	P,DDTCAL
	DPB	LINE,PTALK		;NOW FIX IT UP
	JRST	NOTALK			;SMASH DOPEY RING!
>;FTTKBG
>

;XMTINT, XMTIN1, DPYSTR, DPYDON
;COMMON TRANSMITTER INTERRUPT FOR SCANNER AND CTY(TTY)

↑XMTINT:
	HLL	LINE,LINTAB(LINE)	; GET LINE CHAR.
	SKIPN	DDB,TTYTAB(LINE)	;GET DDB ADDRESS
	POPJ	P,			;IF NONE, X BEING TYPED
	MOVE	IOS,DEVIOS(DDB)		;GET IO STATUS

XMTIN1:

	LDB	DAT,PDVTIM		;RESET HUNG COUNT
	DPB	DAT,PDVCNT
	MOVEI	DAT,TTOBUF(DDB)		;GET PTR. FOR OUTPUT BUFFER.
	TLNE	LINE,DISLIN!DDDLIN
	JRST	DPYSTR			; IF A DISPLAY, GO TO OUR OWN STARTUP ROUTINE
XMTI1A:
	CONO	PI,SCNOFF		;KEEP TOIP AND PUTR/TAKR EQUAL
	MOVE	TAC,TAKR(DAT)		;IS OUTPUT BUFFER EMPTY?
	CAME	TAC,PUTR(DAT)		;(I.E.,HAS TAKR CAUGHT UP WITH PUTR?)
	JRST	XMTIN2			;NO, TYPING STILL IN PROGRESS

	TRNE	IOS,MERTP1		;MONITOR ERROR MESSAGE?
	CAIE	DAT,TTOBUF(DDB)		;OUTPUT BUFFER?
	JRST	XMTIN4			;NO, MUST REALLY BE DONE
	MOVEI	DAT,TTIBUF(DDB)		;YES, NOW EMPTY OUT TTI BUFFER
	JRST	XMTI1A

DPYSTR:
	  ;;INITIATE TYPEOUT ON A DISPLAY CONSOLE.
	HRLI	DAT,DPYTYP		;MAKE INTO CLOCK REQUEST ON DPYTYP(IN DPYSER),
	HRRI	DAT,(LINE)		;PASS HIM THE LINE NUMBER
	JRST	DPYTIM			;AND ENTER IN DPY CLOCK QUEUE.

↑DPYDON:MOVE	IOS,DEVIOS(DSER)	;HERE FROM DPYTYP (IN DPYSER) WHEN OUTPUT BUFFER EMPTY.
	HRRZ	DDB,DSER		; DPYSER SAVES DDB ADDRESS IN DSER
	PUSHJ	P,STLNAC		;SET UP AC LINE.
	TRNN	IOS,MERTP1		;ERROR MESSAGE TYPEOUT ?
	JRST	XMTIN4			; NO, GO FINISH UP
	CAIN	DSER,-TTOBUF(DAT)	;YES. MUST WE STILL TYPE OUT THE INPUT BUFFER ?
	JRST	DPYERT			;YES. GO TYPE REST OF ERROR MESSAGE FROM INPUT BUFFER.
		;; FALL INTO XMTIN4.

;XMTIN4, XMTIN2, LINDON, TTYPE
;HERE WHEN OUTPUT BUFFER(S) EMPTIED.

XMTIN4:
	MOVE	IOS,[XWD TOIP,MERTPO!MERTP1]
	ANDCAB	IOS,DEVIOS(DDB)
	CONO	PI,SCNON
	MOVEI	CHR,0
	LDB	HPOS,PJOBN		;JOB NUMBER DDB IS ATTACHED TO
	TLNN	IOS,IO
	JRST	LINDON
	MOVSI	IOS,IO
	ANDCAB	IOS,DEVIOS(DDB)
	TLNE	LINE,TLKRNG		;KEEP DDB IF TALKING .
	JRST	LINDON			;YES
	JUMPN	HPOS,LINDON		;LINE DONE IF DDB IS A JOB.
	JRST	TTYKIL			;KILL TTY DDB

XMTIN2:
	CONO	PI,SCNON
	TLNE	IOS,TTYHLD		;IF HOLDING OUTPUT, RETURN.
	POPJ	P,
	PUSHJ	P,GETCHO		;NO, GET NEXT CHAR. IN BUFFER
	JUMPE	CHR,XMTIN1		;IGNORE NULLS
	JUMPL	IOS,TTYPE		;KEEP TYPING IF INPUT I/O WAIT
	TRNN	IOS,IOACT		;ARE WE IN I/O WAIT?
	JRST	TTYPE			;NOT IN IO WAIT
	LDB	HPOS,PFITCH		;YES, CHECK TO FIT INTO TTO BUFFER 
	CAIL	HPOS,TTOCHR-50		;ENOUGH ROOM TO ADD 8?
	MOVEI	HPOS,TTOCHR-50		;MAKE LINE BE NEARLY OUT
	CAML	HPOS,FCTR(DAT)		;IS THERE ROOM ENOUGH NOW?
	JRST	TTYPE			;NO, KEEP TYPING

LINDON:
	TLNE	IOS,IOW			;IN IO WAIT?
	TLNE	IOS,TTYIOW		;YES, TTY INPUT WAIT?
	JRST	TTYPE			;NO, GO TTYPE CHAR.
	PUSH	P,LINE			;SAVE LINE
	PUSHJ	P,SETIOD		;YES, SET IO DONE (OUT OF WSYNC)
	POP	P,LINE			;RESTORE LINE
	MOVE	IOS,[XWD IOW,IOACT]	;INDICATE NO IO ACTIVE OR WAIT
	ANDCAB	IOS,DEVIOS(DDB)

TTYPE:
	TLNN LINE,PTYLIN	;DON'T TYPE IF THIS IS A PSEUDO-TTY.
	JUMPN	CHR,TYPL		;IS TYPING STILL TO BE IN PROGRESS?
	POPJ P,			;NO.

;TYP, TYPL, CTYP
;ROUTINE TO TYPE CHAR
;CALL	MOVE LINE,LINE NO.
;	MOVE CHR,CHARACTER
;	PUSHJ P,TYP

TYP:

↑TYPL:	TLNE LINE,DISLIN!DDDLIN
	POPJ P,				;DON'T DO THIS ON DPYS (MAINLY TYPX)
	MOVE TAC,CHR			;GENERATE PARITY BIT IN CASE THIS IS A
					;MODEL 37
	IMULI TAC,200401		;FORM 3 COPIES OF 8 BIT CHAS.
					;ASSUME PARITY BIT IS 0
	AND TAC,[ 11111111]		;FORM 8 COPIES OF ORIGINAL BITS
	IMUL TAC,[ 11111111]		;ADD 8 BITS TOGETHER
	TLNE TAC,10			;TEST PARITY OF SUM
	TRO CHR,200			;PARITY IS ODD, MAKE IT EVEN
	TLNN LINE,CTYLIN		;NO,CONSOLE TTY?
	JRST	SCNTYP			;TYPE CHAR.
CTYP:
	DATAO TTY,CHR
	DPB	CHR,PLASTC
	POPJ P,

;PTYGET, PTOCK, PTICHK, PTYCLR
PTYGET:
	;CREATE A PTY LINE NO.
	SKIPE TTYLOK		;NO PTY'S UNDER TTYLOK
	POPJ P,
	MOVSI LINE,-PTYNUM	;HOW MANY ARE AVAIABLE ?
	MOVSI TAC,PTYLIN
	TDNE TAC,LINTAB+PTYL0(LINE)
	AOBJN LINE,.-1
	JUMPG LINE,CPOPJ
	ADDI LINE,PTYL0
	PUSHJ P,DDBSRC		;GET A DDB
	POPJ P,			;NONE AVAILABLE
	HRLI LINE,PTYLIN!PTYUSE!XON!FCS	;DON'T EXPAND TABS OR INVENT LF'S (XON).
					;ALSO FULL CHARACTER SET MODE
	MOVEM LINE,LINTAB(LINE)
	MOVEM ITEM,PTYJOB-PTYL0(LINE)	;RECORD WHICH JOB OWNS THIS PTY.
	XCTR	XW,[MOVEM LINE,(UUO)]	;RETURN PTY LINE NO. TO LOSER.
	JRST CPOPJ1		;GIVE SKIP RETURN

PTOCK:
    ;COME HERE WHEN A PTY OUTPUTS ANYTHING, TO WAKE UP JOBS WAITING FOR IT.
	MOVE AC1,TOTAKR(DDB)
	CAME AC1,TOPUTR(DDB)	;IS THERE REALLY ANYTHING IN PTY'S OUTPUT BUF ?
	TLNN LINE,PTYUSE	;IS PTY STILL IN USE ?
	JRST SETBF3	;NO. FLUSH THE OUTPUT BUFFER.
	SKIPLE TAC,PTYPTR(DDB)	;IS SOMEONE WAITING FOR OUR OUTPUT ?
	JRST PTCHK2
	PUSH P,J
	MOVE J,PTYJOB-PTYL0(LINE)
	MOVSI AC1,INTPTO	; GIVE PTY OUTPUT INTERRUPT
	TDNE AC1,JBTIEN(J)
	PUSHJ P,TTINT
	POP P,J
	POPJ P,

PTICHK:
	SKIPL TAC,PTYPTR(DDB)
	POPJ P,
PTCHK2:
	SETZM PTYPTR(DDB)
	EXCH TAC,DDB
	PUSHJ P,SETIOD
	MOVSI AC1,IOW+TTYIOW
	ANDCAM AC1,DEVIOS(DDB)
	EXCH TAC,DDB
	PUSHJ P,STLNAC
	LDB J,PJOBN		;SETIOD HAS CLOBBERED THIS, AND APRSER MAY CARE
	POPJ P,

↑PTYCLR:HRRE LINE,JBTLIN(ITEM)
	JUMPL LINE,PTYCL2
	MOVSI TAC,SPCBRK!XON!LERSEE
	HLL LINE,LINTAB(LINE)		; GET LINE BITS BACK
	TLNE LINE,PTYLIN		; IST DAS EINE PTY?
	TLZ TAC,XON			; YES, GIVE HIM BACK HIS LFS
	ANDCAM TAC,LINTAB(LINE)
	ANDCAM TAC,JBTLIN(ITEM)
	PUSHJ P,TTYSRC			;FIND HIS TTY DDB
	MOVSI TAC,STDTBL		;AND SET HIS BREAK TABLE TO STANDARD.
	HRRI TAC,ACTBTS(DDB)
	BLT TAC,ACTMOD(DDB)
	MOVEI TAC,NOECHO!NOECHB
	ANDCAM TAC,DEVIOS(DDB)		;TURN ECHOING BACK ON!
PTYCL2:
	MOVEI LINE,PTYL0	;PREPARE TO SEARCH ALL PTY'S.
PTYCL1:
	CAIL LINE,PTYL0+PTYNUM	;DONE ?
	POPJ P,
	PUSH P,LINE		;GOD ONLY KNOWS.......
	PUSH P,ITEM
	PUSHJ P,PTYRL2			;YES. RELEASE IT FOR HIM.
	POP P,ITEM
	POP P,LINE
	AOJA LINE,PTYCL1

;PTYUUO, LINMAP, PTOCNT, PTIFRE
↑PTYUUO:
	JUMPE UCHN,PTYGET
	XCTR XR,[HRRZ TAC,(UUO)]
	TRZE TAC,400000		;USE THIS TO MAP REAL LINES
	JRST LINMAP
	CAIG TAC,TTPLEN
	CAILE UCHN,PTYXNO
	JRST UUOERR
	JUMPN TAC,PTYUU3
	HRRE TAC,JBTLIN(ITEM)	;IF HE ASKS FOR LINE 0,
	JUMPL TAC,CPOPJ	;NOT IF DETACHED.
	JRST PTYUU2		; GIVE HIM HIS OWN TTY.
PTYUU3:
	CAIL TAC,PTYL0	;IS IT A PTY ?
	CAME ITEM,PTYJOB-PTYL0(TAC)	;YES. DOES HE OWN IT ?
	CAIN UCHN,PTRLCD	;NO. AN ERROR UNLESS HE IS MERELY RELEASING IT.
PTYUU2:
	SKIPA LINE,LINTAB(TAC)
	JRST UUOERR		;SORRY, THE LINE YOU HAVE REQUESTED IS NOT YOURS AT THIS TIME.
	HRRI LINE,(TAC)
	ADDI UUO,1
	HRLI UUO,(<POINT 36,0,35>)	;MAKE FULL-WORD BYTE PTR. IN UUO.
	SKIPE DDB,TTYTAB(LINE)	;GET LOC. OF HIS DDB.
	JRST PTYUU4
	PUSHJ P,DDBSRC		;NO DDB, SO GET HIM ONE.
	JRST UUOERR		;NONE AVAILABLE.
PTYUU4:
	SKIPG PTYDIS(UCHN)	;LEGAL FOR TTY'S?
	TLNE LINE,PTYLIN	;OR PTY?
	JRST @PTYDIS(UCHN)
	JRST UUOERR		;SOMETIMES YOU HAVE TO BE A PTY TO DO A PTY-UUO!

LINMAP:
	CAILE TAC,TTPLEN
	JRST UUOERR
	MOVE AC1,JBTPRV(J)
	TLNE AC1,MESPRV
	JRST PTYUU2		;ALL OK NOW
	SKIPN DDB,TTYTAB(TAC)
	JRST UUOERR
	LDB AC1,PJOBN
	CAMN AC1,J
	JRST PTYUU2
	JRST UUOERR

DEFINE UUOS{FOR X IN(PTYGET,<PTYREL,PTRLCD←←.-PTYDIS>,PTIFRE,<PTOCNT>
,<PTRD1S,400000>,<PTRD1W,400000>,PTWR1S,<PTWR1W>
,<PTRDS,400000>,PTWRS7,PTWRS9,<PTGETL,,GETLN1>
,<PTSETL,,SETLIN>,<PTLOAD,,PTLLED>,PTJOBX)}

; UUOMAC PTYDIS,PTYUUO
PTYDIS:
0+PTYGET
PTRLCD←←.-PTYDIS
0+PTYREL
0+PTIFRE
0+PTOCNT
400000,,0+PTRD1S
400000,,0+PTRD1W
0+PTWR1S
0+PTWR1W
400000,,0+PTRDS
0+PTWRS7
0+PTWRS9
0+GETLN1
0+SETLIN
0+PTLLED
0+PTJOBX
UUOCNT←←.-PTYDIS
PTYUUO UUOCNT-1,UUOLNK
↑↑UUOLNK←←.
SIXBIT/PTYGET/
SIXBIT/PTYREL/
SIXBIT/PTIFRE/
SIXBIT/PTOCNT/
SIXBIT/PTRD1S/
SIXBIT/PTRD1W/
SIXBIT/PTWR1S/
SIXBIT/PTWR1W/
SIXBIT/PTRDS/
SIXBIT/PTWRS7/
SIXBIT/PTWRS9/
SIXBIT/PTGETL/
SIXBIT/PTSETL/
SIXBIT/PTLOAD/
SIXBIT/PTJOBX/
PTYXNO←←UUOCNT-1
ORG PTOCNT
PTOCNT:
	SKIPA CHR,TOFCTR(DDB)
PTIFRE:
	SKIPA CHR,TIFCTR(DDB)
	SUBI CHR,TTOCHR-1	;GET -(NO. OF CHRS. IN BUFFER).
	SUBI CHR,1		;COUNT CAN ONLY GO TO 1 NOT 0.
PTSTOR:
	XCTR XW,[MOVMM CHR,(UUO)]
	POPJ P,

;PTYREL, PTRD1S, PTRD1W, PTWAIT
PTYREL:
	TLNE LINE,PTYLIN	;RELEASE THE PTY, IF IT REALLY IS ONE.
PTYRL2:
	CAME ITEM,PTYJOB-PTYL0(LINE)	;DOES THIS JOB OWN THIS PTY ?
	POPJ P,
	SKIPN DDB,TTYTAB(LINE)	;THIS IS NEEDED IF WE CAME FROM PTYCLR.
	JRST LINCLR		;CLEAR LINE BITS AND RETURN.
	PUSHJ P,XMTIN4		;FINISH OUTPUT.
	PUSHJ P,TSETBF		;CLEAR BOTH ITS BUFFERS.
	SETZM PTYJOB-PTYL0(LINE)	;CLEAR OWNERSHIP FLAG.
	MOVSI TAC,PTYUSE	;MARK PTY AS NO LONGER USED, SO DDB WILL BE
	ANDCAM TAC,LINTAB(LINE)	;KILLED BY TTYKIL.
	LDB J,PJOBN		;GET JOB ON THIS PTY
	JUMPE J,.+2		;IF ANY
	PUSHJ P,INTKILL		;NOW KEEP HIM FROM FUTZING AROUND
	MOVE UUO,[BYTE(7)3,3,"K",12,0]
	XCTR	XW,[MOVEM UUO,JOBTM1]	;PUT IT IN USER CORE.
	MOVE UUO,[POINT 7,JOBTM1]	;THIS WILL BE RELOCATED.
	PUSHJ P,PTWR2			;SEND JOB ↑C ↑C K<LF>.
	POPJ P,

PTRD1S:
	MOVE IOS,DEVIOS(DDB)	;GET STATUS WORD.
	PUSHJ P,XMTIN1
	XCTR	XDB,[DPB CHR,UUO]		;GIVE CHAR. TO LOSER.
	JUMPE CHR,CPOPJ
	JRST CPOPJ1

PTRD1W:
	PUSHJ P,PTRD1S
	SKIPA UCHN,DDB
	POPJ P,
	PUSHJ P,TTYGET
	HRRZM DDB,PTYPTR(UCHN)
	MOVSI IOS,IOW!TTYIOW!DDTM
	TLNE LINE,PTYWAK	;DO WE WANT TO HEAR TTY INPUT ?
	IORM IOS,DEVIOS(DDB)
	PUSHJ P,PTWAIT
	SETZM PTYPTR(DDB)
	PUSHJ P,PTRD1S
	POPJ P,
	POPJ P,

PTWAIT:
	MOVEI TAC,IOWQ
	MOVNM TAC,JOBQUE(J)
	MOVE DDB,UCHN	;RECOVER DDB FOR PTY.
	PUSHJ P,STLNAC			;RESTORE LINE (CLOBBERED BY TTYGET).
	JRST WSCHED

;PTWR1S, PTLL3, PTWR1W, PTRDS, PTWRS7, PTWRS9
PTWR1S:
	MOVEI CHR,1
	CAML CHR,TIFCTR(DDB)		;IS THERE ROOM (>1 NOT 0).
	POPJ P,
	AOS (P)				;THERE IS ROOM FOR THE CHR., SO WE WILL SKIP.
	XCTR XLB,[LDB CHR,UUO]
	LDB UCHN,[POINT 2,CHR,28]
PTLL3:
	LDB DSER,[POINT 7,CHR,35]	;SIMULATE KBDINT, IN CASE THIS PTY IS REALLY A DPY.
	CAIL DSER,"A"
	CAILE DSER,"Z"
	JRST .+2
	TRO DSER,40
	MOVEI AC2,
	PUSHJ P,STLNAC		;IN CASE KBDED IS AROUND CLOBBERING THINGS.
	MOVE TAC,LINTAB(LINE)	;SET UP ESCAPE BITS
	DPB LINE,[PUNITS⊗6,,TAC];BUT NULLIFY MAPPING
	CONO PI,SCNOFF
	PUSHJ P,PTYREC		;PRETEND CHR. HAS JUST BEEN TYPED IN.
	JRST TYPT1		;TURN ON PI AND POPJ.

PTWR1W:
	TLNE LINE,IMLIN		;IMLAC FORWARD-SPACE KLUDGE
	JRST IMWR1W
IMWR10:
	PUSHJ P,PTWR1S		;WRITE A CHAR.
	SKIPA UCHN,DDB		;DIDN'T GO. LET'S WAIT A WHILE.
	POPJ P,			;ALL DONE.
	PUSHJ P,TTYGET
	HRROM DDB,PTYPTR(UCHN)
	PUSHJ P,PTWAIT
	JRST PTWR1W

IMWR1W:
	XCTR XLB,[LDB CHR,UUO]	;IMLAC...
	CAIN CHR,211		;<CONTROL>TAB?
	JRST IMWR11
	CAIE CHR,240		;<CONTROL>SPACE?
	JRST IMWR10		;NEITHER.  BACK TO OLD CODE.
	MOVE CHR,[ASCID/ε↓/]	;CTL-SPACE.  COMMAND TO MOVE FORWARD 1.
	CAIA
IMWR11:
	MOVE CHR,[ASCID/ε}/]	;CTL-TAB.  MOVE FORWARD A BUNCH.
	PUSHJ P,TTYFNU
	JRST FIVOUT		;SEND THE COMMAND.

; PTRDS, PTWRS7, PTWRS9 CHANGED 3-30-71 TO USE LH (ADR+1) AS BYTE
; POINTER SPEC IF NON-ZERO ------ DCS

PTRDS:
	XCTR	XR,[MOVE UUO,(UUO)]	;GET ADDRESS OF BUFFER IN LOSER CORE.
	TLZN	UUO,7777	;CLEAR SIZE FIELD, CHECK FOR BP THERE --DCS
	HRLI	UUO,440700	;NONE, GIVE 7-BIT PTR TO FIRST CHAR --DCS
	TLO	UUO,700		;ASSURE CORRECT SIZE FIELD, AT LEAST--DCS
	IBP	UUO		;STUPID SAIL!
PTRDSA:
	PUSHJ P,PTRD1W	;WAIT FOR AT LEAST ONE CHAR. TO APPEAR.
PTRDS2:
	IBP UUO
	PUSHJ P,PTRD1S	;GET ANY FURTHER CHARS.
	POPJ P,		;NO MORE.
	JRST PTRDS2	;MAYBE MORE.

PTWRS7:
	TLCA UUO,444300	;MAKE 7-BIT PTR. ...
PTWRS9:
	TLC UUO,445500	;MAKE 9-BIT PTR.
	HLR	CHR,UUO	;SAVE BP SPEC FOR FIRST CHAR--DCS
	XCTR	XR,[MOVE UUO,(UUO)]	;GET ADDRESS OF BUFFER IN LOSER CORE.
	TLZN	UUO,7777	;CLEAR SIZE AND INDEX, CHECK--DCS
	HRL	UUO,CHR		;ZERO, PROVIDE CORRECT PTR --DCS
	DPB	CHR,[POINT 12,UUO,17];ASSURE CORRECT SIZE FIELD--DCS
PTWR2:
	XCTR	XLB,[ILDB CHR,UUO]
	JUMPE CHR,STLNAC	;DONE IF NULL
	PUSHJ P,PTWR1W	;GIVE NEXT CHAR. TO PTY.
	JRST PTWR2	;LOOP UNTIL WE SEE A NULL.


;PTJOBX
PTJOBX:
	LDB TAC,PJOBN		;GET JOB WHICH IS ON THIS PTY
	XCTR XR,[MOVE TAC1,(UUO)]	;GET COMMAND
	TLNN TAC1,770000	;IS IT SIXBIT OR DIRECT INDEX?
	JRST PTJDIR		;DIRECT
	MOVEI AC1,PTJLEN	;LENGTH OF TABLE
	CAME TAC1,PTJTAB-1(AC1)	;MATCH?
	SOJG AC1,.-1
	MOVE TAC1,AC1
PTJDIR:
	JUMPLE TAC1,UUOERR
	CAILE TAC1,PTJLEN	;IS IT IN TABLE?
	JRST UUOERR		;NO
	HRRZ TAC1,PTJDIS-1(TAC1)	;GET DISPATCH
	JRST (TAC1)		;AND DISPATCH

DEFINE NAMES
<	C	HALT,PTJHLT,0
	C	CONT,PTJCON,0
	C	DOFF,PTDOFF,0
	C	DON,PTDON,0
	C	LOGIN,PTLOGN,0
	C	IWAITS,PTIWTS,0
	C	CLRBFI,PTCLRB,0
>
DEFINE C(A,B,BITS)
<	XWD BITS,B
>
PTJDIS:
	
XLIST
	NAMES
LIST
PTJLEN←←.-PTJDIS
DEFINE C(A,B,BITS)
<	SIXBIT/A/
>
PTJTAB:
	
XLIST
NAMES
LIST

;PTJHLT, PTJCON, PTIWTS, PTCLRB
;HALT JOB RUNNING ON THIS PTY
PTJHLT:
	JUMPE TAC,CPOPJ
	PUSH P,J		;SAVE OURSELVES FIRST.
	MOVE J,TAC		;NOW DO IT TO HIM
	CAMN J,STUSER		;SYSTEM TAPE USER?
	JRST HLTOK0
	PUSHJ P,STOPCK	;NO, OK TO STOP?
	CAIA
	JRST HLTOK	;YES
NOTOK:
	POP P,J
	PUSHJ P,WSCHED	;WAIT A WHILE
	JRST PTJHLT
HLTOK0:
	SKIPN JBTADR(J)
	JRST HLTOK1
	PUSHJ P,ANYACT
	JRST NOTOK
HLTOK1:
	PUSHJ P,ESTOP
	POP P,J
	JRST CPOPJ1		;SUCCESS RETURN
HLTOK:
	PUSHJ P,STOP1
	POP P,J
	JRST CPOPJ1		;SUCCESS RETURN

;CONTINUE THE JOB RUNNING ON THIS PTY

PTJCON:
	JUMPE TAC,CPOPJ
	PUSH P,J
	MOVE J,TAC
	MOVM TAC,JOBQUE(J)
	CAIE TAC,STOPQ		;THIS IS ONLY PLACE YOU CAN CONTINUE FROM
	JRST NOCONT
	MOVE TAC,JBTSTS(J)
	TLNE TAC,JERR
	JRST NOCONT
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,SETRUN
	AOS -1(P)		;SUCCESS RETURN
NOCONT:
	POP P,J
	JRST CPOPJ1		;SUCCESS RETURN

;SKIP IF PTY IS WAITING FOR INPUT

PTIWTS:
	MOVE IOS,DEVIOS(DDB)
	TLNE IOS,TPMON		;MONMODE OR USRMODE?
	JRST PTIWT1
	JUMPL IOS,CPOPJ1	;USER MODE, CHECK TTYIOW BIT
	POPJ P,			;IT WAS OFF

PTIWT1:
	LDB LINE,PUNIT		;GRUMBLE, GRUMBLE, PTJOBX MUNGS "TAC1"!!
	MOVE TAC,TTYTAB(LINE)	;MONITOR MODE, GOBBLE TTYTAB
	TLNN TAC,COMBIT!DLYBIT
	AOS (P)
	POPJ P,

;PTJOBX [N ; SIXBIT /CLRBFI/] -- DO CLRBFI FOR TTYN
PTCLRB:
	JRST SETBFI		;YES, I KNOW THIS WASTES A CELL AND A CYCLE

;PTDON, PTDOFF,PTLOGN,IMLOAD
; ROUTINES TO SET DUPLEXING OF PTY

PTDON:
	MOVEI IOS,NOECHO
	ANDCAB IOS,DEVIOS(DDB)
	POPJ P,

PTDOFF:
	MOVEI IOS,NOECHO
	ORB IOS,DEVIOS(DDB)
	POPJ P,

;START A NEW JOB ON A PTY.  USES FORK CODE.

PTLOGN:
	JUMPN TAC,PTLGN1	;LOSE IF THERE'S A JOB ALREADY
	HRLM J,(P)		;SAVE OUR JOBNUM
	PUSHJ P,INIJOB		;GOBBLE A NEW JOB
	JRST PTLGN0		;SORRY, NO JOBS
	JRST PTLGN0		;THIS CAN'T HAPPEN (IT SAYS HERE)
	PUSHJ P,FORKC		;THIS COPIES THE OLD JOB'S STUFF
	MOVEI TAC,(J)		;TO RETURN IT TO LOSER
	AOSA	(P)
PTLGN0:
	MOVEI	TAC,0
PTLGN1:
	XCTR	XW,[MOVEM TAC,(UUO)]
	POPJ	P,

;DO A PTLOAD TO AN IMLAC

IMLOAD:
	PUSHJ P,TTYFNU
	XCTR	XR,[MOVE UUO,(UUO)]	;GET GUY'S PTR.
	TLNN	UUO,-1			;IS IT ALREADY (PRESUMABLY) A BYTE PTR. ?
	HRLI	UUO,440700		;NO. MAKE IT ONE.
IMLOD0:
	MOVE CHR,[ASCID/0/]		;Load command is "0"+no. of chars.
	MOVE TAC,[POINT 7,CHR,6]
IMLOD1:
	XCTR	XLB,[ILDB AC3,UUO]	;Get a char,
	JUMPE AC3,IMLOD2		;end on a null.
	ADD CHR,[BYTE (7)1]		;Count the chars.
	IDPB AC3,TAC			;Stuff char into the command.
	TLNE TAC,760000			;Full word (4 chars)?
	JRST IMLOD1			;No.  Do it again.
	PUSHJ P,FIVOUT			;Send those 4 to the IMLAC
	JRST IMLOD0			;and keep going.
IMLOD2:
	CAME CHR,[ASCID/0/]		;Done.  Put out the last few chars.
	PUSHJ P,FIVOUT
	MOVE CHR,[ASCID/¬/]		;Command to move to beginning of
	JRST FIVOUT			;line and return to normal.

;PHONE DIALER LIVES HERE
IFE DILNUM,<DIAL:JRST UUOERR>;IF NO DIALER, UUOERR
IFN DILNUM,<
;DIALER BITS AND DEFINITIONS
DIL0TT←←11		;TTY11 IS DIALER 0

;CONI BITS
DILDS1←←4000		;DATASET ANSWERED OR DIALED END OF NUMBER CODE
DILDS0←←2000		;DATASET HUNG-UP
DILBSY←←1000		;DIALER BUSY
DILOK←←400		;DIALER OK (NOT TIMED OUT)
DILDSS←←200		;CONNECTED
DILVMD←←100		;IN VOICE MODE
DILPWR←←40		;POWER FAIL

;CONO BITS
DILCLR←←40		;CLEAR INTERRUPT CONDITION
DILHUP←←20		;HANG UP
DILENB←←10		;ENABLE INTERRUPT

;DATAO BITS (LEFT HALF)
DAREA←←4000		;DIAL AREA CODE
DVOICE←←2000		;GO TO VOICE MODE ON DSS←1

;DIALER INITIALIZE ROUTINE
DILINI:
	CONO DIL,DILCLR!DILHUP!DILENB!DILCHN	;INIT HARDWARE
	SETZM DILZBG			;BEGIN ZERO OF DIALER DATA
	MOVE TAC,[DILZBG,,DILZBG+1]
	BLT TAC,DILZND			;AND ZERO TO END
	POPJ P,

DILTRL:
	MOVSI AC1,-DILNUM
DILTR1:
	HRRZ TAC,DILTTY(AC1)
	CAIE TAC,(LINE)
	AOBJN AC1,DILTR1
	JUMPGE AC1,CPOPJ
	PUSH P,LINE
	HRRZ LINE,AC1
	SKIPE DILJOB(LINE)
	PUSHJ P,RELDIL	;RELEASE DIALER
	POP P,LINE
	POPJ P,

;DIAL UUO
;CALL
;	MOVEI AC,ADDR
;	DIAL AC,
;	<ERROR RETURN, AC CONTAINS STATUS BITS>
;	<SUCCESS, AC CONTAINS ANY DATA RETURNED>
;
;ADDR:	DIALER #,,FUNCTION CODE
;	SEE INDIVIDUAL CALL FOR REST OF DATA

DILER0:
	JSP TAC,DILERR
DILER1:
	JSP TAC,DILERR
DILER2:
	JSP TAC,DILERR
DILER3:
	JSP TAC,DILERR
DILER4:
	JSP TAC,DILERR

DILERR:
	SUBI TAC,DILER0+1
	HRRZ TAC,TAC
DILSTT:
	XCTR XW,[MOVEM TAC,(UCHN)]	;STORE ERROR CODE BACK IN AC
	POPJ P,

;ERROR CODES FOR ALL DIAL UUO'S
;ERROR 0 -- ILLEGAL DIALER #
;ERROR 1 -- DON'T OWN DIALER
;ERROR 2 -- DON'T MEET DILOWN CONDITIONS
;ERROR 3 -- DIALER BUSY
;ERROR 4 -- DIALING FAILURE

↑DIAL:	XCTR XR,[HRRZ UUO,(UCHN)]	;FETCH POINTER TO ARG BLOCK
	XCTR XR,[HLRZ LINE,(UUO)]	;GET DIALER NUMBER
	CAIL LINE,DILNUM		;LEGAL?
	JRST DILER0			;NO, ERROR 0
	XCTR XR,[HRRZ DSER,(UUO)]	;GET FUNCTION CODE
	CAIL DSER,MXDLCD		;LEGAL FUNCTION CODE?
	JRST UUOERR			;NO
	CAME J,DILJOB(LINE)		;HIS?
	JUMPN DSER,DILER1		;NO, ERROR 1 (UNLESS DILGET)
	JRST @DILDIS(DSER)		;YES, CALL ROUTINE

DILDIS:
	DILGET				;0 GET DIALER
	DILSTA				;1 GET DIALER STATUS
	DILDIL				;2 DIAL A NUMBER
	DILHNG				;3 HANG UP
	DILREL				;4 RELEASE
MXDLCD←←.-DILDIS

;CODE 0	GET DIALER
DILGET:
	CAMN J,DILJOB(LINE)		;DOES HE OWN IT?
	JRST CPOPJ1			;ALREADY HAS IT, SUCCESS
	SKIPE DILJOB(LINE)		;DOES ANYONE OWN IT?
	JRST DILER1			;YES, DON'T OWN ERROR
	XCT DILOWN(LINE)		;CHECK OTHER CONDITIONS
	JRST DILER2			;LOSE
	MOVEM J,DILJOB(LINE)		;CLAIM IT
	JRST CPOPJ1

DILTTY:
	400000,,DIL0TT			;TTY NUMBER FOR THIS DIALER (SIGN BIT MEANS CONNECTED TO AD/DA)

DILOWN:
	PUSHJ P,DIL0CK			;CHECK ROUTINE FOR DIALER 0

DIL0CK:
	MOVE DDB,DILTTY(LINE)
	SKIPN DDB,TTYTAB(DDB)		;CHECK TTY FOR DIALER
	POPJ P,				;NO TTY THERE AT ALL
	LDB TAC,PJOBN
	CAME TAC,J			;IS IT HIS?
	POPJ P,				;NO
	MOVE TAC,DEVMOD(DDB)
	TRNE TAC,ASSPRG			;DOES HE HAVE IT INITED?
	AOS (P)				;YES, SUCCESS
	POPJ P,

;CODE 1 GET STATUS
DILSTA:
	CONI DIL,TAC			;GET CURRENT STATUS
	HRL TAC,DILCNI(LINE)		;LAST I-LEVEL CONI IN LEFT HALF
	AOS (P)				;ALWAYS SUCCESSFUL HERE
	JRST DILSTT			;RETURN STATUS BITS IN AC

;CODE 2 DIAL A NUMBER
DILDIL:
	CONSZ DIL,DILBSY
	JRST DILER3			;DIALER BUSY
	CONSZ DIL,DILPWR		;IS DIALER POWER OK?
	JRST DILER4			;NO, GIVE HIM AN ERROR RIGHT AWAY
	XCTR XR,[MOVE TAC,2(UUO)]	;PICKUP DATAO WORD
IFN 0,<;ENABLE WHEN AD/DA CONNECTED
	TLNE TAC,DVOICE			;ATTEMPTING VOICE MODE?
	SKIPL DILTTY(LINE)		;CONNECTED TO AD/DA?
	JRST DILNM1
;CHECK AD/DA OWNERSHIP HERE
DILNM1:

>;IFN 0
	XCTR XR,[MOVE AC1,1(UUO)]	;PICKUP CONO WORD
	ANDI AC1,777700			;JUST AREA CODE
	CAIN AC1,4B21!1B25!5B29		;AREA 415?
	TLZ TAC,DAREA			;YES, DON'T DIAL AREA CODE
	CONO PI,DILOFF			;DISABLE DIALER CHANNEL
	CONO DIL,DILCLR!DILENB!DILCHN(AC1)	;SETUP
	DATAO DIL,TAC			;AND GO
DILWAT:
	MOVNI TAC,IOWQ
	MOVEM TAC,JOBQUE(J)
	PUSHJ P,REQUE
	MOVE AC1,[JRST DILING]		;DISPATCH FOR I-LEVEL
	MOVEM AC1,DILIDS(LINE)
	SETZM DILCNI(LINE)		;CLEAR CONI BITS FOR CHECK
	CONO PI,DILON
	PUSHJ P,WSCHED			;WAIT FOR DIALER
	CONO PI,DILOFF			;INTERLOCK
	SKIPN TAC,DILCNI(LINE)		;GET CONI BITS
	JRST DILWAT
	CONO PI,DILON
	TRC TAC,DILDS1!DILOK!DILDSS	;ALL THESE SHOULD BE ON
	TRCN TAC,DILDS1!DILOK!DILDSS
	TRNE TAC,DILDS0!DILPWR		;THESE SHOULD BE OFF
	CAIA
	JRST DILSTAT			;OK, RETURN STATUS
	CONO DIL,DILHUP!DILENB!DILCHN	;HANG IT IN YOUR EAR
	JRST DILER4			;DIALER ERROR

;CODE 3 HANG UP
DILHNG:
	CONO DIL,DILHUP!DILENB!DILCHN	;HANG IT IN YOUR EAR
	JRST DILSTAT			;RETURN STATUS

;CODE 4 RELEASE DIALER
DILREL:
	PUSHJ P,RELDIL
	JRST DILSTAT			;RETURN STATUS

RELDIL:
	SETZM DILIDS(LINE)		;CLEAR I-LEVEL DISPATCH
	CONO DIL,DILHUP!DILENB!DILCHN	;HANG IT IN YOUR EAR
	SETZM DILJOB(LINE)
	POPJ P,

;DIALER INTERRUPTS COME HERE
↑DILINT:MOVEM LINE,DILLIN
	MOVEI LINE,0			;ONLY ONE LINE FOR NOW
	MOVEM TAC,DILTAC
	CONI DIL,TAC			;GET STATUS BITS
	MOVEM TAC,DILCNI(LINE)		;LATEST CONI BITS
	SKIPE DILIDS(LINE)		;THIS DIALER ACTIVE?
	XCT DILIDS(LINE)		;DISPATCH TO DIALER ROUTINE OR EXIT
DILXIT:
	CONSO DIL,DILBSY		;DIALER BUSY?
	JRST DILXT1			;NO, DON'T CHECK FOR HANGUP
	CONSO DIL,DILOK			;IF NOT OK
	CONO DIL,DILHUP			;HANG UP
DILXT1:
	CONO DIL,DILCLR!DILENB!DILCHN	;CLEAR INTERRUPT, ENABLE, SET CHANNEL
	MOVE TAC,DILTAC
	MOVE LINE,DILLIN
	JEN @DILCHL

DILING:
	TRNE TAC,DILDS1			;SHOULD HAVE JUST CONNECTED
	TRNN TAC,DILDSS			;AND STILL BE CONNECTED
	TDZA TAC,TAC			;NOT CONNECTED, IDLE STATE
	MOVE TAC,[JRST DILACT]		;CONNECTED, SET TO ACTIVE STATE
	MOVEM TAC,DILIDS(LINE)		;SET DISPATCH
	MOVEM J,DILJ
	MOVE J,DILJOB(LINE)
	MOVM TAC,JOBQUE(J)
	CAIE TAC,IOWQ			;STILL WAITING FOR US?
	JRST DILIN1
	MOVNI TAC,RUNQ
	MOVEM TAC,JOBQUE(J)
	MOVEI TAC,QJOB(J)
	CONO PI,PIOFF
	SKIPE (TAC)
	JRST DILIN0
	EXCH TAC,QJOB
	HRROM TAC,@QJOB
DILIN0:
	CONO PI,PION
DILIN1:
	MOVE J,DILJ
	JRST DILXIT

DILACT:
	TRNE TAC,DILOK			;IF NOT OK,
	TRNE TAC,DILDS0!DILPWR		;OR ANY ERRORS
	XCT DILERP(LINE)		;THEN REPORT ERROR
	JRST DILXIT			;I WONDER WHAT WAS WRONG?

DILERP:
	JRST DILERT			;REPORT TO TTY

DILERT:
	MOVE TAC,DILTTY(LINE)
	SKIPN TAC,TTYTAB(TAC)		;JUST IN CASE
	JRST DILXIT			;FOO
	MOVEM J,DILJ
	MOVSI J,IODERR
	IORM J,DEVIOS(TAC)		;FLAG ERROR TO TTY
	MOVE J,DILJ
	JRST DILXIT
>;IFN DILNUM
;: TTYSER[J17,SYS] EOF.
;: LINED[J17,SYS]
COMMENT ⊗   VALID 00038 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00005 00002	BEGIN LINED
C00007 00003	GLOBAL LINE,KBDCHN,CHR
C00010 00004		COMMENT   KBDED IS CALLED AT UUO OR INTERRUPT LEVELS FROM RECINT, WITH CHR CONTAINING
C00014 00005	KBDBEG:
C00020 00006	LECCN:	PUSH P,I		 SAVE THE DPY PROGRAM HEADER ADDRESS
C00021 00007	LEC1:	JUMPE UCHN,LECB
C00023 00008	LE2CR:	PUSHJ P,LECT		SIMULATE A CTRL TAB (GO TO END OF LINE).
C00025 00009	LE2A:	TRNN UCHN,CBIT2		INSERT CHAR. IF CTRL 2. OR CTRL1 (OR BOTH)
C00028 00010	SUBROUTINES FOR INSERTING CHARACTERS IN THE LINE.
C00031 00011	INSTAB:	MOVEI CHR," "		A TAB. PREPARE TO (SIGH) SIMULATE IT.
C00034 00012	 THIS IS THE LINE EDITOR'S GARBAGE COLLECTOR. IT GOES THROUGH THE
C00037 00013	ROUTINES TO PERFORM EDITING FUNCTIONS.
C00040 00014	LEBS:	CAIN UCHN,CBIT2!CBIT1
C00042 00015	LECI:	TLOE I,INSBT		FLAG INSERT MODE.
C00044 00016	 THIS ROUTINE ADJUSTS THE NEXT TAB, AS GIVEN BY THE BYTE POINTER IN TAC.
C00046 00017	SEARCH:	MOVEI AC1,1		PREPARE TO SEARCH FOR INDICATED CHR.
C00048 00018	LEDESC:	CAIN CHR,10044
C00050 00019	 WE GET HERE IF THE LOSER TYPES <ESC>C OR <ESC>¬C WHICH CAUSES
C00052 00020	 ROUTINE TO PUT PAGE PRINTER IN HOLD
C00054 00021	 ROUTINE TO SET PAGE PRINTER GLITCHES/PAGE
C00055 00022	ESCAPE W,Q.
C00058 00023	ESCAPE	O,F,I,X.
C00061 00024	FNTAB:	TLO I,NOTABB		PREPARE TO FIND NEXT TAB IN LINE.
C00063 00025	MOVEIT MOVES THE PTR. FORWARD OR BACKWARD BY THE NO. OF PLACES
C00066 00026	INIT2:	MOVE TAC,ACTMOD(DDB)	GET SPECIAL BITS
C00069 00027	 THIS IS THE INITIALIZE ROUTINE. HERE WE INITIALIZE ALL THE LINE
C00072 00028	↑LACTIV:TDZA UCHN,UCHN		NO SPURIOUS CTRL BITS PLEASE.
C00077 00029	 WE GET HERE WHEN THE LINE EDITOR BUFFER IS EMPTY.
C00079 00030	ACTIV2:	TLO IOS,SYNC!DDTM	FORCE ACTIVATION
C00081 00031	ECHOCB:	TRNN IOS,NOECHB		IS USER SUPPRESSING ECHO OF CTRL. BITS ?
C00083 00032	 HERE IS WHERE WE QUEUE UP LINE EDITOR TRANSFERS
C00084 00033	 THIS IS A ROUTINE THAT GOES THROUGH THE LINE AND SETS UP EXTRA CRLFS TO BREAK
C00086 00034	 WE GET HERE IF THE LINE IS LONG AND MUST BE BROKEN UP.
C00088 00035	 HERE WE SEE IF THE TAB IS A REAL TAB OR IF IT IS JUST
C00090 00036	 WE GET HERE WHEN THE TAB SURROUNDS A BUNCH OF SPACES. FIRST WE
C00093 00037	 AT THIS POINT, WE ARE IN THE PROCESS OF BREAKING A LONG LINE
C00095 00038	MAKE11:	POP P,AC3		 RESTORE COLUMN COUNT
C00096 ENDMK
C⊗;

BEGIN LINED

COMMENT ⊗  THIS IS THE INCREDIBLE INTRA-LINE EDITOR. ITS FEATURES ARE:

	CTRL1 SPACE-- MOVE FORWARD THROUGH LINE.
	CTRL BS-- MOVE BACKWARD.
	BS -- MOVE BACKWARD, DELETING .(END OF LINE ONLY)
	CTRL I	-- ENTER INSERT MODE (MIDDLE OF LINE ONLY).
	CTRL D -- DELETE FORWARD (MIDDLE OF LINE ONLY).
	CTRL TAB -- MOVE TO END OF LINE.
	CLEAR -- DELETE ENTIRE LINE.
	CTRL S<ANY CHR.> -- MOVE POINTER RIGHT TO NEXT OCCURRENCE OF <ANY CHR.>.
	CTRL K<ANY CHR.> -- DELETE RIGHT TO NEXT OCCURRENCE OF <ANY CHR.>.

	CTRL CR  -- AT START OF LINE ONLY, RETRIEVES THE LAST LINE TYPED IN.

CHARACTERS TYPED WITH META IN THE MIDDLE OF THE LINE WILL BE INSERTED.

ANY COMMAND MAY BE PRECEDED BY A REPEAT NUMBER (TYPED WITH CTRL BUTTON).
    FOR EXAMPLE, CTRL 9 CTRL BS MOVES THE POINTER BACK 9 CHARACTERS.
ANY CTRL COMMAND LEAVES INSERT MODE.

WHAT COULD BE MORE WONDERFUL ??
⊗


GLOBAL LINE,KBDCHN,CHR

I←ITEM

CBIT1←←1	;CTRL BIT 1.
CBIT2←←2	;CTRL BIT 2.
EOLCHR←←12	;LINE FEED TERMINATES THE LINE IN THE BUFFER.

	;;STATUS BITS (LEFT HALF OF I).

SRCHBT←←400	;CTRL1 S SEEN, NEXT CHR. IS SEARCH ARGUMENT.
KILLBT←←1000	;CTRL1 K SEEN....
↑WTFLAG←←1	;WAITING FOR PRGM. TO SWALLOW LAST LINE.
EOLBT←←2	;AT END OF LINE.
INSBT←←4	;INSERT MODE (MIDDLE OF LINE).
TABB←←10	;LOCATION OF NEXT TAB IN NTABPT, SIZE IN NTABCT.
NOTABB←←20	;NO TAB BETWEEN CURRENT POS. AND END OF LINE.
XTABBT←←100	;WE ARE INSIDE A TAB IN GETEM.
REEDBT←←2000	;WE ARE RE-EDITING A LINE (AFTER A CTRL1 CR).
NOCRBT←←4000	;WE SHOULD NOT PUT ANOTHER CR INTO THIS LINE.
NOTEXT←←10000	; THIS BIT MEANS THE TEXT HAS NOT BEEN CHANGED, JUST THE CURSOR
NOTFR←←20000	; MEANS THAT NO TRANSFER AT ALL SHOULD TAKE PLACE
CRBIT←←40000	; USED TO SKIP OVER CRLF IN MIDDLE OF LINE
NOBRBT←←100000	; MEANS LINE HAS NOT BEEN BROKEN UP. LONG LINES ONLY.
ACTNOW←←200000	; MEANS WE SHOULD ACTIVATE NOW
SHLDRB←←200	;Loser wants to see every chr. we see.

;; NOW SOME DISPLAY OPCODES AND MACROS FOR GENERATING DP INSTRS.

DISJMP←←20	;DP JMP INSTR. OPCODE.
DISJMS←←4	; JMS (STORES TWO WORDS)
DISJSR←←24	; STORES ONLY RETURN ADDR.
DISRST←←14	;RESTORE.
DISSEL←←10	;SELECT.
DISNOP←←12	;ACTUALLY TSS, BUT A GOOD NOP WITH ALL BITS OFF.

DEFINE LVW(X,Y,TYPE,MODE,BRT,SIZ)	;ASSEMBLES A LONG VECTOR.
  { MVW1 (MODE,TYPE,BRT,SIZ)	;TWIDDLE PARAMS.
	BYTE (11)<X>,<Y>(3)B,S(2)MD,TT(3)3 }	;ASSEMBLE INSTR.
DEFINE MVW1 (M,T,BRT,SIZ)
 {IFIDN {M}{A}{MD←←1;}MD←←0	;MODE = `A' FOR ABSOLUTE.
  IFIDN {T}{I}{TT←←2;}TT←←0	;TYPE = `I' FOR INVISIBLE.
  IFIDN {BRT}{}{B←←0;}B←←BRT	;BRT = 0 IF OMITTED.
  IFIDN {SIZ}{}{S←←0;}S←←SIZ	;SAME FOR SIZ.
}

↑↑XDEL:	14B10	;X-SIZE OF A SIZE 2 CHARACTER, POSTIONED AT THE X-FIELD.
XDEL2:
	14B11	;ONE HALF OF ABOVE.

	COMMENT ⊗  KBDED IS CALLED AT UUO OR INTERRUPT LEVELS FROM RECINT, WITH CHR CONTAINING
	   THE CHAR. TO BE CONSIDERED WITH ITS CTRL BITS IN PLACE.  UCHN CONTAINS
	   JUST THE CTRL BITS, RIGHT JUSTIFIED, AND DSER CONTAINS THE LOWER-CASE
	   VERSION OF THE CHARACTER IN CHR.  DDB AND LINE ARE SETUP TO THE RIGHT
	   TTY, AS IS IOS.  PROG, IOS, AND UUO ARE PRESERVED BY KBDED.
⊗

↑KBDED:
IFN FTOIKB, <	CAIN CHR,10000		;<CTRL 2> LINE FEED IS FOR ↑O.
		; HANGOVER FOR III KEYBOARDS
		JRST CONTOB		;CONTOB IS IN TTEDIT. >
	MOVE DAT,LINE		;GET DPY NO. AND LINTAB BITS INTO DAT.
	MOVE I,LETAB-DPYL0(DAT)	;LOAD I WITH PRT. TO CONTROL BLOCK AND BITS
	TLZ I,NOTEXT!NOTFR!CRBIT
	SETOM LEINV(I)		; SET BUFFER INVALID
	SETOM LEACT(I)		; MAKE SURE WE STICK AROUND FOR ANOTHER MINUTE
	TLNE I,SHLDRB		;Loser looking over our shoulder ?
	PUSHJ P,LSRSEE		;Hold up chr. for him to see. Hope he likes it.
	PUSHJ P,KBDBEG		; DO LINE EDITOR BIT
	SETZM LEINV(I)
	TLZE I,NOTFR		; WAS THIS A SILENT COMMAND?
	JRST KBDX1		; YES, JUST LEAVE QUIETLY
	TLNE I,NOTEXT		; HAS THE TEXT BEEN CHANGED?
	PUSHJ P,QLECUR		; NO, JUST UPDATE THE CURSOR
	TLZE I,NOTEXT
KBDX1:
	SKIPE LEWAKE(I)		; DID WE CAUSE A TRANSFER TO ABORT?
	PUSHJ P,QLETXT		; YES, UPDATE BOTH
	SETZM LEWAKE(I)		; CLEAR ABORT FLAG
	HRRZ DAT,PRGNUM(I)	; PICK UP DPY NUMBER
	HLLM I,LETAB(DAT)
	TLNE I,WTFLAG		;ARE WE CURRENTLY ACTIVATING SOMETHING?
	POPJ P,			;YES, SNEAK WILL GET WOKEN UP LATER!
	TLNE IOS,SNKWAT		; IN SNEAK WAIT?
	SKIPG CCPOS(I)		; ANYTHING FOR HIM TO SEE?
	POPJ P,
KBDX2:
	MOVE IOS,[XWD TTYIOW!SNKWAT,IOACT]	;YES, CLEAR FLAGS
	ANDCAB IOS,DEVIOS(DDB)
	JRST STTIOD		;BRING HIM OUT OF WAIT

LSRSEE:
	PUSH P,DAT
	MOVEI DAT,TTIBUF(DDB)
	PUSHJ P,PUTCHI		;Put chr. in loser's input buffer.
	JFCL			;Buffer full. Loser loses.
	MOVE AC1,TIFCTR(DDB)
	CAIG AC1,TTICHR/4	;Is his buffer getting full ?
	TLNN IOS,TTYIOW		;Is he waiting for input ?
	JRST LSRSEX		;No.
	PUSHJ P,SYNCHA		;Prepare to activate loser.
	PUSHJ P,KBDX2		;Wake him up.
LSRSEX:
	POP P,DAT
	POPJ P,

KBDBEG:

;DONT	MOVE AC2,TIME		; PICK UP TIME OF DAY
;SAVE	SKIPN DPKTIM(I)		; HAS THE TIME BEEN STORED YET?
;TIME	MOVEM AC2,DPKTIM(I)	; NO, DO SO
	SKIPE III(I)
	JRST KBDBG1
	MOVE AC3,CURPP(I)
	MOVE AC2,DPHPOS(AC3)
	SKIPGE LEPOS(I)
	TDZA AC2,AC2
	ADD AC2,LNLNGT(AC3)
	MOVEM AC2,PPHPOS(I)
KBDBG1:
	TRNE CHR,10000
	JRST LEDESC		;<ESC>SOMETHING
	TRNN CHR,177		;IS THIS MAYBE A CALL?
	JRST  LECCN		;A CALL WILL BE A NULL NOW.
	JUMPL I,NOINIT		;IS THIS THE FIRST CHAR OF A LINE?
	TLNE I,WTFLAG		;YES, IS LAST LINE IN USER BUFFER YET?
	JRST TPOPJ		;NO, JUST IGNORE HIM
	PUSHJ P,INIT2		;CLEANSE THE WORLD
NOINIT:
	ANDI CHR,177		;REMOVE CTRL BITS FROM CHR.
	CAIL CHR,"a"		;IS IT A LOWER CASE LETTER ?
	CAILE CHR,"z"
	JRST LE20		;NO.
;	TLNN IOS,TPMON		;YES. IF MONITOR MODE OR
	TLNN DAT,FCS		; NOT FULL CHAR. SET MODE,
	SUBI CHR,40		; CONVERT TO UPPER CASE.
LE20:
	TLZE I,SRCHBT		;WAS LAST CHR. AN S OR K COMMAND ?
	JRST SEARCH		;YES.
	CAIE CHR,177		;IF IT'S A BACKSPACE, PRETEND IT HAS CTRL 1.
	CAIN UCHN,CBIT1		;DO WE HAVE CTRL 1 ONLY ?
	TLNE IOS,DDTM		;YES. IS EDITOR DISABLED ?
	JRST LE2		;NOT A COMMAND. GO PUT IT IN BUFFER.
	CAIG CHR,"9"		;IS IT A DIGIT ?
	CAIGE CHR,"0"
	JRST LEC1		;NO.
	MOVE AC1,NUMARG(I)	;YES. CTRL NUMBERS ARE PART OF REPEAT ARGUMENT.
	IMULI AC1,=10		;DO DECIMAL CONVERSION.
	ADDI AC1,-"0"(CHR)
	ANDI AC1,777		;DON'T LET IT GET TOO BIG.
	MOVEM AC1,NUMARG(I)
	POPJ P,

LECCN:
	PUSH P,I		; SAVE THE DPY PROGRAM HEADER ADDRESS
	PUSHJ P,RECINB
	POP P,I
	HRRZ DAT,LINE		; RECINB CLOBBERS THIS
	SETZ AC1,
	EXCH AC1,DPHOLD(I)
	JUMPE AC1,LFLUSH
	HRRZ AC1,PRGNUM(I)
	ADD AC1,[XWD UNHOLD,DPYL0]
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
LFLUSH:
	PUSH P,DDB		;SAVE AN AC
	MOVEI DDB,LEB(I)	;TURN OFF EDITOR BUFFER BY
	HRLI DDB,DISJMP		;PUTTING A RETURN JUMP
	MOVSM DDB,LEPPV(I)	;ON TOP OF THE POSITION VECTOR.
;	PUSHJ P,INIT1		;COMMENTED OUT BY FW SO CTRL-CR WILL WORK
	POP P,DDB
	HRRZS I,LETAB-DPYL0(DAT);RESET STATUS
	POPJ P,

LEC1:
	JUMPE UCHN,LECB
	MOVE AC1,XDEL		;GET X DIMENSION OF A CHR.
	TLZE I,INSBT		;LEAVE INSERT MODE, IF WE ARE IN IT.
	PUSHJ P,INSP1		;READJUST CURSOR POSITION.
LECB:
	SKIPN AC1,NUMARG(I)	;DID GUY TYPE RPT ARG ?
	AOS AC1,NUMARG(I)	;NO. USE 1.
	CAIN CHR,177
	JRST LEBS		;BACKSPACE.
	CAIN CHR," "
	JRST LECSP		;CTRL1 SPACE.
	CAIN CHR,14
	JRST LECFF
	TLNE I,EOLBT		; AT END OF LINE?
	JRST LE2		; YES, USER GETS TO SEE CTRL LETTERS.
	TRZ DSER,40		;CHANGE LOWER CASE LETTERS TO UPPER.
	CAIN DSER,"D"		;COMPARE UNSHIFTED CHAR.
	JRST LECD
	CAIN DSER,"I"
	JRST LECI
	CAIN CHR,11		;A TAB ?
	JRST LECT
	CAIN DSER,"K"
	TLOA I,KILLBT
	CAIN DSER,"S"
	TLOA I,SRCHBT
	JRST LE2		;RANDOM CTRL LETTER.
	JRST LECX1		;STORE NEW BITS IN I AND EXIT.

LECFF:
	MOVEI AC1,=200		;SIMULATE 200 CTRL BS'S
	MOVEM AC1,NUMARG(I)
	JRST LEBS

LE2CR:
	PUSHJ P,LECT		;SIMULATE A CTRL TAB (GO TO END OF LINE).
	MOVEI CHR,15		; RESTORE THE CR THAT MAKECR CLOBBERS

LE2:
		;;HERE IF CHR HAS NO CTRL1 BIT.
	TLNN I,EOLBT		;AT END OF LINE ?
	JRST LE2A		;NO.
	TLNE I,NOCRBT		;ARE WE RE-EDITING THIS LINE ?
	CAIE CHR,15		;YES. DON'T PUT ANOTHER CR AT ITS END.
	SKIPA
	JRST ACTIV1		;JUST ACTIVATE GUY WHEN HE TYPES CR AT A RE-EDITED LINE.
	PUSHJ P,PUTCHR		;PLACE CHAR. IN BUFFER.
	MOVEM TAC,FCPOS(I)	;UPDATE FINAL CHAR. POS. CTR.
	JUMPG UCHN,ACTIV1	;ACTIVATE ON ANY CTRL BITS AT EOL.

LE2X:
	MOVE TAC,SPCTAB(CHR)	;SPECIAL BITS.
	TLNN TAC,BREAKB!FCSBRK	;A BREAK CHAR. ?
	TLNE IOS,DDTM		;IS EVERY CHAR. AN ACTIVATOR ?
	JRST ACTIV1		;YES.
	TLZE I,ACTNOW		; ARE WE OUT OF BUFFER SPACE?
	JRST ACTIV1		; YES, ACTIVATE NOW
	TLNE DAT,SPCBRK		;ARE WE IN SPECIAL ACTIVATION MODE?
	TLNE IOS,TPMON
	JRST LE2XA		;NO
	PUSHJ P,SPCACT		;TEST FOR BREAK.
	CAIA
LE2XA:
	TRNE UCHN,CBIT1		;YES. ANY CTRL BITS ?
	JRST ACTIV1		;YES.
	JRST LECX

LE2A:
	TRNN UCHN,CBIT2		;INSERT CHAR. IF CTRL 2. OR CTRL1 (OR BOTH)
	TLNE I,INSBT		;ARE WE IN INSERT MODE ?
	JRST LEINS		;YES.
	CAIN CHR,15
	JRST LE2CR		;CR'S GO AT END OF LINE.
	TRNE UCHN,CBIT1		;NOW TEST CTRL BIT 1
	JRST LEINS		;INSERT
LEOV:
	PUSH P,CHR		;WE'RE OVER-STRIKING. SAVE CHAR.
	MOVEI AC1,1		;FAKE A RPT. ARG. OF 1.
	MOVE TAC,LEPNT1(I)	;IF WE ARE ABOUT TO OVERSTRIKE
LEOVS:
	ILDB AC2,TAC		;A TAB, AND IF THE TAB IS MORE
	JUMPE AC2,.-1
	CAIE CHR,11		;ALWAYS OVERTYPE IF NEW CHAR IS TAB
	CAIE AC2,11		; IS THIS A TAB?
	JRST LEOVD		; NO, JUST GO AHEAD AND OVERSTRIKE.
	ILDB AC3,TAC		;WE WILL INSERT INSTEAD.
	JUMPE AC3,.-1		; NO NULLS, PLEASE.
	CAIE AC3," "		; IS THIS REALLY A TAB OR A LONG LINE CRLF?
	JRST LEOVSC		; IS LONG LINE CRLF, READ PAST IT
	ILDB AC3,TAC		; PICK UP CHARACTER PAST SPACE
	JUMPE AC3,.-1
	CAIN AC3,11		;YES. MORE THAN ONE SPACE ?
LEOVD:
	PUSHJ P,LECD		;DELETE NEXT CHR. IN LINE.
	POP P,CHR		;NOW INSERT NEW ONE.
LEINS:
	TLO I,NOBRBT		; FORCE REPOSITIONING OF THE LONG LINE CRLF
	CAIE UCHN,CBIT2		;IF INSERT VIA META,
	JRST LEINS1
	MOVEI UCHN,		; DON'T LET IT ACTIVATE IN SPECIAL ACT MODE
	PUSHJ P,SPCACT		; UNLESS IT WOULD'VE WITHOUT META
	MOVEI UCHN,CBIT2
LEINS1:
	PUSHJ P,PUTCHR		;PLACE NEW CHR. IN LINE.
	AOS FCPOS(I)		;INC. TOTAL CHR. COUNT.
	MOVNI AC3,1(AC3)	;- NO. OF COLUMNS INSERTED.
	MOVE TAC1,LEPNT1(I)	;GET CURRENT POINTER.
	PUSHJ P,ADJTB		;GO FIDDLE NEXT TAB IN LINE.
	JFCL
	JRST LE2X

LEOVSC:
	ILDB AC3,TAC		; PICK UP NEXT CHARACTER
	CAIE AC3,11		; IS IT THE FINAL TAB YET?
	JRST LEOVSC		; NO, LOOK SOME MORE
	JRST LEOVS		; YES, NOW LOOK AGAIN.

;;SUBROUTINES FOR INSERTING CHARACTERS IN THE LINE.

PUTLF:
	MOVEI CHR,12		;INVENT A LINE FEED.
	AOS FCPOS(I)
PUTCHR:
	SETZB AC3,NUMARG(I)	;CLEAR REPEAT ARG.
	PUSHJ P,INSCHR		;PLACE CHAR. INTO LINE.
	MOVE AC2,XDEL		;PREPARE TO MOVE CURSOR.
	CAIN CHR,11		;DID WE INSERT A TAB ?
	PUSHJ P,INSTAB		;YES.
	ADDM AC2,LEPPV(I)	;MOVE CURSOR OVER ONE PLACE.
	AOS DSER,LEHPOS(I)
	CAILE DSER,=72		;ARE WE AT RIGHT SIDE OF SCREEN ?
	PUSHJ P,SHIFTL		;YES. SHIFT THE LINE LEFT SOME.
	AOS TAC,CCPOS(I)	;CURRENT POSITION IN CHARS.
	CAIN CHR,15		;IS IT A CR ?
	JRST PUTLF		;YES.
	SKIPE III(I)		; IS THIS A DD DISPLAY?
	POPJ P,			; NO, LEAVE NOW
	PUSH P,AC3		; SAVE NUMBER OF CHARACTERS INSERTED
	MOVE AC3,CURPP(I)
	MOVE AC1,PPHPOS(I)	;GET INITIAL X POSITION
	ADD AC1,LEHPOS(I)	; ADD IN LINE EDITOR'S HORIZONTAL POSITION
	CAIE CHR,11		; WAS THE CHARACTER A TAB?
	JRST PUTCH1		; NO, BREAK ONLY IF EVENLY AT END OF LINE
	ADDI AC1,4		; CENTER TAB ON END OF SCREEN
	IDIV AC1,LNLNGT(AC3)	; SEE IF SE ARE NEAR THE END OF THE LINE
	CAIG AC2,10		; WITHIN + OR - 4 CHARACTERS?
PUTCH2:
	TLO I,NOBRBT		; YES, DO LINE BREAKING CALCULATION THIS TIME
PUTCH3:
	POP P,AC3		; RESTORE NUMBER OF CHARACTERS INSERTED
	POPJ P,

PUTCH1:
	SUBI AC1,1
	IDIV AC1,LNLNGT(AC3)	; SEE IF WE ARE EXACTLY AT THE END OF THE LINE
	JUMPE AC2,PUTCH2	; YES, BREAK OUR LINE THIS TIME
	JRST PUTCH3		; RESTORE ACCUMULATOR AND LEAVE

INSTAB:
	MOVEI CHR," "		;A TAB. PREPARE TO (SIGH) SIMULATE IT.
	MOVE AC1,LEHPOS(I)	;GET LINE EDITOR HPOS
	SKIPN III(I)
	ADD AC1,PPHPOS(I)	;MAKE IT ABSOLUTE ON DD
	ANDCAI AC1,7		;HOW MANY SPACES TO INSERT (LESS 1).
	ADDM AC1,LEHPOS(I)
	SKIPA AC3,AC1		;REMEMBER THE MAGIC NUMBER.
INST1:
	ADDM AC2,LEPPV(I)	;MOVE CURSOR OVER ONE PLACE.
	PUSHJ P,INSCHR		;INSERT A SPACE IN THE LINE.
	SOJGE AC1,INST1		;BACK FOR MORE IF APPROPRIATE .
	MOVEI CHR,11		;NOW FINISH OFF WITH ANOTHER TAB.
INSCHR:
	ILDB TAC,LEPNT1(I)	;LOOK AT NEXT CHR.
	JUMPE TAC,INSCH1	;IF NULL, PUT NEW CHR. ON TOP OF IT.
	MOVE TAC,LEPNT1(I)	;GET PTR.
	PUSHJ P,LEINSW		;INSERT A WORD OF NULLS.
INSCH1:
	DPB CHR,LEPNT1(I)	;PUT NEW CHR. IN LINE.
	POPJ P,

LEINSW:
	AOS DSER,LELWD(I)	;UPDATE PTR. TO RETURN JMP.
	CAMLE DSER,MAXPT(I)	;MORE ROOM IN BUFFER ?
	PUSHJ P,GCOLL		; BUFFER NEARLY FULL, COMPRESS OUT ALL THE NULLS
INSW1:
	MOVE TAC1,(DSER)	;GET WORD FROM BUFFER AND
	MOVEM TAC1,1(DSER)	;MOVE IT UP ONE.
	CAILE DSER,(TAC)	;ARE WE DOWN TO WHERE WE WILL INSERT THE NULLS ?
	SOJA DSER,INSW1		;NO.
	MOVEI DSER,0		;PREPEARE TO INSERT NULLS.
	MOVE TAC1,TAC
	IDPB DSER,TAC1		;NULL NEXT CHAR. AFTER CURRENT ONE..
	IDPB DSER,TAC1		;..AND ALSO NEXT 3 AFTER THAT.
	IDPB DSER,TAC1
	IDPB DSER,TAC1
	TLZ I,TABB		;WE NO LONGER KNOW WHERE NEXT TAB IS.
	POPJ P,

; THIS IS THE LINE EDITOR'S GARBAGE COLLECTOR. IT GOES THROUGH THE
; BUFFER AND COMPRESSES OUT ALL THE NULL CHARACTERS. IT MUST RESET THE
; POINTER TO THE LAST WORD IN THE TABLE, LELWD, MUST RESET THE BYTE POINTERS
; IN LEPNT1 AND IN TAC.

GCOLL:
	PUSH P,AC1		; FIRST, SAVE A FEW ACCUMULATORS
	PUSH P,AC2
	PUSH P,AC3
	PUSH P,UUO
	MOVSI AC1,440700	; NOW MAKE UP TWO BYTE POINTERS TO THE BUFFER
	MOVSI AC2,440700
	HRRI AC1,LEBUF(I)
	HRRI AC2,LEBUF(I)
	SETZ AC3,		; THIS WILL BE THE COUNT OF THE NULLS WE SQUEEZED OUT
GCOLL1:
	MOVE UUO,AC1		; NOW, TEST FOR END OF BUFFER
	IBP UUO			; SEE WHAT ADDRESS WE WOULD HAVE ENDED UP ON
	HRRZS UUO		; CLEAN IT UP
	CAML UUO,LELWD(I)	; COMPARE TO END OF BUFFER
	JRST GCOLL4
	ILDB UUO,AC1		; PICK UP FIRST CHARACTER IN LINE
	JUMPN UUO,GCOLL2	; IF NOT A NULL, JUST STUFF IT IN THE BUFFER
	ADDI AC3,1		; ANOTHER NULL, COUNT IT
GCOLL3:
	PUSHJ P,PCHK		; UPDATE BYTE POINTERS IF NECESSARY
	JRST GCOLL1		; GO BACK FOR MORE

PCHK:
	CAMN AC1,LEPNT1(I)	; ARE WE TO THE MAIN POINTER YET?
	MOVEM AC2,LEPNT1(I)	; YES, UPDATE IT
	CAMN AC1,TAC		; HAVE WE GOTTEN TO THE POINTER IN TAC YET?
	MOVEM AC2,TAC		; YES, UPDATE IT TOO
	POPJ P,

GCOLL2:
	IDPB UUO,AC2		; PUT THE CHARACTER DOWN IN ITS NEW POSITION
	JRST GCOLL3		; GO BACK FOR MORE

GCOLL4:
	PUSHJ P,PCHK		; UPDATE FINAL POINTER
	CAIGE AC3,5		; DID WE COLLECT A FULL WORD OF NULLS?
	TLO I,ACTNOW		; NO, ACTIVATE JOB NOW
	HRRZI AC2,1(AC2)	; POINT FINAL POINTER TO LAST WORD IN BUFFER
	MOVE UUO,@LELWD(I)	; PICK UP RETURN JUMP
	MOVEM UUO,(AC2)		; PUT IT DOWN IN ITS NEW PLACE
	MOVEM AC2,LELWD(I)	; AND THIS IS THE NEW END OF BUFFER POINTER
	POP P,UUO		; RESTORE OUR ACCUMULATORS
	POP P,AC3
	POP P,AC2
	POP P,AC1
	POPJ P,

;;ROUTINES TO PERFORM EDITING FUNCTIONS.

LECT:
	MOVEI AC1,=200		;A CTRL TAB. SIMULATE 200 CTRL SPACES.
LECSP:
	JSP TAC,CKNFOR		;CTRL SPACE. PREPARE TO MOVE CURSOR FORWARD.
	PUSHJ P,MOVEIT		;MOVE IT.
	MVFOR			;MOVE FORWARD, PLEASE.
	TLO I,NOTEXT		; NOTE THAT WE HAVE ONLY CHANGED THE CURSOR POSITION, NOT THE TEXT
MVX1:
	MOVEM TAC1,LEPNT1(I)	;UPDATE THE BYTE POINTER.
	MOVE DSER,AC2
MVX2:
	IMUL AC2,XDEL2		;CALC. AMOUNT TO MOVE CURSOR.
	LSH AC2,1		;THIS IS TO HANDLE OVERFLOW.
SHIFT2:
	ADDM AC2,LEPPV(I)	;UPDATE THE POSITION VECTOR.
	ADDB DSER,LEHPOS(I)	;UPDATE HORIZONTAL POS. CNT.
	CAIG DSER,=72		;PAST RIGHT HAND MARGIN ?
	JUMPGE DSER,.+2		;OR MAYBE PAST LEFT ?
	PUSHJ P,SHIFT
LECX:
	TLZ I,SRCHBT!KILLBT
	SETZM NUMARG(I)
LECX1:
	MOVE AC3,PPHPOS(I)
	EXCH AC3,LSTHP(I)	; SEE THAT AS OUR NEW HORIZONTAL STARTING POSITION
	CAMN AC3,LSTHP(I)	; IS IT THE SAME AS LAST TIME
	TLZE I,NOBRBT		; OR HAS THIS LINE BEEN UNTOUCHED
	PUSHJ P,MAKECR		; VIRGIN LINE OR DIFFERENT HORIZONTAL POSITION
	TLZE I,ACTNOW		; DO WE HAVE TO ACTIVATE NOW?
	JRST ACTIV1		; YES, DO SO
	HLLM I,LETAB-DPYL0(DAT)	;UPDATE THE STATUS BITS.
	POPJ P,

CKNFOR:
	TLOE I,EOLBT		;AT END OF LINE ALREADY ?
	JRST LECX		;YES. CAN'T MOVE FORWARD.
	ADD AC1,CCPOS(I)	;FIND POS. AFTER MOVE.
	CAMGE AC1,FCPOS(I)	;WILL MOVE TAKE US TO END OF LINE ?
	TLZA I,EOLBT		;NO. RESET FLAG SAYING WE ARE THERE.
	MOVE AC1,FCPOS(I)	;YES. DON'T LET IT TAKE US PAST END.
	EXCH AC1,CCPOS(I)	;PUT BACK NEW POSITION.
	SUB AC1,CCPOS(I)	;GET -NO. OF PLACES TO MOVE.
	JRST (TAC)		;RETURN.

LEBS:
	CAIN UCHN,CBIT2!CBIT1
	JRST LE2		;LET USER SEE CTRL-META BS
	SKIPN CCPOS(I)		;BACKSPACE OR CTRL BACKSPACE.
	JRST LECX		;AT START OF LINE.
	TRZE UCHN,CBIT2
	JRST .+3		;META-BS ALWAYS DELETES
	TLNN I,EOLBT!INSBT	;ARE WE AT END OF LINE OR IN INSERT MODE ?
	HRRI UCHN,10		;NO. FORCE NON-DELETING BS.
	MOVN AC1,NUMARG(I)	;- RPT. ARG.
	ADDM AC1,CCPOS(I)	;POSITION AFTER MOVE.
	SKIPL AC2,CCPOS(I)	;WILL MOVE GO PAST START OF LINE 
	JRST BSP1		;NO.
	SUB AC1,AC2		;YES. RE-ADJUST CNT. SO IT WON'T.
	SETZM CCPOS(I)		;MARK AT BEGINNING OF LINE.
BSP1:
	JUMPG UCHN,BSP3		;CTRL BITS ?
BSP2:
	ADDM AC1,FCPOS(I)	;NO. WE WILL ACTUALLY DELETE CHRS.
	TLZ I,NOCRBT		;THIS IS FOR BENEFIT OF INIT4.
	TDZA CHR,CHR		;SET CHR TO 0 SO MOVEIT WILL DELETE.
BSP3:
	TLZ I,EOLBT		;CTRL BACKSPACE. NO LONGER ARE WE AT END OF LINE.
	PUSHJ P,MOVEIT
	MVBAK			;MOVE BACKWARD RIGHT AMOUNT.
	MOVNS DSER,AC2		;- NO. OF COLUMNS MOVED.
	TLO I,NOTEXT		; MARK CURSOR CHANGE ONLY
	JUMPG UCHN,MVX1		;IF NON-DELETING BACKSPACE, JUST UPDATE CURSOR AND LEAVE.
	TLZ I,NOTEXT		; AHA, TEXT IS CHANGED TOO!
	MOVEM TAC1,LEPNT1(I)
	PUSHJ P,ADJTB
	SKIPA AC2,DSER
	MOVE AC2,DSER
	JRST MVX2

LECI:
	TLOE I,INSBT		;FLAG INSERT MODE.
	JRST LECX		;ALREADY IN THAT MODE !
	TLO I,NOTFR		; THIS IS A SILENT ONE
	PUSHJ P,LECX		;UPDATE STATUS WORD.
	MOVN AC1,XDEL
INSP1:
	ASH AC1,-1		;FOR INSERT MODE, WE MOVE CURSOR BY
	ADDM AC1,LEPPV(I)	; 1/2 A CHAR. WIDTH.
	LDB AC2,[POINT 11,LEPPV(I),21]
				;NOW THE Y POS.
	ASH AC1,-=26		;(MOVE IT BY 1/4 CHAR. WIDTH.)
	SUB AC2,AC1		;(MOVE IT IN OTHER DIRECTION,TOO.)
	DPB AC2,[POINT 11,LEPPV(I),21]
	POPJ P,

LECD:
	JSP TAC,CKNFOR		;CTRL D. PREPARE TO MOVE FORWARD.
	ADDM AC1,FCPOS(I)	;DECREMENT NO. OF CHRS. IN LINE.
	ADDM AC1,CCPOS(I)	;DON'T INCREMENT THE CURRENT POSITION.
	MOVEI CHR,0		;SET TO DELETE...
	PUSHJ P,MOVEIT		;MOVE FORWARD, DELETING.
	MVFOR
	JRST ADJNTB		; ADJUST NEXT TAB

; THIS ROUTINE ADJUSTS THE NEXT TAB, AS GIVEN BY THE BYTE POINTER IN TAC.
; THE COUNT OF THE NUMBER OF COLUMNS THE LINE HAS BEEN MOVED BY IS IN AC3.

ADJNTB:
	PUSHJ P,ADJTB		; ADJUST OUR TABS
	JRST LECX
	JRST LECX

ADJTB:
	TLNN I,TABB+NOTABB	;DO WE KNOW ABOUT NEXT TAB ?
	PUSHJ P,FNTAB		;NO. FIND OUT.
	TLNN I,TABB		;IS THERE ONE ?
	POPJ P,			;NO.
	ANDI AC3,7		;COUNT MOD 8 OF CHRS. DELETED.
	JUMPE AC3,CPOPJ		;NO CHANGE IF MULTIPLE OF 8.
	MOVE AC2,NTABCT(I)	;GET SIZE OF NEXT TAB.
	ADD AC2,AC3		;NEW SIZE OF NEXT TAB.
	MOVE TAC,NTABPT(I)	;PTR. TO LAST SPACE IN NEXT TAB.
	CAIG AC2,10		;IS NEW SIZE TOO BIG ?
	JRST LECD5		;NO. TAB NEEDS TO GROW.
	SUBI AC2,10
	EXCH AC2,NTABCT(I)	;YES. TAB MUST SHRINK.
	SUB AC2,NTABCT(I)	;FIND OUT HOW MUCH TO SHRINK IT.
	MOVEI AC1,0
LECD4A:
	DPB AC1,TAC		;NULL ONE OF THE SPACES IN THIS TAB.
	ADD TAC,[XWD 70000,0]	;DECREMENT POINTER.
	JUMPG TAC,.+2
	SUB TAC,[XWD 430000,1]
	SOJG AC2,LECD4A
LECD6:
	MOVEM TAC,NTABPT(I)	;STORE UPDATED PTR.
	JRST CPOPJ1

LECD5:
	MOVEI AC1," "		;PREPARE TO MAKE TAB GROW.
	MOVEM AC2,NTABCT(I)	;STORE NEW SIZE.
LECD5A:
	ILDB TAC1,TAC
	JUMPE TAC1,.+2		;IS THERE A NULL NEXT ?
	PUSHJ P,LEINSW		;NO. PUT SOME IN.
	DPB AC1,TAC		;ADD A SPACE.
	SOJG AC3,LECD5A
	JRST LECD6

SEARCH:
	MOVEI AC1,1		;PREPARE TO SEARCH FOR INDICATED CHR.
	MOVEM CHR,TAC		;SAVE CHR. TO BE SEARCHED FOR.
	MOVE AC3,LEPNT1(I)	;MAKE COPY OF CURRENT POINTER.
	MOVEI TAC1,AC3		;PARAMETER FOR GETEM.
	PUSHJ P,GETEM		;SKIP OVER CURRENT CHR. BEFORE STARTING SEARCH.
SRCHL:
	PUSHJ P,GETEM		;GET NEXT CHR. FROM LINE.
	CAIN CHR,EOLCHR		;ARE WE AT END OF LINE ?
	JRST LECX		;YES. DO NOTHING, CHR. NOT FOUND.
	CAMN CHR,TAC		;HAVE WE FOUND IT ?
	SOSLE NUMARG(I)		;YES. IS THE REPEAT COUNT EXHAUSTED ?
	AOJA AC1,SRCHL		;NO. COUNT PLACES MOVED AND LOOK SOME MORE.
	TLZN I,KILLBT		;YES.  ARE WE KILLING OR JUST MOVEING UP TO IT ?
	JRST LECSP		;MOVEING.
	JRST LECD		;KILLING.

GETEM:
	ILDB CHR,(TAC1)		;GET A NON-NULL CHAR. FROM LINE.
	JUMPE CHR,.-1
	CAIN CHR,11		;IS IT A TAB ?
	TLCN I,XTABBT		;YUP. ALREADY INSIDE A TAB ?
	TLNN I,XTABBT		;INSIDE A TAB ?
	JRST GETEM1		; NO, EXIT
	CAIE CHR,11		; ARE WE INSIDE A CRLF?
	CAIN CHR," "
	JRST GETEM2		; NO. PASS OVER THE TAB.
	TLO I,CRBIT		; YES, MARK THIS AS A LONG LINE CRLF
	JRST GETEM		; LOOP BACK FOR NEXT CHARACTER

GETEM1:
	TLZE I,CRBIT		; ARE WE COMING OUT OF A CRLF?
	JRST GETEM		; YES, GET NEXT CHARACTER PAST IT
	POPJ P,			; NO

GETEM2:
	TLZ I,CRBIT
	JRST GETEM

LEDESC:
	CAIN CHR,10044
	JRST CLEAR
	CAIN CHR,10041
	JRST ESCHX
	TLO I,NOTFR		; THIS IS A SILENT TRANSFER
	TRZ DSER,40		; CHANGE LOWER TO UPPER CASE
	CAIN DSER,"F"		;AN F ?
	JRST ESCF		;YES. GO SEE ABOUT FCS MODE.
	CAIN DSER,"O"
	JRST ESCO
	CAIN DSER,"I"
	JRST ESCI
	CAIN DSER,"W"
	JRST ESCW
	CAIN DSER,"Q"
	JRST ESCQ		;GET WHO LINE FOR NEXT JOB WITH SAME PROG NAME
	CAIN DSER,"X"
	JRST ESCX		;SET OR CLEAR UPDATE BIT IN XTIME FOR THIS JOB
	CAIN DSER,"G"
	JRST ESCG
	CAIN DSER,"L"
	JRST ESCL
	CAIN DSER,"Y"
	JRST ESCY
	CAIN DSER,"N"
	JRST ESCN
	CAIN DSER,"E"
	JRST ESCE
	CAIN DSER,"J"
	JRST ESCJ
	CAIN DSER,"C"		; CLEAR SCREEN?
	JRST ESCC		; YES, GO QUEUE UP AN ERASE REQUEST
	CAIN DSER,"P"		; REFRESH HIS PAGE PRINTER?
	JRST ESCP		; YES, GO QUEUE UP A PAGE PRINTER REQUEST
	SKIPE III(I)		; THE REST OF THESE COMMANDS ONLY APPLY TO DATA DISK
	JRST LECX1		; IF III, JUST IGNORE
	CAIN DSER,"H"
	JRST ESCH		;HIDE (OR UNHIDE) HIS CHANNEL
	CAIE DSER,"R"		; REFRESH HIS LINE EDITOR?
	JRST LECX1		; NO, LEAVE
ESCR:
	TLZ I,NOTEXT!NOTFR	; QUEUE UP A COMBINED TEXT AND CURSOR TRANSFER
	JRST LECX1

ESCP:
	JUMPL AC1,BRKP		;<BREAK>P DOES THE WORKS
	HRLI AC2,LERFP		; USE THE MAGIC CLOCK LEVEL ROUTINE FOR REFRESHING THE PAGE
	JRST ESCC1

; WE GET HERE IF THE LOSER TYPES <ESC>C OR <ESC>¬C WHICH CAUSES
; HIS SCREEN (IF HE IS A DATA DISC TYPE) TO GET ERASED TO BLACK OR
; WHITE RESPECTIVLY.

ESCC:
	SKIPE III(I)
	JRST ESCC0
	HRRZ AC2,CURPP(I)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVSI AC3,(1B5)	; PICK UP BLACK BIT
	JUMPL AC1,.+3
	ORM AC3,DDCW(AC2)
	JRST .+2
	ANDCAM AC3,DDCW(AC2)
ESCC0:
	MOVSI AC2,LEERS		; USE CLOCK LEVEL ROUTINE IN DPYSER THAT QUEUES IT UP
ESCC1:
	HRRI AC2,(I)		; PUT IN THE DPY PROGRAM HEADER ADDRESS
ESCC2:
	CONO PI,PIOFF
	IDPB AC2,CLKQ
	CONO PI,PION
	JRST LECX1

; <BREAK>P CLEARS THE SCREEN AND REFRESHES BOTH THE PAGE
; PRINTER AND THE LINE EDITOR.

BRKP:
	HRLI AC2,RFPCS
	JRST ESCC1

CLEAR:
	CAIN UCHN,CBIT1		; <CTRL>CLEAR?
	JRST ESCU		; YES, UNHOLD
	JUMPN UCHN,CPOPJ	; NO, JUST FLUSH LINE UNLESS IT'S GOT <META>
				; (FALL THROUGH INTO LECLR)

; THIS ROUTINE CLEARS THE LINE EDITOR BUFFER WITHOUT DISTURBING
; ITS STATUS. THIS MEANS THAT THE INFORMATION AS TO WHETHER
; THIS IS A RE-EDITED LINE IS PRESERVED.

LECLR:
	SKIPN FCPOS(I)
	POPJ P,
	TLZ I,TABB!NOTABB!EOLBT
	PUSHJ P,INIT3
	MOVE AC1,FCPOS(I)	; JUST DELETE THAT MANY CHARACTERS
	JRST LECD

; ROUTINE TO PUT PAGE PRINTER IN HOLD

ESCHX:
	SETOM DPHOLD(I)
	JRST LECX1

; ROUTINE TO SET NUMBER OF GLITCHES BEFORE HOLD

ESCJ:
	DPB AC1,[POINT 9,GWORD(I),26]
	MOVEM AC1,GLHCNT(I)
	TRNN AC1,-1
	SETOM GLHCNT(I)
	JRST LECX1

; SET NUMBER OF LINES BEFORE HOLD

ESCE:
	DPB AC1,[POINT 9,GWORD(I),17]
	MOVEM AC1,LHCNT(I)
	TRNN AC1,-1
	SETOM LHCNT(I)
	JRST LECX1

; ROUTINE TO UNHOLD THE PAGE PRINTER

ESCU:
	SETZ AC1,
	EXCH AC1,DPHOLD(I)
	JUMPE AC1,LECX1
	HRRZ AC2,PRGNUM(I)
	ADD AC2,[XWD UNHOLD,DPYL0]
	JRST ESCC2

;SET OR CLEAR CONSOLE PRIVACY BIT

ESCH:
	MOVSI AC3,400000
	HLR AC1,PRGNUM(I)
	JUMPL AC1,UNHIDE	;BREAK-H MEANS UNHIDE
	TDNE AC3,DDTAB(AC1)
	JRST LECX1
	IORM AC3,DDTAB(AC1)
	PUSHJ P,DDFLSH
	JRST LECX1

UNHIDE:
	ANDCAM AC3,DDTAB(AC1)
	JRST LECX1

; ROUTINE TO SET PAGE PRINTER GLITCHES/PAGE

ESCG:
	HRLI AC2,PPGSET
	JRST ESCY1

; LINES/GLITCH

ESCL:
	HRLI AC2,PPLSET
	JRST ESCY1

; Y-POSITION

ESCY:
	HRLI AC2,PPYSET
ESCY1:
	HRRZM AC1,LEARG(I)
	JRST ESCC1

; NORMALIZE PAGE PRINTER

ESCN:
	MOVE DSER,AC1
	HRREI TAC,-DDL0(LINE)
	JUMPL TAC,.+2
	PUSHJ P,VDESCN		;NORMALIZE VDS ON DD
	MOVSI AC2,LEERSN
	JUMPL DSER,ESCC1
	MOVSI AC2,PPNSET
	JRST ESCC1

;ESCAPE W,Q.

ESCW:
	JUMPGE AC1,ESCW1	;TURN ON WHO LINE?
	SETZM WHOTAB(I)		;TURN OFF WHO LINE
	JRST LECX1

ESCW2:
	TLZ AC1,-1		;THIS IS WHERE [ESC] # Q DOES [ESC] # W
ESCW1:
	TRNN AC1,-1
	LDB AC1,PJOBN		;GET JOB NUMBER OUT OF DDB IF NO ARGUMENT.
	CAIL AC1,JOBN		;LEGAL JOB?
	JRST LECX1		;NO
				;PUT INTO WHO TIME TABLE
	MOVE AC2,JBTSTS(AC1)	;GET JOB STATUS WORD.
	TLNE AC2,JNA		;IS IT LOGGED IN?
	HRROM AC1,WHOTAB(I)	;YES, STORE JOB #.  ALSO PUT -1 IN INCR TIME SLOT.
	SETZM WHORUN(I)		;CLEAR TIME TO UPDATE RUNTIME NEXT
	JRST LECX1		;THAT'S ALL.

ESCQ:
	TRNE	AC1,-1		;ANY ARGUMENT?
	JRST	ESCW2		;[ESC] # Q AND [BRK] # Q ARE SAME AS [ESC] # W
	SKIPN	TAC,WHOTAB(I)	;GET NUMBER OF JOB ON WHO LINE
	LDB	TAC,PJOBN	;NO WHO LINE.  USE USER'S JOB.
	ANDI	TAC,-1		;MAKE SURE TAC HAS ONLY THE JOB NUMBER
	JUMPE	TAC,LECX1	;IF NOT LOGGED IN AND NO WHO LINE UP, FORGET IT
	HRRZ	AC2,PRJPRG(TAC)	;GET PROGRAMMER NAME OF OLD WHO LINE JOB
	MOVEI	AC3,1		;ASSUME POSITIVE INCREMENT FOR GOING THRU TABLE
	JUMPGE	AC1,.+2		; UNLESS HE SAID [BRK] Q
	SETO	AC3,		; IN WHICH CASE WE USE NEGATIVE INCREMENT
	PUSHJ	P,ESCQ1		;LOOK FROM TAC TO END OF TABLE
	XORI	TAC,JOBN	;START OVER AT OTHER END OF TABLE
	PUSHJ	P,ESCQ1		; AND LOOK THROUGH WHOLE TABLE
	JRST	LECX1		;NO JOB FOUND WITH SAME PN, NOT EVEN ORIGINAL JOB.

ESCQ1:
	ADD	TAC,AC3		;MOVE ON TO NEXT JOB
	CAIGE	TAC,JOBN	;AT END OF TABLE YET?
	JUMPG	TAC,.+2		; OR AT BEGINNING OF TABLE?
	POPJ	P,		;YES TO ONE OF THESE
	HRRZ	AC1,PRJPRG(TAC)	;GET PROGRAMMER NAME FOR THIS JOB
	CAIE	AC1,(AC2)	;IS IT THE ONE WE ARE LOOKING FOR?
	JRST	ESCQ1		;NO
	HRROM	TAC,WHOTAB(I)	;YES!  SAVE JOB NUMBER.  -1 INTO INCR TIME.
	SETZM	WHORUN(I)	; AND CLEAR TIME TO UPDATE RUNTIME NEXT
	SUB	P,[1,,1]	;DONT POPJ.  ADJUST STACK
	JRST	LECX1

;ESCAPE	O,F,I,X.

ESCO:
	MOVEI IOS,IOSUPR	;ASSUME AN UN-↑O.
	ANDCAB IOS,DEVIOS(DDB)
	JUMPL AC1,LECX1
	PUSHJ P,LECX1		;GET STATUS BITS STORED AND RESET.
	PUSH P,I		; SAVE THE DPY PROGRAM HEADER
	PUSHJ P,CONTOB		; DO A ↑O.
	PUSHJ P,UTYPET		;AND MAKE SURE IT GETS OUT
	POP P,I
	POPJ P,

ESCF:
	JUMPL AC1,.+2
	TLOA DAT,FCS		;TURN ON THE ↑F BIT (FULL CHR. SET).
	TLZ DAT,FCS		;WRONG. TURN IT OFF.
	HLLM DAT,LINTAB(DAT)
	JRST LECX1

; <ESC>I INTERRUPTS ON THE INTTTI BIT IN THE LEFT HALF

ESCI:
	MOVSI AC1,INTTTI
	LDB AC2,PJOBN
	TDNN AC1,JBTIEN(AC2)
	JRST LECX1
	ORM AC1,JBTIRQ(AC2)
	SETOM INTREQ(PID)
	JRST LECX1

ESCX:
	LDB	AC2,PJOBN	;GET JOB NUMBER OF THIS GUY
	JUMPE	AC2,LECX1	;IF YOU'RE NOT LOGGED IN, I CANT HELP YOU
	MOVSI	TAC,400000	;THIS IS THE BIT WE WILL SET OR CLEAR
	JUMPN	AC1,.+3		;WAS IT PLAIN [ESC]X?
	ANDCAM	TAC,XTIME(AC2)	;YES.  TURN OFF THE NO-UPDATE BIT IN XTIME
	JRST	LECX1		;BYE
	TRNE	AC1,-1		;WAS THERE AN ARGUMENT TO ESCAPE COMMAND?
	JRST	.+3		;YES
	ORM	TAC,XTIME(AC2)	;NO.  MUST HAVE BEEN [BRK]X.  TURN ON NO-UPDATE FLAG
	JRST	LECX1
	SETZ	AC3,
	HRRZS	DSKOPS(AC2)	;MAKE ALL DISK OPS "RECENT"
	JUMPL	AC1,ESCX1	;WAS IT [ESC] OR [BRK]?
	SKIPGE	AC3,JBTWAT(AC2)	;[ESC]1 X.  UPDATE JB2WAT
	ADD	AC3,UPTIME	;MAKE WAIT TIME HONEST
	HRLS	DSKOPS(AC2)	;ZERO INCREMENTAL COUNT OF DISK OPERATIONS
	ADD	TAC,TTIME(AC2)	;[ESC]1 X.  UPDATE XTIME AND SET NO-UPDATE BIT
ESCX1:
	MOVEM	TAC,XTIME(AC2)	;[BRK]1 X MEANS CLEAR XTIME AND SET NO-UPDATE BIT
	MOVEM	AC3,JB2WAT(AC2)	;SAVE NEW VALUE OF OLD WAIT TIME
	JRST	LECX1

FNTAB:
	TLO I,NOTABB		;PREPARE TO FIND NEXT TAB IN LINE.
FNT1:
	ILDB TAC,TAC1		;LOOK AT NEXT CHR.
	CAIN TAC,EOLCHR		;ARE WE AT END OF LINE ?
	POPJ P,			;YUP. RETURN LEAVING `NO TAB' BIT SET.
	CAIE TAC,11		;A TAB ?
	JRST FNT1		;NO.
	MOVE AC2,TAC1		; SEE IF THIS TAB IS REALLY A LONG LINE CRLF
	ILDB AC2,AC2		; PICK UP CHARACTER PAST TAB
	CAIN AC2," "		; IS IT A SPACE?
	JRST FNT3		; YES, MUST BE REAL TAB
FNT4:
	ILDB TAC,TAC1		; NO, MUST BE LONG LINE CRLF. READ PAST IT.
	CAIE TAC,11		; IS THIS A TAB?
	JRST FNT4		; NO, READ SOME MORE
	JRST FNT1		; YES, GET NEXT CHARACTER PAST CRLF

FNT3:
	MOVEI AC2,0		;COUNT NO. OF SPACES IN TAB.
	TLC I,TABB!NOTABB	;SET BITS PROPERLY.
FNT2:
	ILDB TAC,TAC1
	JUMPE TAC,.-1		; SKIP NULLS
	CAIE TAC," "		;ARE WE OUT OF SPACES YET ?
	JRST FNT5
	MOVEM TAC1,NTABPT(I)	;STORE PTR. TO LAST SPACE IN TAB.
	AOJA AC2,FNT2		;NO. KEEP COUNTING.

FNT5:
	CAIE TAC,11		; IS THIS REALLY THE TERMINATING TAB?
	JRST FNT2		; NO, GO BACK FOR MORE
	MOVEM AC2,NTABCT(I)	;STORE SIZE OF TAB.
	POPJ P,

;;MOVEIT MOVES THE PTR. FORWARD OR BACKWARD BY THE NO. OF PLACES
;; IN AC1, AND DELETES CHARS. PASSED OVER IF CHR=0.

MOVEIT:
	MOVE TAC1,LEPNT1(I)	;GET CURRENT POINTER.
	SETZB AC2,AC3
	POP P,DSER		;GET PTR. TO ARGUMENT.
	MOVEM AC1,1(P)		;REMEMBER COUNT.
	SKIPN CHR		; ARE WE DELETING?
	TLO I,NOBRBT		; YES, REDO THE LONG-LINE CRLF WHEN DONE
	TLZ I,XTABBT		; CLEAR TAB BIT
	JRST @(DSER)		;GO TO EITHER MVFOR OR MVBAK.

MVFOR:
	ILDB TAC,TAC1		;LOOK AT NEXT CHR.
	JUMPE TAC,.-1		;IGNORE NULLS.
	JUMPN CHR,MVA		;DON'T DELETE UNLESS CHR =0.
	DPB CHR,TAC1		;DELETE IT.
	JRST MVA
	
MVBAK:
	LDB TAC,TAC1		;LOOK AT CURENT CHR.
	JUMPN CHR,.+2		;DELETE IT IF APPROPRIATE,
	DPB CHR,TAC1
	ADD TAC1,[XWD 070000,0]	;DECREMENT POINTER.
	JUMPG TAC1,.+2
	SUB TAC1,[XWD 430000,1]
	JUMPE TAC,MVBAK		;IF CURRENT CHR. WAS NULL,GET ANOTHER.
MVA:
	CAIN TAC,11		;HAVE WE JUST ENCOUNTERED A TAB ?
	ADDI AC3,1		;YES.
	TRNN AC3,1		;ARE WE INSIDE A TAB ?
	JRST MVA1		; NO
	CAIN TAC,11		; YES, IS THIS A REAL TAB OR A LONG LINE CRLF?
	AOJA AC2,@(DSER)
	CAIN TAC," "
	JRST MVA2		; MUST BE A REAL TAB, SET THE BIT THAT SAYS SO
	SKIPE CHR		; IF WE ARE DELETING, WE MUST REPOSITION THE CRLF
	TLO I,NOBRBT		; DO SO BY PRETENDING THERE HAVEN'T BEEN ANY
	CAIE TAC,15		; BUMP COUNT ONE AT THE CR TO MAKE THE ENTIRE CRLF INVISIBLE
	JRST @(DSER)		; OTHERWISE, JUST LOOP AROUND
	TLNE I,XTABBT		; IF THIS IS A LONG LINE CRLF ONLY, THEN
	JRST @(DSER)
	SUBI AC1,1		; CORRECT COUNT
	AOJA AC2,@(DSER)

MVA1:
	TLZ I,XTABBT
	AOJL AC1,@(DSER)	; COUNT DOWN RPT. CNT AND LOOP.
	JUMPE AC3,.+2		;ALL DONE. DID WE PASS ANY TABS ?
	TLZ I,TABB!NOTABB	;YES. WE NO LONGER KNOW WHERE NEXT ONE IS.
	SUB AC2,1(P)		;ADD NO. OF CHRS. PASSED TO NO. OF SPACES IN TABS PASSED.
	SUBB AC2,AC3		;SUB. 2⊗NO. OF TABS. THIS (MIRABILE DICTU!) GIVES NO. OF COLUMNS MOVED.
	JRST 1(DSER)

MVA2:
	TLO I,XTABBT
	AOJA AC2,@(DSER)

INIT2:
	MOVE TAC,ACTMOD(DDB)	;GET SPECIAL BITS
	TRNN TAC,SUPCCR		;SUPPRESS CTRL CR?
	CAIE CHR,1B28!15	;HAS LOSER TYPED CTRL1 CR ?
	JRST INITIT		;NO. RESET EVERYTHING FOR NEW LINE.
	SKIPN LEPNT1(I)		; HAVE WE INITIALIZED AT LEAST ONCE?
	JRST INITIT		; NO, DO SO NOW.
	PUSHJ P,QLETXT		; QUEUE UP A TRANSFER IF DD
INIT4:
	HRLI I,400000!REEDBT!NOCRBT
	SETZM LCH(I)
	JUMPGE UCHN,INIT4B
	TLNE DAT,LERSEE
	TLO I,SHLDRB
				;LET LOSER EDIT PREVIOUS LINE SOME MORE.
INIT4B:
	MOVEI UUO,2		;PREPARE TO REMOVE THE CR LF FROM END OF LINE.
INIT4A:
	LDB TAC,LEPNT1(I)	;(WE DON'T WANT TO LET THE LOSER EDIT THEM. )
	MOVNI AC1,1		;TELL BACKSPACE ROUTINE TO DELETE ONE CHR.
	CAIE TAC,12		;IF IT IS A LF ...
	CAIN TAC,15		;... OR A CR ...
	PUSHJ P,CRKILL		;... THEN WE THROW IT OUT.
	SOJG UUO,INIT4A		;ALLOW FOR BOTH A LF AND A CR.
	DPB UUO,PLASTC
	TLZ I,NOTABB		;BS ROUTINE WILL HAVE SET THIS LOSER...
	SKIPN FCPOS(I)		;IS LINE EMPTY?
	TLO I,EOLBT		;YES, TELL SOMEONE PLEASE!!!!!
	SOJA P,INIT3		;RESET ONLY THE POINTER POSITION, AND RETURN UPLEVEL.

; THIS IS A ROUTINE FOR DELETING THE CRLF FROM THE END OF A LINE THAT
; WE GOT FROM PTLOAD OR <CTRL-1>CR.

CRKILL:
	ADDM AC1,FCPOS(I)	; DECREMENT THE TOTAL NUMBER OF CHARACTERS IN THE BUFFER
	TLZ I,NOCRBT
	SETZ CHR,		; FLAG DELETING OPERATION TO MOVEIT
	PUSHJ P,MOVEIT		; BACK THE POINTER UP, DELETING THE CRLF AS IT GOES
	MVBAK
	MOVEM TAC1,LEPNT1(I)	; STORE THE UPDATED POINTER
	POPJ P,

; THIS IS THE INITIALIZE ROUTINE. HERE WE INITIALIZE ALL THE LINE
; EDITOR VARIABLES

INITIT:
	MOVEI TAC,EOLCHR*2+1	;GET DPY CHAR. WORD WITH LINE TERMINATING CHR. IN IT.
	MOVEM TAC,LEBUF(I)	;PLACE IN FIRST WORD OF BUFFER.
	MOVEI TAC,LEB(I)	; PUT RETURN JUMP IN SECOND WORD
	HRLI TAC,DISJMP
	MOVSM TAC,LEBUF+1(I)
	SETZM FCPOS(I)		;NO. OF CHARS. IN LINE.
	HRLI I,EOLBT+400000
	SETZM LCH(I)
	MOVEI TAC,LEBUF(I)	;GET START OF LINE BUFFER.
	HRRZM TAC,LELWD(I)	;INIT. PTR. TO RETURN JMP.
INIT3:
	SETZM LEHPOS(I)		;HORIZONTAL POSITION.
	SETZM NUMARG(I)		; CLEAR THE REPEAT ARGUEMENT
	HLLM I,LETAB-DPYL0(DAT)	; STORE THE FLAG BITS BACK INTO THE LINE EDITOR TABLE
	SETZM CCPOS(I)		;CHARS. FROM START OF LINE.
	MOVE TAC,[LVW (12,-4,I,R,2,2)]
	MOVEM TAC,LEPPV(I)	;INITIAL POS. OF CURSOR.
	HRRZS LELMARG(I)	;RESET LEFT MARGIN.
INIT1:
	HRLI TAC,440700		;MAKE INITIAL BYTE PTR.
	HRRI TAC,LEBUF(I)
	MOVEM TAC,LEPNT1(I)
	POPJ P,

SHIFT:
	JUMPG DSER,SHIFTL	;OVER LEFT MARGIN ?
SHIFTR:
	SKIPA AC2,.+1		;SHIFT LINE RIGHT.
SHIFTL:
	MOVNI AC2,30		;SHIFT LINE LEFT.
	SKIPN III(I)		; ARE WE A DD DISPLAY?
	POPJ P,			; IF SO, DON'T SHIFT LINE OVER, CAUSE IT SCREWS UP DPHPOS
	HRRES DSER,AC2
	IMUL AC2,XDEL
	ADDM AC2,LELMARG(I)	;MOVE WHOLE LINE OVER.
	JRST SHIFT2		;SEE THE HAPPY RECURSIVE EDITOR !

↑LACTIV:TDZA UCHN,UCHN		;NO SPURIOUS CTRL BITS PLEASE.
PTLLX:
	PUSHJ P,STLNAC		;SETUP LINE!
	TLNN LINE,DISLIN!DDDLIN	;IF A DPY, XFER EDITOR BUFFER TO INPUT BUFFER NOW.
	POPJ P,			; IF NOT A DPY, RETURN NOW
	MOVE DAT,LINE
	SKIPGE I,LETAB-DPYL0(DAT)
	SKIPG CCPOS(I)
	POPJ P,			;NOTHING IN EDITOR BUFFER. FERGIT IT.
ACTIV1:
 JUMPGE I,CPOPJ		;POOLE AND HIS RECURSIVE CALLS ON ACTIV1 !
	TLC I,400000!WTFLAG	;READY FLAG OFF, WAIT FLAG ON.
	SETZ AC1,
	EXCH AC1,DPHOLD(I)
	JUMPE AC1,ACTNH		; IF NOT HOLDING, DON'T UNHOLD!
	HRRZ AC1,PRGNUM(I)
	ADD AC1,[XWD UNHOLD,DPYL0]
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
ACTNH:
	AOJG UCHN,.+2		;IS PTYSER PRE-LOADING US WITH A LINE TO EDIT ?	
	PUSHJ P,INIT4		;YOU BETCHUM, R.R.  DON'T ACTIVATE GUY.
	PUSHJ P,INIT1		;RESET LEPNT1.
	MOVEM UCHN,NTABPT(I)	;SAVE CTRL BITS OF ACTIVATION CHR.
	MOVE TAC,FCPOS(I)	;MAKE COPY OF NO. OF CHRS. IN BUFFER.
	TLZN I,REEDBT		;IS THIS A RE-EDIT ?
	JRST ACTNH0
	DPB UCHN,[POINT 2,CHR,28]
	SUBI CHR,200
	DPB CHR,[POINT 9,GWORD(I),35]
	DPB TAC,PLASTC		;YES. REMEMBER LINE LENGTH.
	MOVEI CHR,400
	TLZE I,SHLDRB	;IS loser looking over our shoulder ?
	PUSHJ P,LSRSEE	;Yes. Flag end of edit chrs.
ACTNH0:
	MOVEM TAC,NTABCT(I)
	HLLM I,LETAB-DPYL0(DAT)	; STORE NEW STATUS.
	HRLI DAT,ACTIV3		;DO THE DIRTY WORK AT CLOCK LEVEL.
;	JRST DPYTIM
;PATCH BY RPH TO TRANSFER AS MANY CHARS AS WILL FIT IN
;TTY BUFFER NOW!!!!!! NOT LATER AT CLOCK LEVEL
	PUSH P,DAT		;SAVE LINE NUMBER
	PUSHJ P,ACTIV3		;CALL HIM ONCE
	POP P,DAT		;GET BACK LINE NUMBER
	MOVE I,LETAB-DPYL0(DAT)	;AND BITS
	POPJ P,			;AND RETURN TO WHO EVER

ACTIV5:
	MOVEI UCHN,TTIBUF(DDB)	;GET POINTER FOR PUTCHI.
	HRRZ DDB,I		; PICK UP ADDRESS OF DPY PROGRAM HEADER
	SKIPN III(I)		; IS IT A DATA DISC DISPLAY?
	TLO DDB,400000		; YES, FLAG THAT FACT TO DPYTYO
ACTIVL:
	MOVEM UCHN,DAT		;GIVE PUTCHI A PTR. TO INPUT BUFFER.
	MOVEI TAC1,LEPNT1(I)	;TELL GETEM TO USE LEPNT1.
	PUSHJ P,GETEM		;GET NEXT CHR. FROM BUFFER.
	PUSHJ P,PUTCHI		;PLACE CHAR. IN TTY INPUT BUFFER.
	JRST ACTIV2		;INPUT BUFFER FULL. WAIT A WHILE.
	SOSN CCPOS(I)		;IS THIS THE ACTIVATION CHAR. ?
	SOSG TAC,NTABPT(I)	;YES. DOES IT HAVE CTRL. BITS ?
	JRST ACTIV6		;NO.
	DPB TAC,[POINT 2,CHR,28]
				;YES. PUT CTRL. BITS IN INPUT BUFFER.
	DPB CHR,PUTR(DAT)
	MOVEI CHR,13		;ECHO CTRL. BITS, IF ANY.
	TRNE TAC,CBIT1
	PUSHJ P,ECHOCB
	MOVEI CHR,14	
	TRNE TAC,CBIT2
	PUSHJ P,ECHOCB
ACTIV6:
	LDB CHR,LEPNT1(I)	;GET BACK DPY VERSION OF CHAR. CODE.
	PUSHJ P,ECHO		;ECHO IT ON PAGE PRINTER.
	SKIPE III(I)		;ARE WE A DD
	JRST ACTIVQ
	LDB CHR,LEPNT1(I)	;GET LAST CHR PUT OUT
	CAIN CHR,177		;IS IT A BS
	PUSHJ P,ECHO		;YES, ECHO TWICE FOR DD
ACTIVQ:
	SOSLE NTABCT(I)		;ALL CHRS. XFERED ?
	JRST ACTIVL

; WE GET HERE WHEN THE LINE EDITOR BUFFER IS EMPTY.
; WE CLEAN UP AND LEAVE.

	MOVEI DDB,LEB(I)	; YES, MAKE EDITOR BUFFER INVISIBLE BY PUTTING
	HRLI DDB,DISJMP		; A RETURN JUMP ON TOP OF THE POSITION VECTOR
	MOVSM DDB,LEPPV(I)
	HRLI I,0		;RESET STATUS BITS.
	TLZ	IOS,SYNC!DDTM	;DONT SCREW UP THE COUNT
ACTIV4:
	MOVEI DDB,-TTIBUF(UCHN)	;RECOVER DDB.
	PUSHJ P,STLNAC		;SET UP LINE.
	HLLM I,LETAB-DPYL0(LINE)	;RESET STATUS. 
	PUSH P,TISYNC(DDB)	;REMEMBER CURRENT ACTIVATION COUNT!
	PUSHJ P,SYNCHK		;UPDATE TISYNC
	POP P,TAC		;GET BACK ORIGINAL COUNT
	CAMGE TAC,TISYNC(DDB)	;DID SYNCHK ACTIVATE SOME MORE CHARS?
	JRST RECIN3		;YES, WAKE COMMAND DECODER!
	JRST RECIN4

ACTIV2:
	TLO IOS,SYNC!DDTM	;FORCE ACTIVATION
	PUSHJ P,ACTIV4		;GO ACTIVATE JOB.
	MOVE TAC,TTYTAB(LINE)
	TLNN TAC,400000		;DOES HE ALREADY HAVE A COMMAND WAITING?
	PUSHJ P,COMSET		;NO, SET HIM
	MOVE DAT,LINE
	POPJ P,

		;WE WILL GO TO ACTIV3 NEXT TIC.
↑ACTIV3:	;SET UP EVERYTHING AND GO BACK INTO LOOP.
	HRRZ LINE,DAT
	CAIL LINE,DPYL0
	CAIL LINE,DDL0+DDNUM
	POPJ P,
	MOVE I,LETAB-DPYL0(LINE)
	TLNN I,WTFLAG
	POPJ P,			; IF NOT DOING ANY TRANSFER, LEAVE
	SKIPN DDB,TTYTAB(DAT)
	JRST ACTIV7		;SOMEBODY HAS FLUSHED OUR DDB. QUIT NOW.
ACTIV9:
	MOVE IOS,DEVIOS(DDB)
	MOVE I,LETAB-DPYL0(LINE)
	JRST 2,@[ XWD 020000,ACTIV5]
				;SUPPRESS INCREMENTING OF NEXT ILDB.

; WE GET HERE IF THE DDB HAS BEEN EATEN FROM UNDERNEATH US
; WE TRY TO GET HIM A NEW DDB.

ACTIV7:
	CONO PI,SCNOFF
	SKIPE DDB,TTYTAB(DAT)	; SEE IF IT IS REALLY GONE?
	JRST ACTIV8		; NOT REALLY, GO TO IT
	PUSHJ P,DDBSRC		; GET HIM A DDB
	JRST ACTI10		; NONE AVAILABLE, REPLANT CLOCK REQUEST AND WAIT
	CONO PI,SCNON
	JRST ACTIV9

ACTIV8:
	CONO PI,SCNON
	JRST ACTIV9

ACTI10:
	CONO PI,SCNON
	JRST DPYTIM

ECHOCB:
	TRNN IOS,NOECHB		;IS USER SUPPRESSING ECHO OF CTRL. BITS ?
	TRNE IOS,NOECHO		;OR ALL CHARS?
	TLNE IOS,TPMON		;YES, MONITOR GETS THEM ANYWAY
	JRST DPYTYO		;ECHO BIT
	POPJ P,

ECHO:
	TLNE IOS,TPMON		; ALWAYS ECHO IN MONITOR MODE
	JRST DPYTYO
	TRNE IOS,NOECHO		;IS USER SUPPRESSING ALL ECHOING ?
	POPJ P,
	MOVE AC1,LCH(I)
	MOVEM CHR,LCH(I)
	CAIN CHR,12
	CAIE AC1,15
	JRST DPYTYO
	HRRZ AC1,PRGNUM(I)	; PICK UP TTY NUMBER
	MOVE AC1,LINTAB+DPYL0(AC1)	; FILL IN LINE CHARACTERISTICS
	TLNN AC1,XON		; LET THE LOSER TURN OFF LF AFTER CR IF HE WANTS TO
	JRST DPYTYO
	POPJ P,

↑PTLLED:			;IF WE'RE A DPY, WE WILL PRELOAD THE LINE EDITOR.
	TLNE LINE,IMLIN
	JRST IMLOAD
	TLNN LINE,DISLIN!DDDLIN
	POPJ P,
	HRRZS I,LETAB-DPYL0(LINE)
				;SET NTABCT AS SIGNAL TO KBDED (ACTIV1).
	XCTR	XR,[MOVE UUO,(UUO)]	;GET GUY'S PTR.
	TLNN UUO,-1		;IS IT ALREADY (PRESUMABLY) A BYTE PTR. ?
	HRLI UUO,440700		;NO. MAKE IT ONE.
PTLL2:
	XCTR	XLB,[ILDB CHR,UUO]	;GET CHR. FROM LOSER.
	MOVSI UCHN,-1		;FLAG TO KBDED SAYING IT'S US.
	JUMPE CHR,PTLLX		;IF NULL, QUIT AND RESET EDITOR.
	PUSHJ P,PTLL3		;FEED IT TO KBDED.
	TRNN UCHN,1		;DID KBDED SEE AN ACTIVATION CHR. ?
	JRST PTLL2		;NO. 
	POPJ P,			;RESET EDITOR AND GO AWAY.


; HERE IS WHERE WE QUEUE UP LINE EDITOR TRANSFERS

↑↑QLETXT: SETOM LETXC(I)		; NOTE THAT TEXT HAS CHANGED
QLECUR:
	SKIPE III(I)		; IF III, THIS IS IRRELEVANT
	POPJ P,
	SETO AC2,		; TEST THE FLAG
	EXCH AC2,LECLK(I)	; IS THERE A CLOCK REQUEST ALREADY IN?
	JUMPL AC2,CPOPJ		; IF SO, HE WILL GET IT.
	HRR AC1,I		; IF NOT, MAKE UP ONE WITH THE DPY HEADER ADDRESS IN IT
	HRLI AC1,DPLED		; AND USE THE LINE EDITOR ROUTINE
	CONO PI,PIOFF
	IDPB AC1,CLKQ
	CONO PI,PION
	POPJ P,

; THIS IS A ROUTINE THAT GOES THROUGH THE LINE AND SETS UP EXTRA CRLFS TO BREAK
; LONG LINES.

MAKECR:
	TLZ I,TABB!NOTABBT	; NEXT TAB IS UNKNOWN NOW
	TLNE I,400000		; IS IT REALLY THERE?
	SKIPE III(I)
	POPJ P,			; NOT THERE OR III
↑↑LEFIX:SETZ AC3,
	MOVE AC2,CURPP(I)	; PICK UP PAGE PRINTER CONTROL BLOCK ADDRESS
	MOVE AC1,PPHPOS(I)
	SUB AC1,LNLNGT(AC2)	;ROOM LEFT TO END OF LINE
	HRLI TAC,440700		; PICK UP BYTE POINTER TO BEGINNING OF BUFFER
	HRRI TAC,LEBUF(I)
	SETZM NCRS(I)		; INITIALIZE THE TRANSFER LENGTH COUNTER
MAKEC1:
	ILDB CHR,TAC		; PICK UP CHARACTER
	JUMPE CHR,.-1		; SKIP NULLS
	CAIN CHR,EOLCHR		; IF END OF BUFFER,
	JRST MAKEC6		; LEAVE
	CAIN CHR,11		; IS THIS A TAB?
	JRST MAKEC2		; YES, IT IS, GO PROCESS IT
	AOJL AC1,MAKEC7		; NORMAL CHARACTER, BUMP COLLUMN COUNT

; WE GET HERE IF THE LINE IS LONG AND MUST BE BROKEN UP.

MAKE12:
	MOVE AC1,TAC		; PICK UP BYTE POINTER
MAKE23:
	ILDB CHR,AC1		; LOOK AHEAD SOME
	JUMPE CHR,.-1
	CAIE CHR,11		; MAYBE THIS IS JUST THE LONG-LINE CRLF?
	JRST MAKE20		; APPARANTLY NOT, BUMP CR COUNT
	ILDB CHR,AC1		; PICK UP NEXT CHARACTER
	JUMPE CHR,.-1
	CAIE CHR,15		; IF THIS IS A CR, IS DEFINITELY A LONG-LINE CRLF
	JRST MAKE21
MAKE22:
	ILDB CHR,AC1		; IN WHICH CASE, READ PAST IT
	CAIE CHR,11
	JRST MAKE22
	JRST MAKE23

MAKE20:
	CAIE CHR,EOLCHR		; IF THERE ARE NO MORE CHARACTERS ON NEXT LINE, DON'T BUMP LINE COUNT
MAKE21:
	AOS NCRS(I)		; END OF LINE, BREAK THE LINE UP
	MOVEI CHR,11		; END OF LINE, BREAK LINE
	PUSHJ P,MAKINS
	MOVEI CHR,15
	PUSHJ P,MAKINS
	MOVEI CHR,12
	PUSHJ P,MAKINS
	MOVEI CHR,11
	PUSHJ P,MAKINS
	MOVN AC1,LNLNGT(AC2)	; RESET COLUMN COUNT
MAKEC8:
	MOVE TAC1,TAC		; SAVE POINTER
MAKEC9:
	ILDB CHR,TAC1		; IS NEXT CHARACTER A NULL?
	JUMPN CHR,MAKEC7	; NO, ALL OK
	MOVE TAC,TAC1		; YES, SPACE POINTER OUT PAST NULLS
	JRST MAKEC9

MAKEC7:
	ADDI AC3,1		; BUMP COLUMN COUNT
MAKE10:
	CAMN AC3,CCPOS(I)	; IS THIS WHERE THE POINTER IS SUPPOSED TO BE?
	MOVEM TAC,LEPNT1(I)	; YES, STORE IT
	JRST MAKEC1

; HERE WE SEE IF THE TAB IS A REAL TAB OR IF IT IS JUST
; THE THING WE USE TO DELIMIT A LONG-LINE CRLF

MAKEC2:
	MOVE TAC1,TAC		; SAVE BYTE POINTER
	ILDB CHR,TAC		; PICK UP NEXT CHARACTER
	CAIE CHR,15		; IS IT A CR?
	JRST MAKEC3		; NO, MUST BE REGULAR TAB, GO ADJUST IT
	SETZ DSER,
	DPB DSER,TAC1		; YES, ZERO OUT THE LONG LINE CRLF
	DPB DSER,TAC
	IDPB DSER,TAC
	IDPB DSER,TAC
	JRST MAKE10

MAKEC6:
	SETZ CHR,		; ZERO OUT STUFF AFTER END OF LINE CHARACTER
MAKE17:
	LDB TAC1,[POINT 6,TAC,5]
	CAIG TAC1,7		; IS THERE ANY MORE ROOM IN THE LAST TEXT WORD
	JRST MAKE18		; NO, SET UP LELWD AND LEAVE
	IDPB CHR,TAC		; YES, PLOP DOWN A ZERO THERE
	JRST MAKE17

MAKE18:
	HRRZ TAC1,TAC		; GET BARE ADDRESS OF LAST TEXT WORD IN BUFFER
	EXCH TAC1,LELWD(I)	; STORE IT AND GET THE OLD VALUE
	MOVE AC1,1(TAC1)	; PICK UP THE RETURN JUMP
	MOVEM AC1,1(TAC)	; PUT IT RIGHT AFTER THE END OF LINE CHARACTER
	POPJ P,

; WE GET HERE WHEN THE TAB SURROUNDS A BUNCH OF SPACES. FIRST WE
; DELETE THE ORIGINAL SPACES, THEN WE FIGURE OUT HOW MANY WE NEED
; TO MAKE THE TAB COME OUT RIGHT AND PUT THEM IN.

MAKEC3:
	PUSH P,AC3		; SAVE BYTE POINTER
	PUSH P,UUO		; GET AN ACCUMULATOR FOR COUNTING SPACES IN TABS
	SETZB DSER,UUO
MAKEC4:
	DPB DSER,TAC		; ZERO OUT THE SPACES IN THE TAB
	CAIN CHR," "		; COUNT IT AS A SPACE ONLY IF IT REALY IS A SPACE
	ADDI UUO,1		; BUMP NUMBER OF SPACES IN THIS TAB
	ILDB CHR,TAC
	CAIE CHR,11		; UNTIL WE GET TO THE TERMINATING TAB
	JRST MAKEC4
	MOVE TAC,NCRS(I)	; FIGURE OUT POSITION FROM BEGINNING OF FIRST LINE
	ADDI TAC,1		; BUMP BY ONE TO CORRECT FOR NEGATIVITY OF AC1
	IMUL TAC,LNLNGT(AC2)	; MULTIPLY NUMBER OF LINES BY LENGTH OF LINES
	ADD TAC,AC1		; ADD IN CHARACTERS INTO LAST LINE
	MOVEM TAC,LECHPS(I)	; SAVE FOR FUTURE REFERENCE
	ANDI TAC,7		; MOD 10
	MOVEI AC3,10
	SUB AC3,TAC		; THIS IS NUMBER OF COLUMNS TO GO
	ADD AC1,AC3		; ADD LENGTH OF TAB INTO COLUMN POSITION
	SUBM AC3,UUO		; GET CORRECTION TO THIS TAB
	JUMPLE AC1,MAKE13	; IF NOT AT END OF LINE, GO ON AND ADJUST TAB
	MOVE TAC,TAC1		; GET POINTER TO TAB
	MOVEI CHR," "		; NOW SPACE OUT TO END OF LINE
MAKE16:
	CAML AC1,AC3		; OUT FAR ENOUGH?
	JRST MAKE15		; YES, PUT IN CRLF NOW
	PUSHJ P,MAKINS		; NO, PUT IN ANOTHER SPACE
	SOJA AC3,MAKE16

; AT THIS POINT, WE ARE IN THE PROCESS OF BREAKING A LONG LINE
; IN THE MIDDLE OF A TAB. WE HAVE JUST INSERTED THE APROPRIATE
; NUMBER OF SPACES TO FILL OUT THE LAST LINE, AND NOW WE
; MUST INSERT THE CRLF ITSELF.

MAKE15:
	MOVEI CHR,15
	PUSHJ P,MAKINS		; BREAK LINE IN THE MIDDLE OF A TAB
	MOVEI CHR,12
	PUSHJ P,MAKINS
	AOS NCRS(I)		; UPDATE NUMBER OF CRLFS IN LINE
	MOVE TAC1,TAC		; SAVE BYTE POINTER TO TAB
	MOVE AC3,AC1		; NUMBER OF SPACES IS NUMBER OF CHARACTERS INTO LINE
	SUB AC1,LNLNGT(AC2)	; RESET COLUMN COUNT
MAKE13:
	MOVE TAC,LECHPS(I)	; PICK UP NUMBER OF CHARACTERS FROM FIRST LINE
	CAMGE TAC,LEHPOS(I)	; ARE WE BEFORE THE HORIZONTAL POSITION POINTER?
	ADDM UUO,LEHPOS(I)	; YES, UPDATE IT
MAKE14:
	POP P,UUO
	MOVE TAC,TAC1		; GET BYTE POINTER BACK
	MOVEI CHR,40
	PUSHJ P,MAKINS		; INSERT THAT MANY SPACES
	SOJG AC3,.-1
	LDB CHR,TAC		; NOW UPDATE POINTER TO PAST TAB
MAKEC5:
	CAIN CHR,11
	JRST MAKE11		; THEN GET BACK INTO THE LOOP
	ILDB CHR,TAC		; NOT TAB, GET NEXT CHARACTER
	JRST MAKEC5

MAKE11:
	POP P,AC3		; RESTORE COLUMN COUNT
	JUMPGE AC1,MAKE12	; IF WE GOT LINE OVERFLOW, BREAK LINE UP
	JRST MAKEC8

MAKINS:
	ILDB TAC1,TAC		; IS THIS CHARACTER A NULL?
	JUMPE TAC1,.+2
	PUSHJ P,LEINSW		; NO, INSERT A WORD OF NULLS
	DPB CHR,TAC		; DEPOSIT OUR CHARACTER OVER A NULL
	POPJ P,

BEND LINED
BEND TTYSER
;: LINED[J17,SYS] EOF.
;: SPWSER[J17,SYS]
COMMENT ⊗   VALID 00008 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN SPWSER 
	 SUBTTL	 SPACEWAR SERVICE
C00003 00003	 ROUTINE TO KILL 2-PROCESSOR SPACE WAR FOR JOB N
C00006 00004	 ENTER HERE FROM UUOCON TO SET UP A SPW JOB
C00010 00005	 BASIC LEVEL SPW CLOCK AND RUN ROUTINES
C00013 00006	 HERE, WE KNOW THIS JOB IS RUNABLE. NOW, IS IT TIME TO RUN?
C00017 00007	 INTERRUPT LOCATIONS FOR BOTH PROCESSORS
C00021 00008	 WE GET HERE ON ERROR IN SPW MODE JOB OR DISMISS
C00024 ENDMK
C⊗;

BEGIN SPWSER 
	 SUBTTL	 SPACEWAR SERVICE
; JAM. STANFORD, 8-NOV-68

AP2CHL←CAT(P2CH,\APRCHN)

; INITIALIZE ALL SPACEWAR TABLES

↑SPWINI:
	SETZM	SPWGO			; ZERO OUT P1 SPW TABLE
	MOVE	TAC,[XWD SPWGO,SPWGO+1]
	BLT	TAC,JBTST2+JOBN-1	;CLEAR SPWGO,SP2GO,JBTST2

	SYNINI SPWCSC

	CONI	404,SPWBUT		; SET UP SPW BUTTONS
	SETZM	SPWACT			; KILL SPW JOB COUNT
	SETZM	SPWUUF			;NOT AT SPACEWAR LEVEL ON EITHER PROCESSOR
	SETZM	SPWUUF+P2PID
	SETZM	SPWTMO			;AND INITIALLY, NO TIMEOUT ACTIVE
	SETZM	SPWTMO+P2PID
	POPJ	P,

; ROUTINE TO KILL 2-PROCESSOR SPACE WAR FOR JOB N
; CALLING . . .
;	MOVE	J,JOB		; GET JOB NUMBER IN ITEM
;	PUSHJ	P,KILSPW	; KILLS SPACEWAR, SAVES AC'S

↑KILSPW:PUSH P,TAC
	MOVSI TAC,SPWSNB
	PUSHJ P,CLRSIN		; CLEAR ANY SPACEWAR SWAPIN REQUEST
	POP P,TAC
	PUSH	P,TAC1
	PSYNC	SPWCSC		; GET CONTROL OF SPW CELLS
	SKIPN	JBTST2(J)	; IS A JOB ACTIVE HERE?
	JRST	KILSP1
IFN FTSTAT,<
	PUSH P,TAC
	MOVEI TAC,SPWSTA+7700
	PUSHJ P,STAPUT
	POP P,TAC
>;FTSTAT
	SKIPE	SPWGO(J)	;DOES HE HAVE A P1 SPW JOB
	PUSHJ	P,P1REL		;RELEASE SPW ON PDP 10
	SKIPE	SP2GO(J)	;AND P2
	PUSHJ	P,P2REL		;RELEASE SPW ON PDP 6
	SETZM	JBTST2(J)
KILSP1:
	XSYNC	SPWCSC
	POP	P,TAC1
	POPJ	P,

P1REL:
	SETZ	TAC1,
	MOVE	TAC,TAC1
	LDB	TAC1,[POINT 6,SPWGO(TAC),5]
	CAME	TAC1,J
	JUMPN	TAC1,.-3
	JUMPE	TAC1,CPOPJ
	LDB	TAC1,[POINT 6,SPWGO(J),5]
	DPB	TAC1,[POINT 6,SPWGO(TAC),5]
	SETZM	SPWGO(J)
	SOS	SPWACT
	POPJ	P,

P2REL:
	SETZ	TAC1,
	MOVE	TAC,TAC1
	LDB	TAC1,[POINT 6,SP2GO(TAC),5]
	CAME	TAC1,J
	JUMPN	TAC1,.-3
	JUMPE	TAC1,CPOPJ
	LDB	TAC1,[POINT 6,SP2GO(J),5]
	DPB	TAC1,[POINT 6,SP2GO(TAC),5]
	SETZM	SP2GO(J)
	SOS	SPWACT
	POPJ	P,

OFSPW:
	PUSHJ	P,KILSPW		;HERE IF HE GOOFS.
	JSP	TAC,UUOMES
	ASCIZ	 /ATTEMPT TO INITIATE SPW JOB WITH ONE ALREADY RUNNING
UUO/

; ENTER HERE FROM UUOCON TO SET UP A SPW JOB
; CALL FROM UUOCON:
;	MOVE	UCHN,[MODE-BITS,,TICKS]
;	MOVE	UUO,[ANYTHING,,STARTING ADDRESS]

↑SPWCON:
	MOVE	J,JOB(PID)		; GET CURRENT JOB NUMBER
	MOVEI	TAC,(UUO)		;GET STARTING ADDRESS
	JUMPN	UCHN,SPW0		;ZERO TICKS?
	CAIN	TAC,'SSW'		;STOP CODE?
	JRST	KILSPW			;YES, STOP SPACEWAR
SPW0:
	CAIGE	TAC,140			;ABOVE JOB DATA AREA?
	JRST	UADRER			;GIVE HIM ADDRESS CHECK FOR STARTING ADR
	XCTR	XR,[MOVE TAC,(TAC)]	;ADDRESS CHECK HIS STARTING ADDRESS
				;HERE, P2 IS ALIVE.
	TLNN	UCHN,200000	;REQUESTING PDP-6?
	JUMPL	UCHN,SPW1	;NO, HOW ABOUT PDP-10?
	SKIPE	SP2GO(J)	;IS THERE ALREADY A JOB RUNNING HERE?
	JRST	OFSPW		;YES, HE GOOFED
SPW4H:
	SKIPL	PALIVE+P2PID	;IS THE PDP-6 REALLY THERE?
	JRST	SPW4G
	TLNN	UCHN,200000	;WAS HE REALLY SURE ABOUT USING THE SIX?
	JRST	SPW1		;NO, TRY THE TEN
	JUMPN	PID,SPW4G
	MOVEI	TAC,[ASCIZ /
HUNG DEVICE:	PDP-6
/]
	PUSHJ	P,HNGMES
	JRST	SPW4H

SPW4G:
	AOS	SPWACT
IFN FTSTAT, <
	HRRZ TAC,UCHN
	LSH TAC,6
	TRO TAC,SPWSTA+4000	;FLAG PDP-6
	PUSHJ P,STAPUT
>;FTSTAT
	PSYNC	SPWCSC		; GET CONTROL OF JBTST2
	MOVSI	DAT,SPWRUN
	TLNE	UCHN,40000	;SUPPRESS TIMEOUT?
	MOVSI	DAT,SPWRUN!SPWNT2	;YES. SET TIMEOUT SUPRESSION BIT TOO
	IORM	DAT,JBTST2(J)	; MARK US AS RUNNING
	TSO	UCHN,SP2GO	; COPY FIRST LINK INTO UCHN (RIGHT)
	DPB	J,[POINT 6,SP2GO,5]	;NEW FIRST LINK
	HRLM	UCHN,SP2GO(J)	;DO THIS STUFF NOW TOO
	HRRM	UUO,SP2GO(J)
	XSYNC	SPWCSC		; RELEASE CONTROL OF JBTST2
	JUMPGE	UCHN,CPOPJ	;IS HE REQUESTING IT TO BE RUN ON THE PDP-10 ALSO?

SPW1:
				;HERE FOR P1 SPACEWAR
	SKIPE	SPWGO(J)	; IS THERE ALREADY A JOB THERE?
	JRST	OFSPW		; YES, GO SHOOT HIM!
	AOS	SPWACT		; WE HAVE ONE MORE SPW JOB NOW
IFN FTSTAT, <
	HRRZ TAC,UCHN
	LSH TAC,6
	TRO TAC,SPWSTA		;FLAG PDP-10
	PUSHJ P,STAPUT
>;FTSTAT
	PSYNC	SPWCSC		; GET CONTROL CELLS
	MOVSI	DAT,SPWRUN	; INDICATE THAT A JOB IS RUNNING
	TLNE	UCHN,100000	;P1 TIMEOUT SUPRESSION?
	MOVSI	DAT,SPWRUN!SPWNT1	;YES. SET TIMEOUT SUPRESSION BIT
	IORM	DAT,JBTST2(J)	; PUT IN 'RUNNING' BIT
	TSO	UCHN,SPWGO
	DPB	J,[POINT 6,SPWGO,5]
	HRLM	UCHN,SPWGO(J)	; PUT JIFFIES IN LH
	HRRM	UUO,SPWGO(J)	; PUT ADDRESS IN RH
	XSYNC	SPWCSC
	POPJ	P,

; BASIC LEVEL SPW CLOCK AND RUN ROUTINES
; FIRST, ACCUMULATOR RE-DEFINITIONS
AC←DEVDAT
GO←DAT
A←DSER
B←UCHN
C←UUO
D←PROG
; REGISTER AC CONTAINS THE ADDRESS OF THE PROCESSOR'S AC STORAGE TABLE
; REGISTER GO CONTAINS SPWGO OR SP2GO, DEPENDING ON WHERE WE ARE

↑SPWP2:	MOVEI	AC,SPWB		; LOAD UP AC WITH P2 STORAGE TABLE ADDRGSS
	MOVEI	GO,SP2GO	; AND P2 RUN TABLE
	JRST	SPWPP

↑SPWP1:	MOVEI	AC,SPWA		; AC STORAGE FOR P1
	MOVEI	GO,SPWGO	; APPROPRIATE RUN TABLE
SPWPP:
	PUSH	P,JOB(PID)	;SAVE SO WE CAN RUN SPW UUOS.
	SETOM	SPWUUF(PID)	; FLAG SPW LEVEL.
	HRLI	GO,J		; INDEX SPWGO BY JOB NUMBER
	MOVEI	J,0		; START AT FRONT
SPWPP3:
	PSYNC	SPWCSC
	LDB	J,[POINT 6,@GO,5]	; LINK
	JUMPN	J,SPWPP2		; DISPATCH IF NON-ZERO
	XSYNC	SPWCSC
	POP	P,JOB(PID)
	MOVE	J,JOB(PID)	; PUT JOB NUMBER UP
	MOVE	A,JBTADR(J)	; GET PROT-RELOC FOR JOB WE INTERRUPTED
	MOVEM	A,JOBADR(PID)	;YES.
	HLRZM	A,USRREL(PID)
	SETZM	SPWUUF(PID)
	JUMPE	J,CPOPJ		;DON'T RESTORE PROT-RELOC FOR JOB 0
	PUSHJ	P,GETPR		;GET JOB'S PROT-RELOC
	DATAO	APR,TAC		;SET PR
	POPJ	P,		;END OF LOOP, GO HOME

SPWPP2:
	MOVE	D,@GO		;GET LATEST COPY OF SPW WORD
	TRNE	D,-1		;IS HE BEING FLUSHED?
	SKIPL	A,JBTST2(J)	;IS THIS JOB RUNNABLE?
	JRST	SPWPP5		;NO, EXIT NOW
	JUMPN	PID,SWPP2B	;JUMP IF P2
	TLNN	A,SPWST1	;IS HE SUSPENDED SOMEHOW?
	JRST	SPWPP4		;NO, GO RUN HIM
	SKIPE	SP2GO(J)	;IS HE RUNNING ON P2 TOO?
	JRST	SPWPP5		;YES THEN LET ONLY P2 COUNT THE SUSPENSION.
	ADDI	A,1		;INCREMENT THE SUSPENSION COUNT.
SWPP2A:
	HRRM	A,JBTST2(J)	;STORE NEW SUSPENSION COUNT.
	JRST	SPWPP5		;RELEASE CELLS AND CONTINUE SCAN.

SWPP2B:
	TLNN	A,SPWST2	;SUSPENDED ON P2?
	JRST	SPWPP4		;NO.RUN THIS ONE.
	AOJA	A,SWPP2A	;COUNT THE SUSPENSION

SPWPP9:
	DPB	A,[POINT 4,D,13];UPDATE COUNT
	MOVEM	D,@GO		;REPLACE IN CONTROL WORD
SPWPP5:
	XSYNC	SPWCSC
	JRST	SPWPP3

; HERE, WE KNOW THIS JOB IS RUNABLE. NOW, IS IT TIME TO RUN?

SPWPP4:
	LDB	A,[POINT 4,D,13]	; PICK UP SPW COUNT
	LDB	B,[POINT 4,D,17]	; PICK UP SPW TIME
	JUMPE	B,[JUMPN A,SPWPP9	;ZERO TICKS HE HAS RUN ONCE.
		AOJA	A,SPWPP0]	;RUN HIM HIS ONE TIME.
	CAIGE	A,-1(B)			;WILL IT BE TIME WHEN WE INCREMENT A?
	AOJA	A,SPWPP9		;NOT TIME YET. INCREMENT AND REPLACE.
	SETZ	A,			; YES, ZERO COUNT AND RUN JOB
SPWPP0:
	DPB	A,[POINT 4,D,13]
	MOVEM	D,@GO
	MOVE	B,JBTST2(J)	; GET STATUS REGISTER
	HLLZS	JBTST2(J)	; NOW ZERO ERROR DELAY COUNT
	TLNE	B,SPWSUS	; SHOULD WE WARN HIM OF AN IMPENDING DELAY?
	JRST	SPWPP6		; YES
	HRRZ	B,B		; COUNT OF TICKS WHILE SUSPENDED.
	JRST	SPWPP8		; RUN HIM.
SPWPP6:
	JUMPE	PID,.+2		; COME HERE IF WE MUST GIVE A WARNING
	TLOA	B,SPWSU2	;TURN ON SUSPENSION WARNING FLAG P2
	TLO	B,SPWSU1	;TELL JOB A SUSPENSION IS INDICATED P1
	MOVEM	B,JBTST2(J)	; REPLACE JOB STATUS
	MOVNI	B,1		; PUT WARNING IN B
SPWPP8:
	MOVSI	A,SPWNT1	;TIMEOUT SUPRESSION BIT (P1)
	JUMPE	PID,.+2
	MOVSI	A,SPWNT2	;TIMEOUT SUPRESSION BIT(P2)
	TDNN	A,JBTST2(J)	;SKIP IF TSB IS ON
	MOVEI	A,JIFSEC/2	;TIMEOUT IS HALF A SECOND
	HRRZM	A,SPWTMO(PID)	;STORE THE TIMEOUT WORD
	MOVE	A,[JRST 2,@UUO0]
	ADDI	A,(PID)
	MOVEM	A,SPWXCT(PID)	;SET UP THE UUO EXIT INSTRUCTION
				;WHICH IS CLOBBERED BY CH3 ON TIMEOUTS
	XSYNC	SPWCSC
	HRRZ	A,AC
	BLT	A,17(AC)	; BLT THEM INTO SPWA OR SPWB
	SETZM	A(AC)		; AND ZERO OUT ACCUMULATOR A IN CORE
	HRRZ	17,D		; GET JOB STARTING ADDRESS
	HRLI	17,4000		; PUT IN IOT USER MODE BIT
	PUSHJ	P,GETPR		; GET HIS PR
	DATAO	APR,TAC
	MOVE	2,JBTADR(J)	; GET HIS PROTECTION-RELOCATION
	TLZ	2,1777		; ZERO OUT THESE BITS FOR PDP-10
	MOVE	1,SPWBUT	; GET SPACEWAR BUTTONS FOR HIM

	MOVN	15,J		;
	MOVSI	2,400000
	LSH	2,(15)
	JUMPN	PID,.+2
	DATAO	PI,2		;TURN ON MI WITH JOB NUMBER.

	SETOM	STIME(J)	;FLAG THAT CORE IMAGE HAS BEEN RUN (I.E. MODIFIED)
	MOVE	15,J		; SAVE JOB NUMBER
	MOVE	2,JBTADR(J)	; RESTORE TRUE PROT-REL
	MOVE	7,JOBRL2(PROG)	; UPPER TOO
	MOVE	6,JBTSTS(J)
	MOVE	3,B		; GET FLAG REGISTER
	MOVEI	4,1
	SKIPE	PID
	MOVEI	4,2
	SETZM	5
	SKIPN	P2NUM
	JRST	SIXDED
	JUMPN	PID,SIXTST
	SKIPGE	PALIVE+P2PID
	SETOM	5
	JRST	3,@17
SIXTST:
	SKIPGE	PALIVE+P1PID
SIXDED:
	SETOM	5
	JRST	3,@17

; INTERRUPT LOCATIONS FOR BOTH PROCESSORS

↑SPWINT:
	CONI	APR,A
	TRNE	A,ILM
	TLO	A,ILMSPW
	TRNE	A,NXM
	TLO	A,NXMSPW
	TRNE	A,POV
	TLO	A,POVSPW
	CONO	APR,531110+APRCHN	; CLEAR ANY CONCEIVABLE ERROR
	HRR	A,APRCHL		; GET LOCATION OF ERROR
	MOVEM	A,SPWA+A		; SET INTO SAVED ACCUMULATOR
	MOVE	PID,[P1PID]
	JRST	10,SPWUUX		; TREAT AS A UUO

↑SPWERR:
	MOVE	J,JOB(PID)
	MOVE	A,UUOPC(J)
	SKIPN	PID
	HRRZM	A,SPWA+A
	SKIPE	PID
	HRRZM	A,SPWB+A
↑SPWXIT:		;COME HERE ON DISMIS UUO(SEE US BE SNEAKY)!
	MOVE	P,SPWA+P
	SKIPE	PID
	MOVE	P,SPWB+P
	AOBJP	P,.+1		;GET OLD UUOPC (SAVED BY SPWUUO)
	POP	P,UUOPC(J)	; RESTORE UUO-LEVEL PC WORD
	JRST	SPWUUX

↑SP2INT:
	CONI	APR,A
	TRNE	A,ILM
	TLO	A,ILMSPW
	TRNE	A,NXM
	TLO	A,NXMSPW
	TRNE	A,POV
	TLO	A,POVSPW
	TRNE	A,CNS
	TLO	A,CNSSPW
	CONO	APR,531110+APRCHN	; CLEAR APR ERROR
	HRR	A,AP2CHL		; GET LOCATION OF ERROR
	MOVEM	A,SPWB+A
	MOVE	PID,[P2PID]
	JRST	10,SPWUUX

↑SPWUUO:
;THE FOLLOWING 2 INST. PREVENT UUO'S FROM SPACEWAR--RPH 12-26-71
;	SKIPL	@UUOLOC(PID)
;	JRST	SPWUUX
	JUMPN	PID,SPWUUX	;NO UUO'S ON 6 GODDAMMIT!
	MOVE	J,J+SPWA	;GET JOB NO. OF SPW JOB.
	SKIPE 17,UUOPTR(J)	;MUST CHECK THIS HERE SO WE DON'T DO TESTS ON UUO
	JRST SPWUU3
SPWUU1:
	SKIPE	17,@UUOLOC(PID)	;STOP ON 0
	CAMN	17,[CALL]	;OR CALL WITH 0 ADR
	JRST	SPWUUX
	HLRZ	17,17
	CAIN	17,(<JRST 4,>)	;OR HALT
	JRST	SPWUUX
;	SKIPE	PID
;	MOVE	J,J+SPWB
SPWUU2:
	MOVEM	J,JOB(PID)	;PUT WHERE UUOCON WILL SEE IT.
	MOVE	PROG,JBTADR(J)	;ALSO RELOCATION.
	MOVEM	PROG,JOBADR(PID)
	HLRZM	PROG,USRREL(PID)
	MOVE	P,SPWA+P	;GET A PDL FOR UUOCON.
;	SKIPE	PID
;	MOVE	P,SPWB+P
	PUSH	P,UUOPC(J)	; AND SAVE THE OLD UUO PC WORD
	MOVE	DAT,UUO0(PID)	; PICK UP RETURN
	MOVE	UUO,@UUOLOC(PID)	; AND UUO ITSELF
	JRST	UUOSY1		;LET UUOCON HANDLE IT.

SPWUU3:
	XCTR	XR,[SKIPN SPWBLK+1(17)]	;IF SIMULATOR IS ENABLED FOR SPACEWAR,
	XCTR	XR,[SKIPN SPWBLK+2(17)]	;WE'LL BYPASS THE DISMISSAL TESTS
	JRST	SPWUU1
	JRST	SPWUU2

↑SPTMOE:				;HERE IN EXEC MODE IN CH7 FOR TIME-OUT
	MOVEI	PID,0			;ASSUME PDP-10
	CONSO	APR,MAOFF		;SKIP IF WE ARE THE PDP-10
	MOVEI	PID,P2PID		;PDP-6
	MOVSI	A,ILLTMO		;SET TIMEOUT BIT
	HRR	A,SPWBLO(PID)		;LOOK AT HOW WE WERE SHOT DOWN
	SKIPE	PID
	MOVEM	A,SPWB+A		;STORE EVIL BITS
	SKIPN	PID
	MOVEM	A,SPWA+A
	JRST	SPWUUX			;PRETEND UUO

; WE GET HERE ON ERROR IN SPW MODE JOB OR DISMISS

↑SPWUUX:
	MOVSI	17,SPWA		; RESTORE P1 ACCUMULATORS
	SKIPE	PID
	MOVSI	17,SPWB		; RESTORE P2 ACCUMULATORS
	BLT	17,17
	JUMPE	A,SPWUU0	; NO ERRORS, SCAN FOR NEXT JOB.
	PSYNC	SPWCSC
	HLLZS	@GO		; ERROR, KILL THIS JOB
	TLO	A,SPWERB	; ADD ERROR BIT TO THOSE ALREADY THERE
	MOVEM	A,JBTST2(J)	; MOVE IN ERROR BIT
	XSYNC	SPWCSC
SPWUU0:
	JRST	2,@[SPWPPB]

SPWPPB:
	PSYNC	SPWCSC
	SKIPN	@GO
	JRST	SPWPPC
	LDB	A,[POINT 4,@GO,17]	;GET HIS TIME FIELD 
	JUMPN	A,SPWPPC
	JUMPN	PID,SPWPPD
	PUSHJ	P,P1REL			;ZERO TICKS. RELEASE P1 SPACEWAR
	SKIPE	SP2GO(J)
	JRST	SPWPPC
	JRST	SPWPPE
SPWPPD:
	PUSHJ	P,P2REL			;ZERO TICKS. RELEASE P2 SPACEWAR
	SKIPN	SPWGO(J)
SPWPPE:
	SETZM	JBTST2(J)		;ZERO THIS IF NOT SPW ACTIVE ON OTHER P.
SPWPPC:
	MOVE	A,JBTST2(J)		;PICK UP JOB STATUS
	JUMPN	PID,SPWPPF
	MOVSI	D,SPWST1		;P1 SUSPEND BIT
	SKIPN	SP2GO(J)		;IS THERE SPACEWAR ON P2 ALSO?
	MOVSI	D,SPWST1!SPWST2		;NONE ON P2. GET BOTH PROC. SUSP BITS.
	TLZE	A,SPWSU1		;HAS WARNING BEEN GIVEN?
	TDO	A,D			;YES, SUSPEND THIS JOB
	TLC	A,SPWST1!SPWST2		;ARE BOTH NOW SUSPENDED?
	TLCN	A,SPWST1!SPWST2		;
	TLZ	A,SPWSUS		;BOTH NOW SUSPENDED, CLEAR SUSPENSION REQ.
	MOVEM	A,JBTST2(J)		; AND REPLACE JOB STATUS
	XSYNC	SPWCSC
	JRST	SPWPP3
SPWPPF:
	MOVSI	D,SPWST2		;P2 SUSPEND BIT.
	SKIPN	SPWGO(J)
	MOVSI	D,SPWST1!SPWST2
	TLZE	A,SPWSU2		;HAS SUSPENSION WARNING BEEN GIVEN?
	TDO	A,D			;YES. SET SUSPENSION.
	TLC	A,SPWST1!SPWST2		;ARE BOTH NOW SUSPENDED?
	TLCN	A,SPWST1!SPWST2		;
	TLZ	A,SPWSUS		;BOTH NOW SUSPENDED, CLEAR SUSPENSION REQ.
	MOVEM	A,JBTST2(J)		;STORE JOB STATUS
	XSYNC	SPWCSC
	JRST	SPWPP3
BEND SPWSER
;: SPWSER[J17,SYS] EOF.
;: TVSER[J17,SYS]
COMMENT ⊗   VALID 00007 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN TVSER 
 SUBTTL	TV CAMERA SERVICE ROUTINE - J.SAUTER, 1/21/67
C00003 00003	IFE FTDISK,<
C00006 00004	IFN FTDISK,<
C00007 00005	TVINP:	XCTR	XR,[HRRZ AC1,(UUO)]	ADDRESS CHECK THE COMMAND BLOCK
C00009 00006	↑TVRED:	MOVEI	DDB,TVDDB			HERE FROM FBPACK
C00012 00007	
C00013 ENDMK
C⊗;

BEGIN TVSER 
 SUBTTL	TV CAMERA SERVICE ROUTINE - J.SAUTER, 1/21/67

TVINI:
	CONO	IOP,0		;STOP THE 167.
	CONO	404,0		;AND THE CAMERA
	POPJ	P,		;AND RETURN.


IFE FTDISK,<

	JRST	TVINI		;INITIALIZE
	JRST	HUNG		;HUNG: PRINT MESSAGE & STOP JOB.
↑TVDSP:	JRST	TVINI		;RELEASE
	JRST	TVINI		;CLOSE
	JSP	DAT,UERROR	;INPUT
	JSP	DAT,UERROR	;OUTPUT
	JRST	CPOPJ1		;ENTER
	JRST	CPOPJ1		;LOOKUP
	JSP	DAT,UERROR	;DUMP OUTPUT
	JRST	TVIN		;DUMP INPUT
	POPJ	P,		;SETO
	POPJ	P,		;SETI
	POPJ	P,		;GETF
	JRST	CPOPJ1		;RENAME
	POPJ	P,		;CLOSE INPUT
	POPJ	P,		;DIRECTORY CLEAR
	POPJ	P,		;MTAPE

TVIN:
	HRRZ	TAC,UUO
	CAMLE	TAC,USRREL	;IS ADDRESS LEGAL?
	JRST	ADRERR		;NO.
	HRRZ	TAC,@UUO	;GET FIRST WORD 
	HLRO	DAT,@UUO
	SUB	TAC,DAT		;CALC FINAL ADDRESS
	CAMLE	TAC,USRREL	;IN BOUNDS?
	JRST	ADRERR		;NO.
	MOVEI	TAC,IOPANY!IOPJDN;YES. DO HIS OP FOR HIM.
	HRRM	TAC,TVINT
	MOVE	TAC,@UUO
	ADDI	TAC,0(PROG)	;MAKE ABS ADDR.
	MOVEM	TAC,TVDAT	;SAVE FOR LATER
	MOVEI	TAC,@UUO	;GET ABS ADDR OF DATA HEADER.
	MOVE	TAC1,1(TAC)	;CONO TO 404.
	HRRM	TAC1,CON404	;SAVE IT.
	MOVEI	TAC1,2(TAC)	;DATAO TO 404
	HRRM	TAC1,DAT404	;SAVE IT TOO.
	ADDI	TAC,3
	HRRM	TAC,TVCONI	;SET UP THE CONI BACK TO USERS CORE
	PUSHJ	P,SETACT
	MOVE	TAC,[CLKDES,,1]
	CONO	PI,PIOFF
	IDPB	TAC,CLOCK
	CONO	PI,PION
	POPJ	P,		;RETURN TO UUOCON.

CLKDES:
	CONO	PI,PIOFF	;TURN OFF PI SYSTEM WHILE WE FIDDLE
	CONO	IOP,TVCHN
	DATAO	IOP,TVDAT
CON404:
	CONO	404,0		;FIXED UP.
DAT404:
	DATAO	404,0		;ALSO FIXED UP.
	CONO	PI,PION		;NOW LET IT FLY!
	POPJ	P,		;RETURN TO CLOCK.

↑TVINT:	JSR	TVSAV		;SAVE ACS
TVCONI:
	CONI	IOP,.		;GETS FIXED UP.
HUNG:
	PUSHJ	P,TVINI		;SHUT OFF THE 167 AND CAMERA
	MOVEI	DDB,TVDDB
	MOVE	IOS,DEVIOS(DDB)
	TLZE	IOS,IOW
	PUSHJ	P,SETIOD	;SET I/O DONE.
	JRST	CLRACT		;CLEAR I/O ACTIVE BIT, RESTORE AC'S & DISMISS

TVDAT:
	0
>;END IFE FTDISK

IFN FTDISK,<
	JRST	TVINI		;INITIALIZE
	JRST	HUNG		;HUNG TV CAMERA
↑TVDSP:	POPJ	P,		;RELEASE.
	POPJ	P,		;CLOSE OUTPUT
	JSP	DAT,UERROR	;OUTPUT
	JSP	DAT,UERROR	;INPUT
	JRST	CPOPJ1		;ENTER
	JRST	CPOPJ1		;LOOKUP
	JSP	DAT,UERROR	;DUMP OUTPUT
	JRST	TVINP		;DUMP INPUT
	POPJ	P,		;USETO
	POPJ	P,		;USETI
	POPJ	P,		;UGETF
	JRST	CPOPJ1		;RENAME
	POPJ	P,		;CLOSE INPUT
	POPJ	P,		;UTPCLR
	POPJ	P,		;MTAPE

TVINP:
	XCTR	XR,[HRRZ AC1,(UUO)]	;ADDRESS CHECK THE COMMAND BLOCK
	XCTR	XR,[MOVE TAC1,3(UUO)]	;ADDRESS CHECK THE END.
	XCTR	XR,[MOVE TAC1,(AC1)]	;ADDRESS CHECK FIRST DATA LOCATION.
	XCTR	XR,[HLRO TAC1,(UUO)]	;GET -SIZE OF TRANSFER
	CAIG	AC1,JOBPFI		;ABOVE AREA PROTECTED FROM I/O?
	JRST	UADRER			;NO. ADDRESS ERROR.
	SUB	AC1,TAC1		;CALCULATE THE END OF THE TRANSFER.+1
					;ADDRESS CHECK IS DONE BELOW.
	SETOM	DSKCNT(DDB)		;FLAG WE ARE THE TV CAMERA (SEE DSKSER)
	HLRZ	TAC1,PROG		;GET LOWERS PROTECTION.
	CAIL	TAC1,(UUO)		;MAKE SURE COMMAND BLOCK IS IN LOWER
	CAMGE	TAC1,AC1		;MAKE SURE DATA IS IN THE LOWER TOO.
	JRST	UADRER			;ADDRESS ERROR.
	MOVEI	TAC,@UUO		;GET ADDRESS OF COMMAND BLOCK
	MOVEM	TAC,DSKBUF(DDB)		;STORE ADDRESS OF COMMANDS. FOR TVRED
	HRLZ	TAC1,DDB	;SET UP FOR MONITOR QUEUE
	TLO	TAC1,400000	;FLAG AS INPUT.
	PUSHJ	P,SETACT	;YES, LOCK INTO CORE FIRST
	JRST	FBTVIN		;THEN GO TO FAST-BAND SERVICE FOR QUEUEING

↑TVRED:	MOVEI	DDB,TVDDB			;HERE FROM FBPACK
	MOVE	TAC1,DSKBUF(DDB)

;HERE FROM MONGO WITH IOP OURS AND ADDRESS OF USERS 4
;WORD COMMAND BLOCK IN TAC1.  WE MAY BE AT UUO LEVEL
;IF MONITOR BUFFER WAS EMPTY WHEN WE CALLED TVIN, OR WE
;MAY BE AT INTERRUPT LEVEL, IF WE GOT HERE THROUGH THE
;SUCCESSFUL COMPLETION OF THE PREVIOUS DISK OP.

	LDB	J,PJOBN
	HRRZ	J,JBTADR(J)	;RELOCATION
	ADD	J,0(TAC1)	;RELOCATE CORE ADDRESS
	MOVEI	TAC,IOPANY!IOPJDN;CONSO BITS FOR IOP.
	CONO	PI,DSKOFF	;JUST IN CASE.
	CONO	IOP,TVCHN	;GIVE IOP ITS CHANNEL AND
				;SET IT UP FOR INPUT.
	DATAO	IOP,J		;FEED IT WC,MA (ABSOLUTE).
	CONO	TV,@1(TAC1)	;SEE TV INTERFACE WRITEUP.
	DATAO	TV,2(TAC1)
	HRRM	TAC,TVCON
	CONO	PI,DSKON
	POPJ	P,

HUNG:
	AOSA (P)		;SET SKIP RETURN SO JOB WON'T BE KILLED.
↑TVINT:	JSR	TVSAV		;SAVE ACS, SET UP PDL.
TVIN1:
	MOVEI	DDB,TVDDB
	MOVE	TAC,DSKBUF(DDB)
	CONI	IOP,3(TAC)	;GIVE USER IOP STATUS
	MOVE	TAC1,3(TAC)	;GET STATUS FOR US TOO.
	MOVE	IOS,DEVIOS(DDB)	;GET IOS
	TRNE	TAC1,IOPANY	;ANY IOP ERROR BITS?
	TRNN	IOS,100		;ENABLED FOR THIS DATA?
	JRST	TVIN2		;NO ERRORS OR NOT ENABLED FOR ERRORS
	LDB	J,PJOBN
	DATAI	IOP,IOS		;GET THE IOP WCMA
	HRRZ	IOS,IOS
	HRRZ	TAC1,JBTADR(J)	;GET THE USER'S ADDRESS
	SUB	IOS,TAC1	;USER'S RELATIVE ADDRESS. 
	HRLM	IOS,3(TAC)	;GIVE USER HIS ADDRESS.
TVIN2:
	CONO	IOP,0
	HLLZS	TVCON
	MOVEI	IOS,IOACT	; FIRST, CLEAR THE ACTIVE BIT
	ANDCAB	IOS,DEVIOS(DDB)
	TLNE	IOS,IOW		; NOW, BRING HIM OUT OF IO WAIT
	PUSHJ	PDP,SETIOD
	JRST	FBDFINT		; NOW TO FAST-BAND SERVICE TO BE DEQUEUED
>
BEND TVSER
;: TVSER[J17,SYS] EOF.
;: ADSER[J17,SYS]
COMMENT ⊗   VALID 00006 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN ADSER 
 SUBTTL ADSER  A/D SERVICE ROUTINE - J. SAUTER, STANFORD, 25-FEB-68
C00003 00003	SYSTEM INITIALIZATION OF AD
C00005 00004	INPUT/OUTPUT UUOS
C00009 00005	HERE AT P1 CLOCK LEVEL. READY TO TELL P2 TO START.
C00011 00006	HUNG:	SETOM	ADERR
C00013 ENDMK
C⊗;

BEGIN ADSER 
 SUBTTL ADSER  A/D SERVICE ROUTINE - J. SAUTER, STANFORD, 25-FEB-68


DEFINE CAT!(A,B),<A!B>
ADCHL←CAT(CH,\ADCHN)

	JRST	ADSET		;INITIALIZE
	JRST	HUNG		;HUNG: PRINT MESS & STOP JOB.
↑ADDSP:	POPJ	P,		;RELEASE
	POPJ	P,		;CLOSE
	JSP	DAT,UERROR	;BUFFERED OUTPUT
	JSP	DAT,UERROR	;BUFFERED INPUT
	JRST	CPOPJ1		;ENTER
	JRST	CPOPJ1		;LOOKUP
	JRST	ADOUT		;DUMP OUTPUT (REALLY DAC)
	JRST	ADIN		;DUMP INPUT
	POPJ	P,		;USETO
	POPJ	P,		;USETI
	POPJ	P,		;UGETF
	JRST	CPOPJ1		;RENAME
	POPJ	P,		;CLOSE INPUT
	POPJ	P,		;UTPCLR
	POPJ	P,		;MTAPE


;SYSTEM INITIALIZATION OF AD
ADSET:
	MOVEI	TAC,40+<ADCHN*2>	;ASSUMED LOCATION OF PI CHANNEL WORDS
	SKIPN	TAC1,P2NUM		;IS P2 ACTIVE?
	MOVE	TAC1,P1NUM		;NO. 
	TLNE	TAC1,MAOFF		;IS THIS P IN MA OFFSET?
	ADDI	TAC,100			;YES: ADD OFFSET.
	MOVEM	TAC,ADBLK		;STORE LOCATION OF BLKI/O INSTRUCTION
	MOVE	TAC1,[JSR CH1] ;;replaced;;CAT(CH,\ADCHN)]	;LOAD JSR FOR P1.
	SKIPE	P2NUM				;ARE WE USING P2?
	MOVE	TAC1,[JSR P2CH1] ;;replaced;;CAT(P2CH,\ADCHN)]	;YES. LOAD JSR FOR P2
	MOVEM	TAC1,1(TAC)		;STUFF IT INTO SECOND PI LOCATION
	MOVEM	TAC1,ADJSR		;AND SAVE THE INSTRUCTION HERE
	ADDI	TAC,1
	MOVEM	TAC,ADJSRL		;POINTER TO THE JSR TO INTERRUPT ROUTINE.
	SETZM	ADBKO
	SETZM	ADADV
	POPJ	P,

;INPUT/OUTPUT UUOS
ADIN:
	TLZA	IOS,IO			;CLEAR IO AND SKIP
ADOUT:
	TLOA	IOS,IO			;SET IO AND SKIP
	SKIPA	TAC,[BLKI DCB,ADBKO]	;FOR INPUT GET BLKI AND SKIP.
	MOVE	TAC,[BLKO DCB,ADBKO]	;FOR OUTPUT, GET BLKO
	MOVEM	TAC,@ADBLK		;STORE BLKI/O IN FIRST PI LOCATION
	HRRZ	TAC,UUO			;NOW ADDRESS CHECK
	CAMLE	TAC,USRREL
	JRST	ADRERR			;COMMAND WORD OUT OF BOUNDS.
	HRRZ	TAC,@UUO		;GET FIRST IOWD.
	HLRO	DAT,@UUO
	SUB	TAC,DAT			;IS FINAL ADDRESS IN BOUNDS?
	CAMLE	TAC,USRREL
	JRST	ADRERR			;NO.
	MOVE	TAC,@UUO		;YES.
	ADDI	TAC,(PROG)		;FORM ABSOLUTE ADDRESS.
	MOVEM	TAC,ADBKX		;STORE AS THE BLKO/I WORD
	MOVEI	TAC,@UUO		;GENERATE ABSOLUTE ADDRESS
	MOVE	TAC1,1(TAC)		;CONO TO 136.
	ANDCMI	TAC1,7			;REMOVE HIS PI NUMBER...
	IORI	TAC1,ADCHN		;AND INSERT OURS
	HRRZM	TAC1,ADLOC3		;PUT WHERE IT WILL BE HIT.
	HRRZ	TAC1,2(TAC)		;CONO TO 424.
	HRRZM	TAC1,ADLOC4		;REMEMBER IT LIKEWISE.
	MOVEI	TAC1,3(TAC)		;CONI FROM 136.
	HRRZM	TAC1,ADLOC1		;TO BE REMEMBERED
	MOVEI	TAC1,4(TAC)		;CONI FROM A/D.
	HRRZM	TAC1,ADLOC2		;LIKEWISE.
	PUSHJ	P,SETACT		;MARK A/D IN USE AND STOP JOB.
AD2:
	MOVEI	DDB,ADDDB
	MOVE	IOS,DEVIOS(DDB)
	LDB	TAC,PIOMOD		;GET MODE.
;	CAIN	TAC,SD			;MODE 15?	- FLUSHED 8/7/73
;	POPJ	P,			;YES. RETURN.	- 
	TRNE	IOS,100			;CONTINUOUS MODE ?
	JRST	FOO			;YES.
	CAIN	TAC,D			;17?
	SKIPA	TAC,[CLOC3,,1]		;YES. JUST WAIT ONE JIFFIE.
WT:
	MOVE	TAC,[CLOC2,,3]		;NO. GET CLOCK DESCRIPTOR.
	CONO	PI,PIOFF
	IDPB	TAC,CLOCK		;ENTER CLOCK REQUEST
	CONO	PI,PION
	POPJ	P,			;RETURN TO UUOCON.

FOO:
					;CONTINUOUS MODE.
	MOVE	TAC,[JSR AD2INT]	;MAKE INTERRUPT GO TO RIGHT PLACE.
	MOVEM	TAC,@ADJSRL
	HRRZM	TAC,ADADV		;PREPARE TO GET JOB RESTARTED AT ONCE.
	SKIPL	ADBKO			;IS OUTPUT ALREADY GOING ON ?
	JRST	CLOC3			;NO. START IT. JOB WILL GO ON SINCE ADADV>0.
	MOVE	TAC,ADBKX		;YES. SAVE PTR. FOR NEXT BUFFER.
	MOVEM	TAC,ADADV		;ADADV ALSO SERVES AS A FLAG (SEE ADP1).
	POPJ	P,

;HERE AT P1 CLOCK LEVEL. READY TO TELL P2 TO START.
CLOC2:
	CONSO	TV,1B28			;IS BUTTON BEING PUSHED?
	JRST	WT			;NO. WAIT ANOTHER 3 TICKS
CLOC3:
	SETZM	ADERR
	MOVE	TAC,ADBKX		;GET BLKI/O WORD.
	MOVEM	TAC,ADBKO
	SETOM	ADACT			;TELL P2 TO START RUNNING
	SKIPE	P2NUM			;IF THERE'S NO P2, WE DO IT OURSELVES.
	POPJ	P,			;WAIT FOR P2 CLOCK LEVEL TO START IT.
↑ADP2:	MOVE	TAC,ADACT		;HERE FROM P2 CLOCK LEVEL (OR P1 IF NO P2)
	JUMPE	TAC,CPOPJ		;P2 DOESN'T SKIPN ON 2 PROCESSOR CELLS.
	SKIPE	ADERR			;ERRORS YET?
	JRST	AD6			;YES. GO BLAST IT
	SETZM	ADACT			;CLEAR CLOCK LEVEL REQUEST FLAG
	CONO	AD,4000			; STOP IT IF IT IS RUNNING
	MOVEI	TAC,20			; WAIT FOR IT
	SOJG	TAC,.
	CONO	ADC,0			; KILL NEW AD-DA IF RUNNING
	CONO	DAC,0			; OTHERWISE, WILL LOOP WITHOUT JSR P2CH1
	MOVSI	TAC,(<JRST>)
	HLLM	TAC,ADJMP		; MAKE US JUMP TO APPROPRIATE ROUTINE
	CONO	DCB,@ADLOC3
	CONO	AD,@ADLOC4
	CONO	PI,ADON
	POPJ	P,

;HERE TO STOP THE AD
AD6:
	CONO	DCB,200000		;BLAST THE 136.
	CONO	AD,4000			;AND THE A/D
	CONO	PI,ADOFF		;TURN OFF A/D CHANNEL.
	MOVSI	TAC,(<JFCL>)
	HLLM	TAC,ADJMP		; KILL AD INTERRUPT JUMP
	MOVE	TAC,ADJSR		;MAKE INTERRUPTS GO TO NORMAL PLACE.
	MOVEM	TAC,@ADJSRL
	SETZM	ADBKO			;NO XFER IN PROGRESS.
	POPJ	P,			;AND RETURN.

HUNG:
	SETOM	ADERR
	SETOM	ADACT
	SETZM	ADBKO
	JRST	AD5

↑ADINT:					;BLKO OVERFLOWED
	JSR	@ADSAV			;SAVE ACCUMULATORS.
	CONI	DCB,@ADLOC1		;CONI FROM 136.
	CONI	AD,@ADLOC2		;AND FROM A/D.
	PUSHJ	P,AD6			;KILL A/D AND 136.
	HRRZM	P,ADADV
	SKIPE	P2NUM			;ARE WE ON P2?
	POPJ	P,			;YES. RETURN

;IN CLKSER WE HAVE:	SKIPL	ADADV
;			PUSHJ	P,ADP1
↑ADP1:	SETZM	ADADV			;HERE AT P1 CLOCK LEVEL (OR IF NO P2)
	SKIPE	ADERR			;ERRORS?
	POPJ	P,			;YES.
AD5:
	MOVEI	DDB,ADDDB
	MOVE	IOS,DEVIOS(DDB)
	TLZE	IOS,IOW
	PUSHJ	P,STTIOD
	SKIPL	ADBKO			;IS XFER STILL IN PROGRESS ?
	TRZ	IOS,IOACT		;NO. LET JOB BE SWAPPED AND SHUFFLED.
	MOVEM	IOS,DEVIOS(DEVDAT)
	POPJ	P,

BEND ADSER
;: ADSER[J17,SYS] EOF.
;: MAIL[J17,SYS]
COMMENT ⊗   VALID 00004 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN  MAIL 
	SUBTTL MAIL SERVICE.
C00005 00003	WRCV:	PUSHJ	P,SRCV
C00006 00004	 ROUTINE TO GET THE JOB NUMBER OF THE ADDRESSEE
C00008 ENDMK
C⊗;

BEGIN  MAIL 
	SUBTTL MAIL SERVICE.

↑UMAIL:	CAILE	UCHN,MAXMAIL		;AC FIELD IN BOUNDS?
	JRST	UUOERR			;NO LOSE.
	HRRZ	AC1,UUO			;GET THE EFFECTIVE ADDRESS
	CAML	AC1,USRREL(PID)		;IS THIS INSIDE OF USER'S MAXIMUM?
	JRST	UUOERR			;NO LOSE.
	JRST	@MALTBL(UCHN)		;DISPATCH TO APPROPRIATE ROUTINE

DEFINE UUOS{FOR X IN(SEND,WRCV,SRCV,SKPME,SKPHIM,SKPSEN)}
; UUOMAC MALTBL,MAIL
MALTBL:
0+SEND
0+WRCV
0+SRCV
0+SKPME
0+SKPHIM
0+SKPSEN
UUOCNT←←.-MALTBL
MAIL UUOCNT-1,UUOLNK
↑↑UUOLNK←←.
SIXBIT/SEND/
SIXBIT/WRCV/
SIXBIT/SRCV/
SIXBIT/SKPME/
SIXBIT/SKPHIM/
SIXBIT/SKPSEN/

MAXMAIL←←UUOCNT-1
ORG SKPSEN
SKPSEN:
	JSP	AC3,GETJOB		;THIS JSP MUST BE LABELED SKPSEN
	JRST	SEND1			;ADDRESSEE EXISTS, BEHAVE LIKE "SEND" UUO
SEND:
	JSP	AC3,GETJOB		;DAT ← JOB# OF RECEIVING JOB
SEND1:
	SKIPE	JBTMAIL(DAT)		;DOES THIS GUY HAVE MAIL ALREADY?
	POPJ	P,			;YES. CAN'T DO IT.
	XCTR	XR,[HRRZ TAC,1(UUO)]	;GET THE ADDRESS OF THE MAIL BLOCK
	MOVEI	AC1,37(TAC)		;GET ADDRESS OF LAST WORD.
	CAMLE	AC1,USRREL(PID)		;GOD FORBID HE SHOULD SEND MAIL FROM UPPER.
	JRST	ADRERR
	MOVEI	AC3,40
	PUSHJ	P,UFSGET
	HRRZM	AC1,JBTMAIL(DAT)
	ADDI	TAC,(PROG)
	HRL	AC1,TAC
	MOVE	AC2,AC1
	BLT	AC1,37(AC2)
	MOVEI	J,(DAT)	
	MOVM	TAC,JOBQUE(J)		; WAKE HIM UP IF HE IS IN IOWQ
	SKIPG	JBTSTS(J)		; IF NOT RUNNABLE, DON'T REQUE HIM
	CAIE	TAC,IOWQ
	JRST	NOWAKE
	MOVEI	TAC,RUNQ
	MOVNM	TAC,JOBQUE(J)
	PUSHJ	P,REQUE
NOWAKE:
	MOVSI	AC1,INTMAIL		; IS HE ENABLED FOR A MAIL INTERRUPT?
	AOS	(P)			;SET UP SUCCESS RETURN FROM SEND
	TDNN	AC1,JBTIEN(J)
	POPJ	P,			;NO RETURN QUICK
	IORM	AC1,JBTIRQ(J)		; YES, GIVE HIM THE INTERRUPT.
	SETOM	INTREQ(PID)
	JRST	WSCHED			;SHUT US OFF TO GET THE INTERRUPT PROCESSED.

WRCV:
	PUSHJ	P,SRCV
	TROA	AC1,IOWQ
	POPJ	P,
	MOVNM	AC1,JOBQUE(J)
	PUSHJ	P,WSCHED
	JRST	WRCV

SRCV:
	SKIPN	AC1,JBTMAIL(J)
	POPJ	P,
	SETZM	JBTMAIL(J)
	HRL	TAC,AC1
	HRRI 	TAC,@UUO
	MOVEI	TAC1,37(TAC)
	BLT	TAC,(TAC1)
	PUSHJ	P,FSGIVE
	JRST	CPOPJ1

SKPME:
	SKIPA	DAT,J
SKPHIM:
	JSP	AC3,GETJOB
	SKIPN	JBTMAIL(DAT)
	POPJ	P,
	JRST	CPOPJ1


; ROUTINE TO GET THE JOB NUMBER OF THE ADDRESSEE

↑FNDJOB:				;A ROSE BY ANY OTHER NAME, ETC.
GETJOB:
	MOVE	DAT,@UUO		;GET USER'S ARGUMENT
	TDNN	DAT,[-1,,777700]	;IS IT A NAME?
	JRST	GJ1			;NO THIS IS A NUMBER
	MOVSI	TAC,-JOBN		;SEARCH ALL JOB NAMES.
	CAME	DAT,JOBNAM(TAC)		;IS THIS ONE?
	AOBJN	TAC,.-1			;NOT A MATCH. LOOP.
	JUMPGE	TAC,GJERR		;JUMP IF NO NAMES
	MOVE	TAC1,TAC		;CONTINUE SCAN. LOOK FOR ANOTHER
	AOBJP	TAC1,GJ2		;TEST AT TOP OF LOOP. JUMP WHEN DONE
	CAME	DAT,JOBNAM(TAC1)	;SAME NAME?
	JRST	.-2			;NO. LOOP.
	MOVEI	TAC,GTGARP		;PICKUP THE AMBIGUOUS NAME ERROR MESSAGE
	JRST	GJERR1			;GO TO ERROR STUFF

GJ2:
	MOVEI	DAT,(TAC)		;GET JOB NUMBER.
GJ1:
	MOVE	TAC,JBTSTS(DAT)		;GET JOB STATUS
	TLNE	TAC,JNA			;IS THIS JOB SLOT ASSIGNED?
	JRST	(AC3)			;YES. RETURN WITH JOB NUMBER IN DAT
GJERR:
	MOVEI	TAC,GTGAR1		;GET ADDRESS OF ERROR ROUTINE
GJERR1:
	HRRZ	AC3,AC3			; FIND OUT WHO CALLED GETJOB
	CAIN	AC3,SKPSEN+1		; WAS IT SKPSEN UUO?
	JRST	CPOPJ2			; YES, TERMINATE THE UUO
	PUSHJ	P,HNGMES		; NO, COME BACK WHEN HE TYPES CONTINUE
	JRST	GETJOB			; 

GTGAR1:
	ASCIZ/
?NON-EX JOB NAME OR NUMBER
 /

GTGARP:
	ASCIZ /
?AMBIGUOUS  JOB NAME
/
BEND MAIL
;: MAIL[J17,SYS] EOF.
;: PATCH[J17,SYS]
COMMENT ⊗   VALID 00002 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	FORCE OUT THE LITERALS (XLISTED FOR YOUR READING PLEASURE)
C00004 ENDMK
C⊗;

;FORCE OUT THE LITERALS (XLISTED FOR YOUR READING PLEASURE)
	XLIST	;FOR CRISSAKE SAVE 100 PAGES OF PAPER
	LIT
	LIST
	CHKEND←←.	;END OF CHECKSUMMED REGION.
	VAR

;PATCH - PATCH AREA FOR T. S. MONITOR

;THIS PROGRAM SHOULD BE LOADED AFTER LAST NEEDED PROGRAM
;BUT BEFORE SYSMAK,EXEC DDT,USER DDT, AND ONCE
ORG PATCH ;; skip over 1818 words of space for LIT and VAR
↑PATCH:	BLOCK 100
;: PATCH[J17,SYS] EOF.
;: SYSMAK[J17,SYS]
COMMENT ⊗   VALID 00002 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN SYSMAK -- MAKE NEW SYSTEM FROM OLD.
C00005 ENDMK
C⊗;

BEGIN SYSMAK -- MAKE NEW SYSTEM FROM OLD.
SUBTTL SYSMAK - J. SAUTER, STANFORD, 11-FEB-68, NEW SYSTEMS FOR OLD!

;SYSMAK RUNS IN THE OLD SYSTEM AND CREATES A NEW ONE
;ON TOP OF ITSELF.  WHEN THE SYSTEM IS HALTED AND STARTED
;AT LOCATION 202 (SEE FIRST) CONTROL IS 
;TRANSFERRED TO SYSMAK.  THIS ROUTINE ASSUMES THAT JOB 1
;IS A CORE IMAGE TO RUN IN EXEC MODE.
;IT BLT'S THE PROGRAM DOWN (FROM 140 THROUGH 77777) SO
;THAT IT MAY RUN IN EXEC MODE, AND HALTS.  THE VARIOUS
;INCOMPATABILITIES BETWEEN USER AND EXEC DDT ARE TAKEN
;CARE OF AS WELL.


↑SYSMAK:
	SETZM	41		;TRY TO KILL THE 6
	SETZM	46
	SETZM	SIXRUN
	MOVEI	1,100000
	SOJG	1,.		;GIVE IT A CHANCE TO DIE
	HRRZ	1,JBTADR+1	;GET RELOCATION FOR JOB 1
	JUMPE	1,SYSBUG	;NOT THERE?
	MOVE	2,JOBSYM(1)	;GET HIS SYMBOL TABLE POINTER.
	MOVEM	2,DDTSYM	;PUT WHERE EXEC DDT WILL SEE IT.
	MOVSI	10,(<BLT 3,0>)
	HRR	10,JOBREL(1)
	HRRZM	10,DDTMEM	;SET INITIAL MEMORY LIMIT
	MOVSI	3,140(1)
	HRRI	3,140
	MOVSI	11,(<SETZM>)
	HRRI	11,1(10)	;ZERO FIRST LOC AFTER THE LAST MOVED BY BLT.
	MOVSI	4,1(10)
	HRRI	4,2(10)		;BLT AC
	MOVE	12,RMEMSIZ	;CLEAR ALL OF CORE
	SUBI	12,2		;EXCEPT THE LAST WORD (BLT WITH EA=-1 LOSES)
	HRLI	12,(<BLT 4,0>)
	MOVSI	13,(<JRST 4,>)
	HRR	13,JOBSA(1)	;MAKE 11=HALT STARTING ADDRESS.
	JRST	10		;BLOCK IT DOWN.

SYSBUG:
	DATAO	CTY,[7]
	HALT	SYSMAK		;LET HIM TRY AGAIN

	LIT
ORG MAKEND ;; LIT space
↑MAKEND:
BEND SYSMAK
;: SYSMAK[J17,SYS] EOF.
;: DDT[J17,SYS]
COMMENT ⊗   VALID 00066 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00006 00002	SWITCHES:
C00009 00003	COMF←←200000	COMMA TYPED FLAG
C00010 00004	RIGHT HALF FLAGS
C00012 00005	DEFINE DEVICES
C00013 00006	BREAK POINT LOGIC
C00014 00007	BCOM:	0
C00016 00008	SAVE:	0		SAVE THE ACS AND PI SYSTEM
C00019 00009	XEC0:	MOVEM T,TEMDDT
C00020 00010	IFN EDDT&1,<STARTA:	0>	START ADDRESS FROM PAPER TAPE
C00022 00011	TBLK:	0
C00023 00012	IFN FTDSWP&EDDT&1,<
C00026 00013	INITIALIZE SWAPPING DDT!!!
C00028 00014	GETDDT   CALLED FROM SAVE TO GET DDT INTO CORE!
C00032 00015	GETBAK   CALLED FROM RESTORE TO UPDATE SYMBOL TABLE AND GET USER CORE BACK!
C00035 00016	DDTREAD   CALLED FROM GETDDT TO READ DDT AND SYMBOL TABLE FROM DISK
C00037 00017	SETSYM   CALLED TO READ OR WRITE SYMBOL TABLE
C00039 00018	SETBUF   CALLED FROM EXAMINE & DEPOSIT TO READ OR WRITE 32 WORDS OF USER CORE
C00041 00019	EXAMINE & DEPOSIT ROUTINES FOR SWAPPING DDT!
C00043 00020	DDT STARTS HERE
C00047 00021		MOVE T,SYL
C00049 00022	RET:	MOVEI P,PS
C00051 00023	NUM:	ANDI T,17		T HOLDS CHARACTER
C00055 00024	POWER:	TLNN F,FEF
C00056 00025	PERIOD:	MOVE	T,LLOC		PERIOD ( . ) SEEN.  USUALLY THIS IS CURRENT LOCATION
C00058 00026	EVAL0:	HRLOI W1,37777+DELI
C00065 00027	SIXBI1:	PUSHJ P,TEXIN     INPUT TEXT (SIXBIT)
C00067 00028	TAG:	TLNN F,LTF    NO LETTERS IS ERROR
C00069 00029	SETNAM:	SYMTST
C00072 00030	RPRN:	TLNN F,QF		)
C00073 00031	REGISTER EXAMINATION LOGIC
C00077 00032	LTAB:	MOVSS T		SWAP HALVES FIRST
C00079 00033	MODE CONTROL SWITCHES
C00082 00034	GO AND EXECUTE LOGIC
C00086 00035	IXCT4:	IFE EDDT&1,<	SUBI T,041
C00089 00036	IPUSHJ:	DPB W1,[POINT 4,CPUSHP,12]	STORE AC FIELD INTO A PUSH
C00091 00037	ALL $B COMMANDS OF FORM <A>$<N>B
C00093 00038	FETCH AND DEPOSIT INTO MEMORY
C00097 00039	FIRARG:	MOVEM T,DEFV
C00101 00040	CONSYM:	MOVEM T,LWT
C00103 00041	HLFW:	PRINT AS HALF WORDS
C00106 00042	MASK:	TLNE F,QF
C00108 00043	SEAR3:	PUSHJ P,FETCH
C00110 00044	SETUP:	TROA F,R20F	FOR ZERO ONLY
C00112 00045	TOCC:	TRO F,EQF	SET TO REAL NUMERIC MODE
C00115 00046	FLOATING POINT OUTPUT
C00117 00047	FP7:	JUMPE A,FP7A2
C00119 00048	IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG
C00120 00049	IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG
C00122 00050	IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG
C00124 00051	IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG
C00126 00052	IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG
C00128 00053	CRN:	MOVEI T,15		CARRIAGE RETURN
C00129 00054	IFN EDDT&1,<
C00132 00055	IFE EDDT&1,<
C00135 00056	BDISP:	POINT 12,DISP(R),11
C00137 00057	FLGOUT:	SKIPN R,FLGPNT
C00140 00058		JRST DDT
C00142 00059	DESCRIPTION OF OP DECODER FOR DDT:
C00145 00060	41(8)-72(8)      THE ALPHABET IS ENCODED INTO THIS RANGE.
C00149 00061	OP DECODER
C00153 00062	BEGIN OPDEFS
C00159 00063	PNTR:	INST	POINTER TO BITS IN INST
C00161 00064	DECT:	TRNE F,OUTF
C00164 00065	PATCH:	BLOCK 10
C00165 00066	IFN UEDDTS,<
C00175 ENDMK
C⊗;

;SWITCHES:
;	NONE FOR NORMAL, USER DDT
;	UEDDTS←←1 FOR USER EXEC DDT
;	EXEC DDT SETTINGS:
;		EDDT&1=0		ASSUME UDDT
;		EDDT&2=2		ASSUME EDDT WITH PAPER TAPE
;		EDDT&10=10		ASSUME PDP-10 PAPER TAPE INSTEAD OF PDP-6
;		EDDT&20=20		ASSUME SYSTEM EXEC DDT AND COMPILE SPECIAL CODE!
;		EDDT&40=40		MAKE RELOCATABLE EXEC DDT
;		IF LEFT HALF OF EDDT IS NOT=0, DO A LOC<EDDT>B53

IFNDEF FTDDT,<FTDDT←←-1>
;;omit;; bothersome DDT conditional assembly. 'BEND DDT' sln#60065 `2013-02-21 bgbaumgart@mac.com'
;;omit;;IFN FTDDT,<				;THIS ENTIRE ASSEMBLY IS CONDITIONAL
	IFNDEF FTDSWP,<↓FTDSWP←←0>
	IFNDEF EDDT,<↓EDDT←←0>
	IFE EDDT&20,<↓FTDSWP←←0>
	IFN EDDT,<IFE EDDT&40,<
BEGIN DDT
>>
	SUBTTL	DDT 7 APRL 1968

IFNDEF SAVESW,<SAVESW←0>	;SET UP A STARTING ADRESS
IFNDEF UEDDTS,<UEDDTS←0>	;SET UP UEDDT
;;edit;; replace dots with underbars in
;; DEFINE XP' (X.,Y.),<
;; X.←←Y.
;; >
DEFINE XP' (X_,Y_),<
X_←←Y_
>

IFN EDDT&40,<TITLE DDT - EXEC MODE VERSION>
IFN EDDT,<SUBTTL DDT - EXEC MODE VERSION
	JOBREL←←37
	JOBSYM←←36
	ZLOW←←40>

IFE EDDT,<TITLE UDDT - USER MODE DDT
	EXTERN JOBREL,JOBSYM,JOBSA,JOBHRL,JOBFF
	ZLOW←←140>
IFN EDDT&1,<
F←←0		;FLAGS
R←←1		;POINTERS TO TABLES, CORE, ETC.
S←←2
IFE EDDT&20,<P←←3>	;SETUP PUSHDOWN POINTER IF NOT SYSTEM
W←←4		;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
T←←5		;TRANSFER DATA
W1←←6
W2←←7
SCH←←10		;MODE CONTROL SWITCH FOR OUTPUT
AR←←11		;MODE CONTROL SWITCH FOR OUTPUT
ODF←←12		;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
A←←R
B←←S
TT←←13		;TEMPORARY
>
IFE EDDT&1,<
F←0		;FLAGS
P←1		;PUSH DOWN
R←2		;POINTERS TO TABLES, CORE, ETC.
S←3
W←4		;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
T←5		;TRANSFER DATA
W1←6
W2←7
SCH←10		;MODE CONTROL SWITCH FOR OUTPUT
AR←11		;MODE CONTROL SWITCH FOR OUTPUT
ODF←12		;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
A←R
B←S
TT←13		;TEMPORARY
>


C←←W

PRS←←4
TTYY←←120
PTRR←←104
PTPP←←100

LPDL←←50		;MAX LENGTH PUSH DOWN LIST


COMF←←200000	;COMMA TYPED FLAG
TIF←←100000		;TRUNCATE TO 18 BITS -  SET BY SPACE OR COMMA
PTF←←100		; +, -, OR * HAS BEEN TYPED
CTF←←400
SF←←4		;SYLLABLE FLAG
QF←←1		;QUANTITY TYPED IN TO WORD ASSEMBLER

CF←←40		; $ TYPED
CCF←←10000		; $$ TYPED
MF←←2		;MINUS SIGN TYPED IN
LTF←←20		;LETTER TYPED IN TO CURRENT SYLLABLE
ROF←←10		;REGISTER OPEN FLAG
STF←←4000
FAF←←1000		; < TYPED
SAF←←2000		; > TYPED

FPF←←20000		; . TYPED IN
FEF←←400000		; E FLAG

MLF←←200		;*FLAG
DVF←←40000		;DIVIDE FLAG

PPID←←0		;=0 IF SYMBOL TABLE POINTER IS IN JOBSYM

;RIGHT HALF FLAGS

ITF←←2	;INSTRUCTION TYPED IF ITF=1
OUTF←←4	;OUTPUT IF OUTF=1
CF1←←400		;OUTPUT 1 REGISTER AS CONSTANT
LF1←←2000		;OUTPUT 1 REGISTER AS FORCED SYMBOLIC OR CONSTANT
Q2F←←1		;NUMBER TYPED AFTER ALT MODE 
R20F←←10	;TEMP FLAG USED IN SETUP
SBF←←20
NAF←←200		;NEGATIVE ADDRESSES PERMISSABLE
POWF←←4000		;ARGUMENT FOR EXPONENT COMING
EQF←←20000	;WANTS REAL NUMERIC MODE

GLOBAL←←040000		;GLOBAL SYMBOL
LOCAL←←100000
PNAME←←740000		;PROGRAM NAME
DELI←←200000		;DELETE INPUT
DELO←←400000		;DELETE OUTPUT
IFE EDDT&1,<
LOC 74
DDT		;DDT'S STARTING ADDRESS
IFN UEDDTS,<LOC 124
DDTREN>>
IFE EDDT&1,<RELOC 0>
;;IFN EDDT&<XWD -1,0>,<LOC <EDDT>B53>



INTERN DDT,$M,DDTEND

RADIX =10
NBP←←8
IFN EDDT&20,<NBP←←30>

RADIX =8

IFE UEDDTS,<DEFINE SYMTST<>>
IFN UEDDTS,<DEFINE SYMTST
<	SKIPE SYMLUZ
	PUSHJ P,SYMPR>
OPDEF SETPR2[CALLI 400052]
MAXPR←←400000	;MAX SIZE OF UPPER>

DEFINE DEVICES
<
XQ APR,0
XQ PI,4
XQ IOP,10
XQ PAG,24
XQ PTP,100
XQ PTR,104
XQ CTY,120
XQ LPT,124
XQ DC,200
XQ DCB,204
XQ DTC,210
XQ DTS,214
XQ MTC,220
XQ MTS,224
XQ MTM,230	
XQ ADC,240
XQ DAC,244
XQ DCSA,300
XQ DCSB,304
XQ DKB,310
XQ VMI,364
XQ PK,370
XQ DIL,374
XQ IMP,400
XQ TV,404
XQ PEN,414
XQ ARM,420
XQ AD,424
XQ DPY,430
XQ KBD,434
XQ XGP,440
XQ DSK,444
XQ D11,470
XQ PMP,500
XQ IBM,504
XQ DDD,510
XQ PCLK,730
XQ AS,774
>;END DEVICES


IFN EDDT&1,<
IFE EDDT&20,<

DEFINE XQ(A,B)
<A←←B
>
DEVICES
>
>

XP OR,<<IOR>>
XP JOV,2554B11
XP JEN,2545B11
IFE EDDT&20,<XP HALT,2542B11>

;BREAK POINT LOGIC
;THE B
BP1:
	REPEAT NBP,<	0		;JSR TO HERE FOR BREAKPOINT
	JSA T, BCOM
	0		;HOLDS INSTRUCTION WHILE BREAKPOINT IS IN PLACE
	0
>

B1INS←←BP1+2
BPN←←.-4

BCOM:
	0
	POP T,LEAV		;MOVE INSTRUCTION TO LEAV
	MOVEI T,B1SKP-B1INS+1(T)
	HRRM T,BCOM3		;CONDITIONAL BREAK SETUP
	MOVEI T,B1CNT-B1SKP(T)
	HRRM T,BCOM2		;PROCEDE COUNTER SETUP
	MOVE T,BP1-B1CNT(T)
IFN EDDT&1,<	TLZ T,010000		;TURN OFF USER MODE BIT>
	HLLM T,LEAV1		;SAVE FLAGS FOR RESTORING
	EXCH T,BCOM
IFN FTDSWP,<
	CONSZ APR,MAOFF		;DON'T LET PDP-6 TAKE BREAKS IF NO DDT!
	JRST BCOM3
	SKIPE INDDT
	SKIPN KEEPIN
	HALT NOBREAK
>
BCOM3:
	SKIPN B1SKP		;ADDR MOD TO LOOK AT COND. INST.
	JRST BCOM2
	XCT @BCOM3
	JRST NOBREAK
BCOM2:
	SOSG B1CNT		;ADDR MOD TO LOOK AT PROCEED COUNTER
	JRST BREAK
NOBREAK:

	MOVEM T,AC0+T
	LDB T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIL T,264	;JSR
	CAILE T,266	;JSA,JSP
	TRNN T,700	;UUO
	JRST PROC1		;MUST BE INTERPRETED
	CAIE T,260	;PUSHJ
	CAIN T,256	;XCT
	JRST PROC1		;MUST BE INTERPRETED
	MOVE T,AC0+T
	JRST 2,@LEAV1		;RESTORE FLAGS, GO TO LEAV

LEAV1:
	XWD 0,LEAV

PROC1:
	MOVE T,AC0+T
	JSR SAVE
	JFCL
	JRST PROC2

LEAV:
	0			;INSTRUCTION MODIFIED
	JRST @BCOM
	AOS BCOM
	JRST @BCOM

BREAK:
	JSR SAVE
	JRST BREAKA
	JRST 160462;;BREAKB

SAVE:
	0		;SAVE THE ACS AND PI SYSTEM
	SKIPN SARS
	JRST SAV1
	AOS SAVE
	JRST SAV5
SAV1:

IFN EDDT&1,<
	CONI APR,SAVAPR
	CONI PRS,SAVPI
	CONO PRS, @SAVPI+1
>
	MOVEM 17,AC17
	HRRZI 17,AC0
	BLT 17,AC0+16
	MOVE T, SAVE
	HLLM T, SAVPI
SAV5:
	SETOM SARS
	MOVEI P,PS
IFN FTDSWP&EDDT&1,<
	PUSHJ P,GETDDT		;DO THE SWAPPABLE DDT THING!
>
	IFE EDDT&1,<PUSHJ P,TTYRET>	;IN USER MODE, GET INTO DDT MODE
	MOVEI F,0
	MOVE T,[XWD SCHM,SCH]
	BLT T,ODF		;LOAD THE ACS WITH MODE SWITCHES
	JRST @SAVE

XCTBUF:

	REPEAT 10,<CONO PRS,@SAVPI
		0
		SKIPA
		AOS .+1
		JRST .
		0
	>

XCTQ←←6

RESTORE:
 SETOM TEM3	;RESTORE ACS AND PI SYSTEM
RESTR1:
	HRRM T,SAVE
IFN 0&EDDT&1,<			;SYS WRITE REF KLUDGE HAS BEEN REMOVED.
	MOVE T,SAVAPR
	ANDI T,SYSCLB!7	
	TRNN T,SYSCLB
	CONO APR,CLRCLB(T)	;IF THE SYSTEM WASN'T CLOBBERED WHEN WE CAME 
				;IN, THEN IT ISN'T CLOBBERED NOW.
>
	MOVE T,SAVPI
	HLLM T, SAVE
	MOVEM W,TEMDDT
IFN EDDT&1,<
	AND T, SAVPI+1
	ANDI T,177
	IORI T, 2000	;TURN ON CHANNELS
	EXCH T, SAVPI>
	MOVEI W,XCTBUF
ZZ←←7
	REPEAT 7,<
	TRNE T,1⊗<17-ZZ>
	MOVEI W,XCTBUF+<XCTQ*ZZ>
ZZ←←ZZ-1
>
	HLL W,SAVE
	MOVEM W,RES2
	IFE EDDT&1,<AOS RES2>
	MOVE T,TEMDDT
	MOVEM T,1(W)
	HRRZ T,SAVE
	HRRM T,4(W)
	SKIPGE TEM3
	JRST RES3
	MOVE T,BCOM
	MOVEM T,5(W)
	MOVEI T,5(W)
	HRRM T,1(W)
RES3:

IFN EDDT&20,<
	MOVE TAC,MONPTR	; RECOMPUTE MONITOR CHECKSUM
	PUSHJ P,CHECK
	SKIPN $M-1	; ONLY IF COMMANDS COMING FROM KEYBOARD!
	MOVEM TAC1,MONSUM
IFN FTDSWP,<
	PUSHJ P,GETBAK		;DO THE SWAPPABLE DDT THING
>
>
	MOVSI 17,AC0
	BLT 17,17
	SETZM SARS
	JRST 2,@RES2

RES2:
	0


XEC0:
	MOVEM T,TEMDDT
	PUSHJ P,CRF
	PUSHJ P,TTYLEV
	PUSHJ P,INSRTB
	MOVE W,TEMDDT	;IN CASE OF INTERUPTS (JS STUFF)
	JSP T,RESTORE	;RESTORE WILL XCT W
XEC1:
	JRST DDT		;USED  AT PROC0
	JSR SAVE
	PUSHJ P,REMOVB
	PUSHJ P,CRF
	JRST DD1


RETB:
	HRRZ T,BCOM2	;SET UP TEXT STRING
	SKIPE T,1(T)
	HRLI T,(<POINT 7,0>)
	MOVEM T,STRING
	JRST RET

IFN EDDT&1,<STARTA:	0>	;START ADDRESS FROM PAPER TAPE
IOTBL:

IFN EDDT&1!UEDDTS,<
DEFINE XQ(A,B)
<	B
>
DEVICES
>
REPEAT 10,<-1>
IOTLG←.-IOTBL
SAVPI:
	0
XP $I,SAVPI
	1077			;TURN OFF CHANNELS 2-7
SAVTTY:
	0

IFN EDDT&1,<OUTLPT:	0
SAVAPR:
	0	>
OUTRTN:
0
STRING:
	0
MSK:
	XWD -1,-1
XP $M,MSK
MXINC:
	100
BMASK:
	0
FLGPTR:
	0
B1ADR:
	0
B1SKP:
	0
B1CNT:
	0
B1STR:
	0

DEFINE DBPNT ! (Z_) <XP $!Z_!B,B1ADR+4*Z_-4>

RADIX =10
FOR QZ←1,NBP
<DBPNT (QZ)
>
RADIX =8
REPEAT NBP*4-4, <	0>

BNADR←←.-4
AUTOPI:
	0

AC0:
	BLOCK 17

AC17:
	0

SCHM:
	PIN		;DO NOT CHANGE ORDER
	PADSO
ODFM:
	10

SARS:
	0
TEM1:
	0

PS:
	BLOCK LPDL

TBLK:
	0
TEMDDT:
	0
BLOCK:
	0
SVF:
	0
SW1:
	0
SVFB:
	0
SVTB:
	0
BLVL:
	0
WRD:
	0
WRD2:
	0
PRNC:
	0

FRASE:
	0	;DONT CHANGE ORDER, SEE  SEARC+3
SYL:
	0
LWT:
	0
TEM2:
	0
FRASE1:

TEM3:
	0
DENDDT:
	0

PRGM:
	0
FSV:
	0
FHTTMP:
	0	;TEMP CELL FOR FLOATING POINT VALUE ACCUMULATION
FHDTMP:
	0	;TEMP CELL FOR FLOATING POINT VALUE ACCUMULATION
SYM:
	0
SPSAV:
	0	;POINTER TO LAST SYMBOL TYPED
DEFV:
	0
ULIMIT:
	0
LLOC:
	0
LLOCO:
	0
SAVLOC:
	0
IOTFLG:
	0
SYMP:
IFN UEDDTS,<EXCSYM;	SO WE CAN DEBUG IT>	XWD PPID,JOBSYM

IFN FTDSWP&EDDT&1,<
COMMENT ⊗
INITIALIZATION ROUTINES FOR SWAPPING DDT AT 203 RESTART
SWAPPING DDT CONTROL CELLS AND THEIR MEANINGS:

DDTSWP:
	-1	ENABLE SWAPPING DDT
		0	DISABLE SWAPPING DDT

→→→→→→→→→→→→→→→→THIS IS THE ONLY CELL YOU SHOULD SET!!!!!
		THIS CELL IS LOOKED AT ONLY AT 203 RESTARTS!
		THEREFORE IT IS NECESSARY TO DO A 203 RESTART TO CHANGE THE
		STATE OF SWAPPING DDT.

NOTDDT:
	-1	FLUSH DDT ENTIRELY

KEEPIN:
		-1	DDT STAYS IN CORE ALWAYS
		0	DDT IS SWAPPABLE

		EXAMINED AT GETBAK
		SET IN DDTINI AT 203 RESTART

INDDT:
		-1	DDT IS IN CORE
		0	DDT IS ON DISK

EXMCOR:
		0	EXAMINE & DEPOSIT IN RANGE DDTA TO END OF
			SYMBOL TABLE GO TO DISK
		-1	EXAMINE & DEPOSIT ALWAYS REFERENCE CORE!

⊗

DDTTRY←←10		;TRY THIS MANY TIMES ON ERROR

↑↑DDTSWP:	-1	;NORMALLY ENABLE SWAPPING
↑↑NOTDDT:	0	;START WITH DDT

↑↑KEEPIN:	-1	;DDT STAYS IN AT LEAST UNTIL THE FIRST START-UP

↑↑INDDT:	-1	;DDT STARTS OUT IN CORE!

↑↑SYMLOC:	0	;SET BY BEGIN TO CONTENTS OF DDTSYM BEFORE ONCE ONLY CODE

↑↑EXMCOR:	0	;REFERENCE CORE AT FIRST

↑↑DDTSUM:	0	;CHECKSUM OF DDT

DDTIOP:
		0	;STATE OF IOP SAVED HERE WHEN DDT ENTERED!

SWPWRD:
		0	;PLACE TO KEEP WORD WE ARE DEPOSITING!

USROFF:
		0	;OFFSET FROM CORE TO DISK FOR EXAMINE AND DEPOSIT
			;SET BY SETUSR

;INITIALIZE SWAPPING DDT!!!

↑DDTINI:
	SKIPE DDTSUM		;THIS SHOULD TELL US IF DDT HAS
				;BEEN WRITTEN ON DISK YET!!!
	CONSZ DSK,1B27		;IS DISK THERE AT ALL
	SETZM DDTSWP		;ASK FOR NO SWAPPING
	SKIPN DDTSWP
	SKIPN INDDT
	CAIA
	JRST SETIN
	PUSHJ P,DDTREAD		;TRY TO READ DDT FROM DISK
	JRST CANTSWP		;COULDN'T GET DDT, LOSE BIG!
	CAIA			;COULDN'T GET SYMBOLS, STICK IT IN
	SKIPN DDTSWP
	JRST SETIN
SETOUT:
	SETZM KEEPIN
	SETZM INDDT
	SETZM DDTSYM		;NO SYMBOLS, NOW
	SETZM EXMCOR		;EXAMINE DISK FOR USER
	MOVEI TAC,DDTA
	MOVEM TAC,SYSSIZ	;GIVE LOSERS ALL THIS CORE!
	POPJ P,
SETIN:
	SETOM KEEPIN
	HLRE TAC,DDTSYM
	MOVMS TAC
	ADD TAC,DDTSYM
	JUMPN TAC,.+2
	MOVEI TAC,DDTEND
	HRRZM TAC,SYSSIZ
	SETOM EXMCOR		;EXAMINE CORE ONLY (DDT IS ALWAYS THERE)
	POPJ P,
CANTSWP:

	MOVE TAC,[HALT 201]
	MOVEM TAC,DDT
	JRST SETOUT

;GETDDT   CALLED FROM SAVE TO GET DDT INTO CORE!

GETDDT:
	SKIPN INDDT		;IF DDT ALREADY IN,
	CONSO APR,MAOFF		;OR NOT PDP 10
	POPJ P,			;THEN NOTHING TO DO

;HERE WE ATTEMPT TO STOP THE PDP-6 SO IT WON'T MASH DDT OR SYMBOLS
	SKIPN	P2NUM		;SKIP IF THE PDP-6 IS SUPPOSED TO BE THERE
	JRST	GETDD1		;PDP-6 ISN'T THERE.  LET'S SKIP THIS MESS
	SETOM	P2STP1
	MOVE	TAC,[JSR P2STOP]
	EXCH	TAC,40+2*APRCHN	;STORE IT WHERE THE PDP-6 WILL STUMBLE ON IT
	MOVEM	TAC,P2STP0	;STORE OLD JSR
	MOVSI	TAC,1		;NOW WE WAIT FOR THE PDP-6 TO HIT IT
	SKIPE	P2STP1		;WAIT FOR IT TO BE ZERO
	SOJG	TAC,.-1		;LOOP
	JUMPG	TAC,GETDD1	;JUMP IF IT REALLY STOPPED.
	JSP	TAC,DDTMES
	ASCIZ	/STOP THE PDP-6 AND CONTINUE THE -10
/
	HALT	GETDD1

GETDD1:
	MOVSI	TAC,1		;WAIT FOR THE IBM DISK TO STOP SPINNING
	CONSO	PMP,100020	;WAIT FOR CHANNEL TO REQUEST INTERRUPT OR IDLE
	SOJGE	TAC,.-1		;...
	MOVEI	TAC,.		;LET'S SEE WHERE WE ARE.
	CAMGE	TAC,37		;HAS 37 BEEN CLOBBERED?
	JRST	GETDD2		;I SUPPOSE WE'LL LET IT ALONE.
	CAMGE	TAC,RMEMSIZE	;I HOPE THIS ISNT
	MOVE	TAC,RMEMSIZE
	SUBI	TAC,1
	MOVEM	TAC,37

GETDD2:
	CONSO	IOP,777770	;IS IOP ACTIVE?
	JRST	IOPFRE		;NO
	MOVSI TAC,1
	CONSO IOP,IOPANY!IOPJDN	;WAIT FOR IT TO BECOME INACTIVE
	SOJG TAC,.-1		;IN CASE IT IS HUNG!
IOPFRE:
	CONI IOP,TAC		;SAVE STATE OF IOP
	TRNN TAC,IOPRLY		;ANY IOP ERRORS WE CAN'T SAVE?
	CONSZ DSK,3770		;ANY DISK ERRORS WE CAN'T SAVE?
	TRO TAC,IOPMIS		;YES, SET DATA MISS FLAG
	MOVEM TAC,DDTIOP	;SAVE BITS HERE TO PUT BACK LATER!
	MOVEI TAC1,DDTTRY	;TRY THIS MANY TIMES
OUTLOS:
	CONO DSK,0		;BLAST DISK
	CONO IOP,100		;WRITE THIS TIME
	PUSHJ P,SETUSR		;SET-UP USER ADDRESSES AND START TRANSFER
	SOJG TAC1,OUTLOS
	JUMPG TAC1,NOLOSO		;WIN
	JSP TAC,DDTMES
	ASCIZ/
FAILED TO GET USER WRITTEN OUT!
CONTINUE TO TRY TO GET DDT IN.
/
	HALT .+1
NOLOSO:
	PUSHJ P,DDTREAD	;TRY TO READ IN DDT
	JRST NODDT
	JRST NOSYM
LOSCON:
	CONO IOP,@DDTIOP
	POPJ P,			;ALL IS WELL
NODDT:
	JSP TAC,DDTMES
	ASCIZ/
FAILED TO GET DDT IN AT ALL!
CONTINUE TO TRY AGAIN.
/
	HALT NOLOSO
NOSYM:
	JSP TAC,DDTMES
	ASCIZ/
FAILED TO GET SYMBOL TABLE IN!
CONTINUE TO ENTER DDT ANYWAY.
/
	HALT LOSCON

;GETBAK   CALLED FROM RESTORE TO UPDATE SYMBOL TABLE AND GET USER CORE BACK!

GETBAK:
	CONSO APR,MAOFF
	POPJ P,			;PDP-6 DOESN'T DO ANYTHING
	SKIPN KEEPIN		;DDT GOING OUT?
	SKIPN INDDT		;AND IN NOW
	POPJ P,			;NO
	SETZM DDTSYM		;NO DDT, NO SYMBOLS.
;THE FOLLOWING SEMICOLONED OUT TO KEEP SYMBOLS IN ONE PIECE!
;	MOVEI TAC1,DDTTRY	;UPDATE DDT ONLY IN SWAPPING DDT ENVIRONMENT
;WRTLOS:	CONO DSK,0
;	CONO IOP,100		;WRITE SYMBOL TABLE
;	PUSHJ P,SETSYM		;UPDATE SYMBOL TABLE!!!
;	SOJG TAC1,WRTLOS	;TRY AGAIN?
;	JUMPG TAC1,NOUPDATE	;DID WE WIN?
;	JSP TAC,DDTMES
;	ASCIZ/
;COULDN'T UPDATE YOUR SYMBOL TABLE ON THE DISK, SORRY!
;/
NOUPDATE:

	MOVEI TAC1,DDTTRY	;NOW TO RESTORE LOSER CORE
	SETZM INDDT		;DDT NO LONGER IN CORE
USRLOS:
	CONO DSK,0
	CONO IOP,0		;READ LOSER THIS TIME
	PUSHJ P,SETUSR
	SOJG TAC1,USRLOS
	CONO IOP,@DDTIOP
	JUMPG TAC1,USRLS1	;DID WE GET HIM BACK IN?
	JSP TAC,DDTMES
	ASCIZ/
FAILED TO RESTORE LOSER CORE!
CONTINUE TO IGNORE.
/
	HALT .+1
USRLS1:
	MOVE	TAC,P2STP0	;GET OLD JSR BACK
	MOVEM	TAC,40+APRCHN*2
	SETOM	P2STP1		;FLAG THE PDP-6 TO CONTINUE
	POPJ	P,

P2STP0:
	0			;HERE TO SAVE LOC 46
P2STP1:
	0			;FLAG FOR PDP-6 IS WAITING
P2STP2:
	0			;PDP-6 STORES TAC WHILE WAITING FOR DDT EXIT
P2STOP:
	0			;JSR HERE IN CLOCK CHANNEL TO WAIT WHILE IN DDT
	CONO	PI,PIOFF	;STOP THE WORLD
	MOVEM	TAC,P2STP2	;SAVE AN AC
	SETZM	P2STP1		;TELL THE PDP-10 THAT WE'RE STOPPED
	MOVE	TAC,P2STP1
	JUMPE	TAC,.-1		;WAIT FOR THE 10 TO FINISH
	MOVE	TAC,P2STP2	;RESTORE TAC
	CONO	PI,PION
	JEN	@P2STOP

;DDTREAD   CALLED FROM GETDDT TO READ DDT AND SYMBOL TABLE FROM DISK

DDTREAD:
MOVEI TAC1,DDTTRY
DDTLOS:
	CONO DSK,0
	CONO IOP,0		;READ THIS TIME
	MOVE TAC,[XWD DDTA-DDTEND-40,DDTA]
	ANDCMI TAC,37
	DATAO IOP,TAC
	MOVEI TAC,DDTA
	ASH TAC,-5
	PUSHJ P,SECTOR
	PUSHJ P,IOPWAIT
	SOJG TAC1,DDTLOS
	SETZM DDTSYM
	JUMPLE TAC1,CPOPJ
	SETOM INDDT		;FLAG DDT IN CORE
	MOVE TAC,[XWD DDTA-DDTEND,DDTA]
	PUSHJ P,CHECK		;CHECKSUM DDT!
	SKIPN DDTSUM		;IS THERE A CHECKSUM THERE?
	MOVEM TAC1,DDTSUM	;NO, USE THIS ONE
	CAMN TAC1,DDTSUM	;CHECKSUM OK?
	JRST SUMOK		;YES
	JSP TAC,DDTMES
	ASCIZ/
DDT CHECKSUM FAILURE!
/
SUMOK:
	MOVEI TAC1,DDTTRY
SYMLOS:
	CONO DSK,0
	CONO IOP,0		;READ SYMBOL TABLE
	PUSHJ P,SETSYM
	SOJG TAC1,SYMLOS
	JUMPLE TAC1,CPOPJ1	;LOSE ON SYMBOL TABLE READ
	MOVE TAC,SYMLOC
	ANDCMI TAC,777740
	ADDI TAC,DDTEND
	MOVEM TAC,DDTSYM	;THIS IS WHERE THE SYMBOL TABLE IS
	JRST CPOPJ2

;SETSYM   CALLED TO READ OR WRITE SYMBOL TABLE

SETSYM:
	SKIPN TAC,SYMLOC
	POPJ P,
	HLLZS TAC
	ADD TAC,[XWD -40,DDTEND]
	DATAO IOP,TAC
	HRRZ TAC,SYMLOC
	ASH TAC,-5
	PUSHJ P,SECTOR
	JRST IOPWAIT		;SKIP RETURNS IF ALL OK

;SETUSR   CALLED TO READ OR WRITE USER CORE IN DDT REGION

SETUSR:
	MOVSI TAC,DDTA-DDTEND-100	;LET'S BE CAREFUL
	ADD TAC,SYMLOC		;AND LENGTH OF SYMBOL TABLE
	HRRI TAC,DDTA
	ANDCMI TAC,37		;ROUND IT OFF TO NEAREST SECTOR
	MOVEM TAC,BOOTWC	;SAVE FOR BOOT HACK
	DATAO IOP,TAC		;PHEW!
	HLRE TAC,SYMLOC		;LENGTH OF SYMBOL TABLE
	MOVMS TAC
	ADD TAC,SYMLOC
	HRRZS TAC
	JUMPN TAC,.+2
	MOVEI TAC,BLTBEG	;MAYBE SYMBOL TABLE LOSES?
	ADDI TAC,37
	ASH TAC,-5
	MOVEM TAC,BOOTSE	;SAVE FOR BOOT HACK
	MOVEM TAC,USROFF
	PUSHJ P,USECTOR		;AND THEY'RE OFF	;REG 5-9-72
	MOVNI TAC,DDTA-37
	ASH TAC,-5
	ADDM TAC,USROFF
	JRST IOPWAIT

;SETBUF   CALLED FROM EXAMINE & DEPOSIT TO READ OR WRITE 32 WORDS OF USER CORE

SETBUF:
	DATAO IOP,[XWD -40,DDTBUF]	;THE BUFFER IS EASY
	MOVE TAC,R
	ASH TAC,-5
	ADD TAC,USROFF
	PUSHJ P,USECTOR			;REG 5-9-72
	JRST IOPWAIT

;DDTMES   TYPES MESSAGE ON CTY
;CALLING SEQUENCE:
;	JSP TAC,DDTMES
;	ASCIZ/MESSAGE/
;	<RETURNS HERE>

DDTMES:
	HRLI TAC,(<POINT 7,0>)
	JSR DDTTYPE
	JRST 1(TAC)		;SEE HOW CLEVER WE ARE!!!!

SECTOR:
	CAIL TAC,2300		;NEXT TRACK?
	ADDI TAC,1B24-2300	;TAC←TAC-2300+1B24, WRAPAROUND TO NEXT ONE
	ADD TAC,SYSBAND
	DATAO DSK,TAC
	POPJ P,

USECTOR:
	;SAME AS SECTOR, BUT USES DDTBAND, NOT SYSBAND
		;WRITE USERS HERE.   REG 5-9-72
	CAIL TAC,2300		;NEXT TRACK?
	ADDI TAC,1B24-2300	;TAC←TAC-2300+1B24, WRAPAROUND TO NEXT ONE
	ADD TAC,DDTBAND
	DATAO DSK,TAC
	POPJ P,

IOPWAIT:

	CONSZ DSK,1B27
	POPJ P,
	MOVSI TAC,2
	CONSO IOP,IOPANY!IOPJDN
	SOJG TAC,.-1
	JUMPE TAC,CPOPJ
	CONSO IOP,IOPANY
	CONSZ DSK,3770
	POPJ P,
	JRST CPOPJ1

;EXAMINE & DEPOSIT ROUTINES FOR SWAPPING DDT!
;
SWPEXM:
	CONSO APR,MAOFF
	JRST CPOPJ2			;PDP-6 GETS CORE!
	SKIPN EXMCOR		;EXAMINING REAL CORE
	SKIPE KEEPIN		;IS THERE SOMETHING ON THE DISK?
	JRST CPOPJ2		;NO, DO NORMAL THING
	HLRE W,SYMLOC		;GET LENGTH OF SYMBOL TABLE (ON DISK)
	MOVNS W
	CAIL R,DDTA
	CAILE R,DDTA+100(W)	;IS THIS LOCATION ON DISK?
	JRST CPOPJ2		;NO
	MOVEI T,DDTTRY
	PUSH P,S
	PUSH P,R
EXMLOS:
	CONO DSK,0
	CONO IOP,0
	PUSHJ P,SETBUF
	SOJG T,EXMLOS
	POP P,R
	POP P,S
	JUMPLE T,DSKLOS
	MOVE T,R
	ANDI T,37
	MOVE T,DDTBUF(T)
	POPJ P,			;GOT IT (OFF DISK)
DSKLOS:
	PUSH P,TAC
	JSP TAC,DDTMES
	ASCIZ/
DISK REFERENCE LOST!
/
	POP P,TAC
	JRST CPOPJ1	;SO SWPDEP WON'T TRY TO WRITE

SWPDEP:
	MOVEM T,SWPWRD
	PUSHJ P,SWPEXM
	JRST SWPDP1	;GOT IT IN!
	POPJ P,		;MAKE BELIEVE IT WON!!
	JRST CPOPJ1	;NOT ON DISK GET FROM CORE
SWPDP1:
	MOVE W,R
	ANDI W,37
	MOVE T,SWPWRD
	MOVEM T,DDTBUF(W)
	MOVEI W,DDTTRY
	PUSH P,S
	PUSH P,R
DEPLOS:
	CONO DSK,0
	CONO IOP,100	;WRITE
	PUSHJ P,SETBUF
	SOJG W,DEPLOS
	POP P,R
	POP P,S
	MOVE T,SWPWRD
	JUMPG W,CPOPJ
	SOS (P)			;DSKLOS WANTS TO SKIP RETURN
	JRST DSKLOS		;TELL THEM IT LOST

>

;DDT STARTS HERE
CPOPJ1:
	AOS (P)
CPOPJ:
	POPJ P,
IFN FTDSWP,<TMPTAC:	0>
DDT:

IFN FTDSWP,<
	CONSZ APR,MAOFF
	JRST DDTP1
	SKIPE INDDT
	SKIPN KEEPIN
	HALT DDT
DDTP1:
	SKIPE NOTDDT
	JRST [	MOVEM TAC,TMPTAC
		MOVE TAC,[POINT 7,[ASCIZ/SORRY, CAN'T GET DDT!
/]]
		JSR DDTTYPE
		MOVE TAC,TMPTAC
		HALT DDT]
>
	JSR SAVE
IFN FTDSWP&EDDT&1,<
	JRST DDTA
	JRST DDTB


;MAKE SURE EVERYTHING WE NEED STAYS IN!!!!!!!!!
LIT
VAR
ORG DDTBUF;;LIT+VAR space
DDTBUF:
	BLOCK 40
↑↑DDTA:
>;FTDSWP
	PUSHJ P,REMOVB
DDTB:
	PUSHJ P,CHKSYM	;SEE IF SYMBOL TABLE HAS MOVED
	 HLRZ T,ESTU		;THIS SEQUENCE INITS SYM TABLE LOGIC
	 SUB T,ESTU
	 MOVE W,@SYMP
	 ADD T,W		;IF THE TOP OF THE UNDEFINED SYM TAB DOES
	 TRNE T,-1		; NOT POINT TO BOTTOM OF REGULAR SYM TAB,THEN
	 HRRZM W,ESTU		; RE-INIT UNDEFINED SYM TABLE POINTER, ESTU.
	 MOVE T,PRGM
	 SUB T,W		;IF THE SYM TABLE PNTR AND THE PROGRAM
	 TSC T,T		; NAME (PRGM) PNTR DO NOT END UP IN THE
	 MOVE W1,PRGM		; SAME PLACE, OR THEY DO NOT BOTH START ON
	 XOR W1,W		; AN EVEN (OR BOTH ON ODD) LOCATION, OR
	 TRNN W1,1		; PRGM .GE. 0, THEN RE-INIT PRGM.
	JUMPE T,DD1
	SETZM PRGM
	SETZM BLOCK		;RESET WORLD
DD1:
	TLZ F,ROF		;CLOSE ANY OPEN REGISTER
	PUSHJ P,CRF
DD1.5:
	MOVE T,[XWD SCHM,SCH]
	BLT T,ODF	;LOAD ACS
DD2:
	SETZM  PRNC		;PARENTHESES COUNT
	MOVEI P,PS
LIS:
	MOVE T,ESTU
	MOVEM T,ESTUT		;INIT UNDEFINED SYM ASSEM
	TDZ F,[XWD 777777-ROF-STF,LF1+CF1+SBF+ITF+EQF+Q2F]
	SETZM IOTFLG		;NOT AN IOT YET
LIS0:
	TDZ F,[XWD 777777-ROF-STF-FAF-SAF,NAF]
	SETZM WRD
LIS1:
	SETZM FRASE
LIS2:
	MOVEI T,1
	MOVEM T,FRASE1
	TLZ F,MLF+DVF
L1:
	TLZ F,CF+CCF+SF+FPF		;TURN OFF CONTROL, SYL, PERIOD FLAG
	SETZM SYL
L1RPR:
	SETZM SYM
	MOVEI T,6
	MOVEM T,TEMDDT		;INIT SYMBOL COUNTER
	MOVE T,[POINT 7,TXT]	;SET UP POINTER FOR OPEVAL
	MOVEM T,163255;;CHP
	SETZM DENDDT
	SETZM WRD2

L2:
	PUSHJ P,TIN		;PICK UP CHARACTER
	CAIL T,"A"+40
	CAILE T,"Z"+40
	SKIPA
	TRC T,40
	TLNE F,CF		;CONTROL FLAG
	JRST L21
	CAIG T,"Z"		;Z
	CAIGE T,"A"		;A
	JRST .+2
	JRST LET
L21:
	MOVE R,T
	CAILE T,137
	JRST ERR
	IDIVI R,3
	LDB W,BDISP(R+1)
	CAIGE W,MULT-DDT	;FIRST EVAL ROUTINE
	JRST DDT(W)

	MOVE T,SYL
	TLZN F,LTF
	JRST POWER
	MOVE T,[XWD OPEVAL,EVAL]	;LOOKUP ROUTINES IN CORRETC ORDER
	SKIPN WRD	;USE SYMBOL TABLE FST IF SOMETHING THERE
	MOVSS T
	MOVEM T,SAVE
	JRST L213
L212:
	HLRZS T,SAVE
	JUMPE T,UND1	;NEITHER ONE
L213:
	PUSHJ P,(T)
	JRST L212	;TRY NEXT ONE
L4:
	TLZE F,MF
	MOVN T,T
	TLNN F,SF
	CAIE W,LPRN-DDT
	JRST .+2
	JRST LPRN

	EXCH T,FRASE1
	TLNN F,DVF
	IMULB T,FRASE1
	TLZE F,DVF
	IDIVB T,FRASE1
	CAIGE W,ASSEM-DDT
	JRST DDT(W)		;MULTIPLY OR DIVIDE
	ADDB T,FRASE
	CAIGE W,SPACE-DDT
	JRST DDT(W)		; + - @ ,

	ADD T,WRD
	TLNE F,TIF		;TRUNCATE INDICATOR FLAG
	HLL T,WRD		;TRUNCATE
	MOVEM T,WRD
	TLNN F,QF
	MOVE T,LWT
	SETZM R
	MOVE W1,ESTUT
	CAMN W1,ESTU
	JRST L5
	CAILE W,CARR-DDT
	JRST ERR
L5:
	CAIG W,RPRN-DDT
	JRST DDT(W)
	PUSH P,KILRET
	SKIPN PRNC
	JRST DDT(W)

ERR:
	MOVEI W1,"?"
	JRST WRONG1
UNDEF:
	MOVEI W1,"U"
	JRST WRONG1
WRONG:
	MOVE W1,[ASCII /XXX/]
WRONG1:
	MOVEI P,PS
	PUSHJ P,TEXT
IFN EDDT&1,<PUSHJ P,LCT		;TYPE TAB
	PUSHJ P,LISTEN
	JFCL
	JRST DD2>

RET:
	MOVEI P,PS
	PUSHJ P,LCT		;COMMON RETURN FOR TAB;,JRST LIS
	JRST DD2

UND1:
	MOVE R,ESTUT		;UNDEFINED SYM ASSEMBLER
	HLRE S,ESTUT
	ASH S,-1		;SETUP EVAL END TEST
	HRLOI W1,37777+DELI+LOCAL
	PUSHJ P,EVAL2
	CAIN W,ASSEM-DDT
	TLNN F,ROF
	JRST UNDEF
	SKIPE PRNC
	JRST UNDEF
	MOVEI T,"#"
	CAIE W,ASSEM-DDT
	PUSHJ P,TOUT

	MOVN R,[XWD 2,2]
	ADDB R,ESTUT
	MOVE T,SYM
	TLO T,GLOBAL
	MOVEM T,(R)
	HRRZ T,LLOCO
	TLNE F,MF
	TLO T,400000
	MOVEM T,1(R)
	MOVEI T,0
	JRST L4

QUESTN:
	PUSHJ P,CRF		;LIST UNDEFINED SYMBOLS
	MOVE R,ESTU
QUEST1:
	JUMPGE R,DD1
	MOVE T, (R)
	SKIPA W1,ESTU

QUEST2:
	ADD W1,[XWD 2,2]
	CAME T,(W1)
	JRST QUEST2

	CAME R,W1
	JRST QUEST4
	PUSHJ P,SPT
	PUSHJ P,CRF
QUEST4:
	ADD R,[XWD 2,2]
	JRST QUEST1

NUM:
	ANDI T,17		;T HOLDS CHARACTER
	TLNE F,CF+FPF
	JRST NM1		;$ OR . SEEN
	MOVE W,SYL
	LSH W,3
	ADD W,T
	MOVEM W,SYL		;ACCUMULATE OCTAL VALUE
	MOVE W,DENDDT
	IMULI W,12		;CONVERT TO DECIMAL
	ADD W,T
	MOVEM W,DENDDT		;ACCUMULATE DECIMAL VALUE
LE1:
	AOJA T,LE1A

PERC:
	MOVEI T,47+101-13	;PERCENT SIGN
LET:
	TLC F,SF+FPF		;EXPONENT IFF LTF'*FEF'*(T=105)*SF*FPF=1
	TLZN F,LTF+FEF+SF+FPF
	CAIE T,105		; E
	TLOA F,LTF
	TLOA F,FEF		;E SEEN AS EXPONENT
	JRST LET1
	TLZN F,MF		;MINUS FLAG?
	SKIPA W1,SYL		;NOT MINUS
	MOVN W1,SYL		;GOBBLE NEGATIVE VALUE
	MOVEM W1,FSV		;SAVE FLOATING POINT VALUE.
	SETZM  DENDDT
LET1:
	SUBI T,101-13		;FORM RADIX 50 SYMBOL
LE1A:
	TLO F,SF+QF
LE2:
	MOVE W,SYM
	MOVEI R,101-13(T)	;SET UP IN SIXBIT FOR OPEVAL
	IMULI W,50		;CONVERT TO RADIX 50
	ADD W,T
	SOSGE TEMDDT		;IGNORE CHARACS AFTER 6
	JRST L2		;GO IGNORE
	IDPB R,163255;;CHP	;SAVE FOR OPEVAL
	MOVEM W,SYM
	JRST L2

NUM1:
	EXCH T,WRD2		;FORM NUMBER AFTER $
	IMULI T,12
	ADDM T,WRD2
	TRO F,Q2F
	JRST L2

NM1:
	TLNE	F,CF		;$ SEEN?
	JRST	NUM1		;YES. NOW NUMBER.
	MOVSI	R,204500	;FORM FLOATING POINT NUMBER.  R←10.0
	FMPRM	R,FHDTMP	;MULTIPLY THE DIVISOR BY 10.0
	FMPRM	R,FHTTMP	;MULTIPLY TOTAL ACCUMULATED NUMBER BY 10.0
	MOVSI	R,211000(T)	;UNNORMALIZED VALUE OF THIS DIGIT
	FADRB	R,FHTTMP	;ADD DIGIT TO TOTAL THUS FAR
	FDVR	R,FHDTMP	;DIVIDE BY APPROPRIATE POWER OF 10.0
	MOVEM	R,SYL		;STORE FLOATING VALUE
	AOJA	T,LE1A

CHKSYM:
	 HLRZ T,ESTU		;THIS SEQUENCE INITS SYM TABLE LOGIC
	 SUB T,ESTU
	 MOVE W,@SYMP
	 ADD T,W		;IF THE TOP OF THE UNDEFINED SYM TAB DOES
	 TRNE T,-1		; NOT POINT TO BOTTOM OF REGULAR SYM TAB,THEN
	 HRRZM W,ESTU		; RE-INIT UNDEFINED SYM TABLE POINTER, ESTU.
	 MOVE T,PRGM
	 SUB T,W		;IF THE SYM TABLE PNTR AND THE PROGRAM
	 TSC T,T		; NAME (PRGM) PNTR DO NOT END UP IN THE
	 MOVE W1,PRGM		; SAME PLACE, OR THEY DO NOT BOTH START ON
	 XOR W1,W		; AN EVEN (OR BOTH ON ODD) LOCATION, OR
	 TRNN W1,1		; PRGM .GE. 0, THEN RE-INIT PRGM.
	JUMPE T,CPOPJ
	SETZM PRGM
	SETZM BLOCK		;RESET WORLD
	POPJ P,

POWER:
	TLNN F,FEF
	JRST L4		;NO EXPONENT
	CAIE W,PLUS
	CAIN W,MINUS
	TROE F,POWF
	TRZA F,POWF
	JRST (W)		; E+-

	MOVE W2,DENDDT
	SETZM  FRASE
	MOVEI W1,FT-1
	TLZE F,MF
	MOVEI W1,FT01
	SKIPA T,FSV
POW2:
	LSH W2,-1
	TRZE W2,1
	FMPR T,(W1)
	JUMPE W2,L4
	SOJA W1,POW2

PERIOD:
	MOVE	T,LLOC		;PERIOD ( . ) SEEN.  USUALLY THIS IS CURRENT LOCATION
	TLNE	F,SF		;BUT IF A SYLLABLE HAD BEEN STARTED IT MEANS
	MOVE	T,DENDDT	;DECIMAL OR FLOATING POINT
	MOVEM	T,SYL
	TLNE	F,FPF		;FLOATING POINT ON ALREADY?  I.E., ARE THERE 2 PERIODS?
	TLO	F,LTF		;TWO PERIODS.  THIS ONE IS A LETTER!
	TLON	F,FPF+SF+QF	;SET FLOATING POINT.  SKIP IF IN THE MIDDLE OF SYL
	MOVEI	T,0		;AT FRONT OF SYL. DO THE RIGHT THING FOR .69
	IDIVI	T,400		;FLOAT THE VALUE OF T (HOW?)
	SKIPE	T
	TLC	T,243000
	TLC	W1,233000
	FAD	T,[0]
	FAD	W1,[0]
	FADR	T,W1
	MOVEM	T,FHTTMP	;STORE FLOATING VALUE
	MOVSI	T,201400
	MOVEM	T,FHDTMP	;VALUE OF DIVISOR (10.0↑<NUMBER OF DIGITS AFTER POINT>)
	MOVEI	T,45		;RADIX 50 PERIOD
	JRST	LE2

QUAN:
	SKIPA T,LWT		;LAST QUANTITY TYPED
PILOC:
	MOVEI T, SAVPI
QUAN1:
	MOVEM T,SYL
QUAN2:
	TLO F,SF+QF		;WRD,SYL STARTED
	TLZ F,CF+CCF
	JRST L2

CONTRO:

IFN EDDT&1, <				;SOME KIND OF ALTMODE
	MOVEI T,"$"	;$
	PUSHJ P,TOUT		;TYPE OUT $>
DOLLAR:
	TLOE F,CF
	TLO F,CCF
	JRST L2


EVAL0:
	HRLOI W1,37777+DELI
	HLRE S,@SYMP
	ASH S,-1	;SETUP END TEST
	JRST EVAL3

EVAL1:
	ADD R,[XWD 2,2]
EVAL2:
	SKIPL R
	MOVE R,@SYMP
	AOJG S,CPOPJ		;TRNASFER IF NO SYMBOL FOUND
EVAL3:
	MOVE T,(R)
	XOR T,SYM
	TLNN T,PNAME
	TLOA W1,LOCAL
	TDNE T,W1
	JRST EVAL1
	TLNN T,340000
	JRST EVAL1
	MOVE T,1(R)
	AOS (P)		;FOUND SYMBOL, SKIP
	POPJ P,

;HERE IS THE WFW BLOCK STRUCTURE PATCH 
EVAL:
	SYMTST
	MOVSI W1,DELI
	HLRE S,@SYMP
	ASH S,-1
	SKIPL R,TBLK
	JRST EVL1
	SETZM TBLK
	JRST EVL2
EVL1:
	SKIPL R,BLOCK
	JRST EV5
EVL2:
	MOVE T,1(R)
	MOVEM T,BLVL
	JRST EV1

EV3:
	CAMN R,@SYMP
	JRST EV4
	AOJGE S,CPOPJ
EV1:
	SUB R,[XWD 2,2]
	MOVE T,(R)
	TDNE T,W1
	JRST EV3
	LDB T,[POINT 4,(R),3]
	CAIN T,3
	JRST EV2
	SKIPN T
	TLOA W1,LOCAL
	SKIPA T,(R)
	JRST EV3
	XOR T,SYM
	TLZ T,740000
	JUMPN T,EV3
	MOVE T,1(R)
	JRST CPOPJ1

EV4:
	HLRE R,@SYMP
	MOVNS R
	ADD R,@SYMP
	AOJL S,EV1
	POPJ P,

EV2:
	MOVE T,1(R)
	CAMGE T,BLVL
	JRST EV2A
EV2B:
	SUB R,[XWD 2,2]
	ADDI S,1
	LDB T,[POINT 4,(R),3]
	CAIE T,3
	JRST EV2B
	JRST EV2
EV2A:
	MOVEM T,BLVL
	JRST EV3

EV5:
	MOVEI T,1
	MOVEM T,BLVL
	SKIPGE R,PRGM
	JRST EV1
	HLRE R,@SYMP
	MOVNS R
	ADD R,@SYMP
	JRST EV1

;BIT 40 - DELETE OUTPUT
; 20 - DELETE INPUT
; 10 - LOCAL
; 04 -GLOBAL
; NO BITS - PROGRAM NAME

TEXI:
	PUSHJ P,TEXIN		;INPUT TEXT
	MOVEM T,SYL
	MOVEI W1,5
	MOVEI T-1,0
	PUSHJ P,TEXIN
	TLNE F,CCF	;WAS IT DOUBLE ALTMODE?
	JRST TEXI4	;PERMIT ALTMODE AS FIRST CHR
	CAIN T,33		;NEW ALT MODE, ESCAPE
	JRST QUAN2
TEXI4:
	TLNN F,CCF
	JRST TEXI5
	MOVE R,WRD2
	CAIE R,7
	JRST SIXBIN
	JRST TEXI6
TEXI5:
	TLNE F,CF
	JRST SIXBIN
	SKIPA
TEXI2:
	PUSHJ P,TEXIN
TEXI6:
	CAMN T,SYL
	SOJA W1,TEXI3
	ROT T,-7
	LSHC T-1,7
	SOJG W1,TEXI2
	TLNN F,CCF
	JRST TEXI2
	LSHC T-1,-43
	PUSH P,F
	TLZ F,CF
	TLO F,QF
	PUSHJ P,DEPRA	;DEPOSIT
	POP P,F
	AOS LLOCO
	MOVEI T-1,0
	MOVEI W1,5
	JRST TEXI2

TEXI3:
	LSHC T-1,-43
	JUMPL W1,TEXI7
	JUMPL W1,QUAN1
	LSH T,7
	SOJA W1,.-2
TEXI7:
	TLNN F,CCF
	JRST QUAN1
	LSHC T-1,-43
	PUSH P,F
	TLZ F,CF
	TLO F,QF
	PUSHJ P,DEPRA	;DEPOSIT
	POP P,F
	AOS LLOCO
	MOVEI T,0
	JRST QUAN1

BYTI:
	TRZN F,Q2F
	JRST PERC	;JUST PERC IF NO ALTMODE
	SKIPN T,WRD2	;GET NUMBER OF BITS/BYTE
	JRST BYTIM	;IF ZERO THEN USE BYTE MASK
	MOVEM T,SVBTI	;SAVE
	SETZM SVBTI1	;ASSEMBLED WORD
	MOVEI T,=36	;TOTAL NUMBER OF BITS
	MOVEM T,SVBTI2
BYTI4:
	MOVEI T+1,0	;READ IN NUMBER
BYTI3:
	PUSHJ P,TEXIN	;NEXT CHR
	CAIN T,","	;SEPERATES BYTES
	JRST BYTI1
	CAIN T,33	;ALTMODE TERMINATES
	JRST BYTI2
	CAIL T,"0"	;CHECK FOR DIGIT
	CAILE T,"7"
	JRST ERR
	IMULI T+1,10
	ADDI T+1,-"0"(T)
	JRST BYTI3
BYTI1:
	PUSHJ P,BYTI1A
	JRST BYTI4
BYTI1A:
	MOVN T+2,SVBTI	;GET SIZE
	ROT T+1,(T+2)	;GET THAT MANY BITS INTO LEFT END
	MOVE T,SVBTI1	;NOW THE PARTIALLY ASSEMBLED WORD
	MOVE T+2,SVBTI	;SIZE
	CAMLE T+2,SVBTI2	;MORE THAN WE NEED?
	MOVE T+2,SVBTI2	;YES, TAKE SMALLER
	LSHC T,(T+2)	;SHIFT BITS IN
	MOVNS T+2	;UPDATE NUUMBER OF BITS STILL NEEDED
	ADDM T+2,SVBTI2
	MOVEM T,SVBTI1	;SAVE WORD
	POPJ P,
BYTI2:
	PUSHJ P,BYTI1A
	MOVE T,SVBTI1	;GET WORD
	LSH T,@SVBTI2	;SHIFT REST OF WAY
	JRST QUAN1	;GO PUT IT AWAY
BYTIM:
	MOVEI T,=36	;36 BITS TOTAL
	MOVEM T,SVBTI	;SAVE FOR INPUT CHECK
	SETZM SVBTI1	;BUILD WORD HERE
	MOVE T+2,BMASK	;GET MASK BITS
BYTIM1:
	MOVEI T+1,0	;BUILD NUMBER
BYTIM2:
	PUSHJ P,TEXIN	;GET CHARACTER
	CAIN T,","	;COMMA FOR SEPERATOR
	JRST BYTIM3
	CAIN T,33	;ALTMODE TERMINATES
	JRST BYTIM6
	CAIL T,"0"	;CHECK FOR VALID DIGIT
	CAILE T,"7"
	JRST ERR
	IMULI T+1,10
	ADDI T+1,-"0"(T)	;ACCUMULATE NUMBER
	JRST BYTIM2	;LOOP
BYTIM3:
	PUSHJ P,BYTIM4	;GO PROCESS NUMBER
	JRST BYTIM1
BYTIM4:
	SKIPG SVBTI	;ROOM FOR MORE?
	POPJ P,	;NO, QUIT
	SETZM SVBTI2	;COUNT NUMBER OF BITS THIS POSITION
	SKIPL T+2	;START WITH 1 BITS IN LEFT
	SETCA T+2,0	;COMPLIMENT
BYTIM5:
	LSH T+2,1	;GET NEXT BIT
	ROT T+1,-1	;MOVE ANOTHHER BIT OF NUMBER TO LEFT END
	AOS SVBTI2	;SAVE COUNT
	SOSLE SVBTI	;CHECK TO SEE IF WORD FULL
	JUMPL T+2,BYTIM5	;NEXT BIT PART OF SAME FIELD?
	MOVE T,SVBTI1	;NO, GET WORD
	LSHC T,@SVBTI2	;SHIFT CORRECT NUMBER OF BITS
	MOVEM T,SVBTI1	;AND SAVE AGAIN
	POPJ P,		;RETURN

BYTIM6:
	PUSHJ P,BYTIM4	;PROCESS LAST NUMBER TYPED
	MOVE T,SVBTI1	;GET WORD
	LSH T,@SVBTI	;FINISH  SHIFTING
	JRST QUAN1	;ALL DONE
SVBTI:
	0
SVBTI1:
	0
SVBTI2:
	0

SIXBI1:
	PUSHJ P,TEXIN    ; INPUT TEXT (SIXBIT)
SIXBIN:
	CAMN T,SYL
	JRST SIXBI2
	CAIL T,"A"+40
	CAILE T,"Z"+40
	JRST .+2
	SUBI T,40	;CONVERT LOWER CASE TO UPPER CASE.  REG 7/9/74
	ANDI T,77
	TRC T,40
	ROT T,-6
	LSHC T-1,6
	SOJGE W1,SIXBI1
	TLNN F,CCF
	JRST SIXBI1
	MOVE T,T-1
	PUSH P,F
	TLZ F,CF
	TLO F,QF
	PUSHJ P,DEPRA
	POP P,F
	AOS LLOCO
	MOVEI T-1,0
	MOVEI W1,5
	JRST SIXBI1
SIXBI2:
	MOVE T,T-1
	JUMPL W1,QUAN1
	LSH T,6
	SOJA W1,.-2

KILL:
	TLNN F,LTF		;DELETE SYMBOLS
	JRST ERR
	PUSHJ P,EVAL
	JRST KILL1
	MOVEI T,DELO/200000		;DELETE OUTPUT
	TLNE F,CCF
	MOVEI T,DELI/200000		;NO INPUT OR OUTPUT
	DPB T,[POINT 2,(R),1]	;LEFT 2 BITS IN SYMBOL
KILRET:
	JRST RET		;USED AS A CONSTANT


KILL1:
	MOVE R,ESTU		;REMOVE UNDEFINED SYMS
	JUMPGE R,UNDEF
KILL2:
	PUSHJ P,EVAL0
	JRST RET
	PUSHJ P,REMUN
	JRST KILL2

REMUN:
	MOVE S,[XWD 2,2]	;REMOVE ONE UNDEFINED SYMBOL
	ADDB S,ESTU
	MOVE W,-2(S)
	MOVEM W,(R)
	MOVE W,-1(S)
	MOVEM W,1(R)
	POPJ P,


TAG:
	TLNN F,LTF   ; NO LETTERS IS ERROR
	JRST ERR   ; GO SAY ERROR
	TLNE F,FAF   ; DEFINE SYMBOLS
	JRST DEFIN		;A<B:
	TLNE F,CF		;DEFINE SYMBOL AS OPEN REGISTER
	JRST SETNAM
	MOVE W,LLOCO
	HRRZM W,DEFV

DEFIN:
	PUSHJ P,EVAL
	JRST DEF1
	JRST DEF2		;NO, REDEFINE
DEF1:
	MOVN R,[XWD 2,2]
	ADDB R,@SYMP	;MOVE UNDEFINED TABLE 2 REGISTERS
	HRRZ T,ESTU
	SUBI T,2
	HRL T,ESTU
	HRRM T,ESTU
	SKIPGE ESTU
	BLT T,-1(R)
DEF2:
	MOVE T,DEFV
	MOVEM T,1(R)		;PUT IN NEW VALUE
	MOVSI T,GLOBAL
	IORB T,SYM
	MOVEM T,(R)		;PUT IN NEW SYM AS GLOBAL
	MOVE R,ESTU

DEF3:
	JUMPGE R,RET		;PATCH IN VALUE FOR UNDEF SYM ENTRY
	MOVE T,SYM
	CAME T,(R)
	JRST DEF4
	MOVE S,DEFV
	SKIPGE 1(R)
	MOVN S,S
	PUSH P,R
	MOVE R,1(R)
	PUSHJ P,FETCH
	JRST ERR
	ADD S,T
	HRRM S,T
	PUSHJ P,DEP
	POP P,R
	PUSHJ P,REMUN
DEF4:
	ADD R,[XWD 2,2]		;REMOVE THE NOW DEFINED SYMBOL
	JRST DEF3

SETNAM:
	SYMTST
	MOVE R,@SYMP		;SET PROGRAM NAME - DOLLAR COLON
REPEAT 0,<SET1:	MOVE W,R
SET2:
	JUMPGE R,UNDEF
	MOVE T,(R)
	ADD R,[XWD 2,2]
	TLNE T,PNAME
	JRST SET2
	CAME T,SYM
	JRST SET1
	MOVEM W,PRGM
	JRST RET>

SET1:
	JUMPGE R,UNDEF
	MOVE T,(R)
	CAMN T,SYM
	JRST SET2
	ADD R,[XWD 2,2]
	JRST SET1
SET2:
	MOVEM R,PRGM
	SETZM BLOCK
SET3:
	CAMN R,@SYMP
	JRST RET
	SUB R,[XWD 2,2]
	LDB T,[POINT 4,(R),3]
	JUMPE T,RET
	CAIE T,3
	JRST SET3
	MOVE T,(R)
	XOR T,SYM
	TLZ T,740000
	JUMPN T,SET3
	JRST SBPRM

SETBLK:
	TLNN F,LTF
	JRST ERR
	SKIPL R,PRGM
	JRST ERR
	SYMTST
SB1:
	CAMN R,@SYMP
	JRST UNDEF
	SUB R,[XWD 2,2]
	LDB T,[POINT 4,(R),3]
	JUMPE T,UNDEF
	CAIE T,3
	JRST SB1
	MOVE T,(R)
	XOR T,SYM
	TLZ T,740000
	JUMPN T,SB1
	TLNE F,CF
	JRST SBPRM
	MOVEM R,TBLK
	JRST L1RPR
SBPRM:
	MOVEM R,BLOCK
	JRST RET

MULT:
	TLOA F,PTF+MLF		;*
DIVD:
	TLO F,DVF+PTF		;SINGLE QUOTE
	JRST L1

ASSEM:
	JRST PLUS		;#
MINUS:
	TLO F,MF
PLUS:
	TLO F,PTF
	JRST LIS2

LPRN:
	CAML P,[XWD LPDL-4,0]	;LEFT PARENTHESIS
	JRST ERR
	PUSH P,F		;RECURSE FOR OPEN PAREN
	PUSH P,WRD
	PUSH P,FRASE
	PUSH P,FRASE1
	AOS PRNC
	JRST LIS

INDIRECT:
	HRLZI W,20		;@
	IORB W,WRD
	TLO F,QF
	JRST LIS2

ACCF:
	MOVE R,T		;COMMA
	TLOE F,COMF	;A COMMA SEEN, WAS IT SECOND?
	JRST ACCCF	;YES, GO PROCESS
	ADD T,WRD	;GET TOTAL
	HRRM T,ACCCF	;AND SAVE
	HLLZ T,R	;GET LEFT HALF BACK
	LSH R,27
	SKIPE IOTFLG	;IS THIS AN IOT?
	LSH R,1		;THEN SHIFT ONE MORE
	ADD T,R
	ADDB T,WRD
	JRST SPACE+1
ACCCF:
	MOVSI T,0	;MODIFIED TO BE LEFT HALF ON ,,
	MOVEM T,WRD
	JRST SPACE+1	;AND GO

SPACE:
	TLNE F,QF
	TLO F,TIF
SPAC1:
	TLZ F,MF+PTF
	JRST LIS1

RPRN:
	TLNN F,QF		;)
	MOVEI T,0
	MOVS T,T
	SOSGE PRNC
	JRST ERR
	POP P,FRASE1
	POP P,FRASE
	POP P,WRD
	POP P,F
	TLNE F,PTF
	TLNE F,SF
	JRST RPRN1
	MOVEM T,SYL
	TLO F,QF+SF
	JRST L1RPR
RPRN1:
	ADDB T,WRD
	TLO F,QF
	JRST L1RPR-1

;REGISTER EXAMINATION LOGIC

LINEF:
	PUSHJ P,DEPRA	;NEXT REGISTER
IFE EDDT&1,<PUSHJ P,CRNRB
	JRST .+2>
LI0:
	PUSHJ P,CRF
	AOS T,LLOC
LI1:
	HRRZS T
	HRRZM T,LLOC
	HRRZM T,LLOCO
	PUSHJ P,PAD
	MOVEI T,"/"
	TLNE F,STF
	MOVEI T,"!"
	PUSHJ P,TOUT
LI2:
	TLZ F,ROF
	PUSHJ P,LCT
	MOVE R,LLOCO
	PUSHJ P,FETCH
	JRST ERR
	TLO F,ROF
	TLNE F,STF
	JRST DD2
	JRST CONSYM		;RETURN IS A POPJ

VARRW:
	PUSHJ P,DEPRA		;↑
	PUSHJ P,CRF
	SOS T,LLOC
	JRST LI1

IFN UEDDTS,<			;IN UEDDT, DOWN ARROW (CNTL A) MEANS 
				;CARRIAGE RETURN, PLUS WRITE ON L'SCOPE
DARRW:
	MOVE	R,LLOCO 	;PICK UP ADDRESS TO DEPOSIT
	SKIPE	SPCFLG		;HAVE WE BEEN REENTERED?
	CAML	R,SYSTOP	;IS THIS DEPOSIT WITHIN THE SYSTEM AREA?
	JRST	DARRW1		;NO.  DON'T PATCH THE DISK
	LSH	R,-5
	MOVEM	R,WCMA+2	;SAVE SECTOR ADDRESS
	MOVEI	R,40
	MOVEM	R,WCMA+1	;SAVE WORD COUNT
	MOVEI	R,FBDATA	;GET ADDRESS OF DATA AREA
	MOVEM	R,WCMA		;SAVE IT
	MOVEI	R,400100	;CHANGE THIS WHEN SYSTEM MOVES FROM BAND 100
	FBREAD	R,WCMA		;READ
	JRST	DARRRE		;OOPS.
	MOVE	R,LLOCO		;GET THE ADDRESS AGAIN
	ANDI	R,37		;GET DISPLACEMENT ONLY
	CAMN	T,FBDATA(R)	;SAME AS DISK?
	JRST	DARRW1		;YES. DON'T BOTHER TO WRITE
	MOVEM	T,FBDATA(R)	;SAVE DATA
	MOVEI	R,400100
	FBWRT	R,WCMA		;WRITE IT
	JRST	DARRWE		;OOPS
DARRW1:

	PUSHJ	P,DEPRA		;CLOSE REGISTER, ETC.
	JRST	DD1		;RETURN TO MAIN LOOP

DARRRE:
	OUTSTR	[ASCIZ/
FAST BAND READ FAILED./]
	JRST	DARRE

DARRWE:
	OUTSTR	[ASCIZ/
FAST BAND WRITE FAILED./]
DARRE:
	OUTSTR	[ASCIZ/
WILL NOT STORE IN CORE EITHER./]
	JRST	DD1
;>DARRW←←ERR			;IN OTHER DDT'S DOWN ARROW IS AN ERROR

CARR:
	PUSHJ P,DEPRA		;CLOSE REGISTER
	IFN EDDT&1,<JRST DD1>
	IFE EDDT&1,<JRST DD1.5>


OCON:
	TROA F,LF1+CF1		;OPEN AS CONSTANT
OSYM:
	TRZ F,CF1		;OPEN SYMBOLICALLY
	TROA F,LF1
SUPTYO:
	TLOA F,STF		;SUPPRESS TYPEOUT
SLASH:
	TLZ F,STF		;TYPE OUT REGISTER
	TLNN F,CF		;WAS $ USED?
	JRST SLAS2		;NO
	PUSHJ P,EFFECA		;TRY EFFECTIVE ADR
	JRST ERR		;WE LOST
SLAS2:
	TLNN F,QF
	JRST SLAS1
	MOVE R,LLOC
	MOVEM R,SAVLOC	;SAVE FOR $CR ETC.
	HRRZM T,LLOC		;QUANTITY TYPED
SLAS1:
	HRRZM T,LLOCO
	JRST LI2

ICON:
	TLNN F,ROF	;REGISTER OPENED OR ERR
	JRST ERR
	PUSHJ P,DEPRS
	TLNN F,CF		;CHECK FOR ALTMODE
	JRST SLAS1
	PUSHJ P,EFFECA
	JRST ERR	;LOSE
	JRST SLAS1

LTAB:
	MOVSS T		;SWAP HALVES FIRST
	CAIA		;DON'T DEPOSIT WITH SWAPPED HALVES
TAB:
	PUSHJ P,DEPRS	;OPEN REGISTER OF Q
	TLNN F,CF
	JRST TAB1
	PUSHJ P,EFFECA
	JRST ERR
TAB1:
	MOVEI T,-1(T)
	EXCH T,LLOC
	MOVEM T,SAVLOC		;AGAIN, SAVE IT
	HRROI T,700000
	PUSHJ P,TEXTT
	JRST LI0

DEPRA:
	MOVE R,SAVLOC
	TLNE F,CF	;WAS THERE AN ALTMODE?
	EXCH R,LLOC	;RESTORE OLD LOC
	MOVEM R,SAVLOC	;AND SAVE THIS
	TLNE F,ROF		;IF REGISTER IS BEING CHANGED
	TLNN F,QF		;REMOVE ALL PREVIOUS UNDEFINED
	JRST DEPRS		;SYMBOL REFERENCES TO IT
	MOVE R,ESTU
	MOVEM W1,ESTU
DEPRA2:
	JUMPGE R,DEPRS
	HRRZ W,1(R)
	CAMN W,LLOCO
	PUSHJ P,REMUN
	ADD R,[XWD 2,2]
	JRST DEPRA2

EQUAL:
	TLNE F,CF	;IF $≡
	TRO F,EQF	;THEN REAL NUMERIC MODE
	TROA F,LF1+CF1		;=
PSYM:
	TRZ F,CF1		;@
	TRO F,LF1
	PUSHJ P,CONSYM
	JRST RET

R50PNT:
	LSH T,-36	;RADIX 50 SYMBOL PRINTER
	TRZ T,3
	PUSHJ P,TOC
	PUSHJ P,TSPC
	SETZM SVFB	;NO BLOCK NAME
	MOVEI W1,LWT	;SETUP FOR SPT
	JRST SPT

SIXBP:
	MOVNI W2,6		;SIXBIT PRINTER
	MOVE W1,LWT
SIXBP1:
	MOVEI T,0
	ROTC T,6
	ADDI T,40
	PUSHJ P,TOUT
	AOJL W2,SIXBP1
	POPJ P,

;MODE CONTROL SWITCHES

;SET JOB NUMBER TO EXAMINE
JOBSET:

IFE UEDDTS,<
	JRST ERR
>;IFE UEDDTS
IFN UEDDTS,<
	MOVE T,WRD2
	SKIPL T
	CAMLE T,400222		;LEGAL JOB NUMBER?
	JRST UNDEF		;NO
	MOVEM T,EXJOBN
	JUMPE T,[MOVEI R,37	;THIS IS EXEC JOBREL
		JRST .+1]
	MOVEI R,44		;THIS IS LOSER JOBREL
	PUSHJ P,FETCH
	SETZ T,			;NOT FOUND!!!
	MOVEM T,MEMSIZ		;THIS IS MAX LOC WE ARE LOOKING AT
	SKIPE EXJOBN		;FORCE SYSTEM SYMS IF LOOKING AT SYSTEM
	TLNN F,CCF		;DOES HE WANT LOSER SYMS?
	TDZA T,T		;NO
	SETO T,			;YES
	EXCH T,EXSYMS
	CAMN T,EXSYMS		;CHANGING MODE?
	JUMPE T,RET		;NO, IF STAYING WITH EXEC SYMS, NO RE-INIT
	PUSHJ P,COPSYM		;SETUP SYMBOLS!!!
	JRST DDTB		;FIXUP SYMS!
>;IFN UEDDTS

TEXO:
	MOVEI R,TEXTT-HLFW	;$T ASSUME 7 BIT ASCII
	MOVE T,WRD2
	CAIN T,6		;CHECK FOR $6T
	MOVEI R,SIXBP-HLFW	;SET MODE SWITCH FOR SIXBIT
	CAIN T,5		;CHECK FOR $5T
	MOVEI R,R50PNT-HLFW	;SET MODE SWITCH FOR RADIX 50
	CAIN T,11		;CHECK FOR $9T
	MOVEI R,TEXTT9-HLFW	;SET MODE SWITCH FOR 9 BIT ASCII
HWRDS:
	ADDI R,HLFW-TFLOT		;H
SFLOT:
	ADDI R,TFLOT-PIN		;F
SYMBOL:
	ADDI R,PIN-TOCC		;S
CON:
	ADDI R,TOCC-FTOC		;C
UCON:
	ADDI R,FTOC		;U
	HRRZ SCH,R
	JRST BASE1

RELA:
	TRZE F,Q2F		;CHANGE ADDRESS MODE TO RELATIE
	JRST BASECH
	MOVEI R,PADSO-TOC
ABSA:
	ADDI R,TOC		;A
	HRRZ AR,R
	JRST BASE1

BASECH:
	MOVE T,WRD2		;$NR  CHANGE OUTPUT RADIX TO N, N>1
	CAIGE T,2
	JRST ERR
	HRRZ ODF,T
BASE1:
	MOVS S,[XWD SCHM,SCH]
	TLNN F,CCF
	JRST LIS1
	BLT S,ODFM	;WITH $$, MAKE MODES PERMANENT
	JRST RET

SEMIC:
	MOVEM T,LWT		;SEMICOLON TYPES IN CURRENT MODE
	JRST (SCH)

;GO AND EXECUTE LOGIC

STR:

GO:
	HRLI T,254000             ;G
	TLOE F,QF
	JRST XEC0
	IFN EDDT&1,<	SKIPE T,STARTA>	;LOAD TAPE START ADDRESS
	IFE EDDT&1,<	HRR T,JOBSA>	;GET STARTING ADDRESS

XEC:
	TLNN F,QF		;X
	JRST ERR
	JRST XEC0		;RETCH!!!

BREAKA:
	PUSHJ P,REMOVB		;REMOVE BREAKPOINTS
BREAKB:
	PUSHJ P,CHKSYM	;RESET PRGM AND BLOCK IF SYMBOLS MOVED
	SOS T,BCOM3
	HRRZS T			;GET ADDR OF BREAKPOINT JUST HIT
	SUBI T,B1ADR-4
	IDIVI T,4
	HRRM T,BREAK2	;WE WANT IT LATER
	MOVE W1,BRKNAM-1(T)	;GET THE RIGHT JUNK
	PUSHJ P,TEXT2		;AND PRINT
		;<<<<<<< THESE BALANCE THE >'S IN THE NEXT FEW LINES
;;omit;;MOVSI W1,(<ASCIZ />/>)		;TYPE > FOR COND BREAK
        MOVSI W1,(076B6);;replace;;previous line `2013-02-21 bgbaumgart@mac.com'
	SKIPG @BCOM2		;TEST PROCEED COUNTER
;;omit;;MOVSI W1,(<ASCIZ />>/>)	;TYPE >> FOR PROCEED COUNTER BREAK
        MOVSI W1,(076B6+076B13);;replace;;previous line `2013-02-21 bgbaumgart@mac.com'
	PUSHJ P,TEXT2
	MOVE T,BCOM
	HLLM T, SAVPI		;SAVE PROCESSOR FLAGS
	MOVEI T,-1(T)
	PUSHJ P,PAD		;TYPE PC AT BREAK
	HRRZ T,@BCOM3
	HRRM T,PROC0		;SETUP ADDRESS OF BREAK
	HLRZ T,@BCOM3
	JUMPE T,BREAK1		;TEST FOR REGISTER TO EXAMINE
	PUSHJ P,LCT		;PRINT TAB
	HLRZ T,@BCOM3
	PUSHJ P,LI1		;EXAMINE REGISTER C($NB)LEFT
BREAK1:
	MOVSI S,400000
BREAK2:
	ROT S,0	;WILL BE MODIFIED WITH BREAK NUM
	PUSHJ P,LISTEN		;DONT PROCEED IF TTY KEY HIT
	TDNN S,AUTOPI		;DONT PROCEED IF NOT AUTOMATIC
	JRST RETB		;DONT PROCEED
	MOVEI T,2	;COMPENSATE FOR SOS
	ADDB T,@BCOM2
	JUMPL T,PROCD1	;GO IF STILL LESS THAN
	ANDCAM S,AUTOPI	;TURN OFF AUTOPI
	JRST RETB	;AND BREAK

RADIX =10
BRKNAM:
	FOR @% I←1,NBP
<	ASCII /$%I%B/
>
RADIX =8

PROCEDE:
 TLNE F,QF		;N$P	;PROCEED AT A BREAKPOINT
	JRST PROC3
	MOVEI T,1
	TLNE F,CCF	;IF $$P
	MOVSI T,200000	;THEN VERY LARGE COUNT
PROC3:
	TLNE F,CCF	;IF AUTOPROC
	MOVNS T		;NEGATE
	MOVEM T,@BCOM2
	HRRZ R,BCOM3
	PUSHJ P,AUTOP
PROCD1:
	PUSHJ P,CRF
	PUSHJ P,TTYLEV
PROC0:
	HRRZI R,XEC1		;MODIFIED TO ADDR OF BREAKPOINT
	PUSHJ P,FETCH
	JRST BPLUP1		;ONLY GET HERE IF MEMORY SHRANK
	MOVEM T,LEAV
	PUSHJ P,INSRTB
	JRST PROC2

PROC2:
	MOVEI W,100
	MOVEM W,TEM1		;SETUP MAX LOOP COUNT
	JRST IXCT5

IXCT4:
	IFE EDDT&1,<	SUBI T,041
	JUMPE T,IINIT
	AOJGE T,IXCT6>				;DONT PROCEDE FOR INIT
				;DONT INTERPRET FOR SYSTEM UUOS
	MOVEM R,40		;INTERPRET FOR NON-SYSTEM UUOS
	MOVEI R,41
IXCT:
	SOSL TEM1
	PUSHJ P,FETCH
	JRST BPLUP		;BREAKPOINT LOOPING OR FETCH FAILED
	MOVEM T,LEAV
IXCT5:
	IFN EDDT&1,<
	LDB T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIN T,254		;DON'T DO ANYTHING TO JRST IN EXEC MODE
	JRST IXCT6>
	HRLZI 17,AC0
	BLT 17,17
	MOVEI T,@LEAV
	DPB T,[POINT 23,LEAV,35]	;STORE EFFECTIVE ADDRESS
	LDB W1,[POINT 4,LEAV,12]	;PICK UP AC FIELD
	LDB T,[POINT 9,LEAV,8]		;PICK UP INSTRUCTION FIELD
	MOVEI P,PS
	CAIN T,260
	JRST  IPUSHJ		;INTERPRET PUSHJ

	CAIN T,264
	JRST IJSR		;INTERPRET JSR
	CAIN T,265
	JRST IJSP		;INTERPRET JSP
	CAIN T,266
	JRST IJSA		;INTERPRET JSA
	MOVE R,LEAV
	TRNN T,700
	JRST IXCT4		;INTERPRET UUO
	CAIN T,256
	JRST IXCT		;INTERPRET XCT

IXCT6:
	MOVE W,LEAV	;FOR RESTORE TO XCT
	MOVEI T,@BCOM	;GET RETURN ADR
	JRST RESTORE


BPLUP:
	PUSHJ P,REMOVB		;BREAKPOINT PROCEED ERROR
BPLUP1:
	JSR SAVE
	JFCL
	JRST ERR

IFE EDDT&1,<IINIT:	MOVE T,LEAV
	MOVEM T,INITL	;SET UP TO DO THE INIT HERE
	MOVEI R,@BCOM	;THE LOC OF INIT+1
	PUSHJ P,FETCH
	JRST BPLUP
	MOVEM T,INITL+1
	ADDI R,1
	PUSHJ P,FETCH
	JRST BPLUP
	MOVEM T,INITL+2
	MOVEI T,2
	ADDM T,BCOM	;INCREMENT RETURN ADR
INITL:
	0
	0
	0
	SKIPA
	AOS BCOM
	MOVEI T,@BCOM	;GET RETURN ADR
	JRST IJSR4	;AND MAKE LIKE A JSR>

IPUSHJ:
	DPB W1,[POINT 4,CPUSHP,12]	;STORE AC FIELD INTO A PUSH
	SETZM TEM3
	MOVE W,CPUSHP		;GET A PUSH INSTR
	MOVE T,LEAV
	JRST RESTR1

CPUSHP:
	PUSH

IJSA:
	MOVE T,BCOM		;INTERPRET JSA
	HRL T,LEAV
	EXCH T,AC0(W1)
	JRST IJSR2

IJSR:
	MOVE T,BCOM		;INTERPRET JSR
	HLL T,SAVPI
IJSR2:
	MOVE R,LEAV
	PUSHJ P,DEP
	AOSA T,LEAV
IJSR3:
	MOVE T,LEAV
IJSR4:
	MOVSI W,(<JFCL>)
	JRST RESTORE

IJSP:
	MOVE W,BCOM		;INTERPRET JSP
	HLL T,SAVPI
	MOVEM W,AC0(W1)
	JRST IJSR3

;INSERT BREAKPOINTS

INSRTB:
	MOVE S,[JSR BP1]
INSRT1:
	SKIPE R,B1ADR-BP1(S)
	PUSHJ P,FETCH
	JRST INSRT3
	MOVEM T,B1INS-BP1(S)
	MOVE T,S
	PUSHJ P,DEP
INSRT3:
	ADDI S,4
	CAMG S,[JSR BPN]
	JRST INSRT1
	POPJ P,

;REMOVE BREAKPOINTS

REMOVB:
	MOVEI S,BNADR
REMOV1:
	MOVE T,B1INS-B1ADR(S)
	SKIPE R,(S)
	PUSHJ P,DEP
	SUBI S,4
	CAIL S,B1ADR
	JRST REMOV1
	IFN EDDT&1,<JRST TTYRET>
	IFE EDDT&1,<POPJ P,>

;IN EXEC MODE, SAVE UP TTY STATUS
;IN USER MODE, DONE BY SAVE

;ALL $B COMMANDS OF FORM <A>$<N>B

BPS:
	TLZE F,QF
	JRST BPS1
	TRZE F,Q2F
	JRST BPS2
	MOVE T,[XWD B1ADR,B1ADR+1]
	SETZM  B1ADR
	BLT T,AUTOPI	;CLEAR OUT ALL BREAKPOINTS AND AUTO PROCEDE REGESTER
	JRST RET

BPS1:
	TRZN F,Q2F
	JRST BPS3
	MOVE R,T
	TRO F,2
BPS2:
	MOVE T,WRD2
	CAIL T,1
	CAILE T,NBP
	JRST ERR
	IMULI T,4
	ADDI T,B1ADR-4
	TRZN F,ITF
	JRST MASK2
	EXCH R,T
	JRST BPS5

BPS3:
	MOVEI R,B1ADR		;PROCESS THE A$B
BPS4:
	HRRZ W,(R)
	CAIE W,(T)
	SKIPN (R)
	JRST BPS5
	ADDI R,4
	CAIG R,BNADR
	JRST BPS4
	JRST ERR
BPS5:
	MOVEM T,(R)
	SETZM 1(R)
	SETZM 2(R)
	SETZM 3(R)
IFN EDDT&20,<
	CONSO APR,MAOFF		;WHICH INST SHALL WE USE?
	SKIPA S,[CONSZ APR,MAOFF]
	MOVE S,[CONSO APR,MAOFF]
	MOVEM S,B1SKP-B1ADR(R)	;MAKE BREAK POINTS CONDITIONAL!
>
AUTOP:
	SUBI R,B1ADR		;AOUT PROCEED SETUP
	IDIVI R,4
	MOVEI S,1
	LSH S,(R)
	ANDCAM S,AUTOPI
	TLNE F,CCF
	IORM S,AUTOPI
	POPJ P,


;FETCH AND DEPOSIT INTO MEMORY


DEPRS:
	MOVEM T,LWT		;DEPOSIT REGISTER AND SAVE AS LWT
	MOVE R,LLOCO	;QUAN TYPED IN REGIS EXAM
	TLZE F,ROF
	TLNN F,QF
	POPJ P,0
DEP:
	TRNN R,777760
	JRST DEP1
IFE UEDDTS,<IFE EDDT&1,<
	TRNE R,400000
	SKIPA W,JOBHRL
	MOVE W,JOBREL
	HRRZS W		>
IFN EDDT&1,<
	IFN FTDSWP,<
		PUSHJ P,SWPDEP
		POPJ P,		;DEPOSIT DONE, OR LOST!
	>
	HRRZ W,JOBREL>
	CAILE W,(R)
	MOVEM T,0(R)>

IFN UEDDTS,<
	SKIPE	EXJOBN		;EX-DEP IN JOB??
	POPJ	P,		;YES, LOSE
	CAMG	R,MEMSIZ	;ADDRESS IN BOUNDS?
	SKIPN	SPCFLG		;YES. HAS PROGRAM BEEN REENTERED?
	JRST [	OUTSTR[ASCIZ/DEPOSIT NOT ENABLED!
/]
		POPJ P,]	;ILLEGAL ADDRESS OR NOT REENTERED,
	MOVEM	T,SPCWRD	;SAVE DATA FOR SPACEWAR
	MOVEM	R,SPCADR	;SAVE ADDRESS FOR SPACEWAR
	PUSHJ P,LOGIT		;LOG INTO UEDDT.LOG
	SPCWAR	0,DDTSPC	;ZERO TIC'S WILL DO
	SKIPE	SPCADR		;WAIT FOR SPACEWAR
	JRST	.-1
>
	POPJ P,0

DEP1:
	MOVEM T,AC0(R)
	POPJ P,0

FETCH:

IFE UEDDTS,<
IFE EDDT&1,<
	TRNE R,400000
	SKIPA T,JOBHRL
	MOVE T,JOBREL
	HRRZS T
>;IFE EDDT&1
IFN EDDT&1,<
IFN FTDSWP,<
	PUSHJ P,SWPEXM
	JRST CPOPJ1		;EXAMINE DONE, OR LOST
	JRST CPOPJ1		;DISK REF FAILED!
>;IFN FTDSWP
	HRRZ T,JOBREL
>;IFN EDDT&1
	CAIGE T,(R)
	POPJ P,
	TRNN R,777760
	SKIPA T,AC0(R)
	MOVE T,(R)
	JRST CPOPJ1
>;IFE UEDDTS

IFN UEDDTS,<
	SKIPE EXJOBN		;EXAMINING JOB?
	JRST JEXM		;YES, DO IT!
	MOVEI T,@PROFF
	CAMLE T,PRMAX
	JRST [	HRRZ T,R
		CAMLE T,MEMSIZ
		POPJ P,
		PUSHJ P,PRSET
		JRST FETCH]
	MOVE T,400000(T)
	JRST CPOPJ1

JEXM:
	TRNE R,777760		;AC?
	JRST JEXM1
	MOVE T,[-1,,JOBPC↑]	;GET PC WORD
	MOVEM T,EXJOBN+1
	MOVEI T,EXJOBN
	JOBRD T,
	POPJ P,			;LOSE
	MOVE T,EXJWRD		;GET LOSERS PC
	TLNE T,10000		;USRMOD?
	ADDI R,20		;YES, AC'S ARE REALLY HERE
JEXM1:
	HRRM R,EXJOBN+1
	MOVNI T,1
	HRLM T,EXJOBN+1		;IN CASE WE HAD AN ERROR PREVIOUSLY
	MOVEI T,EXJOBN
	JOBRD T,		;EXAMINE LOSER CORE
	POPJ P,			;LOSE
	MOVE T,EXJWRD
	JRST CPOPJ1
>;IFN UEDDTS

FIRARG:
	MOVEM T,DEFV
	TLO F,FAF
	JRST ULIM1
ULIM:
	TLO F,SAF
	HRRZM T,ULIMIT
ULIM1:
	TLNN F,QF
	JRST ERR
	JRST LIS0


REPEAT 0,<LOOK:	SKIPL R,PRGM	;LOOK UP SYMBOL
	MOVE R,@SYMP
	HLRE S,@SYMP
	ASH S,-1	;SETUP COUNT FOR LENGTH OF SYM TABLE
	TLZ F,400000
	HRLZI W2,DELO+DELI
	MOVEM T,TEMDDT

LOOK1:
	TDNE W2,(R)
	JRST LOOK3
	MOVE T,(R)
	TLNN T,PNAME	;NAME
	TLOA W2,LOCAL
	SKIPA T,TEMDDT
	JRST LOOK3
	MOVE W,1(R)
	XOR W,T
	JUMPL W,LOOK3
	SUB T,1(R)
	JUMPL T,LOOK3
	JUMPGE F,LOOK2
	MOVE W,1(R)
	SUB W,1(W1)
	JUMPLE W,LOOK3
LOOK2:
	HRR W1,R		;POINTER BEST VALUE SO FAR
	TLO F,400000
	JUMPE T,SPT0
LOOK3:
	ADD R,[XWD 2,2]
	SKIPL R
	MOVE R, @SYMP
	AOJLE S,LOOK1	;TERMINATING CONDITION
	MOVE T,TEMDDT
	TLNE F,400000
	SUB T,1(W1)
	JRST CPOPJ1>
LOOK:
	SETZM SVFB
	SETZM SVTB
	SETZM BLVL
	SYMTST
	HLRE S,@SYMP
	ASH S,-1
	TLZ F,600000
	MOVEM F,SVF
	HRLZI W2,DELO+DELI
	MOVEM T,TEMDDT
	SKIPL R,PRGM
	JRST TOPDWD
LOOK1:
	SUB R,[XWD 2,2]
	TDNE W2,(R)
	JRST LOOK3
	LDB T,[POINT 4,(R),3]
	CAIN T,3
	JRST BLNME
	JUMPE T,PNAM
	MOVE T,TEMDDT
	MOVE W,1(R)
	XOR W,T
	JUMPL W,LOOK3
	SUB T,1(R)
	JUMPL T,LOOK3
	JUMPGE F,LOOK2
	MOVE W,1(R)
	SUB W,1(W1)
	JUMPLE W,LOOK3
LOOK2:
	HRR W1,R
	TLO F,400000
	TLNE F,200000
	JRST LOOK2A
	MOVE W,SVTB
	MOVEM W,SVFB
LOOK2A:
	TLNE W2,LOCAL
	SETZM SVFB
	JUMPE T,LOOK4
LOOK3:
	CAMN R,@SYMP
	JRST TOPDWN
LOOK3A:
	AOJLE S,LOOK1
	MOVE T,TEMDDT
	TLNE F,400000
	SUB T,1(W1)
	JUMPE T,SPT0
	JRST CPOPJ1

TOPDWD:
	TLO W2,LOCAL
TOPDWN:
	HLRE R,@SYMP
	MOVNS R
	ADD R,@SYMP
	JRST LOOK3A

BLNME:
	MOVEM R,SVTB
	MOVE T,1(R)
	CAMN R,BLOCK
	JRST BLNM1
	CAML T,BLVL
	JRST BLNM2
BLNM1:
	MOVEM T,BLVL
	TLNE F,200000
	JRST LOOK3
	EXCH F,SVF
	EXCH W1,SW1
	TLO F,200000
	JRST LOOK3

BLNM2:
	TLNN F,200000
	JRST LOOK3
PNAM1:
	EXCH F,SVF
	EXCH W1,SW1
	JRST LOOK3

PNAM:
	TLO W2,LOCAL
	TLNN F,200000
	JRST LOOK3
	JUMPGE F,LOOK5
	MOVE F,SVF
	JUMPGE F,PNAM2
	MOVE T,1(W1)
	EXCH W1,SW1
	CAMGE T,1(W1)
	JRST LOOK5A
	MOVE W1,SW1
PNAM2:
	SETZM SVFB
	TLO F,400000
	TLZ F,200000
	JRST LOOK3

LOOK4:
	TLZN F,200000
	JRST LOOK3
	SETZM SVFB
	JRST SPT0

LOOK5:
	EXCH F,SVF
	EXCH W1,SW1
LOOK5A:
	MOVE T,1(W1)
	CAMN T,TEMDDT
	JRST SPT0
	JRST LOOK3

CONSYM:
	MOVEM T,LWT
	TRNN F,LF1
	JRST (SCH)		;PIN OR FTOC
	TRNE F,CF1
	JRST  FTOC

LFPIN:
	JFCL
RFPIN:
	JFCL		;FOR L AND V MODES (JUST SO THEY ARE NOT PIN)
PIN:
				;PRINT INSTRUCTION
	TLC T,700000
	TLCN T,700000
	JRST INOUT		;IN-OUT INSTRUCTION OR NEG NUM
	AND T,[XWD 777000,0]
	JUMPE T,HLFW
	PUSHJ P,OPTYPE
PIN1:
	MOVSI	T,777000
	AND 	T,LWT
	TRNN F,ITF		;HAS INSTRUCTION BEEN TYPED?
	PUSHJ P,LOOK		;NO, LOOK IN SYMBOL TABLE
	TROA F,NAF		;INSTRUCTION TYPED, ALOOW NEG ADDRESSES
	JRST HLFW		;NOT FOUND, OUTPUT AS HALFWORDS
	PUSHJ P,TSPC
	LDB T,[XWD 270400,LWT]	;GET AC FIELD
	JUMPE T,PI4
	PUSHJ P,PAD
PI3A:
	MOVEI W1,","
	PUSHJ P,TEXT
PI4:
	MOVE W1,LWT
	MOVEI T,"@"
	TLNE W1,20		;CHECK FOR INDIRECT BIT
	PUSHJ P,TOUT
	HRRZ T,LWT
	LDB W,[XWD 331100,LWT]	;INSTRUCTION BITS
	CAIL W,240
	CAILE W,247
	JRST PI8
	TLNN W1,20	;INDIRECT
	CAIN W,<JFFO>⊗-33
	JRST PI8	;AND JFFO GET SYMBOLIC
	PUSHJ P,PADS3A
PI7:
	TRZ F,NAF	
	LDB R,[XWD 220400,LWT]	;INDEX REGISTER CHECK
	JUMPE R,PADS1		;EXIT
	MOVEI T,050;;"("
	PUSHJ P,TOUT
	MOVE T,R
	PUSHJ P,PAD
	MOVEI T,051;;")"
	JRST TOUT		;EXIT

PI8:
	CAIN SCH,LFPIN	;IN ONE OF THE SPECIAL MODES?
	JRST LFFLG
	CAIN SCH,RFPIN
	JRST RFFLG
PI8A:
	PUSHJ P,PAD
	JRST PI7


HLFW:
	;PRINT AS HALF WORDS
	HLRZ T,LWT
	JUMPE T,HLFW1
	TRO F,NAF	;ALLOW NEGATIVE
	PUSHJ P,PAD
	MOVSI W1,(<ASCII /,,/>)
	PUSHJ P,TEXT2
HLFW1:
	HRRZ T,LWT

PAD:
	;PRINT ADDRESS
	JRST (AR)		;PADSO OR PAD1
PADSO:
	JUMPE T,TOC2+1
	PUSHJ P,LOOK
PADS1:
	POPJ P,0
	MOVE W2,1(W1)
	CAMGE T,MXINC
	CAIGE W2,60
	JRST PADS3
	MOVEM T,TEMDDT
	JUMPGE F,PAD1
	PUSHJ P,SPT0
	MOVEI T,"+"
PADS1A:
	PUSHJ P,TOUT
	HRRZ T,TEMDDT
PAD1:
	JRST TOC		;EXIT

PADS3:
	MOVE T,TEMDDT
PADS3A:
	TRNE F,NAF
	CAIGE T,776000
	JRST TOC
PADS3B:
	CAMN T,[-1,,0]
	JRST PADS3C		;SPECIAL CASE THAT PRINTS WRONG
	MOVNM T,TEMDDT
	MOVEI T,"-"
	JRST PADS1A

PADS3C:
	MOVEI T,"-"
	PUSHJ P,TOUT
	MOVSI T,1
	JRST TOC

INOUT:
	TLC T,-1	;IS IT PERHAPS NEGATIVE
	TLCN T,-1
	JRST PADS3B
	TLC T,777000
	TLCN T,777000	;THIS IS ALMOST AS GOOD
	JRST HLFW	;PRINT AS A HALF WORD
	MOVSI R,-IOTLG	;GET LENGTH OF IOT DEVICE TABLE
	LDB W2,[POINT 7,T,9]	;GET DEVICE NUMBER
	LSH W2,2
CKIOT:
	CAMN W2,IOTBL(R)	;THERE?
	JRST ISIOT	;YES
	AOBJN R,CKIOT
	JRST PIN1	;PRINT AS AN INSTRUCTION
ISIOT:
	LDB R,[POINT 3,T,12]
	DPB R,[POINT 6,T,8]	;MOVE IO BITS OVER FOR OP DECODER
	PUSHJ P,OPTYPE
	PUSHJ P,TSPC
	LDB T,[POINT 7,LWT,9]
	JUMPE T,INOU1
	LSH T,2
IFN EDDT&1!UEDDTS,<	MOVSI W1,-IOTB2L	;GET NAME TABLE LENGTH
IOTLK:
	MOVE W,IOTB2(W1)	;GET NAME AND NUMBER
	ANDI W,177	;MASK FOR NUMBER
	LSH W,2		;SHIFT DEVICE NUMBER BACK TO COMPARE
	CAMN T,W
	JRST IOTFD	;GOODY WE FOUND THE NUMBER
	AOBJN W1,IOTLK	;GO LOOK SOME MORE>
	PUSHJ P,LOOK		;LOOK FOR DEVICE NUMBER
	JRST PI3A
	MOVE T,TEMDDT
	PUSHJ P,TOC
	JRST PI3A
IFE EDDT&1!UEDDTS,<INOU1:	JRST PI4>
IFN EDDT&1!UEDDTS,<IOTFD:	MOVE W1,IOTB2(W1)	;GET NAME AND NUMBER
	TRZA W1,177	;MASK OUT NUMBER AND PRINT
INOU1:
	MOVE W1,[ASCII /APR/]
	PUSHJ P,TEXT2
	JRST PI3A

DEFINE XQ (A,B)
<<ASCII /A/>!<B⊗-2>
>
IOTB2:

DEVICES
IOTB2L←.-IOTB2>

MASK:
	TLNE F,QF
	JRST MASK1
	MOVEI T,MSK
MASK2:
	MOVEI W,1
	MOVEM W,FRASE1
	JRST QUAN1
MASK1:
	MOVEM T,MSK
	JRST RET

EFFEC:
	TLO F,LTF
	HRRZ T,T
WORD:
	MOVEI R,322000-326000	;JUMPE-JUMPN
NWORD:
	ADDI R,326000+40*T	;JUMPN T,
	HRLM R,SEAR2

	TLZN F,QF
	JRST ERR
	SETCAM T,WRD
	MOVSI T,FRASE-DENDDT-1		;PREVENT TYPE OUT OF DDT PARTS
	SETCMM FRASE(T)
	AOBJN T,.-1
	MOVE T,ULIMIT
	TLNE F,SAF
	TLO F,QF
	PUSHJ P,SETUP1
	PUSHJ P,CRF
SEAR1:
	PUSHJ P,FETCH
	JRST SEAR2A
	TLNE F,LTF	;CHECK FOR EFFECTIVE ADDRESS SEARCH
	JRST EFFEC0
	EQV T,WRD
	AND T,MSK
SEAR2:
	JUMPE T,SEAR3		;OR JUMPN T
SEAR2A:
	PUSHJ P,LISTEN	;QUIT ON TELETYPE
	CAIA
	JRST SEAR2B
	CAMN R,[-1]	;LOSING AOBJN WILL SCREW THIS UP!!!!
	JRST SEAR2B	;END
	AOBJN R,SEAR1
	TLNE R,777777	;DID IT JUST GET TO 0 OR IS IT LARGER THAN 128K?
	JRST SEAR1	;BIG SEARCH
SEAR2B:
	SETCMM LWT
	JRST DD1

SEAR3:
	PUSHJ P,FETCH
	JRST ERR
	TLZ F,STF	;TURN OFF SUPRESS OUTPUT
	MOVEM R,TEM2
	MOVEM R,T
	PUSHJ P,LI1
	PUSHJ P,CRF
	SETCMM LWT
	SETCMM TEMDDT
SEAR4:
	MOVE R,TEM2
	JRST  SEAR2A

EFFEC0:
	TLNE F,CCF	;DOUBLE ALTMODE?
	JRST EFFECR	;YES, NO @() CHECK -- RPH 5-12-73
	MOVEM R,TEM2
	PUSHJ P,EFFECA
	JRST SEAR4	;LOST ON EFF ADR CALC
	MOVE R,TEM2
EFFECR:
	EQV T,WRD
	ANDI T,777777
	JRST SEAR2
EFFECA:
	MOVEI W,100
	MOVEM W,TEMDDT
EFFEC1:
	MOVE W,T
	LDB R,[POINT 4,T,17]	;GET IR FIELD
	JUMPE R,EFFEC2
	HRRZ T,AC0(R)
	ADD T,W
EFFEC2:
	HRR R,T
	TLNN W,20		;INDIRECT BIT CHECK
	JRST EFFEC3
	SOSE TEMDDT
	PUSHJ P,FETCH
	POPJ P,		;ERROR RETURN
	JRST EFFEC1
EFFEC3:
	HRRZS T		;HALFWORD ONLY
	JRST CPOPJ1	;SKIP RETURN


SETUP:
	TROA F,R20F	;FOR ZERO ONLY
SETUP1:
	TRZ F,R20F
	TLNN F,SAF
IFE UEDDTS,<MOVE T,JOBREL>
IFN UEDDTS,{MOVE T,MEMSIZ	;SYSTEM JOBREL PTR.}
	HLLI	T,
	MOVEM T,ULIMIT
IFE UEDDTS,<CAMLE T,JOBREL>
IFN UEDDTS,{CAMLE T,MEMSIZ}
	JRST ERR
	HRRZ R,DEFV
	TLNN F,FAF
	MOVEI R,0
	CAML R,ULIMIT
	JRST ERR
	MOVEM R,DEFV
	MOVEI W,-1(R)			;RPH 3-17-72
	SUB W,ULIMIT
	HRLM W,R
	POPJ P,0

ZERO:
	TLNN F,CCF
	JRST ERR
	MOVE W2,T
	TLNN F,QF
	MOVEI W2,0
	HRRZ T,ULIMIT
	PUSHJ P,SETUP
ZERO1:
	TRNE R,777760
	JRST ZERO2
	MOVEM W2,AC0(R)
	AOBJN R,ZERO1
	JRST DD1
ZERO2:
	HRRZ R, R
	CAIGE R,ZLOW
	MOVEI R,ZLOW		;DON'T ZERO 20-ZLOW
	HRRZ S,T
	CAIL S, DDT
	MOVEI S, DDT 
	CAMLE S,R
	JSP W,ZEROR
	HRRZ R,R
	CAIG R, DDTEND  ; DON'T ZERO OUT
	MOVEI R, DDTEND  ; DDT
	HRRZ S,T
	CAMLE S, R
	JSP W,ZEROR
	JRST DD1

ZEROR:
	HRL R,R
	MOVEM W2,(R)
	ADDI  R, 1
	BLT R, -1(S)
	JRST (W)


TOCC:
	TRO F,EQF	;SET TO REAL NUMERIC MODE
FTOC:

TOC:
	HRRZ W1,ODF
	CAIN W1,12
	JRST  TOC4
	TRZE F,EQF
	JRST TOCA
	CAIN W1,10
	TLNN T,-1	;IF RADIX NOT 10, OR LEFT HALF EMPTY
	JRST TOCA	;PRINT
	HRRM T,TOCS	;SAVE RIGHT HALF
	HLRZS T
	PUSHJ P,TOCA	;PRINT LEFT HALF
	MOVSI W1,(<ASCII /,,/>)
	PUSHJ P,TEXT2
TOCS:
	MOVEI T,0	;MODIFIED TO HAVE RIGHT HALF
TOCA:
	LSHC T,-43
	LSH W1,-1		;W1=T+1
TOC1:
	DIVI T,(ODF)
	HRLM W1,0(P)
TOC3:
	JUMPE T,TOC2
	PUSHJ P,TOCA
TOC2:
	HLRZ T,0(P)
	ADDI T,"0"
	JRST TOUT	;DOES POPJ TO TOC2 OR EXIT

TOC4:
	MOVM W1,T
	JUMPGE T,TOC5
	MOVEI T,"-"
	PUSHJ P,TOUT
TOC5:
	MOVEI T,0
	PUSHJ P,TOC1
TOC6:
	MOVEI T,"."
	JRST TOUT

SPT0:
	HRRZM W1,SPSAV		;SAVE POINTER TO TYPED SYM
SPT:
	;RADIX 50 SYMBOL PRINT
	MOVE T,SVFB
	JUMPE T,SPT1W
	CAMN T,BLOCK
	JRST SPT1W
	PUSH P,W1
	LDB T,[POINT 32,(T),35]
	PUSHJ P,SPT1
	MOVEI T,"&"
	PUSHJ P,TOUT
	POP P,W1
SPT1W:
	LDB T,[POINT 32,(W1),35]	;GET SYMBOL
SPT1:
	IDIVI T,50
	HRLM W1,0(P)
	JUMPE T,SPT2
	PUSHJ P,SPT1
SPT2:
	HLRZ T,0(P)
	JUMPE T,CPOPJ		;FLUSH NULL CHARACTERS
	ADDI T,260-1
	CAILE T,271
	ADDI T,301-272
	CAILE T,332
	SUBI T,334-244
	CAIN T,243
SPT3:
	MOVEI T,256
	JRST TOUT

SYMD:
	MOVEI T,DELO/200000	;$D ;DELETE LAST SYM & PRINT NEW
	HRRZ R,SPSAV		;PICK UP POINTER TO LAST SYM
	JUMPE R,ERR
	DPB T,[POINT 2,(R),1]	;STORE SEMI-DELETE BITS IN SYMBOL
	MOVE T,LWT
	JRST CONSYM		;PRINT OUT NEXT BEST SYMBOL

;THESE 2 ARE HERE BECAUSE SWAPPING DDT DOESN'T SAVE THE
;UNDEFINED SYMBOL TABLE!!!!!!!
ESTU:
	0
ESTUT:
	0

;FLOATING POINT OUTPUT

TFLOT:
	MOVE A,T
	JUMPG A, TFLOT1
	JUMPE A,FP1A
	MOVNS A
	MOVEI T,"-"
	PUSHJ P,TOUT
	TLZE A,400000
	JRST FP1A
TFLOT1:
	
	TLNN A, 400
	JRST FP7A	;UNNORMALIZED FLOATING PRINT AS DECIMAL

FP1:
	MOVEI B,0
	CAMGE A,FT01
	JRST FP4
	CAML A,FT8
	AOJA B,FP4
FP1A:
	MOVEI C,0

FP3:
	MULI A,400
	ASHC B,-243(A)
	MOVE A,B
	SETZM TEM1
	PUSHJ P,FP7
	PUSHJ P,TOC6		;PRINT DECIMAL POINT
	MOVNI A,10
	ADD A,TEM1
	MOVE W1,C
FP3A:
	MOVE T,W1
	MULI T,12
	PUSHJ P,FP7B
	SKIPE W1
	AOJL A,FP3A
	POPJ P,

FP4:
	MOVNI C,6
	MOVEI W2,0
FP4A:
	ASH W2,1
	XCT FCP(B)
	JRST FP4B
	FMPR A,@FCP+1(B)
	IORI W2,1
FP4B:
	AOJN C,FP4A
	PUSH P,FSGN(B)
	PUSHJ P,FP3
	POP P,W1
	MOVE A,W2
	PUSHJ P,TEXT

FP7:
	JUMPE A,FP7A2
	IDIVI A,12
	AOS TEM1
	HRLM B,(P)
	JUMPE A,FP7A1
	PUSHJ P,FP7
FP7A1:
	HLRZ T,(P)
FP7B:
	ADDI T,260
	JRST TOUT
FP7A:
	PUSHJ P,FP7
	MOVEI T,"."
	JRST TOUT	;PRINT WITH A .
FP7A2:
	MOVEI T,"0"
	JRST TOUT

	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:
	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:
	201400000000	;1.0E0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:
	175631463146	;1.0E-1
FT0←←FT01+1

FCP:
	CAMLE A, FT0(C)
	CAMGE A, FT(C)
	XWD C,FT0

FSGN:
	ASCII .E-.
	ASCII .E+.

TEXTT:
	MOVE W1,T
TEXT:
	TLNN W1,774000		;LEFT JUSTIFIED UNLESS LEFT CHAR IS NULL
	LSH W1,35
TEXT2:
	MOVEI T,0
	LSHC T,7
	CAILE T,04		;EOT
	PUSHJ P,TOUT
	JUMPN W1,TEXT2
	POPJ P,

;RPH 7-29-72  TYPE OUT TTY INPUT BUFFERS
TEXTT9:
	MOVE W1,T
TEXTT0:
	MOVEI T,0
	LSHC T,11
	PUSH P,T
	LSH T,-7
	PUSH P,T
	SKIPA T,["↑"]
	PUSHJ P,TOUT
	SOSL (P)
	JRST .-2
	POP P,(P)
	POP P,T
	ANDI T,177
	SKIPE T
	PUSHJ P,TOUT
	JUMPN W1,TEXTT0
	POPJ P,

IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG


PSR:
	TLNN F,ROF
	JRST ERR
	MOVEM T,LWT
	PUSHJ P,DEPRS
	HRRZM R,DEFV		;R CONTAINS LLOCO
	MOVE T,R
	JRST PUN2

PUNCH:
	TLC F,FAF+QF
	TLCE F,FAF+QF
	JRST ERR		;ONE ARGUMENT MISSING
PUN2:
	ADDI T,1
	HRRZM T,TEM1
	SUB T,DEFV
	JUMPLE T,ERR

PUN1:
	MOVEI T,10
	PUSHJ P,FEED
	HRRZ R,DEFV
	IORI R,37
	ADDI R,1
	CAMLE R,TEM1
	MOVE R,TEM1
	EXCH R,DEFV
	MOVE T,R
	SUB T,DEFV
	HRL R,T
	JUMPGE R,RET		;EXIT OR PUNCH

PBLK:
	MOVE T,R
	SOS W,T
	PUSHJ P,PWRD
PBLK1:
	PUSHJ P,FETCH
	JRST ERR
	ADD W,T
	PUSHJ P,PWRD
	AOBJN R,PBLK1
	MOVE T,W
	PUSHJ P,PWRD
	JRST PUN1

>

IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG


LOADER:
	TLNE F,QF
	JRST ERR
	MOVEI T,400
	PUSHJ P,FEED
	MOVE R,LOADE
LOAD1:
	MOVE T,0(R)
	PUSHJ P,PWRD
	AOBJN R,LOAD1
	MOVEI T,100
LOAD2:
	PUSHJ P,FEED
	JRST RET

BLKEND:
	TLNN F,QF		;BLOCK END
	MOVE T,[JRST 4,DDT]
	TLO T,254000		;JRST
	PUSH P,T
	MOVEI T,100
	PUSHJ P,FEED
	POP P,T
	PUSHJ P,PWRD
	PUSHJ P,PWRD	;EXTRA WORD FOR READER TO STOP ON
	MOVEI T,500
	JRST LOAD2

PWRD:
	MOVEI W1,6
PWRD2:
	ROT T,6
	CONSZ PTPP,20
	JRST .-1
	CONO PTPP,50
	DATAO PTPP,T
	SOJG W1,PWRD2
	POPJ P,0

FEED:
	CONSZ PTPP,20
	JRST .-1
	CONO PTPP,10
	DATAO PTPP,FEED1
	SOJN T,FEED
FEED1:
	POPJ P,0

>

IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG


VERIFY:
	TLO F,LTF
CORE:
	PUSHJ P,SETUP1		;LOAD TAPES INTO CORE
	CONO PTRR,60
CORE1:
	CONSO PTRR,10
	JRST .-1
	DATAI PTRR,T
	CAME T,LOADE-1		;JRST 1
	JRST CORE1
	PUSHJ P,CRF
	PUSHJ P,BLOCKQ

CORE2:
	PUSHJ P,GETW
	CAML R,DEFV
	CAML R,ULIMIT
	JRST VER3
	TLNE F,LTF
	JRST VER2
	PUSHJ P,DEP
	JRST VER3

VER2:
	MOVEM T,TEM2
	PUSHJ P,FETCH
	JRST ERR
	MOVEM T,TEM3
	XOR T,TEM2
	AND T,MSK
	JUMPE T,VER3
	PUSH P,S
	PUSH P,R
	HRRZ T,R
	PUSHJ P,PAD
	MOVEI T,257		;SLASH
	PUSHJ P,TOUT
	PUSHJ P,LCT
	MOVE T,TEM3		;CORE CONTENTS
	PUSHJ P,CONSYM
	PUSHJ P,LCT
	MOVE T,TEM2		;TAPE CONTENTS
	PUSHJ P,CONSYM
	PUSHJ P,CRF
	POP P,R
	POP P,S
VER3:
	PUSHJ P,LISTEN
	AOJA R,CORE2
RUNEND:
	PUSHJ P,BLOCKQ
	JRST .-1


>

IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG



GETW:
	JUMPL S,GETW1
	PUSHJ P,BLOCKQ
GETW1:
	MOVE T,1(S)
	AOBJP S,.+1
	POPJ P,0

BLOCKS:
	CONO PTRR,60		;READ DATA BLOCKS
BLOCKQ:
	CONSO PTRR,10
	JRST .-1
	DATAI PTRR,W
	JUMPL W,BLK1
	MOVEM W,STARTA
	CONO PTRR,0		;TURN OFF READER
	JRST DD1
BLK1:
	MOVEM W,W1
	TLC W,777740
	TLCE W,777740
	JRST ERR		;BLOCK TOO BIG
	ADDI W,1
	HRRZM W,R
	HRRI W,BUFF-1
	MOVEM W,S
BLK2:
	CONSO PTRR,10
	JRST .-1
	BLKI PTRR,W
	JRST BLK3
	ADD W1,0(W)
	JRST BLK2
BLK3:
	ADD W1,0(W)
	CONSO PTRR,10
	JRST .-1
	DATAI PTRR,W
	CAMN W,W1
	POPJ P,0
	CONO PTRR,0		;CHECKSUM ERROR
	JRST 4,BLOCKS

;R CONTAINS RIGHT HALF OF FIRST LINE
;S CONTAINS (-WC,BUFF-1)


>

IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG


LOADB:
	

IFE EDDT&10,<
DATAI PTRR,1
	XWD -1,-22
DATAI PTRR,2
	CONSO PTRR,10
DATAI PTRR,3
	JRST 2
MOVE 4,37
HRLI 4,710441                          ;DATAI PTRR,0(1)
DATAI PTRR,5
	AOJN 1,2
DATAI PTRR,6
	JRST -6(4)
JRST 2


MOVE 0,1
CONSO PTRR,10
JRST -21(4)
DATAI PTRR,0(1)
ROT 0,1
ADD 0,(1)
AOBJN 1,-21(4)
CONSO PTRR,10
JRST -13(4)
DATAI PTRR,1
CAME 1,0
JRST 4,-6(4)
CONSO PTRR,10
JRST -6(4)
DATAI PTRR,1
JUMPL 1,-22(4)
CONO PTRR,0
JRST 1

>
IFN EDDT&10,<
PHASE 0		;RIM10B CHECKSUM LOADER
	XWD -16,0
BEG:
	CONO PTRR,60
	HRRI PTRR,10
RD:
	CONSO PTRR,10
	JRST .-1
	DATAI PTRR,@TBL1-RD+1(AA)
	XCT TBL1-RD+1(AA)
	XCT TBL2-RD+1(AA)
AA:
	SOJA AA,
TBL1:
	CAME CKSM,ADR
	ADD CKSM,1(ADR)
	SKIPL CKSM,ADR
TBL2:
	JRST 4,BEG
	AOBJN ADR,RD
ADR:
	JRST BEG+1
CKSM←←ADR+1

DEPHASE
>
LOADE:
	XWD LOADB-.,LOADB
>


ORG CRN;;Short workaround for tag match failed -184. decimal
CRN:
	MOVEI T,15		;CARRIAGE RETURN
	JRST TOUT

IFE EDDT&1,<
CRNRB:
	PUSHJ P,CRN
	MOVEI T,177
	JRST TOUT	>

CRF:
	PUSHJ P,CRN
	MOVEI T,12		;LINE FEED
	JRST TOUT

LCT:
	IFN EDDT&1,<PUSHJ P,TSPC
	PUSHJ P,TSPC>
	IFE EDDT&1,<MOVEI T,11
	JRST TOUT>

TSPC:
	MOVEI T,40		;SPACE
	JRST TOUT


IFN EDDT&1,<

TINSTR:
	ILDB T,STRING
	JUMPE T,TIN3	;THERE IS A CHR
	CONSZ TTYY,40
	JRST TIN3
	CAIE T,15
	JRST TIN2
	ILDB T,STRING
	CAIN T,12
	JRST TIN4
	MOVSI T,70000
	ADDM T,STRING
TIN4:
	MOVEI T,15
	JRST TIN2
TIN3:
	SETZM STRING	;ZERO AND READ TTY
TIN:
	SKIPE STRING
	JRST TINSTR	;GET IT FROM THE STRING
	PUSHJ P,LISTEN
	JRST .-1
TIN2:
	CAIE T,175
	CAIN T,176
	MOVEI T,33	;CHANGE ALL ALT MODES TO NEW
	CAIN T,177
	JRST WRONG
	TRNE T,140
TOUT:
	CAIG T,4
	POPJ P,
	SKIPE OUTRTN
	JRST @OUTRTN
IFN EDDT&1,<
	SKIPE OUTLPT
	JRST LPOUT
>
	HRLM T,(P)
	IMULI T,200401
	AND T,[11111111]
	IMUL T,[11111111]
	HLR T,(P)
	TLNE T,10
	TRC T,200
	CONSZ TTYY,20
	JRST .-1
	DATAO TTYY,T
	ANDI T,177
	POPJ P,0

IFN EDDT&1,<
LPOUT:
	IDPB T,LPPTR
	SOSLE LPCNT
	POPJ P,
	PUSH P,T
	MOVEI T,5
	MOVEM T,LPCNT
	DATAO LPT,LPWRD
	MOVE T,[POINT 7,LPWRD]
	MOVEM T,LPPTR
	CONSO LPT,100
	JRST .-1
	POP P,T
	POPJ P,

LPPTR:
	POINT 7,LPWRD
LPWRD:
	0
LPCNT:
	5
>

LISTEN:
	CONSO TTYY,40	;LISTEN FOR TTY
	POPJ P,
	DATAI TTYY,T
	ANDI T,177
	JRST CPOPJ1

TTYRET:
	MOVEI  T,3410
TTY1:
	MOVEI W2,40000
	CONSZ TTYY,120
	SOJG W2,.-1
	CONI TTYY,SAVTTY
	DATAI TTYY,W2
	HRLM W2,SAVTTY
	CONO TTYY,(T)
	POPJ P,
TTYLEV:
	MOVE T,SAVTTY
	TRZ T,160
	TRO T,3600
	TRNE T,10
	TRZ T,200
	JRST TTY1

TEXIN:
	PUSHJ P,TIN
	TRNN T,140
	JRST TOUT
	POPJ P,

>

IFE EDDT&1,<

TIN:
	MOVE T,POUTBF		;GET NEXT CHARACTER ROUTINE
	CAME T,[POINT 7,INBFF]
	PUSHJ P,FINOUT
	SKIPE STRING
	JRST TINSTR
;	ILDB T,PINBFF
	INCHRW T		;RPH 5-22-71
	CAIN T,15
	INCHRW 1(P)		;THROW THE LF DOWN ON THE STACK
TIN3:
	CAIE T,176
	CAIN T,175
	MOVEI T,33	;CHANGE TO NEW ALT MODE
	CAIN T,177
	JRST WRONG
	JUMPN T,CPOPJ
;	MOVE T,[POINT 7,INBFF]
;	MOVEM T,PINBFF
;	CALL T,[SIXBIT /DDTIN/]
TIN2:
	SETZM STRING
	JRST TIN

TINSTR:
	ILDB T,STRING
	JUMPE T,TIN2	;ALL DONE
	CAIN T,33	;NOT THIS ONE STUPID
	MOVEI T,"$"	;DO IS AS $
	SKIPN OUTRTN
	JRST TIN4
	PUSHJ P,@OUTRTN
	JRST TIN3
TIN4:
	IDPB T,POUTBF	;DUPLEX
	JRST TIN3	;AND EAT

TOUT:
	JUMPE T,CPOPJ
	SKIPE OUTRTN
	JRST @OUTRTN
	CAIE T,177		;IS IT THIS GODDAMN CHAR?
	JRST NOTDEL		;NO
	SETO T,
	TTYUUO 6,T
	TLNE T,526000		;WILL HE IGNORE A 177?
	POPJ P,			;NO, SKIP IT
	MOVEI T,177		;CHANGE BACK TO 177
NOTDEL:
	IDPB T,POUTBF
	CAIE T,12
	POPJ P,
TTYLEV:

FINOUT:
	MOVEI T,0
	IDPB T,POUTBF
	MOVE T,[POINT 7,INBFF]
;	MOVEM T,PINBFF
	MOVEM T,POUTBF
;	CALL T,[SIXBIT /DDTOUT/]
	OUTSTR INBFF
	SETZM  INBFF
	POPJ P,

;PINBFF:	POINT 7,INBFF
POUTBF:
	POINT 7,INBFF

IFE UEDDTS,<
LISTEN:
	INCHRS T
	POPJ P,
	CLRBFI
	JRST CPOPJ1
>;UEDDTS
IFN UEDDTS,<
LISTEN:
	POPJ P,		;DON'T WASTE TIME CHECKING TTY
>;UEDDTS	RPH 7-30-72
INBFF:
	BLOCK 31

TTYRET:

	MOVE T,[POINT 7,INBFF]
	MOVEM T,POUTBF
;	MOVEM T,PINBFF
	SETZM  INBFF
	POPJ P,


TEXIN←←TIN
>

BDISP:
	POINT 12,DISP(R),11
	POINT 12,DISP(R),23
	POINT 12,DISP(R),35

DISP:
	
DEFINE D' (Z1,Z2,Z3)<
	OCT (Z1-DDT)*1B11+(Z2-DDT)*1B23+Z3-DDT
	LIST>

IFE 0,< ;;replace;;IFE EDDT&1&<EDDT>B36,;;means NOT Exec DDT with Papertape FLAG
	PUNCH←←ERR
	BLKEND←←ERR
	LOADER←←ERR
	VERIFY←←ERR
	CORE←←ERR>



D ERR,DARRW,ERR
D ERR,ERR,JOBSET
D ERR,ERR,VARRW
D TAB,LINEF,ERR
D ERR,CARR,ERR
D ERR,ERR,ERR
D PUNCH,ERR,ERR
D ERR,ERR,ERR
D ERR,ERR,ERR
D CONTROL,ERR,LTAB
D ERR,ERR,SPACE
D SUPTYO,TEXI,ASSEM
D DOLLAR,BYTI,SETBLK
D DIVD,LPRN,RPRN
D MULT,PLUS,ACCF
D MINUS,PERIOD,SLASH
D NUM,NUM,NUM
D NUM,NUM,NUM
D NUM,NUM,NUM
D NUM,TAG,SEMIC
D FIRARG,EQUAL,ULIM
D QUESTN,INDIRECT,ABSA
D BPS,CON,SYMD
D EFFEC,SFLOT,STR
D HWRDS,PILOC,FLGMOD
D KILL,LFTT,MASK
D NWORD,BITO,PROCEDE
D QUAN,RELA,SYMBOL
D TEXO,UCON,RFTT
D WORD,XEC,CORE
D ZERO,OCON,ICON
D OSYM,VARRW,PSYM



FLGOUT:
	SKIPN R,FLGPNT
	JRST HLFW	;IF NO POINTER USE HALFWORD
	MOVSI W1,400000	;SET FOR HIGH ORDER BIT
FLGLP2:
	PUSHJ P,PRNTIT
	JUMPE W1,[SKIPE EXFLAG	;WAS THERE SOMETHING PRINTED
		POPJ P,		;YES, EXIT
		MOVEI T,"0"	;NO, PRINT A 0
		JRST TOUT]
	SKIPN EXFLAG
	JRST FLGLP2
	PUSH P,T
	MOVEI T,","
	PUSHJ P,TOUT
	PUSHJ P,TOUT
	POP P,T
	JRST FLGLP2

GETPTR:
	SKIPN R,FLGPTR
	POPJ P,
FLGSLP:
	HRRZM R,FLGPNT#
	TRNE F,Q2F
	SOSGE WRD2
	JRST CPOPJ1
	HLRZS R
	JUMPE R,CPOPJ
	SKIPE R,(R)
	JRST FLGSLP
	POPJ P,

PRNTIT:
	HRLI R,-=18	;SET FOR HALF WORD
	SETZM FLGNUM#
	SETZM EXFLAG#	;NO ! AND NO NUMERIC
FLGLP:
	TDNN T,W1
	JRST NOBIT
	SKIPN (R)	;TEST FOR NAME
	JRST	[IORM W1,FLGNUM	;SAVE BIT
		JRST NOBIT]
	PUSH P,T
	PUSH P,W1
	MOVEI T,"!"
	SKIPE EXFLAG
	PUSHJ P,TOUT
	MOVE T,(R)
	PUSHJ P,SPT1
	SETOM EXFLAG	;WE HAVE PUT OUT SOMETHING
	POP P,W1
	POP P,T
NOBIT:
	LSH W1,-1
	AOBJN R,FLGLP
	SKIPE FLGNUM
	JRST	[PUSH P,T
		PUSH P,W1
		MOVEI T,"!"
		SKIPE EXFLAG
		PUSHJ P,TOUT
		MOVE T,FLGNUM
		TRNN T,-1	;CHECK TO SEE IF LEFT HALF
		MOVSS T
		PUSHJ P,TOCC
		POP P,W1
		POP P,T
		SETOM EXFLAG
		POPJ P,]
	POPJ P,

FLGMOD:
	PUSHJ P,GETPTR
	SETZM FLGPNT
	MOVEI SCH,FLGOUT
	JRST BASE1
LFTT:
	PUSHJ P,GETPTR
	SETZM FLGPNT
	MOVEI SCH,LFPIN
	JRST BASE1
RFTT:
	PUSHJ P,GETPTR
	SETZM FLGPNT
	MOVEI SCH,RFPIN
	JRST BASE1

LFFLG:
	SKIPN R,FLGPNT
	JRST PI8A	;NONE THERE
COMFLG:
	MOVEI W1,400000
	PUSHJ P,PRNTIT
	MOVEI T,"0"
	SKIPN EXFLAG
	PUSHJ P,TOUT
	JRST PI7
RFFLG:
	SKIPN R,FLGPNT
	JRST PI8A
	ADDI R,=18
	JRST COMFLG

	JRST DDT
BITO:
	MOVEI R,BITT	; PATCH FOR BYTE OUTPUT WW 12-9-66
	HRRZI AR,TOC
	TRZN F,Q2F
	JRST ERR
	MOVE T,WRD2
	MOVEM T,SVBTS
	MOVEI T,=36
	IDIV T,WRD2
	SKIPE T+1
	ADDI T,1
	MOVEM T,SVBTS2
	HRRZ SCH,R
	JRST BASE1
BITT:
	MOVE T+1,T
	SKIPN SVBTS	;0 IS MASK CONDITION
	JRST BITTM
	MOVE T,SVBTS2
	MOVEM T,SVBT2
	MOVEM T+1,SVBT3
BITT2:
	MOVEI T,0
	MOVE T+2,SVBTS
	LSHC T,(T+2)
	MOVEM T+1,SVBT3
	CAIE AR,PADSO
	PUSHJ P,FTOC
	CAIE AR,TOC
	PUSHJ P,PIN
	SOSG SVBT2
	POPJ P,
	MOVEI T,","
	PUSHJ P,TOUT
	MOVE T+1,SVBT3
	JRST BITT2
BITTM:
	MOVEI T,=36	;SET OUTPUT COUNT
	MOVEM T,SVBT3
	MOVE T+2,BMASK	;GET MASK BITS
BITTM1:
	MOVEI T,0	;SET TO SHIFT WORD
	SKIPL T+2	;START WITH 1 BITS
	SETCA T+2,
BITTM2:
	LSHC T,1	;NEXT BIT
	LSH T+2,1	;SHIFT MASK
	SOSLE SVBT3	;ALL BITS GONE?
	JUMPL T+2,BITTM2	;PART OF SAME FIELD
	MOVEM T+2,SVBT2	;SAVE MASK
	MOVEM T+1,SVBT4	;AND PARTIAL MASK
	CAIE AR,PADSO	;DO PROPER OUTPUT
	PUSHJ P,FTOC
	CAIE AR,TOC
	PUSHJ P,PIN
	SKIPG SVBT3	;ANY MORE?
	POPJ P,		;NO, RETURN
	MOVEI T,","	;COMMA
	PUSHJ P,TOUT
	MOVE T+1,SVBT4	;GET WORD BACK
	MOVE T+2,SVBT2	;AND MASK
	JRST BITTM1	;PRINT NEXT FIELD

SVBT4:
	0
SVBTS:
	0
SVBTS2:
	0
SVBT3:
	0
SVBT2:
	0	;END OF PATCH  WW 12-9-66


;DESCRIPTION OF OP DECODER FOR DDT:
;
;         THE ENTIRE INSTRUCTION SET FOR THE PDP-6 CAN BE COMPACTED INTO
;A SPACE MUCH SMALLER THAN ONE REGISTER FOR EVERY SYMBOL.  THIS OCCURS
;BECAUSE OF THE MACHINE ORGANIZATION AND INSTRUCTION MNEMONICS CHOSEN
;FOR THE PDP-6.  FOR EXAMPLE, IF BITS (0-2) OF AN INSTRUCTION EQUAL
;101(2) THE INSTRUCTION IS A HALF WORD INSTRUCTION AND AN "H" MAY
;BE ASSUMED. "T" MAY BE ASSUMED FOR ALL TEST INSTRUCTIONS (WHICH
;BEGIN WITH 110(2).
;
;     	THE TABLE TBL IN DDT CONSISTS OF 9 BIT BYTES, 4 TO A WORD.
;THE NUMBERS IN THE BYTES HAVE THE FOLLOWING SIGNIFICANCE:
;0-37(8):	THIS IS A DISPATCH COMMAND FOR THE OP-DECODER INTERPRETER.
;	LET THE RIGHT MOST TWO BITS EQUAL N; LET THE NEXT 3 BITS
;	EQUAL P.
;
;	THE CONTENTS OF INST (INSTRUCTION) CONTAIN IN THE RIGHT
;	MOST NINE BITS THE BINARY FOR THE MACHINE INSTRUCTION.
;	P AND N REFER TO THE CONTENTS OF INST, AND THE OP DECODER
;	WILL PRODUCE AN ANSWER D GIVEN P, N, AND THE CONTENTS
;	OF INSTX N+1 GIVES THE NUMBER OF BITS IN INST; P GIVES THE
;	POSITION (FROM THE RIGHT EDGE) OF THE N+1 BITS.
;
;	EXAMPLE: P = 6
;	         N = 2
;
;;	C(INST) = .010 101 100(2)
;
;	THE RESULT- D = 010(2) = 2(8)
;
;	D IS USED AS A DISPATCH ON THE NEXT BYTES IN THE TABLE.
;	IF D = 5, 5 BYTES IN THE TABLE (DON'T COUNT THE BYTES WHICH
;	PRINT TEXT, 41-72(8)) ARE SKIPPED OVER AND THE 6TH BYTE RESUMES
;	THE INTERPRETATION.
;
;40(8)	THIS IS A STOP CODE; WHEN THIS IS REACHED INTERPRETATION
;	IS FINISHED.

;41(8)-72(8)      THE ALPHABET IS ENCODED INTO THIS RANGE.
;	        41- A
;	        42- B
;	        72- Z
;	        WHEN A BYTE IN THIS RANGE IS REACHED, ITS CORRESPONDING
;	        LETTER IS TYPED.
;
;73(8)-777(8)     THIS IS A TRANSFER BYTE.  IF THE BYTE IN THIS RANGE IS
;	        CONSIDERED TO BE A, TRANSFER INTERPRETATION TO THE A-73(8)RD
;	        BYTE IN THE TABLE.
;
;MAROS ASSEMBLE THE TABLE TBL:
; 1.   A NUMBER FOLLOWED BY ↑ ASSEMBLES A DISPATCH BYTE.  THE FIRST
;      DIGIT IS THE POSITION; THE SECOND DIGIT IS THE SIZE.
; 2.   A POINT (.) ASSEMBLES A STOP CODE.
; 3.   A NAME FOLLOWED BY A SLASH ASSEMBLES A TRANSFER TO THE
;      SYMBOLICALLY NAMED BYTE.
; 4.   A STRING OF LETTERS TERMINATED BY A SPACE, COMMA, OR POINT,
;      ASSEMBLE INTO A STRING OF BYTES, EACH BYTE BEING ONE LETTER.
;
;EXAMPLE OF BINARY TO SYMBOLIC DECODING:
;      THE MACHINE CODE FOR JRST IAS 254
;          INST    0  1  0  1  0  1  1  0  0
;      THE INTERPRETER STARTS WITH THE FIRST BYTE IN THE TABLE (63↑).
;      THE RESULT OF APPLYING THIS TO C(INST) GIVES 2.  SKIPPING OVER
;      2 BYTES IN THE TABLE AND INTERPRETING THE THIRD RESULTS IN
;      HAK/ BEING INTERPRETED.  AT HAK:, THERE IS A 33↑.  APPLYING
;      THIS TO C(INST) RESULTS IN 5 NON PRINTING BYTES BEING SKIPPED
;      OVER:
;          1.  MV/
;               MOV      PRINTING TEXT
;          2.  MO/
;          3.  ML/
;          4.  DV/
;          5.  SH/
;
;H1/ IS THE NEXT BYTE INTERPRETER.  AT H1: 03↑ IS FOUND SO
;4 BYTES ARE SKIPPED OVER:
;              EXC      PRINTING TEXT
;          1.  S3/
;              BL       PRINTING TEXT
;              T        PRINTING TEXT
;          2.  .
;          3.  AO/
;          4.  AOB/
;          THE NEXT LETTERS JRS ARE TYPED OUT.  THEN T/ IS FOUND.  AT
;T; A T IS TYPED OUT; THEN A "." IS FOUND AND EVERYTHING STOPS.
;
;          THE TABLE IS ALSO USED GOING FROM SYMBOLIC TO BINARY BUT A

SUBTTL OP DECODER

;41-72      THE ALPHABET IS ENCODED INTO THIS RANGE.
;	        41- A
;	        42- B
;	        72- Z
;	        WHEN A BYTE IN THIS RANGE IS REACHED, ITS CORRESPONDING
;	        LETTER IS TYPED.
;
;73-777     THIS IS A TRANSFER BYTE.  IF THE BYTE IN THIS RANGE IS
;	        CONSIDERED TO BE A, TRANSFER INTERPRETATION TO THE A-73(8)RD
;	        <A-73+FIR.>BYTE IN THE TABLE.
;
;MAROS ASSEMBLE THE TABLE TBL:
; 1.   A NUMBER FOLLOWED BY ↑ ASSEMBLES A DISPATCH BYTE.  THE FIRST
;      DIGIT IS THE POSITION; THE SECOND DIGIT IS THE SIZE.
; 2.   A POINT (.) ASSEMBLES A STOP CODE.
; 3.   A NAME FOLLOWED BY A SLASH ASSEMBLES A TRANSFER TO THE
;      SYMBOLICALLY NAMED BYTE.
; 4.   A STRING OF LETTERS TERMINATED BY A SPACE, COMMA, OR POINT,
;      ASSEMBLE INTO A STRING OF BYTES, EACH BYTE BEING ONE LETTER.
;
;EXAMPLE OF BINARY TO SYMBOLIC DECODING:
;      THE MACHINE CODE FOR JRST IS 254
;          INST    0  1  0  1  0  1  1  0  0
;      THE INTERPERTED STARTS WITH THE FIRST BYTE IN THE TABLE (63↑).
;      THE RESULT OF APPLYING THIS TO C(INST) GIVES 2.  SKIPPING OVER
;      2 BYTES IN THE TABLE AND INTERPRETING THE THIRD RESULTS IN
;      HAK/ BEING INTERPRETED.  AT HAK:, THERE IS A 33↑.  APPLYING
;      THIS TO C(INST) RESULTS IN 5 NON PRINTING BYTES BEING SKIPPED
;      OVER:
;          1.  MV/
;               MOV      PRINTING TEXT
;          2.  MO/
;          3.  ML/
;          4.  DV/
;          5.  SH/
;
;H1/ IS THE NEXT BYTE INTERPRETER.  AT H1: 03↑ IS FOUND SO
;4 BYTES ARE SKIPPED OVER:
;              EXC      PRINTING TEXT
;          1.  S3/
;              BL       PRINTING TEXT
;              T        PRINTING TEXT
;          2.  .
;          3.  AO/
;          4.  AOB/
;          THE NEXT LETTERS JRS ARE TYPED OUT.  THEN T/ IS FOUND.  AT
;T: A " T " IS TYPED OUT; THEN A "." IS FOUND AND EVERYTHING STOPS.
;
;          THE TABLE IS ALSO USED GOING FROM SYMBOLIC TO BINARY BUT A

BEGIN OPDEFS
XLIST
DEFINE P' (A)
<OUTP A&70/2+A&7-1
>
DEFINE G' (A)
<OUTP A+73
>
DEFINE T' (A)
<FOR Bε<A> <OUTP "B"-40
>>
DEFINE S' (Q)
<OUTP 40
>
DEFINE L' (A)
<IFGE CLOC+73-2000,<PRINTX OPTABLE TOO LONG>
A←←CLOC
>
DEFINE OUTP' (A)
<CLOC←←CLOC+1
>
DEFINE BYT9' (A)
<FOR B⊂(A) <B
>>

↑TBL:
BINRY←←0
CLOC←←0
BINC←←3

DEFINE TABLE <
BYT9 <P 63,G %UUO,G %FLO,G %HAK,G %ACCP,G %BOOLE,T H,G %HWT,T T,G %ACBM>
BYT9 <P 21,G %BD,T CON,P 11,G %OI,T S,P 01,G %Z,G %O>
BYT9 <L %BD,P 01,T BLK,G %IO,T DATA,L %IO,P 11,G %I,G %O,L %OI,P 1,G %O,G %I>
BYT9 <L %UUO,P 51,S,P 32,G %U40,G %U50,G %U60,P 21,G %U703,P 11,G %USET>
BYT9 <P 1,T LOOKU,G %P,T ENTE,G %R,L %USET,T USET,P 1,G %I,G %O>
BYT9 <L %U40,P 3,G %U47,T INI,G %T,S,T SPCWA,G %R,S,S,S,L %U47,T CALL>
BYT9 <P 1,S,G %I,L %U60,P 21,G %U603,P 1,T IN,G %BPUT,T OUT,L %BPUT>
BYT9 <P 11,T BU,L %F,T F,S,T PU,G %T,L %U50,P 3,T OPE,G %N,S,S,S,S>
BYT9 <T RENAM,G %E,T I,G %N,T OU,G %T,L %U603,P 1,G %U6062,T STAT>
BYT9 <P 11,L %O,T O,S,L %Z,T Z,S,L %U6062,P 11,T S,G %U62,T G,L %U62>
BYT9 <T ETST,G %S,L %U703,P 2,T CLOS,G %E,T RELEA,G %S,T MTAP,G %E>
BYT9 <T UGET,G %F>

BYT9 <L %FLO,P 51,G %BYTE,T F,P 32,T AD,G %A,T SB,G %A,T MP,G %A,T DV>
BYT9 <L %A,P 21,G %LMB,T R,L %LMB,P 2,S,L %L,T L,S,L %M,T M,S,L %B>
BYT9 <T B,S,L %BYTE,P 32,S,S,S,P 3,S,S,T FS,G %C,T IB,L %P,T P,S>
BYT9 <T I,G %LD,L %LD,T LD,G %B,T I,G %DP,L %DP,T DP,G %B>

BYT9 <L %HAK,P 33,G %MV,L %MV,T MOV,G %MO,G %ML,G %DV,G %SH,G %H1>
BYT9 <G %JP,P 21,T ADD,G %IMB,T SU,L %BIMB,T B,L %IMB,P 2>
BYT9 <S,L %I,T I,S,G %M,G %B,L %MO,P 22,L %EIMS,T E,G %IMS,T S>
BYT9 <G %IMS,T N,G %IMS,T M,L %IMS,P 2,S,G %I,G %M,L %S,T S,S>
BYT9 <L %ML,P 21,T I,G %ML1,L %ML1,T MUL,G %IMB,L %DV,P 21,T I,G %DV1>
BYT9 <L %DV1,T DI,L %DV2,T V,G %IMB,L %H1,P 3,T EXC,G %S3,T BL,L %T>
BYT9 <T T,S,G %AO,L %AO,T AOBJ,G %AOB,T JRS,G %T,T JFC,G %L,T XC,G %T>
BYT9 <T CON,G %S,L %AOB,P 1,G %P,G %N,L %JP,P 3,G %PU,L %PU,T PUSH>
BYT9 <G %PUS,G %PO,L %PO,T POP,G %POP,T JS,L %R,T R,S,T JS,G %P>
BYT9 <T JS,L %PA,T A,S,T JR,G %PA,L %PUS,P 1,L %J,T J,S,S,L %POP>
BYT9 <P 1,S,G %J,L %SH,P 2,T A,G %S2,T ROT,G %S1,T L,L %S2,T S,L %S3>
BYT9 <T H,G %S1,P 21,T JFF,G %O,T FIX,S,L %S1,P 21,S,L %C,T C,S>

BYT9 <L %ACCP,P 42,T CA,G %CA1,G %SJ,T A,G %JS,T S,L %JS,T O,P 31>
BYT9 <T J,G %COMP,T S,G %COMP,L %CA1,P 31,T I,G %COMP,T M,G %COMP>
BYT9 <L %SJ,P 31,T JUM,G %PSJ,T SKI,L %PSJ,T P,L %COMP>
BYT9 <P 3,S,G %L,L %E,T E,S,T L,G %E,G %PA,T G,G %E,L %N,T N,S,T G,S>

BYT9 <L %HWT,P 51,G %HW1,P 21,T R,G %HW2,T L,L %HW2,T R,G %HW3,L %HW1>
BYT9 <P 21,T L,G %HW4,T R,L %HW4,T L,L %HW3,P 32,G %IMS,T Z,G %IMS,T O>
BYT9 <G %IMS,G %EIMS>

BYT9 <L %ACBM,P 31,G %AC1,P 1,T D,G %AC2,T S,G %AC2,L %AC1,P 1,T R>
BYT9 <G %AC2,T L,L %AC2,P 42,T N,G %EAN,T Z,G %EAN,T C,G %EAN,T O>
BYT9 <L %EAN,P 12,S,G %E,G %PA,G %N>

BYT9 <L %CB,T C,G %BIMB,L %BOOLE,P 24,G %ST,L %AN,T AND,G %B2,G %AN>
BYT9 <G %ST,G %AN,G %ST,T X,L %OR,T OR,G %B2,T I,G %OR,G %AN,T EQ>
BYT9 <G %DV2,G %ST,G %OR,G %ST,G %OR,G %OR,L %ST,T SET,L %B2>
BYT9 <P 24,T Z,G %IMB,G %IMB,L %CA,T C,G %TA,L %TM,T M,G %IMB,L %CM>
BYT9 <T C,G %TM,L %TA,T A,G %IMB,G %IMB,G %IMB,T C,G %BIMB,G %IMB,G %CA>
BYT9 <G %CA,G %CM,G %CM,G %CB,T O,G %IMB>>

TABLE

;;here;;

DEFINE OUTP(A)<
BINRY←←BINRY⊗12+A
BINC←←BINC-1
IFE BINC,<XLIST
BINRY⊗6
BINRY←←0
BINC←←3
>
CLOC←←CLOC+1
>

CLOC←←0

TABLE

REPEAT BINC,<BINRY←←BINRY⊗12>

IFN BINRY,<BINRY⊗6>

LIST
BEND OPDEFS

ORG PNTR;;we were -167. word short here
PNTR:
	INST	;POINTER TO BITS IN INST
INST:
	0		;BINARY FOR INSTRUCTION
CHP:
	0		;CHAR POINTER INTO TXT, TXT+1
TXT:
	BLOCK 2		;STORE INPUT TEXT FOR OPEVAL
SAVPDL:
	0		;SAVE PUSH DOWN LIST POINTER

BTAB:
	POINT 10,TBL	;TABLE USED TO GET NEXT BYTE POINTER
	POINT 10,TBL,9	;FOR TRANSFER BYTE
	POINT 10,TBL,19

OPEVAL:
	MOVEI T,0		;EVALUATE FOR AN OP CODE
	IDPB T,163255;;CHP
	MOVEM P,SAVPDL
	TRZA F,OUTF
OPTYPE:
	TRO F,OUTF		;TYPE AN OPCODE SYMBOLICALLY
	LSH T,-33
	MOVEM T,INST		;GET OPCODE INTO RIGHT 9 BITS
	MOVE T,[XWD 440700,TXT]
	MOVEM T,163255;;CHP		;FOR OPEVAL,SETUP POINTER TO INPUT TEXT
	TRZ F,ITF		;CLEAR INSTRUCTION TYPED FLAG
	SETZB  R,W1
	MOVE W2,BTAB
DC1:
	ILDB T,W2		;GET NEXT BYTE IN TBL
	CAILE T,40
	CAIL T,73
	SOJGE R,DC1		;SKIP OVER # BYTES = C(R)
	JUMPG R,DC1		;SKIP OVER ALPHA TEXT WITHOUT COUNTING
	SUBI T,40
	JUMPE T,DECX		;TRANSFER ON ASTOP CODE
	JUMPG T,DC2
	DPB T,[XWD 340500,PNTR]	;SETUP R ON A DISPATCH BYTE
	TRZ T,-4
	AOS T
	DPB T,[XWD 300600,PNTR]
	TRNN F,OUTF
	JRST DC6		;FOR OPEVAL ONLY
	LDB R,PNTR		;GET # BYTES TO SKIP OVER
	JRST DC1

DC2:
	HRREI T,-33(T)
	JUMPL T,DECT		;TYPE OUT A LETTER
	MOVE W1,T		;BYTE IS A TRANSFER
	IDIVI W1,3
	MOVE W2,BTAB(W2)	;CALCULATE POINTER TO NEXT BYTE
	ADDI W2,(W1)
	JRST DC1


DECT:
	TRNE F,OUTF
	JRST DC8	;TYPE OUT A LETTER
	ILDB W1,163255;;CHP	;GET NEXT INPUT LETTER
	CAIE W1,133(T)	;COMPARE WITH ASSUMED NEXT LETTER
	JRST NOMAT	;DOESNT MATCH
	JRST DC1	;MATCHES, TRY NEXT

DECX:
	TRNE F,OUTF	;STOP (CODE 40) HAS BEEN SEEN
	POPJ P,		;IF FOR OUTPUT, RETURN
	ILDB W1,163255;;CHP	;GET NEXT INPUT CHAR IF ANY
	JUMPE W1,DC7	;DOES # OF CHARS MATCH
NOMAT:
	POP P,R		;NO, BACK UP AND TRY SOME MORE
	POP P,W2
	POP P,PNTR
	POP P,163255;;CHP
NOMAT1:
	AOS R		;ASSUME NEXT NUMBER FOR BIN VALUE
	DPB R,PNTR	;STUFF INTO ANSWER
	LDB R,PNTR
	JUMPN R,DC6AA	;IF =0, BYTE WAS TOO BIG
	CAME P,SAVPDL
	JRST NOMAT	;NOT AT TOP LEVEL
	POPJ P,		;UNDEFINED, FINALLY

DC6:
	MOVEI R,0	;ASSUME 0 FOR INITIAL BINARY VALUE
	DPB R,PNTR
DC6AA:
	CAMN P,SAVPDL
	JRST DC6BB
	LDB T,-2(P)	;OLD VALUE OF PNTR
	CAME T,(P)
	JRST NOMAT1
DC6BB:
	PUSH P,163255;;CHP
	PUSH P,PNTR
	PUSH P,W2
	PUSH P,R
	JRST DC1

DC7:
	MOVE P,SAVPDL		;RESTORE PUSH DOWN POINTER
	MOVE T,INST
	LSH T,33		;PUSH BINARY INTO POSITION FOR OPEVAL
	TLC T,700000
	TLCE T,700000
	JRST CPOPJ1
	SETOM IOTFLG	;IT IS AN IOT
	LDB R,[POINT 3,T,8]
	DPB R,[POINT 10,T,12]	;ONLY DONE FOR IO INSTRUCTIONS
	JRST CPOPJ1

DC8:
	TRO F,ITF		;SET INSTRUCTION TYPED FLAG
	MOVEI T,133(T)
	PUSHJ P,TOUT		;OUTPUT A LETTER
	SETZM  SPSAV		;SO $D WONT TRY TO DELETE OP CODES
	JRST DC1

PATCH:
	BLOCK 10

IFN 0,< ;;replace;;IFN EDDT&1&<EDDT>B36,;;means Exec DDT with Papertape FLAG
BUFF:
	BLOCK 40>

IFN UEDDTS,<
FBDATA:
	BLOCK	40				;FOR DATA FROM/TO L'SCOPE
UESTRT:
	SETZM EXJOBN		;JOB WE ARE EXAMINING!
	SETZM EXSYMS
	MOVEI S,37
	CALL S,['PEEK  ']
	MOVEM S,MEMSIZ#
	MOVE T,S
	ANDI S,MAXPR-1
	HRLZM S,PRSIZ#
	ANDI T,¬<MAXPR-1>
	MOVEM T,PRTOP#
	SETZM SYMSYS#
	SETZM SYMLUZ#
	MOVEI	S,265
	CALLI	S,33		;PEEK ADDRESS OF SYSTOP
	CALLI	S,33		;PEEK SYSTOP ITSELF
	MOVEM	S,SYSTOP#
	MOVEI T,
	MOVEI P,PS
	PUSHJ P,PRSET
	MOVEI S,DDTEND
	MOVE T,74
	CAIN T,DDT		;ARE WE "THE" DEBUGGER?
	MOVEM S,JOBFF		;FLUSH SYMS IF NOT BEING DEBUGGED
	SKIPN S,400036
	JRST SYMCOP
	OUTSTR[ASCIZ/COPY SYMBOLS?/]
	INCHRW W
	CAIN W,15
	INCHRW W
	CAIE W,"Y"
	CAIN W,"y"
	JRST SYMCOP
	TRO S,400000
	MOVEM S,EXCSYM#		;LOOK DIRECTLY INTO SYSTEM FOR SYMBOLS
	MOVE S,JOBFF		;MAYBE SHRINK?
	CALLI S,11
	JFCL
	SETOM SYMSYS
	JRST NOCOP

SYMCOP:
	MOVEI P,PS		;GET A STACK
	PUSHJ P,COPSYM		;GET SOME SYMBOLS
NOCOP:
	SETZM SPCFLG#
	JRST DDT

COPSYM:
	SKIPE EXSYMS		;WHOSE SYMBOLS ARE WE LOOKING AT?
	JRST USYMS
ESYMS:
	SETZM EXSYMS		;IN CASE WE JUMPED HERE
	SKIPN R,400036	;EXEC SYMBOL POINTER
	JRST NOSYMS	;TRY DISK
	JRST CSYMS	;COPY THEM IN

USYMS:
	MOVEI R,JOBSYM
	PUSHJ P,FETCH	;FETCH LOSER JOBSYM
	SETZ T,
	JUMPE T,ESYMS	;IF NO SYMBOLS, TRY SYSTEM SYMS
	MOVE R,T
CSYMS:
	HLRO T,R
	MOVNS T
	ADD T,JOBFF
	IORI T,1777
	CALLI T,11
	JRST NOCORE
	HLRO W1,R
	ADD W1,JOBREL
	HLL W1,R
	HRRM W1,EXCSYM
	HLLM R,EXCSYM
UELP1:
	PUSHJ P,FETCH
	SETZ T,		;STORE A 0
	MOVEM T,(W1)
	ADDI R,1
	AOBJN W1,UELP1
	POPJ P,

NOSYMS:
	SETZM EXCSYM	;NO SYMBOLS YET!
	MOVE W,JOBFF
	MOVEI S,42(W)	;MAKE ENOUGH ROOM FOR ONE SECTOR
	CALLI S,11	;GET IT
	JRST NOCORE	;CAN'T
	MOVEI S,400100	;SYSBAND
	MOVEM W,WCMA	;WHERE TO
	MOVEI W2,40
	MOVEM W2,WCMA+1	;# OF WORDS
	SETZM WCMA+2	;SECTOR 0
	FBREAD S,WCMA
	JRST FBERR
	SKIPN W2,36(W)	;GET EXCSYM FROM DISK
	JRST NOSYM1	;NONE THERE EITHER!
	MOVEI W1,(W2)	;ADDR OF SYMBOLS
	LSH W1,-5	;SECTOR
	MOVEM W1,WCMA+2	;TO MEM
	HLRO W1,W2	;-# OF WORDS
	MOVNS W1
	ADDI W1,40	;BUGGER
	MOVEM W1,WCMA+1	;COUNT
	ADDI W1,2(W)	;NEW TOP OF CORE
	CALLI W1,11		;GET MORE CORE
	JRST NOCORE
	FBREAD S,WCMA
	JRST FBERR
	MOVEI W1,(W2)
	ANDI W1,37
	ADD W1,W		;LOC OF NEW SYMBOL TABLE
	HRRM W1,EXCSYM
	HLLM W2,EXCSYM
	POPJ P,

NOCORE:
	OUTSTR[ASCIZ/CAN'T GET CORE/]
	POPJ P,

FBERR:
	OUTSTR[ASCIZ/FAST BAND ERROR!/]
	POPJ P,

NOSYM1:
	OUTSTR[ASCIZ/NO SYMBOLS ANYWHERE???/]
	POPJ P,

WCMA:
	BLOCK 3

EXSYMS:
	0
EXJOBN:
	0
	-1,,0
	EXJWRD
EXJWRD:
	0

DDTREN:
	SETZ T,
	GETPRV T,		;GET CURRENT PRIVILEGES
	TLNN T,40		;DOES HE HAVE ACW PRV?
	JRST NOREN
	SETOM SPCFLG
	SETZM SPCADR
	TLNN T,4		;FBW PRV?
	OUTSTR[ASCIZ/FAST BAND WRITE NOT ENABLED.
/]
	JRST DDT

NOREN:
	OUTSTR[ASCIZ/SORRY, YOU CAN'T DO THAT!
/]
	JRST DDT

DDTSPC:
	SKIPN SPCADR
	CALLI 400024
	MOVE 1,SPCADR#
	MOVE 3,SPCWRD#
	CONSO 1B24
	TDZA 4,4
	MOVEI 4,1
	DATAO 104,[0]		;DISABLE SYS WR DETECTOR
	HRROS 2
	DATAO 2
	MOVNS 2
	ADD 1,2
	MOVEM 3,(1)
	DATAO 104,4
	SETZM SPCADR
	CALLI 400024

SYMPR:
	HRRZ T,EXCSYM
	TRZ T,400000
PRSET:
	ANDI T,¬<MAXPR-1>
	CAME T,PRTOP
	TLOA T,<MAXPR-1>&376001
	HLL T,PRSIZ
	SETPR2 T,
	JRST PRLUZ
	TLO T,1777
	HLRZM T,PRMAX#
	MOVNS T
	HRRM T,PROFF
	SKIPN SYMSYS
	POPJ P,
	ADD T,EXCSYM
	SETZM SYMLUZ
	MOVEI T,-400000(T)
	CAMLE T,PRMAX
	SETOM SYMLUZ
	POPJ P,

PRLUZ:
	OUTSTR [ASCIZ /SETPR2 FAILED!
/]
	JRST 4,.

PROFF:
	(R)

LOGIT:
	INIT 17
	'DSK   '
	0
	POPJ P,			;BARF
	MOVE T,['  SSYS']
	MOVEM T,LOGPPN
	LOOKUP LOGNAM
	JRST [	HRRZ T,LOGEXT
		JUMPN T,LOGLOS	;BARF
	LOGZ0:	SETZM LOGBUF
		SETZM LOGPTR
		AOS LOGPTR
		JRST LOGOUT]
	EXCH T,LOGPPN
	MOVS T,T
	MOVN T,T
	SOJL T,LOGZ0
	LSH T,-7
	ADDI T,1
	MOVEM T,LOGPTR
	USETI @LOGPTR
	IN[IOWD 200,LOGBUF
0]
	JRST LOGOUT
	STATO 1B22
	JRST LOGLOS
LOGOUT:
	HLLZS LOGEXT
	SETZM LOGDAT
	ENTER LOGNAM
	JRST LOGLOS
	MOVE R,[POINT 7,LOGBUF]
LOGZ:
	ILDB T,R
	JUMPN T,LOGZ
	ADD R,[70000,,0]
	PUSH P,W1
	PUSH P,W2
	GETPPN W2,
	PUSHJ P,LOGSIX
	PUSHJ P,INLMES
	ASCIZ/	(/
	PJOB W1,
	PUSHJ P,LOGDEC
	PUSHJ P,INLMES
	ASCIZ/.)	TTY/
	SETO W1,
	GETLIN W1
	HRRZ W1,W1
	PUSHJ P,LOGOCT
	MOVEI W1,11
	PUSHJ P,LOGCHR
	DATE W1,
	IDIVI W1,=31
	PUSH P,W2
	IDIVI W1,=12
	EXCH W1,(P)
	PUSH P,W1
	MOVEI W1,1(W2)
	PUSHJ P,LOGDC2
	MOVEI W1,"-"
	PUSHJ P,LOGCHR
	POP P,W1
	ADDI W1,1
	PUSHJ P,LOGDC2
	MOVEI W1,"-"
	PUSHJ P,LOGCHR
	POP P,W1
	ADDI W1,=64
	PUSHJ P,LOGDEC
	MOVEI W1," "
	PUSHJ P,LOGCHR
	MSTIME W1,
	IDIVI W1,=1000*=60
	IDIVI W1,=60
	PUSH P,W2
	PUSHJ P,LOGDC2
	POP P,W1
	PUSHJ P,LOGDC2
	MOVEI W1,11
	PUSHJ P,LOGCHR
	HRRZ W1,SPCADR
	PUSHJ P,LOGOCT
	PUSHJ P,INLMES
	ASCIZ ?/	?
	MOVE W1,SPCADR
	PEEK W1,
	SETZM LOGCNT
	PUSHJ P,LOGWRD
	MOVEI W1,11
	MOVE W2,LOGCNT
	CAIGE W2,8
	PUSHJ P,LOGCHR
	PUSHJ P,LOGCHR
	MOVE W1,SPCWRD
	PUSHJ P,LOGWRD
	PUSHJ P,INLMES
	ASCIZ/
/
	SETZ W1,
LOGZ1:
	PUSHJ P,LOGCHR
	TLNE R,760000			;FILL OUT WORD
	JRST LOGZ1
	HRRZ R,R
	SUBI R,LOGBUF-1			;GET # OF WORDS
	MOVN R,R
	MOVS R,R
	HRRI R,LOGBUF-1
	MOVEM R,LOGADR
	USETO @LOGPTR
	OUTPUT LOGADR
	POP P,W2
	POP P,W1
	MOVE T,SPCWRD
	MOVE R,SPCADR
LOGLOS:
	RELEASE
	POPJ P,

LOGDC2:
	CAIL W1,=10
	JRST LOGDEC
	PUSH P,W1
	MOVEI W1,"0"
	PUSHJ P,LOGCHR
	POP P,W1
	JRST LOGDEC

LOGWRD:
	HRLM W1,(P)
	HLRZ W1,W1
	PUSHJ P,LOGOCT
	PUSHJ P,INLMES
	ASCIZ/,,/
	HLRZ W1,(P)
LOGOCT:
	SKIPA T,[10]
LOGDEC:
	MOVEI T,=10
LOGNUM:
	IDIV W1,T
	HRLM W2,(P)
	JUMPE W1,.+2
	PUSHJ P,LOGNUM
	HLRZ W1,(P)
	ADDI W1,60
LOGCHR:
	CAME R,[POINT 7,LOGBUF+177,34]	;END OF BUFFER?
	JRST LOGOK			;NO
	USETO @LOGPTR
	OUTPUT[IOWD 200,LOGBUF
0]
	MOVE R,[POINT 7,LOGBUF]
	AOS LOGPTR
LOGOK:
	IDPB W1,R
	AOS LOGCNT
	POPJ P,

LOGSIX:
	JUMPE W2,CPOPJ
	SETZ W1,
	LSHC W1,6
	ADDI W1,40
	PUSHJ P,LOGCHR
	JRST LOGSIX

INLMES:
	POP P,W2
	HRLI W2,(<POINT 7,0>)
INLMS1:
	ILDB W1,W2
	JUMPE W1,1(W2)
	PUSHJ P,LOGCHR
	JRST INLMS1

LOGCNT:
	0
LOGPTR:
	0
LOGADR:
	0
	0

LOGBUF:
	BLOCK 201

LOGNAM:
	'UEDDT '
LOGEXT:
	'LOG   '
LOGDAT:
	0
LOGPPN:
	'  SSYS'
>

;KEEP IT ALL TOGETHER FOR SWAPPING DDT
LIT
VAR

XP DDTEND,.
↑↑DDTEND←DDTEND

IFE EDDT&1,<IFE UEDDTS!SAVESW,<END>
	IFN UEDDTS,<END UESTRT>
	IFN SAVESW,<END DDT>>
IFE EDDT&41-1,<
BEND DDT
>
IFN EDDT&40,<END>
;;omit;;> ;; bothersome DDT conditional assembly. See sln#55858 `2013-02-21 bgbaumgart@mac.com'
;: DDT[J17,SYS] EOF.
;: ONCE[J17,SYS]
COMMENT ⊗   VALID 00019 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00003 00002	BEGIN ONCE ONLY CODE
C00005 00003	SETUP LOCATIONS 40 THRU 61
C00007 00004	ONCE ONLY CODE - OPERATOR SETUP DIALOGUE
C00008 00005	 HERE, WE MUST DISCOVER WHETHER WE HAVE BEEN CONFIGURED
C00011 00006	 NOW WE SIT AND WAIT FOR P2 TO START UP, OR FOR THE OPERATOR TO
C00014 00007	 HERE IS WHERE P2 STARTS
C00017 00008	 WE GET HERE IF P2 IS A PDP-10
C00019 00009	 FINISHED CONFIGURING, NOW CHECK DATE AND ALL
C00020 00010	ASK FOR TODAY'S DATE AND CONVERT
C00022 00011	GET TIME OF DAY
C00024 00012	DECIMAL INPUT ROUTINE - JAM
C00025 00013	IFN 0*FTDISK,<
C00027 00014	ROUTINE TO READ A LINE FROM OPERATORS CONSOLE
C00029 00015	ROUTINE TO TYPE A LINE ON OPERATOR CONSOLE
C00031 00016	CONSTANTS AND PUSH DOWN LIST
C00032 00017	206 RESTARTS -- USER AND EXEC MODE
C00037 00018	PUNCH SYSTEM LOADER WITH CURRENT LOC OF SYSTEM ON LIBRASCOPE
C00040 00019	DEFINE NPRINT(TAG,START,FINISH)
C00042 ENDMK
C⊗;

BEGIN ONCE ONLY CODE
SUBTTL 	ONCE	1969 JAN 29	;WITH MODS FOR DSKSER -RAS.

↑UUOFLK←←UUOLNK			;FIX THIS UP NOW (AT END OF SYSTEM)
ORG LINKSR ;; prior LIT VAR DDT space
LINKSR:

	MOVE TAC,[PUSHJ PDP,OUTCHS]	;DWP FOR TTYSER
	MOVEM TAC,CONTYO		;DWP
	MOVE TAC,[PUSHJ PDP,GETCHR]
	MOVEM TAC,CONTYI	;DWP
LINKS1:
	PUSHJ PDP,APRCHK
	CONSZ TTY,20		;WAIT FOR CTY
	JRST LINKS1
	MOVE AC1,ONCE		;SAVE RETURN ADDR

IFN FTDDT,<
;SAVE SYMBOLS FOR DDT. DDTSYM IS SET UP AT LOAD TIME.

	HLRO TAC1,DDTSYM	;-LENGTH OF SYMBOL TABLE
	MOVNS TAC1		;MAKE IT +
	HRL TAC,DDTSYM		;SYMTAB BEGINS HERE
	HRRI TAC,BLTBEG		;MOVE IT TO HERE
	BLT TAC,BLTBEG-1(TAC1)	;THERE IT WENT
	MOVEI TAC,BLTBEG	;TELL EXEC DDT WHERE
	HRRM TAC,DDTSYM		;IT LOOKS AT 36
	MOVEI TAC,BLTBEG(TAC1)	;END OF SYMBOL TABLE ...
>
IFE FTDDT,<
	MOVEI TAC,BLTBEG
>
	MOVEM TAC,SYSSIZ	;IS TOP OF SYSTEM.
	JRST @AC1		; EXIT NOW, STAGE LEFT

LIT
↑↑BLTBEG←←.

;SETUP LOCATIONS 40 THRU 61
ORG LOC40;;LIT space
LOC40:
	0			;UUO PC
	JSR UUO0		;TO UUO HANDLER
	JSR CH1
	JSP DAT,ERROR
	JSR CH2
	JSP DAT,ERROR
	JSR CH3
	JSP DAT,ERROR
	JSR CH4
	JSP DAT,ERROR
	JSR CH5
	JSP DAT,ERROR
	JSR CH6
	JSP DAT,ERROR
	JSR CH7
	JSP DAT,ERROR
	0			;UUO PC FOR TRAPS TO 60.
	JSR UUO2

P2LOC40:

	0			; P2 UUO'S COME HERE
	JSR UUO0+P2PID
	JSR P2CH1
	JSP DAT,ERROR
	JSR P2CH2
	JSP DAT,ERROR
	JSR P2CH3
	JSP DAT,ERROR
	JSR P2CH4
	JSP DAT,ERROR
	JSR P2CH5
	JSP DAT,ERROR
	JSR P2CH6
	JSP DAT,ERROR
	JSR P2CH7
	JSP DAT,ERROR
	0			; P2 UNDEF OPCODES COME HERE
	JSR UUO2+P2PID		; JSR OFF TO UNDEF OPCODE HANDLER

;ONCE ONLY CODE - OPERATOR SETUP DIALOGUE

↑ONCE:	0
	MOVSI TAC,40000
	MOVEM TAC,41		;KLUDGE TO GET 6 INTO EXEC MODE
	SETZM	P2NUM		;IT ISN'T THERE YET
	MOVE DAT,LINEP		;SETUP LINE BYTE POINTER
	MOVE PDP,[XWD -ONCEPN,ONCEPD]
	MOVEI IOS,0		;MAKE SURE SCNSER WILL TYPE ;JS
	MOVE TAC,[IDPB TEM,DAT]	;DWP FOR TTYSER
	MOVEM TAC,CONTYO	;DWP
	MOVE TAC,[ILDB TEM,DAT]
	MOVEM TAC,CONTYI	;DWP
	PUSHJ PDP,CRLF
	MOVEI TAC,CONFIG
	PUSHJ PDP,CONMES
	PUSHJ	PDP,CRLF
IFE FTDDT,<
	MOVEI TAC,NDDTM
	PUSHJ P,CONMES
>
	PUSHJ P,OPOUT

; HERE, WE MUST DISCOVER WHETHER WE HAVE BEEN CONFIGURED
; AND IF SO, EXACTLY HOW AND FOR WHAT REASON

	SETZM DETFLG
	JFCL 17,.+1		; CLEAR ARITHMETIC FLAGS
	MOVEI TAC,1		; IF THIS PRODUCES AR CRY 0, WE ARE A 10
	SOS TAC
	JCRY0 PDP10		; P1 IS A TEN, HOW 'BOUT THAT?

; P1 IS A PDP-6, TELL THE WORLD ABOUT IT

	MOVEI TAC,1B20		; PARITY IS BIT 20 ON THE 6
	HRRM TAC,PARCON
	MOVEI TAC,132237		; THIS ENABLES PARITY ON THE 6
	HRRM TAC,PICON
	MOVEI TAC,6		; PUT A 6 IN P1NUM
P1OK:
	PUSH PDP,TAC		; PUT FUTURE P1NUM ON STACK
	MOVE TAC,[XWD LOC40,40]	; SET UP TO BLT IN THE INTERRUPT LOCATIONS
	BLT TAC,61
	MOVEI TAC,40		; 40 IS OUR UUO TRAP LOCATION
	MOVEM TAC,UUOLOC+P1PID
; REGARDLESS OF WHETHER P1 IS A 6 OR A 10, WE GET HERE

P1GO:
	POP PDP,P1NUM		; SET UP OUR PROCESSOR NUMBER
	CONO DCB,7		; SEE IF THE DCB IS ON LINE
	CONSZ DCB,7		; SEE IF IT GIVES US BACK A 7
	JRST ONEP		; WE HAVE DCB, P2 HAS NOTHING
	MOVEI TAC,100000	; IS P2 STARTED?
	SKIPN P2NUM
	SOJGE TAC,.-1
	SKIPE P2NUM
	JRST P1G1		;YES. SKIP CTY TYO
	MOVE DAT,LINEP		; ASK OPERATOR TO START UP P2
	MOVEI TAC,[ASCIZ /START OTHER PROCESSOR AT /]
	PUSHJ PDP,CONMES
	MOVEI TAC,SYSDSP+4
	PUSHJ PDP,OCTPNT
	MOVEI TAC,[ASCIZ /, OR TYPE <CR>./]
	PUSHJ PDP,CONMES
	PUSHJ PDP,CRLF
	PUSHJ PDP,OPOUT		; DUMP CTY BUFFER ONTO THE CTY

; NOW WE SIT AND WAIT FOR P2 TO START UP, OR FOR THE OPERATOR TO
; TELL US IT ISN'T GOING TO START

P1G1:
	SKIPN P2NUM
	CONSZ CTY,40		; HAS HE TYPED CR?
	CAIA
	JRST P1G1
	CONO CTY,3000+SCNCHN	; CLEAR CTY
	SKIPE P2NUM		; HAS P2 STARTED ALREADY?
	JRST P2OK		; YES, LEAVE

	MOVEI TAC,P2XFR+1	; MAKE SURE NO ONE STARTS P2 NOW
	HRRM TAC,P2XFR1
	MOVE TAC,[JRST 4,204]
	MOVEM TAC,204		;EVEN FROM HERE
	MOVE DAT,UUOLOC
	XORI DAT,101		;OTHER PROC'S 41
	HRLI DAT,-1(TAC)
	MOVEM TAC,-1(DAT)	;ZAP OTHER PROCESSORS TRAP LOCS
	BLT DAT,61-41(DAT)	;NORMALLY A NO-NO BUT INTS OFF HERE
	MOVE DAT,LINEP
	PUSHJ PDP,CRLF		; ACKNOWLEDGE RECEIPT OF THE C.R.
	PUSHJ PDP,OPOUT

; HERE, WE MUST DETACH THE AD AND DIS, BECAUSE WE ARE THE ONLY
; PROCESSOR AND WE DON'T HAVE THEM

	SETOM DETFLG		; TELLS SYSINI TO DETACH THESE

	JRST ONEP		; NOW GO CHECK CRK

; WE GET HERE IF P1 IS A PDP-10

PDP10:
	MOVEI TAC,1B19		; THIS IS THE PARITY BIT
	HRRM TAC,PARCON
	MOVEI TAC,652237	; AND THIS ENABLES IT
	HRRM TAC,PICON
	MOVEI TAC,=10		; PUT 10 IN P1NUM
	CONSO APR,MAOFF		; ARE WE IN MA TRP OFFSET?
	JRST P1OK		; NO, JUST LIKE A PDP-6
	TLO TAC,MAOFF		; SET BIT IN P1NUM SAYING JUST THAT
	PUSH PDP,TAC		; PUT P1NUM ON THE STACK
	MOVE TAC,[JSR P2START-1]
	MOVEM TAC,204		;TIME TO LET THE 6 GO
	MOVEM TAC,41		;PERHAPS FROM HERE
	MOVE TAC,[XWD LOC40,140]
	BLT TAC,161		; PUT INTERRUPT LOCATIONS IN RIGHT PLACE
	MOVEI TAC,140		; AND THIS IS OUR UUO TRAP LOCATION
	MOVEM TAC,UUOLOC+P1PID

REPEAT 0,<			;IT STOPPED WORKING!!! 4-13-74
	CONO	PTR,120		;THIS IS THE PTR REVERSE HACK
PTREV1:
	CONSZ	PTR,20		;WAIT FOR ¬BUSY
	JRST	.-1
	DATAI	PTR,TAC
	ANDI	TAC,300
	CAIN	TAC,200		;SKIP IF ¬ A BINARY TAPE
	JRST	PTREV1
>				;END REPEAT 0

	JRST P1GO

; HERE IS WHERE P2 STARTS
; WE MUST DECIDE IF THIS IS A LEGAL CONFIGURATION OR NOT

	0			;JSR HERE TO ENTER EXEC MODE
↑P2START:
	MOVE TAC,[JRST P2INI]	; TELL SYSTEM WE HAVE INITIALIZED
	MOVEM TAC,SYSDSP+4
	JFCL 17,.+1		; CLEAR AR FLAGS
	MOVE PDP,[XWD -P2PLN,P2PDL]
	MOVEI TAC,1		; A PDP-10 SETS AR CRY 0
	SOS TAC			; UPON ARRIVING AT 0
	JCRY0 P2P10		; WE ARE A PDP-10

; HERE, P2 IS A PDP-6. MAKE SURE P1 IS IN TRP OFFSET

P2SZZ1:
	MOVE DAT,P1NUM
	JUMPE DAT,.-1		; WAIT UNTIL P1 IS ON THE AIR
	CAMN DAT,[XWD MAOFF,=10]
	JRST P2PAR
ULOSE:
	MOVE TAC,ILLPNT
	JSR DDTTYPE
	HALT ULOSE

ILLPNT:
	POINT 7,.+1
	ASCIZ/
ππππPDP-10 IS NOT IN MA TRAP OFFSET MODE!!!!
/


P2PAR:
	MOVEI DAT,1B20		; PDP-6 PARITY BIT
	HRRM DAT,P2RCON
	MOVEI TAC,40		; UUO TRAP LOCATION
	MOVEM TAC,UUOLOC+P2PID
	MOVEI TAC,132237		; PI CONO TO SET UP PARITY ENABLE
	HRRM TAC,P2CON
	MOVEI DAT,6		; PUT 6 IN P2NUM
	MOVE TAC,[XWD P2LOC40,40]
	BLT TAC,61		; SET UP INTERRUPT LOCATIONS

P2GO:
	CONO DCB,7		; SEE IF DCB IS ON LINE
	CONSZ DCB,7
	JRST P2WENT		; HE'S THERE, GO ON.

	MOVE TAC,DCBPNT
	JSR DDTTYPE		; TELL THEM
	JRST P2WENT

DCBPNT:
	POINT 7,.+1
	ASCIZ/
ππππDEVICE 204 DOES NOT ANSWER!!!!!
/


P2WENT:
	PUSH PDP,DAT
	MOVE TAC,[XWD ALTSAV,PTPSAV]
	BLT TAC,ALTSAV-1	; SET UP DEVICE AC SAVE INDIRECT LOCATIONS
	PUSHJ PDP,DATIME	; SEE IF CRK WORKS
	JRST P2GO1		; NO, SKIP IT
	MOVEM DAT,CRKDAT	; YES, SET STARTING DATE
	MOVEM ITEM,CRKTIM

P2GO1:
	POP PDP,P2NUM
	JRST P2XFR1

; WE GET HERE IF P2 IS A PDP-10

P2P10:
	MOVE DAT,1B19
	HRRM DAT,P2RCON
	MOVEI TAC,652237
	HRRM TAC,P2CON
	MOVE DAT,P1NUM
	CONSO APR,MAOFF		; ARE WE IN TRP OFFSET?
	JRST P2P10A		; NO, CONTINUE
	TLNN DAT,MAOFF		; IS P1 IN TRP OFFSET?
	JRST P2P10X		; OK
	MOVE TAC,BOTHPN
	JSR DDTTYPE
	HALT .-2

BOTHPN:
	POINT 7,.+1
	ASCIZ/
ππππHELP, WE'RE BOTH IN MA TRAP OFFSET MODE!!!
/

P2P10X:
	MOVE DAT,[XWD MAOFF,=10]
	MOVEI TAC,[XWD P2LOC40,140]
	BLT TAC,161		; LOAD UP INTERRUPT LOCATIONS
	MOVEI TAC,140		; THIS IS OUT UUO TRAP LOCATION
	MOVEM TAC,UUOLOC+P2PID
	JRST P2GO

P2P10A:
	TLNE DAT,MAOFF
	JRST P2P10B
	MOVE TAC,NONPNT
	JSR DDTTYPE
	HALT .-2

NONPNT:
	POINT 7,.+1
	ASCIZ/
ππππNO-ONE IN MA TRAP OFFSET MODE!!!!
/

P2P10B:
	MOVEI DAT,=10		; SET P2NUM TO 10
	MOVEI TAC,[XWD P2LOC40,40]
	BLT TAC,61		; BLT IN INTERRUPT TRAP LOCATIONS
	MOVEI TAC,40		; THIS IS OUR UUO TRAP LOCATION
	MOVEM TAC,UUOLOC+P2PID
	JRST P2GO

; FINISHED CONFIGURING, NOW CHECK DATE AND ALL

ONEP:
	PUSHJ PDP,DATIME	; DO WE HAVE THE CRK?
	JRST TBAD		; NO, GET IT FROM OPERATOR
	JRST P2OK1

P2OK:
	MOVE ITEM,CRKTIM	; DOES P2 HAVE CRK?
	SKIPN DAT,CRKDAT
	JRST TBAD		; NO, AGAIN GET IT FROM OPERATOR
P2OK1:
	MOVEM ITEM,TIME
	MOVEM DAT,THSDAT
	JRST ONCE9

;ASK FOR TODAY'S DATE AND CONVERT
;DATE STORED AS ((Y-64)*12.+M-1)*31.+D-1

TBAD:
	PUSHJ PDP,DATLOP
	JRST .-1
DATLOP:
	SETZM THSDAT
	MOVE DAT,LINEP
	MOVEI TAC,TODATE
	PUSHJ PDP,CONMES
	PUSHJ PDP,OPOUT
	PUSHJ PDP,GETLIN
	JRST DATLOP
	PUSH PDP,TAC		;SAVE INPUT BYTE POINTER
	MOVEI IOS,11		;STORE DATE TYPED IN ON TOP OF DATE OF SYSTEM
	MOVE ITEM,DATPTR	;MAX. OF 11 CHAR. INCL. CR
				;CLOBBER SYSDAT
	ILDB TAC1,TAC
	IDPB TAC1,ITEM
	CAIE TAC1,15
	SOJG IOS,.-3
	JUMPLE IOS,DATLOP	;TOO MANY CHARS?
	MOVEI TAC1,0		;STORE NULL ON TOP OF CR
	DPB TAC1,ITEM
	POP PDP,TAC		;RESTORE INPUT BYTE POINTER
	PUSHJ PDP,DECIN		;MONTH
	JRST DATLOP		;ERROR
	SKIPE TAC1
	CAILE TAC1,=12
	JRST DATLOP
	SUBI TAC1,1
	IMULI TAC1,=31
	ADDM TAC1,THSDAT
	PUSHJ PDP,DECIN		;DAY
	JRST DATLOP
	SKIPE TAC1
	CAILE TAC1,=31
	JRST DATLOP
	SUBI TAC1,1
	ADDM TAC1,THSDAT
	PUSHJ PDP,DECIN		;YEAR
	JRST DATLOP
	CAIL TAC1,=68
	CAILE TAC1,=99
	JRST DATLOP
	SUBI TAC1,=64		;YEAR ZERO
	IMULI TAC1,=12*=31
	ADDM TAC1,THSDAT

;GET TIME OF DAY



	POP PDP,TAC
	PUSHJ PDP,TIMLOP
	JRST .-1
TIMLOP:
	SETZM TIME
	MOVE DAT,LINEP
	MOVEI TAC,TIMEM
	PUSHJ PDP,CONMES
	PUSHJ PDP,OPOUT
	PUSHJ PDP,GETLIN
	JRST TIMLOP		;JUST A CR
	ILDB TAC1,TAC
	SUBI TAC1,60
	SKIPL TAC1		;CHECK FIRST DIGIT OF HOUR
	CAILE TAC1,2
	JRST TIMLOP
	IMUL TAC1,[JIFSEC*=60*=60*=10]
	MOVEM TAC1,TIME
	ILDB TAC1,TAC
	SUBI TAC1,60		;CONVERT TO BINARY
	SKIPL TAC1
	CAILE TAC1,=9
	JRST TIMLOP
	IMULI TAC1,JIFSEC*=60*=60
	ADDM TAC1,TIME
	PUSHJ PDP,DECIN
	JRST TIMLOP
	CAILE TAC1,=59
	JRST TIMLOP
	IMULI TAC1,JIFSEC*=60
	ADDM TAC1,TIME
ONCE9:
	MOVSI TAC,(<JFCL>)
	MOVEM TAC,ONCEI
IFN 0*FTDISK,<
	DATAI APR,TAC		;-1 IN KEYS GETS YOU
	AOJN TAC,LINKSR		;THE REFRESH DIALOG.
	PUSHJ PDP,REF
>
	JRST LINKSR

;;DECIMAL INPUT ROUTINE - JAM

DECIN:
	ILDB TAC1,TAC		; FIRST, SKIP NULLS, SPACES, AND TABS
	JUMPE TAC1,DECIN
	CAIE TAC1," "
	CAIN TAC1,"	"
	JRST DECIN
	CAIG TAC1,"9"
	CAIGE TAC1,"0"
	POPJ PDP,
	SUBI TAC1,"0"

DECIN1:
	ILDB AC1,TAC
	CAIE AC1,"-"
	CAIN AC1,"/"
	JRST CPOPJ1
	CAIE AC1,15
	CAIN AC1,12
	JRST CPOPJ1
	CAIG AC1,"9"
	CAIGE AC1,"0"
	POPJ PDP,
	SUBI AC1,"0"
	IMULI TAC1,=10
	ADD TAC1,AC1
	JRST DECIN1

IFN 0*FTDISK,<

;REFRESH DIALOGUE

REF:
	MOVE DAT,LINEP		;DO YOU WANT TO REFRESH?
	MOVEI TAC,REF1M
	PUSHJ PDP,CONMES
	PUSHJ PDP,OPOUT
	PUSHJ PDP,GETLIN
	POPJ PDP,		;NO
	ILDB DAT,TAC		;GET FIRST CHAR
	CAIE DAT,"Y"		;Y?
	POPJ PDP,		;NO. DONT REFRESH THE DISK
	MOVE DAT,LINEP		;YES. ARE YOU SURE?
	MOVEI TAC,REF2M
	PUSHJ PDP,CONMES
	PUSHJ PDP,OPOUT
	PUSHJ PDP,GETLIN
	POPJ PDP,		;NO
	ILDB DAT,TAC
	CAIE DAT,"Y"
	POPJ PDP,
REF3:
	PUSHJ PDP,REFRES	;REFRESH.
	MOVE DAT,LINEP		;OK
	MOVEI TAC,REF6M
	PUSHJ PDP,CONMES
	PUSHJ PDP,OPOUT
	MOVE TAC,DUMPPN	;DEC 3.16
	MOVEM TAC,REFLAG
	POPJ PDP,

REF1M:
	ASCIZ /DO YOU WANT TO REFRESH THE DISK? 
/
REF2M:
	ASCIZ /DO YOU REALLY WANT TO REFRESH?
/
REF6M:
	ASCIZ /REFRESHED! FIRST JOB TO LOG IN GETS IN FREE.
/
>

;ROUTINE TO READ A LINE FROM OPERATORS CONSOLE
;CALL:	PUSHJ PDP,GETLIN
;	JUST A CR TYPED IN
;	A LINE TYPED IN,TAC SET AS BYTE POINTER

CHREC←TEM	;CHAR TO TYPE OUT(MUST BE SAME AS SCNSER ROUTINE
LINE←TAC1	;TTY LINE NO.(ALSO SAME AS SCNSER)


GETLIN:
	MOVE TAC,LINEP
	MOVEI ITEM,0
GET1:
	PUSHJ PDP,TYI
	DATAI TTY,TAC1
	ANDI TAC1,177
	CAIN TAC1,177		;RUBOUT?
	JRST DELETE
	MOVE CHREC,TAC1		;NO, ECHO CHAR.
	PUSHJ PDP,TYO
	IDPB TAC1,TAC		;AND STORE CHAR.
	CAIE TAC1,15
	AOJA ITEM,GET1
	MOVEI CHREC,12		;OUTPUT LF
	PUSHJ PDP,TYO		;TYPE OUT
	MOVE TAC,LINEP		;RESET BYTE POINTER
	JUMPN ITEM,CPOPJ1	;NULL LINE?
	POPJ PDP,		;YES, DON'T SKIP RETURN

DELETE:
	JUMPE ITEM,DELET1	;AT BEGINNING OF LINE?
	ADD TAC,[XWD 070000,0]	;NO, BACK UP BYTE POINTER
	TLNE TAC,400000		;FINISHED THIS WORD YET?
	ADD TAC,[XWD 347777,-1]	;YES, BACK UP ADDRESS
	MOVEI CHREC,134		;OUTPUT BACK SLASH
	PUSHJ PDP,TYO
	SOJA ITEM,GET1

DELET1:
	MOVEI CHREC,15
	PUSHJ PDP,TYO
	MOVEI CHREC,12
	PUSHJ PDP,TYO
	JRST GETLIN

;ROUTINE TO TYPE A LINE ON OPERATOR CONSOLE
;ECHO CHECK STOPS LINE AND RETURNS
;CALL:	DAT SET TO END OF MESSAGE

OPOUT:
	MOVE TAC,LINEP
	CONO TTY,1000		;CLEAR INPUT
OPOUT1:
	CAMN TAC,DAT
	POPJ PDP,
	CONSZ TTY,40
	JRST OPOUT2		;ECHO CHECK
	ILDB CHREC,TAC
	PUSHJ PDP,TYO
	JRST OPOUT1

OPOUT2:
	MOVEI CHREC,15
	PUSHJ PDP,TYO
	MOVEI CHREC,12
	PUSHJ PDP,TYO
	CONO TTY,1000		;CLEAR INPUT

;WAIT TILL OUTPUT BUSY OFF BEFORE TYPING OUT CHAR.



TYO:
	PUSHJ PDP,APRCHK	;CHECK CLOCK
	CONSZ TTY,20
	JRST TYO
	DATAO TTY,CHREC		;DWP FOR TTYSER
	POPJ PDP,

;WAIT TIL INPUT DONE ON BEFORE RETURNING WITH NEXT CHAR.

TYI:
	PUSHJ PDP,APRCHK
	CONSO TTY,40
	JRST TYI
	POPJ PDP,

;CHECK APR FOR CLOCK FLAG SO TIME USER TYPES IN WILL BE ACCURATE

APRCHK:
	CONSO APR,1000		;IS CLOCK FLAG ON?
	POPJ PDP,		;NO
	CONO APR,1000		;YES, CLEAR CLOCK FLAG
	AOS TIME		;INCREMENT TIME
	POPJ PDP,

;CONSTANTS AND PUSH DOWN LIST

LINEP:
	POINT 7,LINBUF	;INPUT AND OUTPUT LINE BUFFER
LINBUF:
	BLOCK 30
ONCEPN←100
ONCEPD:
	BLOCK ONCEPN	;PUSH DOWN LIST
P2PLN←100
P2PDL:
	BLOCK P2PLN
SYSDAT:
	BLOCK 2

;MESSAGES

TODATE:
	ASCIZ /
TYPE TODAY'S DATE AS ABOVE.
/


DATPTR:
	POINT 7,SYSDAT	;POINTER TO SYSTEM DATE

TIMEM:
	ASCIZ /
TYPE 4 DIGIT TIME.
/

IFE FTDDT,<
NDDTM:
	ASCIZ/NON-DDT SYSTEM!!
/
>

;206 RESTARTS -- USER AND EXEC MODE
BEGERR:
	DATAO	CTY,[7]			;DING FOR HIM
	SETZM	SYSTHERE		;SYSTEM'S NOT ON L'SCOPE
IFN FTDSWP,<
	SETZM	DDTSUM
	SETZM	SYMLOC			;NO SWAPPING DDT YET
>
	HALT	BEGIN
↑BEGIN:	SETOM	SYSTHERE		;SET TO SAY SYSTEM IS ON LIBRASCOPE
	MOVE	P,[-ERRPLN,,ERRPDL-1]	;GET A PDL
	JSP	TAC,.+1			;206 START:  WRITE OUT SYSTEM.
	TLNE	TAC,USRMOD		;ARE WE IN USER MODE?
	JRST	USBG1			;USER MODE, SPECIAL HACK.
	CONO 200000			;RESET THE WORLD
	PUSHJ	P,FMCHK			;MAKE SURE WE HAVE FAST AC'S
	JRST	BEGIN			;NO. LOOK AGAIN.
	CONSZ	DSK,400			; IS THE DISK ON-LINE?
	JRST	BEGERR			; NO, EXIT NOW.
IFN FTDSWP,<
	SKIPA	TAC,DDTSYM
USBG1:
	MOVE	TAC,JOBSYM
	MOVEM	TAC,SYMLOC
	MOVE	TAC,[XWD DDTA-DDTEND,DDTA]	;GET IOWD FOR CHECKSUM
	PUSHJ	P,CHECK			;MAKE A CHECKSUM
	MOVEM	TAC1,DDTSUM		;SAVE DDT CHECKSUM
;>;;	USBG1:				;DEFINED AT LAST.
	MOVE	TAC,[JRST 4,203]	;SET UP LOCATION 206
	MOVEM	TAC,SYSDSP+6		;STUFF SYSTEM INITIALIZATION ADDRESS
	JSP	TAC,.+1
	TLNE	TAC,USRMOD		;USER MODE?
	JRST	USRBEG			;YES.  GO OFF AND FAKE IT.
	MOVE TAC,[LOD20,,20]
	BLT TAC,27			;MAKE SURE 20 LOADER IS GOOD
	CONO	IOP,100			;SET UP IOP FOR WRITING.
	DATAO	IOP,[XWD -=76*2000,0]	;ALL OF LOWER CORE.
	DATAO	DSK,SYSBAND		;BAND FOR SYSTEM STORAGE
	CONSO	IOP,IOPANY!IOPJDN	;WAIT UNTIL DONE.
	JRST	.-1			;LOOP
	CONSO	IOP,IOPANY		;ERRORS?
	CONSZ	DSK,3370		;ERRORS?
	JRST	BEGERR			;LOSE
	JRST	SYSDSP			;START UP SYSTEM.
	
;HERE IF USER SAYS
;GET SYSTEM
;S 206
USRBEG:
	CALLI	0			;RESET SELF.
	SETO	TAC,
	CALLI	TAC,400066		;SETPRV - GET CURRENT PRIVILEGES.
	TLON	TAC,PRIPRV+FBWPRV	;HAVE WE GOT PRIVILEGE?
	JRST	[OUTSTR	[ASCIZ/LOSER/]
		CALLI	12]			;NOPE.
	CALLI	TAC,400066		;GET IT.
	MOVEI	AC1,140			;FIRST ADDRESS TO WRITE.
	MOVE	TAC,SYSBND		;GET THE SYSTEM BAND.
	TRO	TAC,400000		;MAKE IT ABSOLUTE.
	MOVE	AC2,JOBREL		;GET THIS SIZE
	SUBI	AC2,137			;LESS OFFSET, LEAVES WORD COUNT
	MOVEI	AC3,3			;START IN SECTOR 3 TO ACCOUNT FOR
					;OFFSET.
	FBWRT	TAC,AC1			;ASK SYSTEM TO WRITE THIS.
	OUTSTR	[ASCIZ/FBERROR: SYSTEM WRITE
/]
	MOVEI	AC2,=76*2000-1		;THIS IS THE SIZE OF AN L'SCOPE BAND
	SUB	AC2,JOBREL		;THIS IS THE SIZE OF NEXT XFER
	JUMPE	AC2,BEGUX		;JUMP IF THERE'S NO SPACE TO FILL UP
	MOVE	AC3,JOBREL
	ADDI	AC3,1
	LSH	AC3,-5			;COMPUTE SECTOR
	FBWRT	TAC,AC1			;MAKE SURE ENTIRE BAND IS READABLE
	OUTSTR	[ASCIZ/FBERROR CLEARING BAND
/]
BEGUX:
	MOVEI	AC2,101			;(PAD TO 137 WITH ZEROES)
	SETZ	AC3,			;SECTOR
	MOVEI	AC1,LODTAB		;PLACE TO START.
	MOVE	TAC1,JOBSYM
	MOVEM	TAC1,LODSYM		;SAVE CYMBALS
	MOVE	TAC1,JOBREL
	MOVEM	TAC1,LODREL		;SAVE JOBREL
	FBWRT	TAC,AC1
	OUTSTR	[ASCIZ/FBERROR: LOW CORE WRITE
/]
	CALLI	12

;PUNCH SYSTEM LOADER WITH CURRENT LOC OF SYSTEM ON LIBRASCOPE
↑SYSLOD:
	MOVE 1,SYSBAND
	MOVEM 1,LODTAB+SBAND	;GET BAND DYNAMICALLY
	JSP 2,FEED
	CONSZ PTP,20
	JRST .-1
	CONO PTP,50		;CLEAR PAPER TAPE PUNCH AND SET BINARY MODE
	SKIPA 1,[-LODLEN,,LODTAB]
PUNXT0:
	TDZA 2,2
PUNNXT:
	MOVE 2,(1)
	MOVEI 3,6
PUN1:
	ROT 2,6
	CONSZ PTP,20
	JRST .-1
	DATAO PTP,2
	SOJG 3,PUN1
	AOBJN 1,PUNNXT
	TLNN 1,-1
	JRST PUNXT0		;PUNCH EXTRA WORD OF ZERO TO STOP PTR ON READIN
	JSP 2,FEED
	HALT SYSLOD

FEED:
	MOVEI 1,=100
FEED1:
	CONSZ PTP,20
	JRST FEED1
	CONO PTP,10
	DATAO PTP,[0]
	SOJG 1,FEED1
	JRST (2)

LODTAB:
	XWD -LODLEN+1,0
PHASE 1
LODIT:
	MOVE BLTAC		;1 THIS IS LOC 20 BE CAREFUL
	SETZM 20		;2
	BLT 377777		;3
LODLUP:
	DATAO IOP,SLOC		;4
	DATAO DSK,SBAND		;5
	CONSO IOP,IOPANY!IOPJDN	;6
	JRST .-1		;7
	CONSO IOP,IOPANY	;10
	CONSZ DSK,3370		;11
	HALT LODLUP		;12
	JRST SYSDSP		;13
SLOC:
	XWD -=76*2000,0		;14
SBAND:
	100B23			;15 REALLY TO BE FILLED IN BY SYSLOD
BLTAC:
	20,,21			;16
	JRST LODIT		;17 TO START IT
DEPHASE
LODLEN←←.-LODTAB
	BLOCK	20-LODLEN	;BLOCK UP TO BOUNDARY, IF NEEDED.
LOD20:
	CONO	PTR,60		;20 LOADER
	CONSO	PTR,10
	JRST	21
	DATAI	PTR,26
	CONSO	PTR,10
	JRST	24
	0
	JRST	21
	BLOCK	6		;GET TO 36
LODSYM:
	0
LODREL:
	0
	BLOCK	41		;PAD TO AT LEAST 101 WORDS FROM LODTAB

DEFINE NPRINT(TAG,START,FINISH)
<
	OUTSTR[ASCIZ/
TAG/]
	MOVEI TAC,FINISH-START
	PUSHJ P,DECOUT
>

DECOUT:
	IDIVI TAC,=10
	HRLM TAC1,(P)
	JUMPE TAC,.+2
	PUSHJ P,DECOUT
	HLRZ TAC,(P)
	ADDI TAC,60
	OUTCHR TAC
	POPJ P,

↑START:	MOVE	P,[IOWD 20,SPDL]	;FOR USE WITH DUMP COPY OF SYSTEM
	OUTSTR	CONFIG		;SYSTEM NAME
	NPRINT	<IMPURE PART	>,0,TPOPJ1
	NPRINT	<SYSTEM STUFF	>,TPOPJ1,DEVBEG
	NPRINT	<DEV SERVICES	>,DEVBEG,PATCH
	NPRINT	<DDT & SYSMAK	>,PATCH,BLTBEG
	NPRINT	<ONCE ONLY	>,BLTBEG,THEEND
	HLRO	TAC,116		;JOBSYM
	MOVNS	TAC
	OUTSTR	[ASCIZ/
SYMBOLS		/]
	PUSHJ	P,DECOUT
	NPRINT	<DDT SWAPPED	>,0,DDT
	CALLI	12

SPDL:
	BLOCK 20

LIT
VAR
ORG THEEND;;final LIT VAR space
THEEND:

BEND ONCE
END SYSDSP
;: ONCE[J17,SYS] EOF.
